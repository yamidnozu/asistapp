name: Deploy to VPS

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/asistapp_backend

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image: ${{ steps.meta.outputs.tags }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: production

    steps:
    - name: Validate secrets
      run: |
        echo "Validating required secrets"
        test -n "${{ secrets.VPS_HOST }}" || exit 1
        test -n "${{ secrets.VPS_USER }}" || exit 1
        test -n "${{ secrets.SSH_PRIVATE_KEY }}" || exit 1
        test -n "${{ secrets.DOMAIN }}" || exit 1
        test -n "${{ secrets.EMAIL }}" || exit 1
        test -n "${{ secrets.DB_USER }}" || exit 1
        test -n "${{ secrets.DB_PASS }}" || exit 1
        test -n "${{ secrets.DB_NAME }}" || exit 1
        test -n "${{ secrets.DB_PORT }}" || exit 1
        test -n "${{ secrets.JWT_SECRET }}" || exit 1
        echo "All secrets OK"

    - name: Deploy to VPS
      uses: appleboy/ssh-action@v1.0.3
      env:
        DOMAIN: ${{ secrets.DOMAIN }}
        EMAIL: ${{ secrets.EMAIL }}
        DB_USER: ${{ secrets.DB_USER }}
        DB_PASS: ${{ secrets.DB_PASS }}
        DB_NAME: ${{ secrets.DB_NAME }}
        DB_PORT: ${{ secrets.DB_PORT }}
        JWT_SECRET: ${{ secrets.JWT_SECRET }}
        IMAGE_TAG: ${{ needs.build-and-push.outputs.image }}
      with:
        host: ${{ secrets.VPS_HOST }}
        username: ${{ secrets.VPS_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        envs: DOMAIN,EMAIL,DB_USER,DB_PASS,DB_NAME,DB_PORT,JWT_SECRET,IMAGE_TAG
        script_stop: true
        command_timeout: 30m
        script: |
          set -e
          echo "Deploy start: $(date)"
          echo "Image: $IMAGE_TAG"
          mkdir -p /opt/asistapp
          test -f /opt/asistapp/docker-compose.prod.yml && cp /opt/asistapp/docker-compose.prod.yml /opt/asistapp/backup-$(date +%Y%m%d%H%M%S).yml
          cat > /opt/asistapp/.env << EOF
          DB_USER=$DB_USER
          DB_PASS=$DB_PASS
          DB_NAME=$DB_NAME
          DB_PORT=$DB_PORT
          JWT_SECRET=$JWT_SECRET
          DOMAIN=$DOMAIN
          IMAGE_TAG=$IMAGE_TAG
          EOF
          cat > /opt/asistapp/docker-compose.prod.yml << 'EOF'
          version: '3.8'
          services:
            db:
              image: postgres:15
              container_name: asistapp_db
              restart: always
              env_file: .env
              environment:
                POSTGRES_USER: \${DB_USER}
                POSTGRES_PASSWORD: \${DB_PASS}
                POSTGRES_DB: \${DB_NAME}
              ports:
                - "\${DB_PORT}:5432"
              volumes:
                - postgres_data:/var/lib/postgresql/data
              networks:
                - asistapp-network
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U \${DB_USER}"]
                interval: 10s
                timeout: 5s
                retries: 5
            app:
              image: \${IMAGE_TAG}
              container_name: backend-app-v3
              restart: always
              env_file: .env
              environment:
                DATABASE_URL: postgresql://\${DB_USER}:\${DB_PASS}@db:5432/\${DB_NAME}?schema=public
                JWT_SECRET: \${JWT_SECRET}
                PORT: 3000
                HOST: 0.0.0.0
                NODE_ENV: production
                LOG_LEVEL: info
                API_BASE_URL: https://\${DOMAIN}
              ports:
                - "127.0.0.1:3002:3000"
              depends_on:
                db:
                  condition: service_healthy
              networks:
                - asistapp-network
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
          volumes:
            postgres_data:
          networks:
            asistapp-network:
              driver: bridge
          EOF
          command -v docker || (apt-get update && apt-get install -y ca-certificates curl && install -m 0755 -d /etc/apt/keyrings && curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc && chmod a+r /etc/apt/keyrings/docker.asc && echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | tee /etc/apt/sources.list.d/docker.list && apt-get update && apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin && systemctl enable docker && systemctl start docker)
          command -v nginx || (apt-get update && apt-get install -y nginx certbot python3-certbot-nginx && systemctl enable nginx && systemctl start nginx)
          command -v ufw && (ufw --force allow OpenSSH && ufw --force allow 'Nginx Full' && ufw --force enable)
          cat > /etc/nginx/sites-available/asistapp << 'NGINX'
          server {
            listen 80;
            listen [::]:80;
            server_name DVAR www.DVAR;
            location /.well-known/acme-challenge/ {
              root /var/www/letsencrypt;
            }
            return 301 https://\$server_name\$request_uri;
          }
          server {
            listen 443 ssl http2;
            listen [::]:443 ssl http2;
            server_name DVAR www.DVAR;
            ssl_certificate /etc/letsencrypt/live/DVAR/fullchain.pem;
            ssl_certificate_key /etc/letsencrypt/live/DVAR/privkey.pem;
            ssl_protocols TLSv1.2 TLSv1.3;
            location / {
              proxy_pass http://127.0.0.1:3002;
              proxy_http_version 1.1;
              proxy_set_header Upgrade \$http_upgrade;
              proxy_set_header Connection 'upgrade';
              proxy_set_header Host \$host;
              proxy_set_header X-Real-IP \$remote_addr;
              proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto \$scheme;
            }
          }
          NGINX
          sed -i "s/DVAR/$DOMAIN/g" /etc/nginx/sites-available/asistapp
          ln -sf /etc/nginx/sites-available/asistapp /etc/nginx/sites-enabled/
          rm -f /etc/nginx/sites-enabled/default
          mkdir -p /var/www/letsencrypt
          test -d /etc/letsencrypt/live/$DOMAIN || certbot certonly --webroot -w /var/www/letsencrypt -d $DOMAIN -d www.$DOMAIN --email $EMAIL --agree-tos --non-interactive --no-eff-email
          nginx -t && systemctl reload nginx
          cd /opt/asistapp
          docker compose -f docker-compose.prod.yml down --timeout 30 || true
          docker compose -f docker-compose.prod.yml pull
          docker compose -f docker-compose.prod.yml up -d
          echo "Deploy completed"
          docker compose -f docker-compose.prod.yml ps
