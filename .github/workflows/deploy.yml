name: Deploy to VPS

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/asistapp_backend

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image: ${{ steps.meta.outputs.tags }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: production

    steps:
    - name: Validate secrets
      run: |
        echo "Validating required secrets..."
        if [ -z "${{ secrets.VPS_HOST }}" ]; then echo "‚ùå VPS_HOST secret missing"; exit 1; fi
        if [ -z "${{ secrets.VPS_USER }}" ]; then echo "‚ùå VPS_USER secret missing"; exit 1; fi
        if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then echo "‚ùå SSH_PRIVATE_KEY secret missing"; exit 1; fi
        if [ -z "${{ secrets.DOMAIN }}" ]; then echo "‚ùå DOMAIN secret missing"; exit 1; fi
        if [ -z "${{ secrets.EMAIL }}" ]; then echo "‚ùå EMAIL secret missing"; exit 1; fi
        if [ -z "${{ secrets.DB_USER }}" ]; then echo "‚ùå DB_USER secret missing"; exit 1; fi
        if [ -z "${{ secrets.DB_PASS }}" ]; then echo "‚ùå DB_PASS secret missing"; exit 1; fi
        if [ -z "${{ secrets.DB_NAME }}" ]; then echo "‚ùå DB_NAME secret missing"; exit 1; fi
        if [ -z "${{ secrets.DB_PORT }}" ]; then echo "‚ùå DB_PORT secret missing"; exit 1; fi
        if [ -z "${{ secrets.JWT_SECRET }}" ]; then echo "‚ùå JWT_SECRET secret missing"; exit 1; fi
        echo "‚úÖ All secrets validated"

    - name: Deploy to VPS
      uses: appleboy/ssh-action@v1.0.3
      env:
        DOMAIN: ${{ secrets.DOMAIN }}
        EMAIL: ${{ secrets.EMAIL }}
        DB_USER: ${{ secrets.DB_USER }}
        DB_PASS: ${{ secrets.DB_PASS }}
        DB_NAME: ${{ secrets.DB_NAME }}
        DB_PORT: ${{ secrets.DB_PORT }}
        JWT_SECRET: ${{ secrets.JWT_SECRET }}
        IMAGE_TAG: ${{ needs.build-and-push.outputs.image }}
      with:
        host: ${{ secrets.VPS_HOST }}
        username: ${{ secrets.VPS_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        envs: DOMAIN,EMAIL,DB_USER,DB_PASS,DB_NAME,DB_PORT,JWT_SECRET,IMAGE_TAG
        script: |
          set -euo pipefail
          echo "üöÄ Starting production deployment..."
          echo "üìÖ $(date)"
          echo "üè∑Ô∏è  Image: $IMAGE_TAG"
          if [ -f "/opt/asistapp/docker-compose.prod.yml" ]; then
            echo "üíæ Creating backup..."
            cp /opt/asistapp/docker-compose.prod.yml /opt/asistapp/docker-compose.prod.yml.backup.$(date +%Y%m%d_%H%M%S)
          fi
          mkdir -p /opt/asistapp
          cat > /opt/asistapp/docker-compose.prod.yml <<EOF
          version: '3.8'
          services:
            db:
              image: postgres:15
              container_name: asistapp_db
              restart: always
              environment:
                POSTGRES_USER: $DB_USER
                POSTGRES_PASSWORD: $DB_PASS
                POSTGRES_DB: $DB_NAME
              ports:
                - "$DB_PORT:5432"
              volumes:
                - postgres_data:/var/lib/postgresql/data
              networks:
                - asistapp-network
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U $DB_USER"]
                interval: 10s
                timeout: 5s
                retries: 5
            app:
              image: $IMAGE_TAG
              container_name: backend-app-v3
              restart: always
              ports:
                - "127.0.0.1:3002:3000"
              environment:
                DATABASE_URL: "postgresql://$DB_USER:$DB_PASS@db:5432/$DB_NAME?schema=public"
                JWT_SECRET: $JWT_SECRET
                PORT: 3000
                HOST: 0.0.0.0
                NODE_ENV: production
                LOG_LEVEL: info
                API_BASE_URL: https://$DOMAIN
              depends_on:
                db:
                  condition: service_healthy
              networks:
                - asistapp-network
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
          volumes:
            postgres_data:
          networks:
            asistapp-network:
              driver: bridge
          EOF
          echo "‚úÖ Docker Compose generated"
          
          # VPS Infrastructure Setup
          echo "üîß Setting up VPS infrastructure..."
          
          # Install Docker if not present
          if ! command -v docker >/dev/null 2>&1; then
            echo "üê≥ Installing Docker..."
            apt-get update
            apt-get install -y ca-certificates curl gnupg lsb-release
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
            apt-get update
            apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
            systemctl enable docker
            systemctl start docker
          fi
          
          # Install nginx and certbot if not present
          if ! command -v nginx >/dev/null 2>&1; then
            echo "üåê Installing nginx and certbot..."
            apt-get update
            apt-get install -y nginx certbot python3-certbot-nginx
            systemctl enable nginx
            systemctl start nginx
          fi
          
          # Configure firewall
          if command -v ufw >/dev/null 2>&1; then
            echo "üî• Configuring firewall..."
            ufw --force allow OpenSSH
            ufw --force allow 'Nginx Full'
            ufw --force enable
          fi
          
          # Configure nginx with SSL
          echo "üåê Configuring nginx with SSL..."
          cat > /etc/nginx/sites-available/asistapp << NGINX_EOF
server {
  listen 80;
  listen [::]:80;
  server_name $DOMAIN www.$DOMAIN;
  
  location /.well-known/acme-challenge/ {
    root /var/www/letsencrypt;
  }
  
  return 301 https://\$server_name\$request_uri;
}

server {
  listen 443 ssl http2;
  listen [::]:443 ssl http2;
  server_name $DOMAIN www.$DOMAIN;
  
  ssl_certificate /etc/letsencrypt/live/$DOMAIN/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/$DOMAIN/privkey.pem;
  ssl_protocols TLSv1.2 TLSv1.3;
  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
  ssl_prefer_server_ciphers off;
  
  # Security headers
  add_header X-Frame-Options "SAMEORIGIN" always;
  add_header X-XSS-Protection "1; mode= block" always;
  add_header X-Content-Type-Options "nosniff" always;
  add_header Referrer-Policy "no-referrer-when-downgrade" always;
  add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;
  
  location / {
    proxy_pass http://127.0.0.1:3002;
    proxy_http_version 1.1;
    proxy_set_header Upgrade \$http_upgrade;
    proxy_set_header Connection 'upgrade';
    proxy_set_header Host \$host;
    proxy_set_header X-Real-IP \$remote_addr;
    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto \$scheme;
    proxy_cache_bypass \$http_upgrade;
    proxy_read_timeout 86400;
  }
}
NGINX_EOF

          ln -sf /etc/nginx/sites-available/asistapp /etc/nginx/sites-enabled/ 2>/dev/null || true
          rm -f /etc/nginx/sites-enabled/default
          
          # SSL certificates
          echo "üîí Setting up SSL certificates..."
          mkdir -p /var/www/letsencrypt/.well-known/acme-challenge
          chown -R www-data:www-data /var/www/letsencrypt
          
          if [ ! -d "/etc/letsencrypt/live/$DOMAIN" ]; then
            echo "üìú Obtaining SSL certificates..."
            certbot certonly --webroot -w /var/www/letsencrypt \
              -d $DOMAIN -d www.$DOMAIN \
              -m $EMAIL --agree-tos --non-interactive --no-eff-email
          else
            echo "‚úÖ SSL certificates already exist"
          fi
          
          # Test nginx configuration
          echo "üß™ Testing nginx configuration..."
          if nginx -t; then
            systemctl reload nginx
            echo "‚úÖ Nginx reloaded successfully"
          else
            echo "‚ùå Nginx configuration error"
            exit 1
          fi
          
          # Deploy containers
          echo "üöÄ Deploying application..."
          cd /opt/asistapp
          
          # Graceful shutdown of existing containers
          docker compose -f docker-compose.prod.yml down --timeout 30 || true
          
          # Pull latest images
          docker compose -f docker-compose.prod.yml pull
          
          # Start services
          docker compose -f docker-compose.prod.yml up -d
          
          # Wait for services to be healthy
          echo "‚è≥ Waiting for services to be healthy..."
          timeout=300
          elapsed=0
          
          while [ $elapsed -lt $timeout ]; do
            if docker compose -f docker-compose.prod.yml ps | grep -q "healthy\|running"; then
              echo "‚úÖ Services are healthy"
              break
            fi
            sleep 10
            elapsed=$((elapsed + 10))
          done
          
          if [ $elapsed -ge $timeout ]; then
            echo "‚ö†Ô∏è  Services may not be fully healthy, but deployment completed"
          fi
          
          # Final verification
          echo ""
          echo "üéâ DEPLOYMENT COMPLETED SUCCESSFULLY"
          echo "üåê Application URL: https://$DOMAIN"
          echo "üìä Container Status:"
          docker compose -f docker-compose.prod.yml ps
          echo ""
          echo "üîç Health Check: https://$DOMAIN/health"
          echo "üìù Logs: docker compose -f /opt/asistapp/docker-compose.prod.yml logs -f"