name: Deploy to VPS

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      run_seed:
        description: 'Run database seed (WARNING: This wipes the database!)'
        required: false
        default: false
        type: boolean
      reset_db:
        description: 'Reset Database (Wipe all data and start fresh)'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/asistapp_backend

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image: ${{ steps.meta.outputs.tags }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
    - name: Validate secrets
      run: |
        echo "Validating required secrets..."
        missing=0
        if [ -z "${{ secrets.VPS_HOST }}" ]; then echo "âŒ Missing: VPS_HOST"; missing=1; fi
        if [ -z "${{ secrets.VPS_USER }}" ]; then echo "âŒ Missing: VPS_USER"; missing=1; fi
        if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then echo "âŒ Missing: SSH_PRIVATE_KEY"; missing=1; fi
        if [ -z "${{ secrets.DOMAIN }}" ]; then echo "âŒ Missing: DOMAIN"; missing=1; fi
        if [ -z "${{ secrets.EMAIL }}" ]; then echo "âŒ Missing: EMAIL"; missing=1; fi
        if [ -z "${{ secrets.DB_USER }}" ]; then echo "âŒ Missing: DB_USER"; missing=1; fi
        if [ -z "${{ secrets.DB_PASS }}" ]; then echo "âŒ Missing: DB_PASS"; missing=1; fi
        if [ -z "${{ secrets.DB_NAME }}" ]; then echo "âŒ Missing: DB_NAME"; missing=1; fi
        if [ -z "${{ secrets.DB_PORT }}" ]; then echo "âŒ Missing: DB_PORT"; missing=1; fi
        if [ -z "${{ secrets.JWT_SECRET }}" ]; then echo "âŒ Missing: JWT_SECRET"; missing=1; fi
        if [ "$missing" -eq 1 ]; then
          echo ""
          echo "âš ï¸  One or more required secrets are missing."
          echo "ðŸ“ Add them in: Settings â†’ Secrets and variables â†’ Actions"
          echo "    OR under the 'production' environment if using environment-level secrets"
          exit 1
        fi
        echo "âœ… All secrets validated successfully"

    - name: Deploy to VPS
      uses: appleboy/ssh-action@v1.0.3
      env:
        DOMAIN: ${{ secrets.DOMAIN }}
        EMAIL: ${{ secrets.EMAIL }}
        DB_USER: ${{ secrets.DB_USER }}
        DB_PASS: ${{ secrets.DB_PASS }}
        DB_NAME: ${{ secrets.DB_NAME }}
        DB_PORT: ${{ secrets.DB_PORT }}
        JWT_SECRET: ${{ secrets.JWT_SECRET }}
        IMAGE_TAG: ghcr.io/${{ github.repository }}/asistapp_backend:main
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GITHUB_ACTOR: ${{ github.actor }}
        RUN_SEED: ${{ github.event.inputs.run_seed || 'false' }}
        RESET_DB: ${{ github.event.inputs.reset_db || 'false' }}
      with:
        host: ${{ secrets.VPS_HOST }}
        username: ${{ secrets.VPS_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        envs: DOMAIN,EMAIL,DB_USER,DB_PASS,DB_NAME,DB_PORT,JWT_SECRET,IMAGE_TAG,GITHUB_TOKEN,GITHUB_ACTOR,RUN_SEED,RESET_DB
        command_timeout: 30m
        script: |
          set -e
          echo "Deploy start: $(date)"
          echo "Image: $IMAGE_TAG"
          SUDO=""
          if [ "$(id -u)" -ne 0 ]; then
            if command -v sudo >/dev/null 2>&1; then
              SUDO=sudo
              if ! $SUDO -n true 2>/dev/null; then
                echo "âŒ Error: User '$(whoami)' has sudo but requires a password."
                echo "ðŸ‘‰ Please configure passwordless sudo on the VPS for this user:"
                echo "   echo '$(whoami) ALL=(ALL) NOPASSWD:ALL' | sudo tee /etc/sudoers.d/$(whoami)"
                exit 1
              fi
            else
              echo "Error: need root or sudo"; exit 1
            fi
          fi
          $SUDO mkdir -p /opt/asistapp
          test -f /opt/asistapp/docker-compose.prod.yml && $SUDO cp /opt/asistapp/docker-compose.prod.yml /opt/asistapp/backup-$(date +%Y%m%d%H%M%S).yml
          printf "DB_USER=%s\nDB_PASS=%s\nDB_NAME=%s\nDB_PORT=%s\nJWT_SECRET=%s\nDOMAIN=%s\nIMAGE_TAG=%s\n" "$DB_USER" "$DB_PASS" "$DB_NAME" "$DB_PORT" "$JWT_SECRET" "$DOMAIN" "$IMAGE_TAG" | $SUDO tee /opt/asistapp/.env > /dev/null
          $SUDO tee /opt/asistapp/docker-compose.prod.yml > /dev/null << 'EOF'
          version: '3.8'
          services:
            db:
              image: postgres:15
              container_name: asistapp_db
              restart: always
              env_file: .env
              environment:
                POSTGRES_USER: ${DB_USER}
                POSTGRES_PASSWORD: ${DB_PASS}
                POSTGRES_DB: ${DB_NAME}
              ports:
                - "${DB_PORT}:5432"
              volumes:
                - postgres_data:/var/lib/postgresql/data
              networks:
                - asistapp-network
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U ${DB_USER}"]
                interval: 10s
                timeout: 5s
                retries: 5
            app:
              image: ${IMAGE_TAG}
              container_name: backend-app-v3
              restart: always
              env_file: .env
              environment:
                DATABASE_URL: postgresql://${DB_USER}:${DB_PASS}@db:5432/${DB_NAME}?schema=public
                JWT_SECRET: ${JWT_SECRET}
                PORT: 3000
                HOST: 0.0.0.0
                NODE_ENV: production
                LOG_LEVEL: info
                API_BASE_URL: https://${DOMAIN}
              ports:
                - "127.0.0.1:3002:3000"
              depends_on:
                db:
                  condition: service_healthy
              networks:
                - asistapp-network
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
          volumes:
            postgres_data:
          networks:
            asistapp-network:
              driver: bridge
          EOF
          command -v docker || ($SUDO apt-get update && $SUDO apt-get install -y ca-certificates curl && $SUDO install -m 0755 -d /etc/apt/keyrings && curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc && $SUDO chmod a+r /etc/apt/keyrings/docker.asc && echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | $SUDO tee /etc/apt/sources.list.d/docker.list && $SUDO apt-get update && $SUDO apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin && $SUDO systemctl enable docker && $SUDO systemctl start docker)
          command -v nginx || ($SUDO apt-get update && $SUDO apt-get install -y nginx certbot python3-certbot-nginx && $SUDO systemctl enable nginx && $SUDO systemctl start nginx)
          command -v ufw || ($SUDO apt-get update && $SUDO apt-get install -y ufw)
          if command -v ufw >/dev/null 2>&1; then
            echo "ufw found â€” configuring firewall rules"
            # Always allow SSH
            if $SUDO ufw --version >/dev/null 2>&1; then
              $SUDO ufw allow OpenSSH || echo "Warning: ufw allow OpenSSH failed" >&2
            fi
            # Prefer the "Nginx Full" profile if available, otherwise open ports 80/443
            if $SUDO ufw app list 2>/dev/null | grep -q "Nginx Full"; then
              $SUDO ufw allow "Nginx Full" || echo "Warning: ufw allow 'Nginx Full' failed" >&2
            else
              echo "ufw profile 'Nginx Full' not found â€” allowing ports 80 and 443"
              $SUDO ufw allow 80/tcp || echo "Warning: ufw allow 80 failed" >&2
              $SUDO ufw allow 443/tcp || echo "Warning: ufw allow 443 failed" >&2
            fi
            # Enable ufw if not already enabled
            if $SUDO ufw status verbose 2>/dev/null | grep -q "Status: inactive"; then
              $SUDO ufw --force enable || echo "Warning: ufw enable failed" >&2
            else
              echo "ufw already active"
            fi
          else
            echo "ufw not present"
          fi
          $SUDO tee /etc/nginx/sites-available/asistapp > /dev/null << 'NGINX'
          server {
            listen 80;
            listen [::]:80;
            server_name DVAR www.DVAR;
            location /.well-known/acme-challenge/ {
              root /var/www/letsencrypt;
            }
            return 301 https://$server_name$request_uri;
          }
          server {
            listen 443 ssl http2;
            listen [::]:443 ssl http2;
            server_name DVAR www.DVAR;
            ssl_certificate /etc/letsencrypt/live/DVAR/fullchain.pem;
            ssl_certificate_key /etc/letsencrypt/live/DVAR/privkey.pem;
            ssl_protocols TLSv1.2 TLSv1.3;
            location / {
              proxy_pass http://127.0.0.1:3002;
              proxy_http_version 1.1;
              proxy_set_header Upgrade $http_upgrade;
              proxy_set_header Connection 'upgrade';
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $scheme;
            }
          }
          NGINX
          $SUDO sed -i "s/DVAR/$DOMAIN/g" /etc/nginx/sites-available/asistapp
          $SUDO ln -sf /etc/nginx/sites-available/asistapp /etc/nginx/sites-enabled/
          $SUDO rm -f /etc/nginx/sites-enabled/default
          $SUDO mkdir -p /var/www/letsencrypt
          test -d /etc/letsencrypt/live/$DOMAIN || $SUDO certbot certonly --webroot -w /var/www/letsencrypt -d $DOMAIN -d www.$DOMAIN --email $EMAIL --agree-tos --non-interactive --no-eff-email || echo "Warning: certbot failed, SSL not obtained"
          $SUDO nginx -t && $SUDO systemctl reload nginx || echo "Warning: nginx reload failed"
          echo "$GITHUB_TOKEN" | $SUDO docker login ghcr.io -u "$GITHUB_ACTOR" --password-stdin || echo "Warning: docker login failed"
          cd /opt/asistapp
          
          if [ "$RESET_DB" = "true" ]; then
            echo "âš ï¸ RESET_DB is true. Wiping database volume..."
            $SUDO docker compose -f docker-compose.prod.yml down -v || true
          else
            $SUDO docker compose -f docker-compose.prod.yml down --timeout 30 || true
          fi

          # Ensure we fetch latest image and force recreate container
          $SUDO docker compose -f docker-compose.prod.yml pull || echo "Warning: docker pull failed"
          # Remove any stopped/old containers for app service to ensure fresh start
          $SUDO docker compose -f docker-compose.prod.yml rm -f -s app || true
          # Force recreate containers and don't use local cache
          $SUDO docker compose -f docker-compose.prod.yml up -d --force-recreate --no-build || echo "Warning: docker up failed"
          # Clean up unused images to free space and avoid collisions with old tag caching
          $SUDO docker image prune -af || true

          echo "ðŸ”„ Running database migrations..."
          $SUDO docker compose -f docker-compose.prod.yml run --rm app npx prisma migrate deploy || echo "Warning: migrations failed"

          if [ "$RUN_SEED" = "true" ]; then
            echo "ðŸŒ± Seeding database..."
            $SUDO docker compose -f docker-compose.prod.yml run --rm app npx prisma db seed || echo "Warning: seed failed"
          fi

          echo "Deploy completed"
          $SUDO docker compose -f docker-compose.prod.yml ps
