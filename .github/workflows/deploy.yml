name: Deploy to VPS

on:
  push:
    branches:
      - main
    paths:
      - 'backend/**'
      - 'docker-compose.yml'
      - 'scripts/**'
      - 'prisma/**'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:
    inputs:
      run_seed:
        description: 'Run database seed (WARNING: This wipes the database!)'
        required: false
        default: false
        type: boolean
      reset_db:
        description: 'Reset Database (Wipe all data and start fresh)'
        required: false
        default: false
        type: boolean
      deploy_force_recreate:
        description: 'When true, remove conflicting containers found on the VPS with the same names.'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/asistapp_backend

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image: ${{ steps.meta.outputs.tags }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest

    env:
      DEPLOY_SSH_RETRIES: 5
      DEPLOY_FORCE_RECREATE: ${{ github.event.inputs.deploy_force_recreate || 'false' }}
    steps:
    - name: Validate secrets
      run: |
        echo "Validating required secrets..."
        missing=0
        if [ -z "${{ secrets.VPS_HOST }}" ]; then echo "‚ùå Missing: VPS_HOST"; missing=1; fi
        if [ -z "${{ secrets.VPS_USER }}" ]; then echo "‚ùå Missing: VPS_USER"; missing=1; fi
        if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then echo "‚ùå Missing: SSH_PRIVATE_KEY"; missing=1; fi
        if [ -z "${{ secrets.DOMAIN }}" ]; then echo "‚ùå Missing: DOMAIN"; missing=1; fi
        if [ -z "${{ secrets.EMAIL }}" ]; then echo "‚ùå Missing: EMAIL"; missing=1; fi
        if [ -z "${{ secrets.DB_USER }}" ]; then echo "‚ùå Missing: DB_USER"; missing=1; fi
        if [ -z "${{ secrets.DB_PASS }}" ]; then echo "‚ùå Missing: DB_PASS"; missing=1; fi
        if [ -z "${{ secrets.DB_NAME }}" ]; then echo "‚ùå Missing: DB_NAME"; missing=1; fi
        if [ -z "${{ secrets.DB_PORT }}" ]; then echo "‚ùå Missing: DB_PORT"; missing=1; fi
        if [ -z "${{ secrets.JWT_SECRET }}" ]; then echo "‚ùå Missing: JWT_SECRET"; missing=1; fi
        if [ "$missing" -eq 1 ]; then
          echo ""
          echo "‚ö†Ô∏è  One or more required secrets are missing."
          echo "üìù Add them in: Settings ‚Üí Secrets and variables ‚Üí Actions"
          echo "    OR under the 'production' environment if using environment-level secrets"
          exit 1
        fi
        echo "‚úÖ All required secrets validated successfully"
        echo ""
        echo "üìã Optional secrets status:"
        [ -z "${{ secrets.WHATSAPP_API_TOKEN }}" ] && echo "‚ö†Ô∏è  WHATSAPP_API_TOKEN not set (notifications won't work)" || echo "‚úÖ WHATSAPP_API_TOKEN set"
        [ -z "${{ secrets.WHATSAPP_PHONE_NUMBER_ID }}" ] && echo "‚ö†Ô∏è  WHATSAPP_PHONE_NUMBER_ID not set" || echo "‚úÖ WHATSAPP_PHONE_NUMBER_ID set"
        [ -z "${{ secrets.WHATSAPP_BUSINESS_ACCOUNT_ID }}" ] && echo "‚ö†Ô∏è  WHATSAPP_BUSINESS_ACCOUNT_ID not set" || echo "‚úÖ WHATSAPP_BUSINESS_ACCOUNT_ID set"
        [ -z "${{ secrets.FIREBASE_SERVICE_ACCOUNT_JSON }}" ] && echo "‚ö†Ô∏è  FIREBASE_SERVICE_ACCOUNT_JSON not set (push notifications won't work)" || echo "‚úÖ FIREBASE_SERVICE_ACCOUNT_JSON set"

    - name: Load SSH key into ssh-agent
      uses: webfactory/ssh-agent@v0.7.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Test SSH connectivity (retries)
      run: |
        HOST=${{ secrets.VPS_HOST }}
        USER=${{ secrets.VPS_USER }}
        RETRIES=${{ env.DEPLOY_SSH_RETRIES }}
        for i in $(seq 1 $RETRIES); do
          echo "Attempt $i connecting to $USER@$HOST"
          if ssh -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=10 ${USER}@${HOST} 'echo SSH_OK' >/dev/null 2>&1; then
            echo "-> Connected on attempt $i"
            # Check sudo capability without prompting for password
            ssh -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=10 ${USER}@${HOST} 'id -u; if [ "$(id -u)" -ne 0 ]; then if command -v sudo >/dev/null 2>&1; then sudo -n true >/dev/null 2>&1 && echo SUDO_NO_PWD || echo SUDO_PWD_REQUIRED; fi; fi'
            break
          else
            echo "Attempt $i failed"
            if [ "$i" -eq "$RETRIES" ]; then
              echo "Failed to connect to $USER@$HOST after $RETRIES attempts"
              exit 1
            fi
            sleep 5
          fi
        done

    - name: Deploy to VPS
      # SSH connectivity is tested before this step. If the test fails, the job stops early with a clear error.
      uses: appleboy/ssh-action@v1.0.3
      env:
        DOMAIN: ${{ secrets.DOMAIN }}
        EMAIL: ${{ secrets.EMAIL }}
        DB_USER: ${{ secrets.DB_USER }}
        DB_PASS: ${{ secrets.DB_PASS }}
        DB_NAME: ${{ secrets.DB_NAME }}
        DB_PORT: ${{ secrets.DB_PORT }}
        JWT_SECRET: ${{ secrets.JWT_SECRET }}
        IMAGE_TAG: ghcr.io/${{ github.repository }}/asistapp_backend:main
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GITHUB_ACTOR: ${{ github.actor }}
        RUN_SEED: ${{ github.event.inputs.run_seed || 'false' }}
        RESET_DB: ${{ github.event.inputs.reset_db || 'false' }}
        WHATSAPP_API_TOKEN: ${{ secrets.WHATSAPP_API_TOKEN }}
        WHATSAPP_PHONE_NUMBER_ID: ${{ secrets.WHATSAPP_PHONE_NUMBER_ID }}
        WHATSAPP_BUSINESS_ACCOUNT_ID: ${{ secrets.WHATSAPP_BUSINESS_ACCOUNT_ID }}
        WHATSAPP_FALLBACK_TEMPLATE: ${{ secrets.WHATSAPP_FALLBACK_TEMPLATE }}
        FIREBASE_PROJECT_ID: ${{ secrets.FIREBASE_PROJECT_ID || 'asistapp-1c728' }}
        FIREBASE_SERVICE_ACCOUNT_JSON: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_JSON }}
      with:
        host: ${{ secrets.VPS_HOST }}
        username: ${{ secrets.VPS_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        envs: DOMAIN,EMAIL,DB_USER,DB_PASS,DB_NAME,DB_PORT,JWT_SECRET,IMAGE_TAG,GITHUB_TOKEN,GITHUB_ACTOR,RUN_SEED,RESET_DB,WHATSAPP_API_TOKEN,WHATSAPP_PHONE_NUMBER_ID,WHATSAPP_BUSINESS_ACCOUNT_ID,FIREBASE_PROJECT_ID,FIREBASE_SERVICE_ACCOUNT_JSON,WHATSAPP_FALLBACK_TEMPLATE
        command_timeout: 30m
        script: |
          set -e
          echo "=========================================="
          echo "üöÄ DEPLOYMENT AUTOM√ÅTICO - AsistApp"
          echo "=========================================="
          echo "Deploy start: $(date)"
          echo "Image: $IMAGE_TAG"
          echo "User: $(whoami)"
          echo "UID: $(id -u)"
          echo ""
          
          # Determinar si necesitamos sudo
          SUDO=""
          if [ "$(id -u)" -eq 0 ]; then
            echo "‚úÖ Running as root - no sudo needed"
          else
            echo "‚öôÔ∏è  Running as non-root user, checking sudo..."
            if command -v sudo >/dev/null 2>&1; then
              SUDO=sudo
              if ! $SUDO -n true 2>/dev/null; then
                echo "‚ö†Ô∏è  Passwordless sudo not configured, attempting auto-configuration..."
                CURRENT_USER=$(whoami)
                
                # Crear el archivo sudoers para el usuario
                # Esto funciona si el usuario tiene ALG√öN acceso sudo aunque requiera contrase√±a
                # El SSH agent de GitHub Actions puede manejar esto
                if ! echo "$CURRENT_USER ALL=(ALL) NOPASSWD:ALL" | sudo tee /etc/sudoers.d/$CURRENT_USER > /dev/null 2>&1; then
                  echo "‚ùå Cannot configure passwordless sudo."
                  echo "üìù SOLUCI√ìN: Ejecuta este comando UNA VEZ en tu VPS:"
                  echo ""
                  echo "   ssh $(whoami)@\$VPS_HOST 'echo \"$(whoami) ALL=(ALL) NOPASSWD:ALL\" | sudo tee /etc/sudoers.d/$(whoami) && sudo chmod 0440 /etc/sudoers.d/$(whoami)'"
                  echo ""
                  echo "Despu√©s re-ejecuta el workflow."
                  exit 1
                fi
                sudo chmod 0440 /etc/sudoers.d/$CURRENT_USER 2>/dev/null || true
                
                # Verificar
                if $SUDO -n true 2>/dev/null; then
                  echo "‚úÖ Passwordless sudo configurado autom√°ticamente"
                else
                  echo "‚ùå Auto-configuraci√≥n fall√≥"
                  echo "üìù Ejecuta manualmente: echo '$(whoami) ALL=(ALL) NOPASSWD:ALL' | sudo tee /etc/sudoers.d/$(whoami)"
                  exit 1
                fi
              else
                echo "‚úÖ Passwordless sudo already configured"
              fi
            else
              echo "‚ùå Error: sudo command not found and not running as root"
              exit 1
            fi
          fi
          
          echo ""
          echo "üîß Starting deployment with SUDO='$SUDO'..."
          echo ""
          $SUDO mkdir -p /opt/asistapp
          test -f /opt/asistapp/docker-compose.prod.yml && $SUDO cp /opt/asistapp/docker-compose.prod.yml /opt/asistapp/backup-$(date +%Y%m%d%H%M%S).yml
          cat << 'ENVEOF' | $SUDO tee /opt/asistapp/.env > /dev/null
          # ============================================
          # CONFIGURACI√ìN DE BASE DE DATOS
          # ============================================
          DB_USER=$DB_USER
          DB_PASS=$DB_PASS
          DB_NAME=$DB_NAME
          DB_PORT=$DB_PORT
          DB_HOST=db
          
          # ============================================
          # CONFIGURACI√ìN JWT
          # ============================================
          JWT_SECRET=$JWT_SECRET
          JWT_EXPIRES_IN=24h
          
          # ============================================
          # CONFIGURACI√ìN DEL SERVIDOR
          # ============================================
          PORT=3000
          HOST=0.0.0.0
          NODE_ENV=production
          LOG_LEVEL=info
          
          # ============================================
          # URL DE LA API
          # ============================================
          API_BASE_URL=https://$DOMAIN
          
          # ============================================
          # DOMINIO
          # ============================================
          DOMAIN=$DOMAIN
          
          # ============================================
          # IMAGEN DOCKER
          # ============================================
          IMAGE_TAG=$IMAGE_TAG
          
          # ============================================
          # WhatsApp Cloud API (Meta Business)
          # ============================================
          WHATSAPP_API_TOKEN=${WHATSAPP_API_TOKEN:-}
          WHATSAPP_PHONE_NUMBER_ID=${WHATSAPP_PHONE_NUMBER_ID:-}
          WHATSAPP_BUSINESS_ACCOUNT_ID=${WHATSAPP_BUSINESS_ACCOUNT_ID:-}
          WHATSAPP_FALLBACK_TEMPLATE=${WHATSAPP_FALLBACK_TEMPLATE:-asistapp_asistencia}
          WHATSAPP_FALLBACK_TEMPLATE_LANG=es_CO
          
          # ============================================
          # FIREBASE CLOUD MESSAGING
          # ============================================
          FIREBASE_PROJECT_ID=${FIREBASE_PROJECT_ID:-}
          GOOGLE_APPLICATION_CREDENTIALS=/opt/asistapp/firebase-service-account.json
          
          # ============================================
          # OPCIONALES
          # ============================================
          TWILIO_ACCOUNT_SID=
          TWILIO_AUTH_TOKEN=
          TWILIO_FROM_NUMBER=
          SENDGRID_API_KEY=
          FROM_EMAIL=noreply@asistapp.com
          ENVEOF
          if [ -n "$FIREBASE_SERVICE_ACCOUNT_JSON" ]; then
            echo "üî• Configurando Firebase Service Account..."
            $SUDO rm -rf /opt/asistapp/firebase-service-account.json
            echo "$FIREBASE_SERVICE_ACCOUNT_JSON" | $SUDO tee /opt/asistapp/firebase-service-account.json > /dev/null
            $SUDO chmod 600 /opt/asistapp/firebase-service-account.json
            echo "‚úÖ Firebase Service Account configurado"
          else
            echo "‚ö†Ô∏è  FIREBASE_SERVICE_ACCOUNT_JSON no configurado, push notifications no funcionar√°n"
          fi
          $SUDO tee /opt/asistapp/docker-compose.prod.yml > /dev/null << 'EOF'
          version: '3.8'
          services:
            db:
              image: postgres:15
              container_name: asistapp_db
              restart: always
              env_file: .env
              environment:
                POSTGRES_USER: ${DB_USER}
                POSTGRES_PASSWORD: ${DB_PASS}
                POSTGRES_DB: ${DB_NAME}
              ports:
                - "${DB_PORT}:5432"
              volumes:
                - postgres_data:/var/lib/postgresql/data
              networks:
                - asistapp-network
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U ${DB_USER}"]
                interval: 10s
                timeout: 5s
                retries: 5
            app:
              image: ${IMAGE_TAG}
              container_name: backend-app-v3
              restart: always
              env_file: .env
              environment:
                DATABASE_URL: postgresql://${DB_USER}:${DB_PASS}@db:5432/${DB_NAME}?schema=public
                JWT_SECRET: ${JWT_SECRET}
                JWT_EXPIRES_IN: 24h
                PORT: 3000
                HOST: 0.0.0.0
                NODE_ENV: production
                LOG_LEVEL: info
                API_BASE_URL: https://${DOMAIN}
                WHATSAPP_API_TOKEN: ${WHATSAPP_API_TOKEN}
                WHATSAPP_PHONE_NUMBER_ID: ${WHATSAPP_PHONE_NUMBER_ID}
                WHATSAPP_BUSINESS_ACCOUNT_ID: ${WHATSAPP_BUSINESS_ACCOUNT_ID}
                WHATSAPP_FALLBACK_TEMPLATE: ${WHATSAPP_FALLBACK_TEMPLATE}
                WHATSAPP_FALLBACK_TEMPLATE_LANG: ${WHATSAPP_FALLBACK_TEMPLATE_LANG}
                FIREBASE_PROJECT_ID: ${FIREBASE_PROJECT_ID}
                GOOGLE_APPLICATION_CREDENTIALS: /app/firebase-service-account.json
              ports:
                - "127.0.0.1:3002:3000"
              volumes:
                - /opt/asistapp/firebase-service-account.json:/app/firebase-service-account.json:ro
              depends_on:
                db:
                  condition: service_healthy
              networks:
                - asistapp-network
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
          volumes:
            postgres_data:
          networks:
            asistapp-network:
              driver: bridge
          EOF
          command -v docker || ($SUDO apt-get update && $SUDO apt-get install -y ca-certificates curl && $SUDO install -m 0755 -d /etc/apt/keyrings && curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc && $SUDO chmod a+r /etc/apt/keyrings/docker.asc && echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | $SUDO tee /etc/apt/sources.list.d/docker.list && $SUDO apt-get update && $SUDO apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin && $SUDO systemctl enable docker && $SUDO systemctl start docker)
          command -v nginx || ($SUDO apt-get update && $SUDO apt-get install -y nginx certbot python3-certbot-nginx && $SUDO systemctl enable nginx && $SUDO systemctl start nginx)
          command -v ufw || ($SUDO apt-get update && $SUDO apt-get install -y ufw)
          if command -v ufw >/dev/null 2>&1; then
            echo "ufw found ‚Äî configuring firewall rules"
            # Always allow SSH
            if $SUDO ufw --version >/dev/null 2>&1; then
              $SUDO ufw allow OpenSSH || echo "Warning: ufw allow OpenSSH failed" >&2
            fi
            # Prefer the "Nginx Full" profile if available, otherwise open ports 80/443
            if $SUDO ufw app list 2>/dev/null | grep -q "Nginx Full"; then
              $SUDO ufw allow "Nginx Full" || echo "Warning: ufw allow 'Nginx Full' failed" >&2
            else
              echo "ufw profile 'Nginx Full' not found ‚Äî allowing ports 80 and 443"
              $SUDO ufw allow 80/tcp || echo "Warning: ufw allow 80 failed" >&2
              $SUDO ufw allow 443/tcp || echo "Warning: ufw allow 443 failed" >&2
            fi
            # Enable ufw if not already enabled
            if $SUDO ufw status verbose 2>/dev/null | grep -q "Status: inactive"; then
              $SUDO ufw --force enable || echo "Warning: ufw enable failed" >&2
            else
              echo "‚úÖ ufw already active"
            fi
          else
            echo "‚ÑπÔ∏è ufw not present on the system."
          fi
          
          echo "‚úçÔ∏è  Writing Nginx configuration for domain '$DOMAIN'..."
          $SUDO tee /etc/nginx/sites-available/asistapp > /dev/null << 'NGINX'
          server {
            listen 80;
            listen [::]:80;
            server_name DVAR www.DVAR;
            
            # ACME Challenge Handler
            location /.well-known/acme-challenge/ {
              root /var/www/letsencrypt;
            }
            
            # Redirect all HTTP to HTTPS
            location / {
              return 301 https://$server_name$request_uri;
            }
          }
          server {
            listen 443 ssl http2;
            listen [::]:443 ssl http2;
            server_name DVAR www.DVAR;
            
            # SSL Config
            ssl_certificate /etc/letsencrypt/live/DVAR/fullchain.pem;
            ssl_certificate_key /etc/letsencrypt/live/DVAR/privkey.pem;
            ssl_protocols TLSv1.2 TLSv1.3;
            ssl_prefer_server_ciphers off;

            # General proxy configuration
            location / {
              proxy_pass http://127.0.0.1:3002;
              proxy_http_version 1.1;
              proxy_set_header Upgrade $http_upgrade;
              proxy_set_header Connection 'upgrade';
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $scheme;
              proxy_read_timeout 90;
            }
          }
          NGINX
          
          echo "üîÑ Replacing placeholder 'DVAR' with actual domain '$DOMAIN'..."
          $SUDO sed -i "s/DVAR/$DOMAIN/g" /etc/nginx/sites-available/asistapp
          
          echo "üìÑ --- Generated Nginx Config ---"
          $SUDO cat /etc/nginx/sites-available/asistapp
          echo "üìÑ -----------------------------"

          echo "üîó Enabling the site and removing default..."
          $SUDO ln -sf /etc/nginx/sites-available/asistapp /etc/nginx/sites-enabled/
          $SUDO rm -f /etc/nginx/sites-enabled/default
          
          echo "üåê Preparing webroot for SSL certificate..."
          $SUDO mkdir -p /var/www/letsencrypt

          echo "üîê Requesting/renewing SSL certificate with Certbot..."
          # We add || true so the script doesn't fail if certs already exist and don't need renewal.
          test -d /etc/letsencrypt/live/$DOMAIN || $SUDO certbot certonly --webroot -w /var/www/letsencrypt -d $DOMAIN -d www.$DOMAIN --email $EMAIL --agree-tos --non-interactive --no-eff-email --quiet || echo "‚úÖ Certbot check completed or certs already exist."

          echo "üß™ Testing Nginx configuration..."
          if $SUDO nginx -t; then
            echo "‚úÖ Nginx configuration is OK."
            echo "üîÑ Reloading Nginx to apply changes..."
            if $SUDO systemctl reload nginx; then
              echo "‚úÖ Nginx reloaded successfully."
            else
              echo "‚ùå ERROR: Nginx reload FAILED."
              exit 1
            fi
          else
            echo "‚ùå ERROR: Nginx configuration test FAILED."
            echo "--- Problematic Nginx Config ---"
            $SUDO cat /etc/nginx/sites-available/asistapp
            echo "--------------------------------"
            exit 1
          fi
          
          echo "üê≥ Logging into container registry..."
          echo "$GITHUB_TOKEN" | $SUDO docker login ghcr.io -u "$GITHUB_ACTOR" --password-stdin || echo "‚ö†Ô∏è Warning: docker login failed"
          
          cd /opt/asistapp
          
          if [ "$RESET_DB" = "true" ]; then
            echo "‚ö†Ô∏è RESET_DB is true. Wiping database volume..."
            $SUDO docker compose -f docker-compose.prod.yml down -v || true
          else
            $SUDO docker compose -f docker-compose.prod.yml down --timeout 30 || true
          fi

          # Check for conflicting containers with fixed names. If they exist we either fail with instructions
          # or (optionally) remove them if DEPLOY_FORCE_RECREATE=true.
          CONFLICTS=""
          if $SUDO docker ps -a --format '{{.Names}}' | grep -q '^asistapp_db$'; then
            CONFLICTS="asistapp_db"
          fi
          if [ -n "$CONFLICTS" ]; then
            if [ "$DEPLOY_FORCE_RECREATE" = "true" ]; then
              echo "‚ö†Ô∏è Found conflicting containers: $CONFLICTS. Removing because DEPLOY_FORCE_RECREATE=true"
              for c in $CONFLICTS; do
                $SUDO docker rm -f $c || echo "Warning: failed to remove $c"
              done
            else
              echo "‚ùå Found conflicting containers: $CONFLICTS"
              echo "üëâ To automatically remove them, re-run this workflow and set 'deploy_force_recreate' to true"
              echo "Or connect to the VPS and run: sudo docker rm -f $CONFLICTS"
              exit 1
            fi
          fi

          # Ensure we fetch latest image and force recreate container
          $SUDO docker compose -f docker-compose.prod.yml pull || echo "Warning: docker pull failed"
          # Remove any stopped/old containers for app service to ensure fresh start
          $SUDO docker compose -f docker-compose.prod.yml rm -f -s app || true
          # Force recreate containers and don't use local cache
          $SUDO docker compose -f docker-compose.prod.yml up -d --force-recreate --no-build || echo "Warning: docker up failed"
          # Clean up unused images to free space and avoid collisions with old tag caching
          $SUDO docker image prune -af || true

          echo "üîÑ Running database migrations..."
          MIGRATION_OUTPUT=$($SUDO docker compose -f docker-compose.prod.yml run --rm app npx prisma migrate deploy 2>&1) || true
          echo "$MIGRATION_OUTPUT"
          if echo "$MIGRATION_OUTPUT" | grep -q "P3005"; then
            echo "‚ö†Ô∏è Prisma reported P3005 (Database schema is not empty). This indicates that the DB already has schema/migrations applied."
            echo "Actions recommended:"
            echo "  - If this is expected, consider running a baseline migration or using prisma migrate resolve in a controlled way."
            echo "  - If this is unexpected (CI should control DB schema), inspect the DB and migration state before re-running." 
            echo "  - To skip migrations automatically (not recommended) set PRISMA_ALLOW_FAIL=true in the workflow env or handle manually."
          elif echo "$MIGRATION_OUTPUT" | grep -q "Already up to date"; then
            echo "Prisma: Already up to date"
          elif [ -n "$MIGRATION_OUTPUT" ] && ! echo "$MIGRATION_OUTPUT" | grep -q "No migrations to apply"; then
            echo "Warning: migrations possibly failed or produced a warning above. Check logs and DB state."
          fi

          if [ "$RUN_SEED" = "true" ]; then
            echo "üå± Seeding database..."
            $SUDO docker compose -f docker-compose.prod.yml run --rm app npx prisma db seed || echo "Warning: seed failed"
          fi

          echo "Deploy completed"
          $SUDO docker compose -f docker-compose.prod.yml ps

