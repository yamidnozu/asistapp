
/* Directorio: \lib */
â”œâ”€â”€ main.dart [94]
â”œâ”€â”€ ðŸ“‚ managers
â”‚   â””â”€â”€ app_lifecycle_manager.dart [110]
â”œâ”€â”€ ðŸ“‚ models
â”‚   â”œâ”€â”€ institution.dart [97]
â”‚   â””â”€â”€ user.dart [290]
â”œâ”€â”€ ðŸ“‚ providers
â”‚   â”œâ”€â”€ auth_provider.dart [194]
â”‚   â”œâ”€â”€ institution_provider.dart [229]
â”‚   â””â”€â”€ user_provider.dart [403]
â”œâ”€â”€ ðŸ“‚ screens
â”‚   â”œâ”€â”€ admin_dashboard.dart [123]
â”‚   â”œâ”€â”€ app_shell.dart [62]
â”‚   â”œâ”€â”€ home_screen.dart [339]
â”‚   â”œâ”€â”€ ðŸ“‚ institutions
â”‚   â”‚   â”œâ”€â”€ create_institution_admin_screen.dart [354]
â”‚   â”‚   â”œâ”€â”€ institutions_list_screen.dart [502]
â”‚   â”‚   â”œâ”€â”€ institution_admins_screen.dart [242]
â”‚   â”‚   â””â”€â”€ institution_form_screen.dart [326]
â”‚   â”œâ”€â”€ institution_selection_screen.dart [194]
â”‚   â”œâ”€â”€ login_screen.dart [348]
â”‚   â”œâ”€â”€ student_dashboard.dart [133]
â”‚   â”œâ”€â”€ super_admin_dashboard.dart [117]
â”‚   â”œâ”€â”€ teacher_dashboard.dart [133]
â”‚   â”œâ”€â”€ teacher_dashboard_with_scroll.dart [89]
â”‚   â”œâ”€â”€ ðŸ“‚ users
â”‚   â”‚   â”œâ”€â”€ create_professor_screen.dart [11]
â”‚   â”‚   â”œâ”€â”€ create_student_screen.dart [11]
â”‚   â”‚   â”œâ”€â”€ users_list_screen.dart [687]
â”‚   â”‚   â”œâ”€â”€ user_detail_screen.dart [160]
â”‚   â”‚   â””â”€â”€ user_form_screen.dart [745]
â”‚   â””â”€â”€ welcome_screen.dart [91]
â”œâ”€â”€ ðŸ“‚ services
â”‚   â”œâ”€â”€ auth_service.dart [190]
â”‚   â”œâ”€â”€ institution_service.dart [239]
â”‚   â”œâ”€â”€ profesor_service.dart [272]
â”‚   â””â”€â”€ user_service.dart [378]
â”œâ”€â”€ ðŸ“‚ theme
â”‚   â”œâ”€â”€ app_colors.dart [95]
â”‚   â”œâ”€â”€ app_constants.dart [59]
â”‚   â”œâ”€â”€ app_spacing.dart [24]
â”‚   â”œâ”€â”€ app_text_styles.dart [153]
â”‚   â”œâ”€â”€ app_theme.dart [205]
â”‚   â”œâ”€â”€ index.dart [5]
â”‚   â””â”€â”€ theme_extensions.dart [42]
â”œâ”€â”€ ðŸ“‚ ui
â”‚   â””â”€â”€ ðŸ“‚ widgets
â”‚       â”œâ”€â”€ app_button.dart [194]
â”‚       â”œâ”€â”€ app_components.dart [217]
â”‚       â”œâ”€â”€ error_logger.dart [198]
â”‚       â””â”€â”€ index.dart [4]
â”œâ”€â”€ ðŸ“‚ utils
â”‚   â”œâ”€â”€ app_constants.dart [6]
â”‚   â”œâ”€â”€ app_router.dart [245]
â”‚   â”œâ”€â”€ app_routes.dart [48]
â”‚   â”œâ”€â”€ responsive_utils.dart [166]
â”‚   â”œâ”€â”€ role_enum.dart [53]
â”‚   â””â”€â”€ route_guards.dart [32]
â””â”€â”€ ðŸ“‚ widgets
    â”œâ”€â”€ ðŸ“‚ common
    â”‚   â”œâ”€â”€ empty_state_widget.dart [47]
    â”‚   â”œâ”€â”€ management_scaffold.dart [218]
    â”‚   â””â”€â”€ shimmer_list_widget.dart [32]
    â”œâ”€â”€ dashboard_widgets.dart [268]
    â”œâ”€â”€ form_widgets.dart [305]
    â”œâ”€â”€ index.dart [1]
    â”œâ”€â”€ pagination_widget.dart [411]
    â”œâ”€â”€ role_guard.dart [39]
    â”œâ”€â”€ scroll_state_keeper.dart [31]
    â””â”€â”€ session_info_footer.dart [105]


/* Directorio: \backend */
â”œâ”€â”€ ðŸ“‚ dist
â”‚   â”œâ”€â”€ ðŸ“‚ config
â”‚   â”‚   â”œâ”€â”€ app.js [13]
â”‚   â”‚   â”œâ”€â”€ database.js [40]
â”‚   â”‚   â””â”€â”€ jwt.js [60]
â”‚   â”œâ”€â”€ ðŸ“‚ controllers
â”‚   â”‚   â”œâ”€â”€ admin-institucion.controller.js [103]
â”‚   â”‚   â”œâ”€â”€ auth.controller.js [127]
â”‚   â”‚   â”œâ”€â”€ institucion.controller.js [100]
â”‚   â”‚   â”œâ”€â”€ institution-admin.controller.js [247]
â”‚   â”‚   â””â”€â”€ user.controller.js [175]
â”‚   â”œâ”€â”€ index.js [84]
â”‚   â”œâ”€â”€ ðŸ“‚ middleware
â”‚   â”‚   â”œâ”€â”€ auth.js [88]
â”‚   â”‚   â””â”€â”€ errorHandler.js [98]
â”‚   â”œâ”€â”€ ðŸ“‚ routes
â”‚   â”‚   â”œâ”€â”€ admin-institucion.routes.js [30]
â”‚   â”‚   â”œâ”€â”€ auth.routes.js [40]
â”‚   â”‚   â”œâ”€â”€ index.js [55]
â”‚   â”‚   â”œâ”€â”€ institucion.routes.js [30]
â”‚   â”‚   â”œâ”€â”€ institution-admin.routes.js [28]
â”‚   â”‚   â””â”€â”€ user.routes.js [41]
â”‚   â”œâ”€â”€ ðŸ“‚ scripts
â”‚   â”‚   â””â”€â”€ cleanup-tokens.js [33]
â”‚   â”œâ”€â”€ ðŸ“‚ services
â”‚   â”‚   â”œâ”€â”€ admin-institucion.service.js [247]
â”‚   â”‚   â”œâ”€â”€ auth.service.js [232]
â”‚   â”‚   â”œâ”€â”€ institucion.service.js [192]
â”‚   â”‚   â”œâ”€â”€ profesor.service.js [310]
â”‚   â”‚   â””â”€â”€ user.service.js [381]
â”‚   â”œâ”€â”€ ðŸ“‚ types
â”‚   â”‚   â””â”€â”€ index.js [44]
â”‚   â””â”€â”€ ðŸ“‚ utils
â”‚       â””â”€â”€ index.js [78]
â”œâ”€â”€ jest.unit.config.js [13]
â”œâ”€â”€ ðŸ“‚ prisma
â”‚   â”œâ”€â”€ seed.ts [381]
â”œâ”€â”€ ðŸ“‚ src
â”‚   â”œâ”€â”€ ðŸ“‚ config
â”‚   â”‚   â”œâ”€â”€ app.ts [12]
â”‚   â”‚   â”œâ”€â”€ database.ts [43]
â”‚   â”‚   â””â”€â”€ jwt.ts [59]
â”‚   â”œâ”€â”€ ðŸ“‚ controllers
â”‚   â”‚   â”œâ”€â”€ admin-institucion.controller.ts [103]
â”‚   â”‚   â”œâ”€â”€ auth.controller.ts [130]
â”‚   â”‚   â”œâ”€â”€ institucion.controller.ts [175]
â”‚   â”‚   â”œâ”€â”€ institution-admin.controller.ts [285]
â”‚   â”‚   â””â”€â”€ user.controller.ts [208]
â”‚   â”œâ”€â”€ index.ts [98]
â”‚   â”œâ”€â”€ ðŸ“‚ middleware
â”‚   â”‚   â”œâ”€â”€ auth.ts [87]
â”‚   â”‚   â””â”€â”€ errorHandler.ts [106]
â”‚   â”œâ”€â”€ ðŸ“‚ routes
â”‚   â”‚   â”œâ”€â”€ admin-institucion.routes.ts [32]
â”‚   â”‚   â”œâ”€â”€ auth.routes.ts [37]
â”‚   â”‚   â”œâ”€â”€ index.ts [54]
â”‚   â”‚   â”œâ”€â”€ institucion.routes.ts [43]
â”‚   â”‚   â”œâ”€â”€ institution-admin.routes.ts [20]
â”‚   â”‚   â””â”€â”€ user.routes.ts [33]
â”‚   â”œâ”€â”€ ðŸ“‚ scripts
â”‚   â”‚   â””â”€â”€ cleanup-tokens.ts [32]
â”‚   â”œâ”€â”€ ðŸ“‚ services
â”‚   â”‚   â”œâ”€â”€ admin-institucion.service.ts [270]
â”‚   â”‚   â”œâ”€â”€ auth.service.ts [259]
â”‚   â”‚   â”œâ”€â”€ institucion.service.ts [319]
â”‚   â”‚   â”œâ”€â”€ profesor.service.ts [332]
â”‚   â”‚   â””â”€â”€ user.service.ts [377]
â”‚   â”œâ”€â”€ ðŸ“‚ types
â”‚   â”‚   â””â”€â”€ index.ts [248]
â”‚   â””â”€â”€ ðŸ“‚ utils
â”‚       â””â”€â”€ index.ts [87]
â”œâ”€â”€ test-server.ts [25]
â”œâ”€â”€ ðŸ“‚ tests
â”‚   â”œâ”€â”€ auth.integration.test.js [160]
â”‚   â”œâ”€â”€ auth.integration.test.ts [402]
â”‚   â”œâ”€â”€ auth.service.test.js [213]
â”‚   â”œâ”€â”€ auth.service.test.ts [514]
â”‚   â”œâ”€â”€ institucion.integration.test.ts [432]
â”‚   â”œâ”€â”€ setup.js [15]
â”‚   â”œâ”€â”€ setup.ts [16]
â”‚   â”œâ”€â”€ simple-validation.test.js [277]
â”‚   â”œâ”€â”€ test-database.ts [56]
â”‚   â”œâ”€â”€ user.controller.test.ts [411]
â”‚   â”œâ”€â”€ user.integration.test.ts [683]
â”‚   â”œâ”€â”€ user.logic.test.ts [230]
â”‚   â”œâ”€â”€ user.service.test.ts [463]
â”‚   â””â”€â”€ user.validation.test.ts [217]


Total de lÃ­neas resumidas: 21199
Total de archivos: 124
Promedio de lÃ­neas por archivo: 171
Archivo mÃ¡s grande: user_form_screen.dart (745 lÃ­neas)


/* Inicio lib\main.dart */
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'providers/auth_provider.dart';
import 'providers/institution_provider.dart';
import 'providers/user_provider.dart';
import 'managers/app_lifecycle_manager.dart';
import 'theme/app_theme.dart';
import 'theme/app_colors.dart';
import 'utils/app_router.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle(
    statusBarColor: AppColors.instance.transparent,
    statusBarIconBrightness: Brightness.light,
    systemNavigationBarColor: AppColors.instance.black,
    systemNavigationBarIconBrightness: Brightness.light,
  ));

  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> with WidgetsBindingObserver {

  late final AppLifecycleManager _lifecycleManager;
  late final AuthProvider _authProvider;
  late final InstitutionProvider _institutionProvider;
  late AppRouter _appRouter;

  @override
  void initState() {
    super.initState();

    _lifecycleManager = AppLifecycleManager();
    _authProvider = AuthProvider();
    _institutionProvider = InstitutionProvider();

    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _appRouter.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider.value(value: _authProvider),
        ChangeNotifierProvider.value(value: _institutionProvider),
        ChangeNotifierProvider(create: (_) => UserProvider()),
        ChangeNotifierProvider.value(value: _lifecycleManager),
      ],
      child: Builder(
        builder: (context) {

          _appRouter = AppRouter(
            authProvider: _authProvider,
          );

          return MaterialApp.router(
            title: 'AsistApp',
            debugShowCheckedModeBanner: false,
            theme: AppTheme.defaultTheme,
            routerConfig: _appRouter.router,
            builder: (context, child) {
              return DefaultTextStyle(
                style: TextStyle(
                  decoration: TextDecoration.none,
                  color: AppColors.instance.white,
                  fontSize: 14.0,
                  fontWeight: FontWeight.normal,
                ),
                child: child!,
              );
            },
          );
        },
      ),
    );
  }
}
/* Fin lib\main.dart */

/* Inicio lib\managers\app_lifecycle_manager.dart */
import 'package:flutter/widgets.dart';
enum AppState {
  resumed,
  paused,
  hidden,
  detached,
}
class AppLifecycleManager extends ChangeNotifier {
  AppState _currentState = AppState.resumed;
  DateTime? _lastPausedTime;
  bool _isFirstResume = true;

  AppState get currentState => _currentState;
  bool get isInForeground => _currentState == AppState.resumed;
  bool get isInBackground => _currentState == AppState.paused || _currentState == AppState.hidden;

  AppLifecycleManager() {
    WidgetsBinding.instance.addObserver(_AppLifecycleObserver(this));
  }

  void _onLifecycleChanged(AppState state) {
    final previousState = _currentState;
    _currentState = state;

    switch (state) {
      case AppState.paused:
        _handleAppPaused();
        break;
      case AppState.resumed:
        _handleAppResumed(previousState);
        break;
      case AppState.hidden:
        _handleAppHidden();
        break;
      case AppState.detached:
        _handleAppDetached();
        break;
    }

    notifyListeners();
  }

  void _handleAppPaused() {
    _lastPausedTime = DateTime.now();
    debugPrint('AppLifecycleManager: App paused at $_lastPausedTime');
  }

  void _handleAppResumed(AppState previousState) {
    final now = DateTime.now();
    final timeInBackground = _lastPausedTime != null ? now.difference(_lastPausedTime!) : Duration.zero;

    debugPrint('AppLifecycleManager: App resumed after ${timeInBackground.inSeconds}s in background');
    if (_isFirstResume) {
      _isFirstResume = false;
      return;
    }
    if (timeInBackground.inSeconds > 30) {
      debugPrint('AppLifecycleManager: Long background time, triggering data refresh');
      _triggerDataRefresh();
    } else {
      debugPrint('AppLifecycleManager: Quick resume, using cached data');
    }
  }

  void _handleAppHidden() {
    debugPrint('AppLifecycleManager: App hidden');
  }

  void _handleAppDetached() {
    debugPrint('AppLifecycleManager: App detached');
  }
  void _triggerDataRefresh() {
    debugPrint('AppLifecycleManager: Triggering data refresh...');
  }
  void addLifecycleCallback(String key, VoidCallback callback) {
  }

  void removeLifecycleCallback(String key) {
  }
}
class _AppLifecycleObserver extends WidgetsBindingObserver {
  final AppLifecycleManager _manager;

  _AppLifecycleObserver(this._manager);

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    AppState mappedState;

    switch (state) {
      case AppLifecycleState.resumed:
        mappedState = AppState.resumed;
        break;
      case AppLifecycleState.paused:
        mappedState = AppState.paused;
        break;
      case AppLifecycleState.hidden:
        mappedState = AppState.hidden;
        break;
      case AppLifecycleState.detached:
        mappedState = AppState.detached;
        break;
      case AppLifecycleState.inactive:
        mappedState = AppState.paused;
        break;
    }

    _manager._onLifecycleChanged(mappedState);
  }
}
/* Fin lib\managers\app_lifecycle_manager.dart */

/* Inicio lib\models\institution.dart */
class Institution {
  final String id;
  final String nombre;
  final String? direccion;
  final String? telefono;
  final String? email;
  final bool activa;
  final DateTime? createdAt;
  final DateTime? updatedAt;
  final String? role
  final Map<String, dynamic>? metadata;

  Institution({
    required this.id,
    required this.nombre,
    this.direccion,
    this.telefono,
    this.email,
    this.activa = true,
    this.createdAt,
    this.updatedAt,
    this.role,
    this.metadata,
  });

  factory Institution.fromJson(Map<String, dynamic> json) {
    return Institution(
      id: json['id'] as String,
      nombre: json['nombre'] as String? ?? json['name'] as String? ?? 'InstituciÃ³n sin nombre',
      direccion: json['direccion'] as String?,
      telefono: json['telefono'] as String?,
      email: json['email'] as String?,
      activa: json['activa'] as bool? ?? true,
      createdAt: json['createdAt'] != null ? DateTime.parse(json['createdAt']) : null,
      updatedAt: json['updatedAt'] != null ? DateTime.parse(json['updatedAt']) : null,
      role: json['rolEnInstitucion'] as String? ?? json['role'] as String?,
      metadata: json['metadata'] as Map<String, dynamic>?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'nombre': nombre,
      if (direccion != null) 'direccion': direccion,
      if (telefono != null) 'telefono': telefono,
      if (email != null) 'email': email,
      'activa': activa,
      if (createdAt != null) 'createdAt': createdAt!.toIso8601String(),
      if (updatedAt != null) 'updatedAt': updatedAt!.toIso8601String(),
      if (role != null) 'role': role,
      if (role != null) 'rolEnInstitucion': role,
      if (metadata != null) 'metadata': metadata,
    };
  }
  String get name => nombre;

  Institution copyWith({
    String? id,
    String? nombre,
    String? direccion,
    String? telefono,
    String? email,
    bool? activa,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? role,
    Map<String, dynamic>? metadata,
  }) {
    return Institution(
      id: id ?? this.id,
      nombre: nombre ?? this.nombre,
      direccion: direccion ?? this.direccion,
      telefono: telefono ?? this.telefono,
      email: email ?? this.email,
      activa: activa ?? this.activa,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      role: role ?? this.role,
      metadata: metadata ?? this.metadata,
    );
  }

  @override
  String toString() {
    return 'Institution(id: $id, nombre: $nombre, activa: $activa)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Institution && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;
}
/* Fin lib\models\institution.dart */

/* Inicio lib\models\user.dart */
import '../utils/app_constants.dart';

class User {
  final String id;
  final String email;
  final String nombres;
  final String apellidos;
  final String rol;
  final String? telefono;
  final bool activo;
  final List<UserInstitution> instituciones;
  final StudentDetails? estudiante;

  User({
    required this.id,
    required this.email,
    required this.nombres,
    required this.apellidos,
    required this.rol,
    this.telefono,
    required this.activo,
    required this.instituciones,
    this.estudiante,
  });

  String get nombreCompleto => '$nombres $apellidos';

  bool get esProfesor => rol == 'profesor';
  bool get esEstudiante => rol == 'estudiante';
  bool get esAdminInstitucion => rol == 'admin_institucion';
  bool get esSuperAdmin => rol == 'super_admin';

  factory User.fromJson(Map<String, dynamic> json) {
    return User(
      id: json['id'] as String? ?? '',
      email: json['email'] as String? ?? '',
      nombres: json['nombres'] as String? ?? '',
      apellidos: json['apellidos'] as String? ?? '',
      rol: json['rol'] as String? ?? 'profesor', // Default to profesor for institution-admin context
      telefono: json['telefono'] as String?,
      activo: json['activo'] as bool? ?? true,
      instituciones: (json['usuarioInstituciones'] as List<dynamic>?)
          ?.map((e) => UserInstitution.fromJson(e as Map<String, dynamic>))
          .toList() ?? [],
      estudiante: json['estudiante'] != null
          ? StudentDetails.fromJson(json['estudiante'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'email': email,
      'nombres': nombres,
      'apellidos': apellidos,
      'rol': rol,
      'telefono': telefono,
      'activo': activo,
      'usuarioInstituciones': instituciones.map((e) => e.toJson()).toList(),
      if (estudiante != null) 'estudiante': estudiante!.toJson(),
    };
  }

  User copyWith({
    String? id,
    String? email,
    String? nombres,
    String? apellidos,
    String? rol,
    String? telefono,
    bool? activo,
    List<UserInstitution>? instituciones,
    StudentDetails? estudiante,
  }) {
    return User(
      id: id ?? this.id,
      email: email ?? this.email,
      nombres: nombres ?? this.nombres,
      apellidos: apellidos ?? this.apellidos,
      rol: rol ?? this.rol,
      telefono: telefono ?? this.telefono,
      activo: activo ?? this.activo,
      instituciones: instituciones ?? this.instituciones,
      estudiante: estudiante ?? this.estudiante,
    );
  }
}

class UserInstitution {
  final String id;
  final String nombre;
  final String? rolEnInstitucion;
  final bool activo;

  UserInstitution({
    required this.id,
    required this.nombre,
    this.rolEnInstitucion,
    required this.activo,
  });

  factory UserInstitution.fromJson(Map<String, dynamic> json) {
    return UserInstitution(
      id: json['institucion']?['id'] as String? ?? '',
      nombre: json['institucion']?['nombre'] as String? ?? '',
      rolEnInstitucion: json['rolEnInstitucion'] as String?,
      activo: json['activo'] as bool? ?? true,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'institucion': {
        'id': id,
        'nombre': nombre,
      },
      'rolEnInstitucion': rolEnInstitucion,
      'activo': activo,
    };
  }
}

class StudentDetails {
  final String id;
  final String identificacion;
  final String codigoQr;
  final String? nombreResponsable;
  final String? telefonoResponsable;

  StudentDetails({
    required this.id,
    required this.identificacion,
    required this.codigoQr,
    this.nombreResponsable,
    this.telefonoResponsable,
  });

  factory StudentDetails.fromJson(Map<String, dynamic> json) {
    return StudentDetails(
      id: json['id'] as String? ?? '',
      identificacion: json['identificacion'] as String? ?? '',
      codigoQr: json['codigoQr'] as String? ?? '',
      nombreResponsable: json['nombreResponsable'] as String?,
      telefonoResponsable: json['telefonoResponsable'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'identificacion': identificacion,
      'codigoQr': codigoQr,
      'nombreResponsable': nombreResponsable,
      'telefonoResponsable': telefonoResponsable,
    };
  }
}
class CreateUserRequest {
  final String email;
  final String password;
  final String nombres;
  final String apellidos;
  final String rol;
  final String? telefono;
  final String? institucionId;
  final String? rolEnInstitucion;
  final String? identificacion;
  final String? nombreResponsable;
  final String? telefonoResponsable;
  final String? titulo;
  final String? especialidad;

  CreateUserRequest({
    required this.email,
    required this.password,
    required this.nombres,
    required this.apellidos,
    required this.rol,
    this.telefono,
    this.institucionId,
    this.rolEnInstitucion,
    this.identificacion,
    this.nombreResponsable,
    this.telefonoResponsable,
    this.titulo,
    this.especialidad,
  });

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = {
      'email': email,
      'password': password,
      'nombres': nombres,
      'apellidos': apellidos,
      'rol': rol,
      if (telefono != null) 'telefono': telefono,
      if (institucionId != null) 'institucionId': institucionId,
      if (rolEnInstitucion != null) 'rolEnInstitucion': rolEnInstitucion,
    };
    if (rol == 'estudiante') {
      if (identificacion != null) data['identificacion'] = identificacion;
      if (nombreResponsable != null) data['nombreResponsable'] = nombreResponsable;
      if (telefonoResponsable != null) data['telefonoResponsable'] = telefonoResponsable;
    }
    if (rol == 'profesor') {
      if (titulo != null) data['titulo'] = titulo;
      if (especialidad != null) data['especialidad'] = especialidad;
    }

    return data;
  }
}

class UpdateUserRequest {
  final String? email;
  final String? nombres;
  final String? apellidos;
  final String? telefono;
  final bool? activo;
  final String? identificacion;
  final String? nombreResponsable;
  final String? telefonoResponsable;

  UpdateUserRequest({
    this.email,
    this.nombres,
    this.apellidos,
    this.telefono,
    this.activo,
    this.identificacion,
    this.nombreResponsable,
    this.telefonoResponsable,
  });

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = {};

    if (email != null) data['email'] = email;
    if (nombres != null) data['nombres'] = nombres;
    if (apellidos != null) data['apellidos'] = apellidos;
    if (telefono != null) data['telefono'] = telefono;
    if (activo != null) data['activo'] = activo;
    if (identificacion != null) data['identificacion'] = identificacion;
    if (nombreResponsable != null) data['nombreResponsable'] = nombreResponsable;
    if (telefonoResponsable != null) data['telefonoResponsable'] = telefonoResponsable;

    return data;
  }
}

class PaginationInfo {
  final int page;
  final int limit;
  final int total;
  final int totalPages;
  final bool hasNext;
  final bool hasPrev;

  PaginationInfo({
    required this.page,
    required this.limit,
    required this.total,
    required this.totalPages,
    required this.hasNext,
    required this.hasPrev,
  });

  factory PaginationInfo.fromJson(Map<String, dynamic> json) {
    return PaginationInfo(
      page: json['page'] as int? ?? 1,
      limit: json['limit'] as int? ?? AppConstants.itemsPerPage,
      total: json['total'] as int? ?? 0,
      totalPages: json['totalPages'] as int? ?? 1,
      hasNext: json['hasNext'] as bool? ?? false,
      hasPrev: json['hasPrev'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'page': page,
      'limit': limit,
      'total': total,
      'totalPages': totalPages,
      'hasNext': hasNext,
      'hasPrev': hasPrev,
    };
  }
}
/* Fin lib\models\user.dart */

/* Inicio lib\providers\auth_provider.dart */
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../services/auth_service.dart';
import '../models/institution.dart';

class AuthProvider with ChangeNotifier {
  final AuthService _authService = AuthService();

  String? _accessToken;
  String? _refreshToken;
  Map<String, dynamic>? _user;
  String? _selectedInstitutionId;
  List<Institution>? _institutions;

  String? get accessToken => _accessToken;
  String? get refreshToken => _refreshToken;
  Map<String, dynamic>? get user => _user;
  String? get selectedInstitutionId => _selectedInstitutionId;
  List<Institution>? get institutions => _institutions;

  bool get isAuthenticated => _accessToken != null && _user != null;

  Institution? get selectedInstitution {
    if (_selectedInstitutionId == null || _institutions == null) return null;
    try {
      return _institutions!.firstWhere(
        (institution) => institution.id == _selectedInstitutionId,
      );
    } catch (e) {
      return null;
    }
  }

  AuthProvider() {
    _loadTokensFromStorage();
  }

  Future<void> _loadTokensFromStorage() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      _accessToken = prefs.getString('accessToken');
      _refreshToken = prefs.getString('refreshToken');
      final userJson = prefs.getString('user');
      if (userJson != null) {
        _user = Map<String, dynamic>.from(jsonDecode(userJson));
      }
      _selectedInstitutionId = prefs.getString('selectedInstitutionId');
      notifyListeners();
    } catch (e) {
      debugPrint('Error loading from storage: $e');
    }
  }

  Future<void> _saveTokensToStorage() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      if (_accessToken != null) {
        await prefs.setString('accessToken', _accessToken!);
      } else {
        await prefs.remove('accessToken');
      }
      if (_refreshToken != null) {
        await prefs.setString('refreshToken', _refreshToken!);
      } else {
        await prefs.remove('refreshToken');
      }
      if (_user != null) {
        await prefs.setString('user', jsonEncode(_user));
      } else {
        await prefs.remove('user');
      }
      if (_selectedInstitutionId != null) {
        await prefs.setString('selectedInstitutionId', _selectedInstitutionId!);
      } else {
        await prefs.remove('selectedInstitutionId');
      }
    } catch (e) {
      debugPrint('Error saving to storage: $e');
    }
  }

  Future<void> _clearTokens() async {
    _accessToken = null;
    _refreshToken = null;
    _user = null;
    _selectedInstitutionId = null;
    await _saveTokensToStorage();
    notifyListeners();
  }

  void clearHeavyData() {
    _institutions = null;
    notifyListeners();
  }

  void clearTemporaryData() {
    _institutions = null;
    _selectedInstitutionId = null;
    notifyListeners();
  }

  Future<void> recoverFullState() async {
    if (_accessToken != null) {
      debugPrint('Recuperando estado completo del usuario');
      await loadUserInstitutions();

      if (_selectedInstitutionId != null && _institutions != null) {
        final institutionExists = _institutions!.any((i) => i.id == _selectedInstitutionId);
        if (!institutionExists) {
          debugPrint('InstituciÃ³n guardada ya no existe, limpiando');
          _selectedInstitutionId = null;
          await _saveTokensToStorage();
        }
      }

      notifyListeners();
    }
  }

  Future<void> loadUserInstitutions({bool notify = true}) async {
    if (_accessToken == null) return;

    try {
      final institutionMaps = await _authService.getUserInstitutions(_accessToken!);
      _institutions = institutionMaps?.map((map) => Institution.fromJson(map)).toList();
      if (notify) notifyListeners();
    } catch (e) {
      debugPrint('Error loading user institutions: $e');
    }
  }

  void selectInstitution(String institutionId) {
    _selectedInstitutionId = institutionId;
    _saveTokensToStorage();
    notifyListeners();
  }

  Future<bool> login(String email, String password) async {
    try {
      final result = await _authService.login(email, password);
      if (result != null) {
        _accessToken = result.accessToken;
        _refreshToken = result.refreshToken;
        _user = result.user;

        await loadUserInstitutions(notify: false);

        if (_institutions != null && _institutions!.length == 1) {
          _selectedInstitutionId = _institutions!.first.id;
          debugPrint('InstituciÃ³n seleccionada automÃ¡ticamente: $_selectedInstitutionId');
        } else if (_institutions != null && _institutions!.length > 1) {

          _selectedInstitutionId = null;
          debugPrint('MÃºltiples instituciones encontradas, esperando selecciÃ³n manual');
        }

        await _saveTokensToStorage();
        notifyListeners();
        return true;
      }
      return false;
    } catch (e) {
      debugPrint('Login error: $e');
      return false;
    }
  }

  Future<bool> refreshAccessToken() async {
    if (_refreshToken == null) return false;

    try {
      final result = await _authService.refreshToken(_refreshToken!);
      if (result != null) {
        _accessToken = result.accessToken;
        _refreshToken = result.refreshToken;
        await _saveTokensToStorage();
        notifyListeners();
        return true;
      }
      return false;
    } catch (e) {
      debugPrint('Refresh error: $e');
      return false;
    }
  }

  Future<void> logout() async {
    if (_refreshToken != null) {
      await _authService.logout(_refreshToken!);
    }
    await _clearTokens();
  }
}
/* Fin lib\providers\auth_provider.dart */

/* Inicio lib\providers\institution_provider.dart */
import 'dart:async';
import 'package:flutter/foundation.dart';
import '../services/institution_service.dart';
import '../models/institution.dart';
import '../models/user.dart';

enum InstitutionState {
  initial,
  loading,
  loaded,
  error,
}

class InstitutionProvider with ChangeNotifier {
  final InstitutionService _institutionService = InstitutionService();

  InstitutionState _state = InstitutionState.initial;
  String? _errorMessage;
  List<Institution> _institutions = [];
  Institution? _selectedInstitution;
  PaginationInfo? _paginationInfo;
  bool _isLoadingMore = false;
  bool _hasMoreData = true;
  InstitutionState get state => _state;
  String? get errorMessage => _errorMessage;
  List<Institution> get institutions => _institutions;
  Institution? get selectedInstitution => _selectedInstitution;
  PaginationInfo? get paginationInfo => _paginationInfo;

  bool get isLoading => _state == InstitutionState.loading;
  bool get hasError => _state == InstitutionState.error;
  bool get isLoaded => _state == InstitutionState.loaded;
  bool get isLoadingMore => _isLoadingMore;
  bool get hasMoreData => _hasMoreData;
  List<Institution> get activeInstitutions =>
      _institutions.where((inst) => inst.activa).toList();

  List<Institution> get inactiveInstitutions =>
      _institutions.where((inst) => !inst.activa).toList();

  int get totalInstitutions => _institutions.length;
  int get activeInstitutionsCount => activeInstitutions.length;
  int get inactiveInstitutionsCount => inactiveInstitutions.length;

  void _setState(InstitutionState newState, [String? error]) {
    _state = newState;
    _errorMessage = error;
    notifyListeners();
  }
  void resetPagination() {
    _hasMoreData = true;
    _isLoadingMore = false;
  }
  Future<void> loadInstitutions(String accessToken, {int? page, int? limit, bool? activa, String? search}) async {
    if (_state == InstitutionState.loading) return;

    _setState(InstitutionState.loading);
    resetPagination()

    try {
      debugPrint('InstitutionProvider: Iniciando carga de instituciones...');
      final response = await _institutionService.getAllInstitutions(accessToken, page: page ?? 1, limit: limit, activa: activa, search: search);
      if (response != null) {
        debugPrint('InstitutionProvider: Recibidas ${response.institutions.length} instituciones');
        _institutions = response.institutions;
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
        _setState(InstitutionState.loaded);
        debugPrint('InstitutionProvider: Estado cambiado a loaded');
      } else {
        _setState(InstitutionState.error, 'Error al cargar instituciones');
      }
    } catch (e) {
      debugPrint('InstitutionProvider: Error loading institutions: $e');
      _setState(InstitutionState.error, e.toString());
    }
  }
  Future<void> loadInstitutionById(String accessToken, String id) async {
    _setState(InstitutionState.loading);

    try {
      final institution = await _institutionService.getInstitutionById(accessToken, id);
      _selectedInstitution = institution;
      _setState(InstitutionState.loaded);
    } catch (e) {
      debugPrint('Error loading institution: $e');
      _setState(InstitutionState.error, e.toString());
    }
  }
  Future<bool> createInstitution(
    String accessToken,
    Map<String, dynamic> institutionData,
  ) async {
    _setState(InstitutionState.loading);

    try {
      final newInstitution = await _institutionService.createInstitution(
        accessToken,
        nombre: institutionData['nombre'],
        direccion: institutionData['direccion'],
        telefono: institutionData['telefono'],
        email: institutionData['email'],
      );
      if (newInstitution != null) {
        _institutions.insert(0, newInstitution);
      }
      _setState(InstitutionState.loaded);
      return true;
    } catch (e) {
      debugPrint('Error creating institution: $e');
      _setState(InstitutionState.error, e.toString());
      return false;
    }
  }
  Future<bool> updateInstitution(
    String accessToken,
    String id, {
    String? nombre,
    String? direccion,
    String? telefono,
    String? email,
    bool? activa,
  }) async {
    _setState(InstitutionState.loading);

    try {
      final updatedInstitution = await _institutionService.updateInstitution(
        accessToken,
        id,
        nombre: nombre,
        direccion: direccion,
        telefono: telefono,
        email: email,
        activa: activa,
      );
      final index = _institutions.indexWhere((inst) => inst.id == id);
      if (index != -1 && updatedInstitution != null) {
        _institutions[index] = updatedInstitution;
      }
      if (_selectedInstitution?.id == id && updatedInstitution != null) {
        _selectedInstitution = updatedInstitution;
      }

      _setState(InstitutionState.loaded);
      return true;
    } catch (e) {
      debugPrint('Error updating institution: $e');
      _setState(InstitutionState.error, e.toString());
      return false;
    }
  }
  Future<bool> deleteInstitution(String accessToken, String id) async {
    _setState(InstitutionState.loading);

    try {
      await _institutionService.deleteInstitution(accessToken, id);
      _institutions.removeWhere((inst) => inst.id == id);
      if (_selectedInstitution?.id == id) {
        _selectedInstitution = null;
      }

      _setState(InstitutionState.loaded);
      return true;
    } catch (e) {
      debugPrint('Error deleting institution: $e');
      _setState(InstitutionState.error, e.toString());
      return false;
    }
  }
  void selectInstitution(Institution institution) {
    _selectedInstitution = institution;
    notifyListeners();
  }
  void clearSelectedInstitution() {
    _selectedInstitution = null;
    notifyListeners();
  }
  void clearData() {
    _institutions = [];
    _selectedInstitution = null;
    _setState(InstitutionState.initial);
  }
  Future<void> refreshData(String accessToken) async {
    await loadInstitutions(accessToken);
  }
  List<Institution> searchInstitutions(String query) {
    if (query.isEmpty) return _institutions;

    final lowercaseQuery = query.toLowerCase();
    return _institutions.where((inst) {
      return inst.nombre.toLowerCase().contains(lowercaseQuery) ||
             (inst.email?.toLowerCase().contains(lowercaseQuery) ?? false);
    }).toList();
  }
  Future<void> loadMoreInstitutions(String accessToken, {bool? activa, String? search}) async {
    if (_isLoadingMore || !_hasMoreData || _paginationInfo == null) return;

    _isLoadingMore = true;
    notifyListeners();

    try {
      final nextPage = _paginationInfo!.page + 1;
      debugPrint('InstitutionProvider: Cargando mÃ¡s instituciones, pÃ¡gina $nextPage...');

      final response = await _institutionService.getAllInstitutions(
        accessToken,
        page: nextPage,
        limit: _paginationInfo!.limit,
        activa: activa,
        search: search
      );

      if (response != null && response.institutions.isNotEmpty) {
        debugPrint('InstitutionProvider: Recibidas ${response.institutions.length} instituciones adicionales');
        _institutions.addAll(response.institutions);
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
      } else {
        _hasMoreData = false;
      }
    } catch (e) {
      debugPrint('InstitutionProvider: Error loading more institutions: $e');
      _hasMoreData = false;
    } finally {
      _isLoadingMore = false;
      notifyListeners();
    }
  }
}
/* Fin lib\providers\institution_provider.dart */

/* Inicio lib\providers\user_provider.dart */
import 'dart:async';
import 'package:flutter/foundation.dart';
import '../services/user_service.dart' as user_service;
import '../services/profesor_service.dart' as profesor_service;
import '../models/user.dart';

enum UserState {
  initial,
  loading,
  loaded,
  error,
}

class UserProvider with ChangeNotifier {
  final user_service.UserService _userService = user_service.UserService();
  final profesor_service.ProfesorService _profesorService = profesor_service.ProfesorService();

  UserState _state = UserState.initial;
  String? _errorMessage;
  List<User> _users = [];
  User? _selectedUser;
  String? _selectedInstitutionId;
  PaginationInfo? _paginationInfo;
  bool _isLoadingMore = false;
  bool _hasMoreData = true;
  UserState get state => _state;
  String? get errorMessage => _errorMessage;
  List<User> get users => _users;
  User? get selectedUser => _selectedUser;
  String? get selectedInstitutionId => _selectedInstitutionId;
  PaginationInfo? get paginationInfo => _paginationInfo;

  bool get isLoading => _state == UserState.loading;
  bool get hasError => _state == UserState.error;
  bool get isLoaded => _state == UserState.loaded;
  bool get isLoadingMore => _isLoadingMore;
  bool get hasMoreData => _hasMoreData;
  List<User> get activeUsers => _users.where((user) => user.activo).toList();
  List<User> get inactiveUsers => _users.where((user) => !user.activo).toList();

  List<User> get professors => _users.where((user) => user.esProfesor).toList();
  List<User> get students => _users.where((user) => user.esEstudiante).toList();
  List<User> get adminInstitutions => _users.where((user) => user.esAdminInstitucion).toList();

  int get totalUsers => _users.length;
  int get activeUsersCount => activeUsers.length;
  int get inactiveUsersCount => inactiveUsers.length;

  int get professorsCount => professors.length;
  int get studentsCount => students.length;
  int get adminInstitutionsCount => adminInstitutions.length;

  void _setState(UserState newState, [String? error]) {
    _state = newState;
    _errorMessage = error;
    notifyListeners();
  }
  Future<void> loadUsers(String accessToken, {int? page, int? limit, bool? activo, String? search, List<String>? roles}) async {
    if (_state == UserState.loading) return;

    _setState(UserState.loading);
    resetPagination()

    try {
      debugPrint('UserProvider: Iniciando carga de usuarios...');
      final response = await _userService.getAllUsers(
        accessToken,
        page: page ?? 1,
        limit: limit,
        activo: activo,
        search: search,
        roles: roles,
      );
      if (response != null) {
        debugPrint('UserProvider: Recibidos ${response.users.length} usuarios');
        _users = response.users;
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
        _setState(UserState.loaded);
        debugPrint('UserProvider: Estado cambiado a loaded');
      } else {
        _setState(UserState.error, 'Error al cargar usuarios');
      }
    } catch (e) {
      debugPrint('UserProvider: Error loading users: $e');
      _setState(UserState.error, e.toString());
    }
  }
  Future<void> loadUsersByInstitution(String accessToken, String institutionId, {int? page, int limit = 5, String? role, bool? activo, String? search}) async {
    if (_state == UserState.loading) return;

    _setState(UserState.loading);
    _selectedInstitutionId = institutionId;
    resetPagination()

    try {
      debugPrint('UserProvider: Iniciando carga de usuarios por instituciÃ³n $institutionId...');
      final response = await _userService.getUsersByInstitution(accessToken, institutionId, page: page ?? 1, limit: limit, role: role, activo: activo, search: search);
      if (response != null) {
        debugPrint('UserProvider: Recibidos ${response.users.length} usuarios de instituciÃ³n $institutionId');
        _users = response.users;
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
        _setState(UserState.loaded);
      } else {
        _setState(UserState.error, 'Error al cargar usuarios de la instituciÃ³n');
      }
    } catch (e) {
      debugPrint('UserProvider: Error loading users by institution: $e');
      _setState(UserState.error, e.toString());
    }
  }
  Future<void> loadAdminsByInstitution(String accessToken, String institutionId) async {
    if (_state == UserState.loading) return;

    _setState(UserState.loading);
    _selectedInstitutionId = institutionId;

    try {
      debugPrint('UserProvider: Cargando admins de la instituciÃ³n $institutionId...');
      final admins = await _userService.getAdminsByInstitution(accessToken, institutionId);
      if (admins != null) {
        _users = admins;
        _hasMoreData = false;
        _setState(UserState.loaded);
      } else {
        _setState(UserState.error, 'Error al cargar administradores de la instituciÃ³n');
      }
    } catch (e) {
      debugPrint('UserProvider: Error loading admins by institution: $e');
      _setState(UserState.error, e.toString());
    }
  }
  Future<bool> assignAdminToInstitution(String accessToken, String institutionId, String userId) async {
    try {
      final updated = await _userService.assignAdminToInstitution(accessToken, institutionId, userId);
      if (updated != null) {
        await loadAdminsByInstitution(accessToken, institutionId);
        return true;
      }
      return false;
    } catch (e) {
      debugPrint('Error assignAdminToInstitution: $e');
      return false;
    }
  }
  Future<bool> removeAdminFromInstitution(String accessToken, String institutionId, String userId) async {
    try {
      final result = await _userService.removeAdminFromInstitution(accessToken, institutionId, userId);
      if (result != null) {
        await loadAdminsByInstitution(accessToken, institutionId);
        return true;
      }
      return false;
    } catch (e) {
      debugPrint('Error removeAdminFromInstitution: $e');
      return false;
    }
  }
  Future<void> loadUsersByRole(String accessToken, String role, {int? page, int? limit}) async {
    if (_state == UserState.loading) return;

    _setState(UserState.loading);
    resetPagination()

    try {
      debugPrint('UserProvider: Iniciando carga de usuarios por rol $role...');
      final response = await _userService.getUsersByRole(accessToken, role, page: page ?? 1, limit: limit);
      if (response != null) {
        debugPrint('UserProvider: Recibidos ${response.users.length} usuarios con rol $role');
        _users = response.users;
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
        _setState(UserState.loaded);
      } else {
        _setState(UserState.error, 'Error al cargar usuarios por rol');
      }
    } catch (e) {
      debugPrint('UserProvider: Error loading users by role: $e');
      _setState(UserState.error, e.toString());
    }
  }
  Future<void> loadUserById(String accessToken, String userId) async {
    _setState(UserState.loading);

    try {
      final user = await _userService.getUserById(accessToken, userId);
      if (user != null) {
        _selectedUser = user;
        _setState(UserState.loaded);
      } else {
        _setState(UserState.error, 'Usuario no encontrado');
      }
    } catch (e) {
      debugPrint('Error loading user: $e');
      _setState(UserState.error, e.toString());
    }
  }
  Future<bool> createUser(String accessToken, CreateUserRequest userData) async {
    _setState(UserState.loading);

    try {
      final newUser = await _userService.createUser(accessToken, userData);
      if (newUser != null) {
        _users.insert(0, newUser);
        _setState(UserState.loaded);
        return true;
      } else {
        _setState(UserState.error, 'Error al crear usuario');
        return false;
      }
    } catch (e) {
      debugPrint('Error creating user: $e');
      _setState(UserState.error, e.toString());
      return false;
    }
  }
  Future<bool> updateUser(String accessToken, String userId, UpdateUserRequest userData) async {
    _setState(UserState.loading);

    try {
      final updatedUser = await _userService.updateUser(accessToken, userId, userData);
      if (updatedUser != null) {
        final index = _users.indexWhere((user) => user.id == userId);
        if (index != -1) {
          _users[index] = updatedUser;
        }
        if (_selectedUser?.id == userId) {
          _selectedUser = updatedUser;
        }

        _setState(UserState.loaded);
        return true;
      } else {
        _setState(UserState.error, 'Error al actualizar usuario');
        return false;
      }
    } catch (e) {
      debugPrint('Error updating user: $e');
      _setState(UserState.error, e.toString());
      return false;
    }
  }
  Future<bool> deleteUser(String accessToken, String userId, String currentUserRole, String targetUserRole) async {
    try {
      bool success = false;
      if (currentUserRole == 'admin_institucion' && targetUserRole == 'profesor') {
        success = await _profesorService.deleteProfesor(accessToken, userId);
      } else {
        success = await _userService.deleteUser(accessToken, userId);
      }

      if (!success) {
        _errorMessage = 'Error al eliminar el usuario desde el servicio.';
      }
      return success;
    } catch (e) {
      debugPrint('Error deleting user: $e');
      _errorMessage = e.toString();
      return false;
    }
  }
  void selectUser(User user) {
    _selectedUser = user;
    notifyListeners();
  }
  void clearSelectedUser() {
    _selectedUser = null;
    notifyListeners();
  }
  void clearData() {
    _users = [];
    _selectedUser = null;
    _selectedInstitutionId = null;
    _paginationInfo = null;
    _setState(UserState.initial);
  }
  Future<void> refreshData(String accessToken) async {
    if (_selectedInstitutionId != null) {
      await loadUsersByInstitution(accessToken, _selectedInstitutionId!);
    } else {
      await loadUsers(accessToken);
    }
  }
  List<User> searchUsers(String query) {
    if (query.isEmpty) return _users;

    final lowercaseQuery = query.toLowerCase();
    return _users.where((user) {
      return user.nombreCompleto.toLowerCase().contains(lowercaseQuery) ||
             user.email.toLowerCase().contains(lowercaseQuery) ||
             (user.telefono?.contains(lowercaseQuery) ?? false);
    }).toList();
  }
  List<User> filterUsersByRole(String role) {
    if (role.isEmpty) return _users;
    return _users.where((user) => user.rol == role).toList();
  }
  List<User> filterUsersByStatus({bool? active}) {
    if (active == null) return _users;
    return _users.where((user) => user.activo == active).toList();
  }
  Future<void> loadNextPage(String accessToken) async {
    if (_paginationInfo == null || !_paginationInfo!.hasNext || _state == UserState.loading) return;

    final nextPage = _paginationInfo!.page + 1;
    if (_selectedInstitutionId != null) {
      await loadUsersByInstitution(accessToken, _selectedInstitutionId!, page: nextPage, limit: _paginationInfo!.limit);
    } else {
      await loadUsers(accessToken, page: nextPage, limit: _paginationInfo!.limit);
    }
  }
  Future<void> loadPreviousPage(String accessToken) async {
    if (_paginationInfo == null || !_paginationInfo!.hasPrev || _state == UserState.loading) return;

    final prevPage = _paginationInfo!.page - 1;
    if (_selectedInstitutionId != null) {
      await loadUsersByInstitution(accessToken, _selectedInstitutionId!, page: prevPage, limit: _paginationInfo!.limit);
    } else {
      await loadUsers(accessToken, page: prevPage, limit: _paginationInfo!.limit);
    }
  }
  Future<void> loadPage(String accessToken, int page) async {
    if (_state == UserState.loading) return;

    if (_selectedInstitutionId != null) {
      await loadUsersByInstitution(accessToken, _selectedInstitutionId!, page: page, limit: _paginationInfo?.limit ?? 5);
    } else {
      await loadUsers(accessToken, page: page, limit: _paginationInfo?.limit ?? 5);
    }
  }
  Map<String, int> getUserStatistics() {
    return {
      'total': _paginationInfo?.total ?? totalUsers,
      'activos': activeUsersCount,
      'inactivos': inactiveUsersCount,
      'profesores': professorsCount,
      'estudiantes': studentsCount,
      'admins_institucion': adminInstitutionsCount,
    };
  }
  Future<void> loadMoreUsers(String accessToken, {bool? activo, String? search, List<String>? roles}) async {
    if (_isLoadingMore || !_hasMoreData || _paginationInfo == null) return;

    _isLoadingMore = true;
    notifyListeners();

    try {
      final nextPage = _paginationInfo!.page + 1;

      user_service.PaginatedUserResponse? response;
      if (_selectedInstitutionId != null) {
        response = await _userService.getUsersByInstitution(
          accessToken,
          _selectedInstitutionId!,
          page: nextPage,
          limit: _paginationInfo!.limit,
        );
      } else {
        response = await _userService.getAllUsers(
          accessToken,
          page: nextPage,
          limit: _paginationInfo!.limit,
          activo: activo,
          search: search,
          roles: roles,
        );
      }

      if (response != null) {
        _users.addAll(response.users)
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
        debugPrint('UserProvider: Cargados ${response.users.length} usuarios mÃ¡s. Total ahora: ${_users.length}');
      } else {
        _hasMoreData = false;
      }
    } catch (e) {
      debugPrint('UserProvider: Error loading more users: $e');
    } finally {
      _isLoadingMore = false;
      notifyListeners();
    }
  }
  Future<List<User>?> searchUsersRemote(String accessToken, {String? search, int limit = 10}) async {
    try {
      final response = await _userService.getAllUsers(
        accessToken,
        page: 1,
        limit: limit,
        search: search,
      );
      return response?.users;
    } catch (e) {
      debugPrint('Error searchUsersRemote: $e');
      return null;
    }
  }
  void resetPagination() {
    _hasMoreData = true;
    _isLoadingMore = false;
  }
}
/* Fin lib\providers\user_provider.dart */

/* Inicio lib\screens\admin_dashboard.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../utils/responsive_utils.dart';
import '../widgets/dashboard_widgets.dart';

class AdminDashboard extends StatelessWidget {
  const AdminDashboard({super.key});

  Widget _buildUserGreeting(String userName, AuthProvider authProvider, Map<String, dynamic> responsive) {
    final selectedInstitution = authProvider.selectedInstitution;

    return UserGreetingWidget(
      userName: userName,
      responsive: responsive,
      subtitle: selectedInstitution?.name,
    );
  }

  Widget _buildDashboardOptions(BuildContext context, Map<String, dynamic> responsive) {
    final colors = context.colors;

    final cards = [
      DashboardFeatureCard(
        icon: Icons.people,
        title: 'Usuarios',
        description: 'Gestionar profesores y estudiantes',
        color: colors.primary,  // Usar color primario consistente
        responsive: responsive,
        onTap: () => context.go('/users'),
      ),
      DashboardFeatureCard(
        icon: Icons.class_,
        title: 'Grupos',
        description: 'Administrar salones de clase',
        color: colors.primary,  // Usar color primario consistente
        responsive: responsive,
      ),
      DashboardFeatureCard(
        icon: Icons.schedule,
        title: 'Horarios',
        description: 'Configurar horarios de clases',
        color: colors.primary,  // Usar color primario consistente
        responsive: responsive,
      ),
      DashboardFeatureCard(
        icon: Icons.assignment,
        title: 'Asistencia',
        description: 'Control y registro de asistencia',
        color: colors.primary,  // Usar color primario consistente
        responsive: responsive,
      ),
      DashboardFeatureCard(
        icon: Icons.bar_chart,
        title: 'Reportes',
        description: 'EstadÃ­sticas de la instituciÃ³n',
        color: colors.primary,  // Usar color primario consistente
        responsive: responsive,
      ),
      DashboardFeatureCard(
        icon: Icons.settings,
        title: 'ConfiguraciÃ³n',
        description: 'Ajustes de la instituciÃ³n',
        color: colors.primary,  // Usar color primario consistente
        responsive: responsive,
      ),
    ];

    return DashboardOptionsGrid(
      cards: cards,
      responsive: responsive,
    );
  }

  PreferredSizeWidget _buildAppBar(BuildContext context, AuthProvider authProvider, Color primaryColor, String userRole) {
    return DashboardAppBar(
      backgroundColor: primaryColor,
      actions: [
        DashboardAppBarActions(
          userRole: userRole,
          roleIcon: Icons.admin_panel_settings,
          onLogout: () async {
            await authProvider.logout();
            if (context.mounted) {
              context.go('/login');
            }
          },
        ),
      ],
    );
  }

  Widget _buildBody(BuildContext context, String userName, AuthProvider authProvider, Map<String, dynamic> responsive) {
    return DashboardBody(
      userGreeting: _buildUserGreeting(userName, authProvider, responsive),
      dashboardOptions: _buildDashboardOptions(context, responsive),
      responsive: responsive,
    );
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final colors = context.colors;

    final user = authProvider.user;
    final userName = user?['nombres'] ?? 'Usuario';
    final userRole = 'Administrador';

    return Scaffold(
      backgroundColor: colors.background,
      appBar: _buildAppBar(context, authProvider, colors.primary, userRole),
      body: LayoutBuilder(
        builder: (ctx, constraints) {
          final responsive = ResponsiveUtils.getResponsiveValues(constraints);
          return _buildBody(context, userName, authProvider, responsive);
        },
      ),
    );
  }
}
/* Fin lib\screens\admin_dashboard.dart */

/* Inicio lib\screens\app_shell.dart */
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';

class AppShell extends StatelessWidget {
  final StatefulNavigationShell navigationShell;

  const AppShell({
    super.key,
    required this.navigationShell,
  });

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final userRole = authProvider.user?['rol'] as String?;
    final allBranches = [
      (label: 'Dashboard', icon: Icons.dashboard, branchIndex: 0, roles: ['super_admin', 'admin_institucion', 'profesor', 'estudiante']),
      (label: 'Instituciones', icon: Icons.business, branchIndex: 1, roles: ['super_admin']),
      (label: 'Usuarios', icon: Icons.people, branchIndex: 2, roles: ['super_admin', 'admin_institucion']),
    ];
    final accessibleBranches = allBranches.where((branch) => branch.roles.contains(userRole)).toList();
    int? selectedIndex;
    if (accessibleBranches.isNotEmpty) {
      selectedIndex = accessibleBranches.indexWhere((b) => b.branchIndex == navigationShell.currentIndex);
      if (selectedIndex == -1) {
        selectedIndex = 0;
      }
    }

    return Scaffold(
      body: Row(
        children: [
          if (accessibleBranches.isNotEmpty)
            NavigationRail(
              selectedIndex: selectedIndex,
              onDestinationSelected: (index) {
                final branchIndex = accessibleBranches[index].branchIndex;
                navigationShell.goBranch(branchIndex);
              },
              labelType: NavigationRailLabelType.all,
              destinations: [
                for (final branch in accessibleBranches)
                  NavigationRailDestination(
                    icon: Icon(branch.icon),
                    selectedIcon: Icon(branch.icon), // Puedes cambiar a outlined si tienes Ã­conos diferentes
                    label: Text(branch.label),
                  ),
              ],
            )
          else
            const SizedBox(width: 0),
          const VerticalDivider(thickness: 1, width: 1),
          Expanded(
            child: navigationShell,
          ),
        ],
      ),
    );
  }
}
/* Fin lib\screens\app_shell.dart */

/* Inicio lib\screens\home_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../utils/responsive_utils.dart';

class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  Widget _buildUserInfo(AuthProvider authProvider, TextStyle headlineMedium, Color primary, bool isSmallScreen) {
    final user = authProvider.user;
    final userName = user?['nombres'] ?? user?['email'] ?? 'Usuario';

    return Column(
      children: [
        Text(
          userName,
          style: headlineMedium.copyWith(
            color: primary,
            fontSize: isSmallScreen ? 18 : 24,
          ),
          textAlign: TextAlign.center,
        ),
        const SizedBox(height: 8),
        Text(
          'Rol: ${user?['rol'] ?? 'Sin rol'}',
          style: TextStyle(
            color: primary.withValues(alpha: 0.7),
            fontSize: isSmallScreen ? 14 : 16,
          ),
          textAlign: TextAlign.center,
        ),
      ],
    );
  }

  Widget _buildInstitutionInfo(AuthProvider authProvider, TextStyle bodyLarge, Color textMuted, bool isSmallScreen) {
    final selectedInstitution = authProvider.selectedInstitution;

    if (selectedInstitution == null) {
      return Builder(
        builder: (context) {
          final colors = context.colors;
          return Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: colors.warningBackground,
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: colors.warningBorder),
            ),
            child: Column(
              children: [
                Icon(
                  Icons.business,
                  color: colors.warning,
                  size: isSmallScreen ? 24 : 32,
                ),
                const SizedBox(height: 8),
                Text(
                  'No hay instituciÃ³n seleccionada',
                  style: bodyLarge.copyWith(
                    color: colors.warning,
                    fontWeight: FontWeight.w500,
                  ),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 4),
                Text(
                  'Como super administrador, puedes gestionar todas las instituciones del sistema.',
                  style: TextStyle(
                    color: textMuted,
                    fontSize: isSmallScreen ? 12 : 14,
                  ),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          );
        },
      );
    }

    return Column(
      children: [
        Text(
          'InstituciÃ³n: ${selectedInstitution.name}',
          style: bodyLarge.copyWith(
            fontWeight: FontWeight.bold,
            fontSize: isSmallScreen ? 16 : 18,
          ),
          textAlign: TextAlign.center,
        ),
        const SizedBox(height: 4),
        Text(
          'Rol en instituciÃ³n: ${selectedInstitution.role ?? 'Sin rol'}',
          style: TextStyle(
            color: textMuted,
            fontSize: isSmallScreen ? 14 : 16,
          ),
          textAlign: TextAlign.center,
        ),
      ],
    );
  }

  Widget _buildDashboardOptions(bool isSmallScreen, Color textPrimary, Color textSecondary) {
    return Builder(
      builder: (context) {
        final colors = context.colors;
        return Column(
          children: [
            const SizedBox(height: 32),
            Wrap(
              spacing: 12,
              runSpacing: 12,
              alignment: WrapAlignment.center,
              children: [
                _buildFeatureCard(
                  icon: Icons.people,
                  title: 'GestiÃ³n de Usuarios',
                  description: 'Administrar usuarios del sistema',
                  isSmallScreen: isSmallScreen,
                  textPrimary: textPrimary,
                  textSecondary: textSecondary,
                ),
                _buildFeatureCard(
                  icon: Icons.business,
                  title: 'Instituciones',
                  description: 'Gestionar instituciones educativas',
                  isSmallScreen: isSmallScreen,
                  textPrimary: textPrimary,
                  textSecondary: textSecondary,
                ),
                _buildFeatureCard(
                  icon: Icons.assignment,
                  title: 'Asistencia',
                  description: 'Registro y control de asistencia',
                  isSmallScreen: isSmallScreen,
                  textPrimary: textPrimary,
                  textSecondary: textSecondary,
                ),
                _buildFeatureCard(
                  icon: Icons.bar_chart,
                  title: 'Reportes',
                  description: 'EstadÃ­sticas y reportes',
                  isSmallScreen: isSmallScreen,
                  textPrimary: textPrimary,
                  textSecondary: textSecondary,
                ),
              ],
            ),
            const SizedBox(height: 24),
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: colors.infoBackground,
                borderRadius: BorderRadius.circular(12),
                border: Border.all(color: colors.infoBorder),
              ),
              child: Column(
                children: [
                  Icon(
                    Icons.info_outline,
                    color: colors.info,
                    size: isSmallScreen ? 24 : 32,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Sistema en Desarrollo',
                    style: TextStyle(
                      color: colors.info,
                      fontWeight: FontWeight.bold,
                      fontSize: isSmallScreen ? 16 : 18,
                    ),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 4),
                  Text(
                    'Las funcionalidades estarÃ¡n disponibles prÃ³ximamente.',
                    style: TextStyle(
                      color: textSecondary,
                      fontSize: isSmallScreen ? 12 : 14,
                    ),
                    textAlign: TextAlign.center,
                  ),
                ],
              ),
            ),
          ],
        );
      },
    );
  }

  Widget _buildFeatureCard({
    required IconData icon,
    required String title,
    required String description,
    required bool isSmallScreen,
    required Color textPrimary,
    required Color textSecondary,
  }) {
    return Builder(
      builder: (context) {
        final colors = context.colors;
        return Container(
          width: isSmallScreen ? 160 : 180,
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: colors.surface,
            borderRadius: BorderRadius.circular(12),
            boxShadow: [
              BoxShadow(
                color: colors.shadow,
                spreadRadius: 1,
                blurRadius: 4,
                offset: const Offset(0, 2),
              ),
            ],
            border: Border.all(color: colors.borderLight),
          ),
          child: Column(
            children: [
              Icon(
                icon,
                size: isSmallScreen ? 32 : 40,
                color: colors.secondary,
              ),
              const SizedBox(height: 8),
              Text(
                title,
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                  fontSize: isSmallScreen ? 14 : 16,
                  color: textPrimary,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 4),
              Text(
                description,
                style: TextStyle(
                  color: textSecondary,
                  fontSize: isSmallScreen ? 10 : 12,
                ),
                textAlign: TextAlign.center,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildSignOutButton(AuthProvider authProvider) {
    return ElevatedButton(
      onPressed: () async {
        await authProvider.logout();
      },
      child: const Text('Cerrar SesiÃ³n'),
    );
  }

  AppBar _buildAppBar(Color primaryColor) {
    return AppBar(
      title: const Text('AsistApp'),
      backgroundColor: primaryColor,
      actions: _buildAppBarActions(),
    );
  }

  List<Widget> _buildAppBarActions() {
    return [
      IconButton(
        icon: const Icon(Icons.logout),
        onPressed: () async {
        },
      ),
    ];
  }

  Widget _buildBody(AuthProvider authProvider, dynamic textStyles, dynamic colors, Map<String, dynamic> responsive) {
    return SafeArea(
      child: SingleChildScrollView(
        child: ConstrainedBox(
          constraints: BoxConstraints(maxWidth: responsive['maxWidth']),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Padding(
                padding: EdgeInsets.symmetric(
                  horizontal: responsive['horizontalPadding'],
                  vertical: responsive['verticalPadding'],
                ),
                child: Column(
                  children: [
                    _buildUserInfo(authProvider, textStyles.headlineMedium, colors.primary, responsive['isSmallScreen']),
                    SizedBox(height: responsive['elementSpacing']),

                    _buildInstitutionInfo(authProvider, textStyles.bodyLarge, colors.textMuted, responsive['isSmallScreen']),
                    SizedBox(height: responsive['elementSpacing']),

                    _buildDashboardOptions(responsive['isSmallScreen'], colors.textPrimary, colors.textSecondary),

                    SizedBox(height: responsive['elementSpacing'] * 2),

                    _buildSignOutButton(authProvider),

                    SizedBox(height: responsive['verticalPadding']),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final colors = context.colors;
    final textStyles = context.textStyles;

    return Scaffold(
      backgroundColor: colors.background,
      appBar: _buildAppBar(colors.primary),
      body: LayoutBuilder(
        builder: (context, constraints) {
          final responsive = ResponsiveUtils.getResponsiveValues(constraints);
          return _buildBody(authProvider, textStyles, colors, responsive);
        },
      ),
    );
  }
}
/* Fin lib\screens\home_screen.dart */

/* Inicio lib\screens\institutions\create_institution_admin_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../models/institution.dart';
import '../../models/user.dart';
import '../../providers/auth_provider.dart';
import '../../providers/user_provider.dart';
import '../../theme/theme_extensions.dart';
import '../../widgets/form_widgets.dart';

class CreateInstitutionAdminScreen extends StatefulWidget {
  final Institution institution;

  const CreateInstitutionAdminScreen({
    super.key,
    required this.institution,
  });

  @override
  State<CreateInstitutionAdminScreen> createState() => _CreateInstitutionAdminScreenState();
}

class _CreateInstitutionAdminScreenState extends State<CreateInstitutionAdminScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nombresController = TextEditingController();
  final _apellidosController = TextEditingController();
  final _emailController = TextEditingController();
  final _telefonoController = TextEditingController();

  bool _isLoading = false;
  bool _activo = true;

  @override
  void dispose() {
    _nombresController.dispose();
    _apellidosController.dispose();
    _emailController.dispose();
    _telefonoController.dispose();
    super.dispose();
  }

  Future<void> _saveAdmin() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final userProvider = Provider.of<UserProvider>(context, listen: false);

      final createRequest = CreateUserRequest(
        email: _emailController.text.trim(),
        password: 'TempPass123!', // ContraseÃ±a temporal que debe ser cambiada por el usuario
        nombres: _nombresController.text.trim(),
        apellidos: _apellidosController.text.trim(),
        telefono: _telefonoController.text.trim().isNotEmpty ? _telefonoController.text.trim() : null,
        rol: 'admin_institucion',
        institucionId: widget.institution.id,
        rolEnInstitucion: 'admin', // Rol especÃ­fico dentro de la instituciÃ³n
      );

      final success = await userProvider.createUser(
        authProvider.accessToken!,
        createRequest,
      );

      if (success && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              'Administrador de instituciÃ³n creado exitosamente',
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onPrimary,
              ),
            ),
            backgroundColor: Theme.of(context).colorScheme.primary,
          ),
        );
        context.go('/institutions');
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              'Error al crear administrador: ${e.toString()}',
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onError,
              ),
            ),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Scaffold(
      appBar: AppBar(
        title: Text('Crear Administrador - ${widget.institution.nombre}'),
        backgroundColor: colors.primary,
        foregroundColor: colors.getTextColorForBackground(colors.primary),
      ),
      body: SingleChildScrollView(
        padding: EdgeInsets.all(spacing.lg),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              SizedBox(height: spacing.lg),

              Text(
                'InformaciÃ³n Personal',
                style: textStyles.headlineMedium.bold,
              ),
              SizedBox(height: spacing.lg),
              LayoutBuilder(
                builder: (context, constraints) {
                  final isWide = constraints.maxWidth > 600;
                  return isWide
                    ? Row(
                        children: [
                          Expanded(
                            child: CustomTextFormField(
                              controller: _nombresController,
                              labelText: 'Nombres',
                              hintText: 'Ingrese los nombres',
                              validator: (value) {
                                if (value == null || value.trim().isEmpty) {
                                  return 'Los nombres son requeridos';
                                }
                                if (value.trim().length < 2) {
                                  return 'Los nombres deben tener al menos 2 caracteres';
                                }
                                return null;
                              },
                            ),
                          ),
                          SizedBox(width: spacing.md),
                          Expanded(
                            child: CustomTextFormField(
                              controller: _apellidosController,
                              labelText: 'Apellidos',
                              hintText: 'Ingrese los apellidos',
                              validator: (value) {
                                if (value == null || value.trim().isEmpty) {
                                  return 'Los apellidos son requeridos';
                                }
                                if (value.trim().length < 2) {
                                  return 'Los apellidos deben tener al menos 2 caracteres';
                                }
                                return null;
                              },
                            ),
                          ),
                        ],
                      )
                    : Column(
                        children: [
                          CustomTextFormField(
                            controller: _nombresController,
                            labelText: 'Nombres',
                            hintText: 'Ingrese los nombres',
                            validator: (value) {
                              if (value == null || value.trim().isEmpty) {
                                return 'Los nombres son requeridos';
                              }
                              if (value.trim().length < 2) {
                                return 'Los nombres deben tener al menos 2 caracteres';
                              }
                              return null;
                            },
                          ),
                          SizedBox(height: spacing.md),
                          CustomTextFormField(
                            controller: _apellidosController,
                            labelText: 'Apellidos',
                            hintText: 'Ingrese los apellidos',
                            validator: (value) {
                              if (value == null || value.trim().isEmpty) {
                                return 'Los apellidos son requeridos';
                              }
                              if (value.trim().length < 2) {
                                return 'Los apellidos deben tener al menos 2 caracteres';
                              }
                              return null;
                            },
                          ),
                        ],
                      );
                },
              ),
              SizedBox(height: spacing.md),
              CustomTextFormField(
                controller: _emailController,
                labelText: 'Email',
                hintText: 'admin@ejemplo.com',
                keyboardType: TextInputType.emailAddress,
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'El email es requerido';
                  }
                  final emailRegex = RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$');
                  if (!emailRegex.hasMatch(value.trim())) {
                    return 'Ingrese un email vÃ¡lido';
                  }
                  return null;
                },
              ),
              SizedBox(height: spacing.md),
              CustomTextFormField(
                controller: _telefonoController,
                labelText: 'TelÃ©fono',
                hintText: '+57 300 123 4567',
                keyboardType: TextInputType.phone,
                validator: (value) {
                  if (value != null && value.trim().isNotEmpty) {
                    final phoneRegex = RegExp(r'^\+?[0-9\s\-\(\)]+$');
                    if (!phoneRegex.hasMatch(value.trim())) {
                      return 'Ingrese un telÃ©fono vÃ¡lido';
                    }
                  }
                  return null;
                },
              ),
              SizedBox(height: spacing.lg),
              Card(
                elevation: 2,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(spacing.borderRadius),
                ),
                child: Padding(
                  padding: EdgeInsets.all(spacing.md),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'InstituciÃ³n Asignada',
                        style: textStyles.titleMedium.bold,
                      ),
                      SizedBox(height: spacing.sm),
                      Row(
                        children: [
                          Icon(Icons.business, color: colors.primary),
                          SizedBox(width: spacing.sm),
                          Expanded(
                            child: Text(
                              widget.institution.nombre,
                              style: textStyles.bodyLarge,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ),
              SizedBox(height: spacing.lg),
              Card(
                elevation: 2,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(spacing.borderRadius),
                ),
                child: Padding(
                  padding: EdgeInsets.all(spacing.md),
                  child: Row(
                    children: [
                      Icon(
                        _activo ? Icons.check_circle : Icons.cancel,
                        color: _activo ? colors.success : colors.error,
                      ),
                      SizedBox(width: spacing.md),
                      Expanded(
                        child: Text(
                          'Usuario Activo',
                          style: textStyles.bodyLarge,
                        ),
                      ),
                      Switch(
                        value: _activo,
                        onChanged: (value) {
                          setState(() => _activo = value);
                        },
                        activeColor: colors.primary,
                      ),
                    ],
                  ),
                ),
              ),
              SizedBox(height: spacing.xl),
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed: _isLoading ? null : () => context.pop(),
                      style: OutlinedButton.styleFrom(
                        padding: EdgeInsets.symmetric(vertical: spacing.md),
                        side: BorderSide(color: colors.primary),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(spacing.borderRadius),
                        ),
                      ),
                      child: Text(
                        'Cancelar',
                        style: textStyles.button.withColor(colors.primary),
                      ),
                    ),
                  ),
                  SizedBox(width: spacing.md),
                  Expanded(
                    child: ElevatedButton(
                      onPressed: _isLoading ? null : _saveAdmin,
                      style: ElevatedButton.styleFrom(
                        padding: EdgeInsets.symmetric(vertical: spacing.md),
                        backgroundColor: colors.primary,
                        foregroundColor: Theme.of(context).colorScheme.onPrimary,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(spacing.borderRadius),
                        ),
                      ),
                      child: _isLoading
                        ? SizedBox(
                            height: 20,
                            width: 20,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              valueColor: AlwaysStoppedAnimation<Color>(
                                Theme.of(context).colorScheme.onPrimary,
                              ),
                            ),
                          )
                        : Text('Crear Administrador', style: textStyles.button),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}
/* Fin lib\screens\institutions\create_institution_admin_screen.dart */

/* Inicio lib\screens\institutions\institutions_list_screen.dart */
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../models/institution.dart';
import '../../providers/auth_provider.dart';
import '../../providers/institution_provider.dart';
import '../../theme/theme_extensions.dart';
import '../../theme/app_text_styles.dart';
import '../../widgets/common/management_scaffold.dart';
import 'institution_form_screen.dart';
import 'create_institution_admin_screen.dart';

class InstitutionsListScreen extends StatefulWidget {
  const InstitutionsListScreen({super.key});

  @override
  State<InstitutionsListScreen> createState() => _InstitutionsListScreenState();
}

class _InstitutionsListScreenState extends State<InstitutionsListScreen> {
  final TextEditingController _searchController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  Timer? _searchDebounceTimer;

  String _searchQuery = '';
  bool? _statusFilter

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);

    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadInstitutions();
    });
  }

  @override
  void dispose() {
    _searchDebounceTimer?.cancel();
    _scrollController.dispose();
    _searchController.dispose();
    super.dispose();
  }

  void _onScroll() {
    if (_scrollController.position.pixels == _scrollController.position.maxScrollExtent) {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);

      if (authProvider.accessToken != null && institutionProvider.hasMoreData && !institutionProvider.isLoadingMore) {
        institutionProvider.loadMoreInstitutions(
          authProvider.accessToken!,
          search: _searchQuery.isNotEmpty ? _searchQuery : null,
          activa: _statusFilter,
        );
      }
    }
  }

  Future<void> _loadInstitutions() async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);

    if (authProvider.accessToken != null) {
      debugPrint('Cargando instituciones con token: ${authProvider.accessToken!.substring(0, 20)}...');
      await institutionProvider.loadInstitutions(
        authProvider.accessToken!,
        search: _searchQuery.isNotEmpty ? _searchQuery : null,
        activa: _statusFilter,
      );
      debugPrint('Instituciones cargadas: ${institutionProvider.institutions.length}');
      debugPrint('Estado del provider: ${institutionProvider.state}');
      if (institutionProvider.hasError) {
        debugPrint('Error del provider: ${institutionProvider.errorMessage}');
      }
    } else {
      debugPrint('No hay token de acceso disponible');
    }
  }

  void _onSearchChanged(String query) {
    _searchDebounceTimer?.cancel();
    _searchDebounceTimer = Timer(const Duration(milliseconds: 500), () {
      setState(() {
        _searchQuery = query;
      });
      _loadInstitutions();
    });
  }

  void _onStatusFilterChanged(bool? status) {
    setState(() {
      _statusFilter = status;
    });
    _loadInstitutions();
  }

  Future<void> _loadPage(int page) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);

    if (authProvider.accessToken != null) {
      await institutionProvider.loadInstitutions(
        authProvider.accessToken!,
        page: page,
        search: _searchQuery.isNotEmpty ? _searchQuery : null,
        activa: _statusFilter,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Consumer2<AuthProvider, InstitutionProvider>(
      builder: (context, authProvider, institutionProvider, child) {
        return ManagementScaffold(
          title: "GestiÃ³n de Instituciones",
          isLoading: institutionProvider.isLoading && institutionProvider.institutions.isEmpty,
          hasError: institutionProvider.hasError,
          errorMessage: institutionProvider.errorMessage ?? 'Error desconocido',
          itemCount: institutionProvider.institutions.length,
          itemBuilder: (context, index) => _buildInstitutionCard(
            institutionProvider.institutions[index],
            institutionProvider,
            context,
          ),
          hasMoreData: institutionProvider.hasMoreData,
          onRefresh: () => _loadInstitutions(),
          scrollController: _scrollController,
          floatingActionButton: FloatingActionButton(
            key: const Key('addInstitutionButton'),
            onPressed: () => _navigateToForm(context),
            backgroundColor: context.colors.primary,
            child: Icon(Icons.add, color: context.colors.getTextColorForBackground(context.colors.primary)),
          ),
          filterWidgets: _buildFilterWidgets(context),
          statisticWidgets: _buildStatisticWidgets(context, institutionProvider),
          paginationInfo: institutionProvider.paginationInfo,
          onPageChange: _loadPage,
          emptyStateTitle: _searchQuery.isNotEmpty ? 'No se encontraron instituciones' : 'No hay instituciones',
          emptyStateMessage: _searchQuery.isNotEmpty ? 'Intenta con otros tÃ©rminos de bÃºsqueda' : 'Comienza creando tu primera instituciÃ³n',
          emptyStateIcon: _searchQuery.isNotEmpty ? Icons.search_off : Icons.business,
        );
      },
    );
  }

  List<Widget> _buildFilterWidgets(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return [
      TextField(
        key: const Key('searchInstitutionField'),
        controller: _searchController,
        style: textStyles.bodyLarge,
        decoration: InputDecoration(
          hintText: 'Buscar por nombre, cÃ³digo o email...',
          hintStyle: textStyles.bodyMedium.withColor(colors.textMuted),
          prefixIcon: Icon(Icons.search, color: colors.textSecondary),
          suffixIcon: _searchQuery.isNotEmpty
              ? IconButton(
                  icon: Icon(Icons.clear, color: colors.textSecondary),
                  onPressed: () {
                    _searchController.clear();
                    _onSearchChanged('');
                  },
                )
              : null,
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.border),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.borderLight),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.primary, width: 2),
          ),
          filled: true,
          fillColor: colors.surface,
          contentPadding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
        ),
        onChanged: _onSearchChanged,
      ),
      SizedBox(height: spacing.sm),
      Row(
        children: [
          Text('Mostrar:', style: textStyles.labelMedium),
          SizedBox(width: spacing.md),
          FilterChip(
            label: const Text('Todas'),
            selected: _statusFilter == null,
            onSelected: (selected) {
              if (selected) _onStatusFilterChanged(null);
            },
          ),
          SizedBox(width: spacing.md),
          FilterChip(
            label: const Text('Activas'),
            selected: _statusFilter == true,
            onSelected: (selected) {
              if (selected) _onStatusFilterChanged(true);
            },
          ),
          SizedBox(width: spacing.md),
          FilterChip(
            label: const Text('Inactivas'),
            selected: _statusFilter == false,
            onSelected: (selected) {
              if (selected) _onStatusFilterChanged(false);
            },
          ),
        ],
      ),
    ];
  }

  List<Widget> _buildStatisticWidgets(BuildContext context, InstitutionProvider provider) {
    return [
      _buildCompactStat(
        'Total',
        provider.totalInstitutions.toString(),
        Icons.business,
        context.colors.primary,
        context.textStyles,
      ),
      Container(
        height: 24,
        width: 1,
        color: context.colors.border,
      ),
      _buildCompactStat(
        'Activas',
        provider.activeInstitutionsCount.toString(),
        Icons.check_circle,
        context.colors.success,
        context.textStyles,
      ),
      Container(
        height: 24,
        width: 1,
        color: context.colors.border,
      ),
      _buildCompactStat(
        'Inactivas',
        provider.inactiveInstitutionsCount.toString(),
        Icons.cancel,
        context.colors.error,
        context.textStyles,
      ),
    ];
  }

  Widget _buildCompactStat(String title, String value, IconData icon, Color color, AppTextStyles textStyles) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(icon, size: 20, color: color),
        const SizedBox(width: 6),
        Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              value,
              style: textStyles.titleMedium.copyWith(
                color: color,
                fontWeight: FontWeight.bold,
              ),
            ),
            Text(
              title,
              style: textStyles.bodySmall.copyWith(
                color: color.withValues(alpha: 0.7),
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildInstitutionCard(Institution institution, InstitutionProvider provider, BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;
    return Card(
      margin: EdgeInsets.only(bottom: spacing.xs),
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(spacing.borderRadius),
      ),
      child: ListTile(
        leading: CircleAvatar(
          backgroundColor: institution.activa ? colors.success : colors.error,
          child: Icon(
            institution.activa ? Icons.check : Icons.close,
            color: colors.surface,
          ),
        ),
        title: Text(
          institution.nombre,
          style: textStyles.titleMedium.bold,
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (institution.email != null) Row(children: [
              Icon(Icons.email_outlined, size: 14, color: colors.textSecondary),
              SizedBox(width: 4),
              Text(institution.email!, style: textStyles.bodySmall),
            ]),
            if (institution.telefono != null) Row(children: [
              Icon(Icons.phone_outlined, size: 14, color: colors.textSecondary),
              SizedBox(width: 4),
              Text(institution.telefono!, style: textStyles.bodySmall),
            ]),
          ],
        ),
        trailing: Consumer<AuthProvider>(
          builder: (context, authProvider, child) {
            final userRole = authProvider.user?['rol'] as String?;
            final isSuperAdmin = userRole == 'super_admin';

            return PopupMenuButton<String>(
              onSelected: (value) => _handleMenuAction(value, institution, provider),
              itemBuilder: (context) => [
                if (isSuperAdmin) PopupMenuItem(
                  value: 'create_admin',
                  child: Row(
                    children: [
                      Icon(Icons.admin_panel_settings, color: colors.primary),
                      SizedBox(width: spacing.sm),
                      Text('Crear Administrador', style: textStyles.bodyMedium.withColor(colors.primary)),
                    ],
                  ),
                ),
                if (isSuperAdmin) PopupMenuItem(
                  value: 'manage_admins',
                  child: Row(
                    children: [
                      Icon(Icons.group, color: colors.primary),
                      SizedBox(width: spacing.sm),
                      Text('Gestionar Administradores', style: textStyles.bodyMedium.withColor(colors.primary)),
                    ],
                  ),
                ),
                PopupMenuItem(
                  value: 'edit',
                  child: Row(
                    children: [
                      Icon(Icons.edit, color: colors.textSecondary),
                      SizedBox(width: spacing.sm),
                      Text('Editar', style: textStyles.bodyMedium),
                    ],
                  ),
                ),
                PopupMenuItem(
                  value: 'toggle_status',
                  child: Row(
                    children: [
                      Icon(Icons.toggle_on, color: colors.textSecondary),
                      SizedBox(width: spacing.sm),
                      Text('Cambiar Estado', style: textStyles.bodyMedium),
                    ],
                  ),
                ),
                PopupMenuItem(
                  value: 'delete',
                  child: Row(
                    children: [
                      Icon(Icons.delete, color: colors.error),
                      SizedBox(width: spacing.sm),
                      Text('Eliminar', style: textStyles.bodyMedium.withColor(colors.error)),
                    ],
                  ),
                ),
              ],
            );
          },
        ),
        onTap: () => _navigateToForm(context, institution: institution),
      ),
    );
  }

  void _handleMenuAction(String action, Institution institution, InstitutionProvider provider) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    switch (action) {
      case 'create_admin':
        _navigateToCreateInstitutionAdmin(institution);
        break;

      case 'edit':
        _navigateToForm(context, institution: institution);
        break;

      case 'toggle_status':
        final newStatus = !institution.activa;
        final success = await provider.updateInstitution(
          authProvider.accessToken!,
          institution.id,
          activa: newStatus,
        );

        if (success && mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                'InstituciÃ³n ${newStatus ? 'activada' : 'desactivada'} correctamente',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onPrimary),
              ),
              backgroundColor: Theme.of(context).colorScheme.primary,
            ),
          );
        }
        break;

      case 'delete':
        _showDeleteConfirmationDialog(institution, provider);
        break;
      case 'manage_admins':

        context.push('/institutions/${institution.id}/admins');
        break;
    }
  }

  void _showDeleteConfirmationDialog(Institution institution, InstitutionProvider provider) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Eliminar InstituciÃ³n', style: Theme.of(context).textTheme.headlineSmall),
        content: Text(
          'Â¿EstÃ¡s seguro de que quieres eliminar "${institution.nombre}"?\n\n'
          'Esta acciÃ³n no se puede deshacer.',
          style: Theme.of(context).textTheme.bodyMedium,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: Text('Cancelar', style: Theme.of(context).textTheme.labelLarge),
          ),
          TextButton(
            onPressed: () async {
              Navigator.of(context).pop();
              await _deleteInstitution(institution, provider);
            },
            style: TextButton.styleFrom(foregroundColor: Theme.of(context).colorScheme.error),
            child: Text('Eliminar', style: Theme.of(context).textTheme.labelLarge?.copyWith(color: Theme.of(context).colorScheme.error)),
          ),
        ],
      ),
    );
  }

  Future<void> _deleteInstitution(Institution institution, InstitutionProvider provider) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    final success = await provider.deleteInstitution(
      authProvider.accessToken!,
      institution.id,
    );

    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            'InstituciÃ³n eliminada correctamente',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onPrimary),
          ),
          backgroundColor: Theme.of(context).colorScheme.primary,
        ),
      );
    }
  }

  void _navigateToForm(BuildContext context, {Institution? institution}) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => InstitutionFormScreen(institution: institution),
      ),
    );
  }

  void _navigateToCreateInstitutionAdmin(Institution institution) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => CreateInstitutionAdminScreen(institution: institution),
      ),
    );
  }
}
/* Fin lib\screens\institutions\institutions_list_screen.dart */

/* Inicio lib\screens\institutions\institution_admins_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../providers/user_provider.dart';
import '../../providers/auth_provider.dart';
import '../../providers/institution_provider.dart';
import '../../widgets/common/management_scaffold.dart';
import '../../theme/theme_extensions.dart';
import '../../models/user.dart';
import 'create_institution_admin_screen.dart';

class InstitutionAdminsScreen extends StatefulWidget {
  final String institutionId;

  const InstitutionAdminsScreen({super.key, required this.institutionId});

  @override
  State<InstitutionAdminsScreen> createState() => _InstitutionAdminsScreenState();
}

class _InstitutionAdminsScreenState extends State<InstitutionAdminsScreen> {
  final ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadAdmins();
    });
  }

  Future<void> _loadAdmins() async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final userProvider = Provider.of<UserProvider>(context, listen: false);
    if (authProvider.accessToken != null) {
      await userProvider.loadAdminsByInstitution(authProvider.accessToken!, widget.institutionId);
    }
  }

  Future<void> _removeAdmin(User user) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final userProvider = Provider.of<UserProvider>(context, listen: false);

    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Remover Administrador'),
        content: Text('Â¿Deseas remover el rol de administrador a ${user.nombreCompleto}?'),
        actions: [
          TextButton(onPressed: () => Navigator.of(context).pop(false), child: const Text('Cancelar')),
          TextButton(onPressed: () => Navigator.of(context).pop(true), child: const Text('Remover')),
        ],
      ),
    );

    if (confirmed != true) return;

    if (authProvider.accessToken != null) {
      final success = await userProvider.removeAdminFromInstitution(authProvider.accessToken!, widget.institutionId, user.id);
      if (success && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Administrador removido correctamente')));
        await _loadAdmins();
      }
    }
  }

  void _openAddAdminSheet() {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (context) {
        final colors = context.colors;
        return Padding(
          padding: EdgeInsets.only(bottom: MediaQuery.of(context).viewInsets.bottom),
          child: Wrap(
            children: [
              ListTile(
                leading: Icon(Icons.person_add, color: colors.primary),
                title: const Text('Crear Nuevo Administrador'),
                onTap: () {
                  Navigator.of(context).pop();
                  final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);
                  final institution = institutionProvider.institutions.firstWhere((i) => i.id == widget.institutionId);
                  Navigator.push(
                    context,
                    MaterialPageRoute(builder: (_) => CreateInstitutionAdminScreen(institution: institution)),
                  ).then((_) => _loadAdmins());
                },
              ),
              ListTile(
                leading: Icon(Icons.person_search, color: colors.primary),
                title: const Text('Asignar Usuario Existente'),
                onTap: () {
                  Navigator.of(context).pop();
                  _showAssignExistingUserDialog();
                },
              ),
            ],
          ),
        );
      },
    );
  }

  void _showAssignExistingUserDialog() {
    showDialog(
      context: context,
      builder: (context) => AssignExistingUserDialog(institutionId: widget.institutionId, onAssigned: () async {
        await _loadAdmins();
      }),
    );
  }

  @override
  Widget build(BuildContext context) {
    final userProvider = Provider.of<UserProvider>(context);

    return ManagementScaffold(
      title: 'Administradores',
      isLoading: userProvider.isLoading && userProvider.users.isEmpty,
      hasError: userProvider.hasError,
      errorMessage: userProvider.errorMessage ?? 'Error desconocido',
      itemCount: userProvider.users.length,
      itemBuilder: (context, index) {
        final user = userProvider.users[index];
        return Card(
          margin: EdgeInsets.only(bottom: context.spacing.xs),
          child: ListTile(
            leading: CircleAvatar(child: Text(user.nombres.isNotEmpty ? user.nombres[0] : '?')),
            title: Text(user.nombreCompleto),
            subtitle: Text(user.email),
            trailing: IconButton(
              icon: Icon(Icons.remove_circle, color: context.colors.error),
              onPressed: () => _removeAdmin(user),
            ),
          ),
        );
      },
      hasMoreData: userProvider.hasMoreData,
      onRefresh: _loadAdmins,
      scrollController: _scrollController,
      floatingActionButton: FloatingActionButton(
        onPressed: _openAddAdminSheet,
        backgroundColor: context.colors.primary,
        child: Icon(Icons.add, color: context.colors.getTextColorForBackground(context.colors.primary)),
      ),
      onPageChange: (page) async {
        final authProvider = Provider.of<AuthProvider>(context, listen: false);
        if (authProvider.accessToken != null) {
          await userProvider.loadUsersByInstitution(authProvider.accessToken!, widget.institutionId, page: page);
        }
      },
      emptyStateTitle: 'No hay administradores',
      emptyStateMessage: 'Agrega administradores a esta instituciÃ³n',
      emptyStateIcon: Icons.group_off,
    );
  }
}

class AssignExistingUserDialog extends StatefulWidget {
  final String institutionId;
  final VoidCallback? onAssigned;

  const AssignExistingUserDialog({super.key, required this.institutionId, this.onAssigned});

  @override
  State<AssignExistingUserDialog> createState() => _AssignExistingUserDialogState();
}

class _AssignExistingUserDialogState extends State<AssignExistingUserDialog> {
  final _searchController = TextEditingController();
  List<User> _results = [];
  bool _isSearching = false;

  Future<void> _search(String query) async {
    setState(() => _isSearching = true);
    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final userProvider = Provider.of<UserProvider>(context, listen: false);
      final users = await userProvider.searchUsersRemote(authProvider.accessToken!, search: query, limit: 10);
      final response = users;
      if (response != null) {
        final candidates = response.where((u) => u.instituciones.every((inst) => !inst.activo || inst.rolEnInstitucion != 'admin')).toList();
        setState(() => _results = candidates);
      }
    } catch (e) {
      debugPrint('Error buscando usuarios: $e');
    } finally {
      setState(() => _isSearching = false);
    }
  }

  Future<void> _assign(User user) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final userProvider = Provider.of<UserProvider>(context, listen: false);
    if (authProvider.accessToken != null) {
      final success = await userProvider.assignAdminToInstitution(authProvider.accessToken!, widget.institutionId, user.id);
      if (success && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Administrador asignado correctamente')));
        widget.onAssigned?.call();
        Navigator.of(context).pop();
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Asignar Usuario Existente'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          TextField(
            controller: _searchController,
            decoration: const InputDecoration(hintText: 'Buscar por nombre o email'),
            onSubmitted: _search,
          ),
          const SizedBox(height: 12),
          if (_isSearching) const CircularProgressIndicator(),
          if (!_isSearching && _results.isNotEmpty)
            SizedBox(
              height: 200,
              child: ListView.builder(
                itemCount: _results.length,
                itemBuilder: (context, index) {
                  final user = _results[index];
                  return ListTile(
                    title: Text(user.nombreCompleto),
                    subtitle: Text(user.email),
                    trailing: TextButton(onPressed: () => _assign(user), child: const Text('Asignar')),
                  );
                },
              ),
            ),
        ],
      ),
      actions: [
        TextButton(onPressed: () => Navigator.of(context).pop(), child: const Text('Cerrar')),
      ],
    );
  }
}

/* Fin lib\screens\institutions\institution_admins_screen.dart */

/* Inicio lib\screens\institutions\institution_form_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../models/institution.dart';
import '../../providers/auth_provider.dart';
import '../../providers/institution_provider.dart';
import '../../theme/theme_extensions.dart';

class InstitutionFormScreen extends StatefulWidget {
  final Institution? institution;

  const InstitutionFormScreen({super.key, this.institution});

  @override
  State<InstitutionFormScreen> createState() => _InstitutionFormScreenState();
}

class _InstitutionFormScreenState extends State<InstitutionFormScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nombreController = TextEditingController();
  final _direccionController = TextEditingController();
  final _telefonoController = TextEditingController();
  final _emailController = TextEditingController();

  bool _activa = true;
  bool _isLoading = false;

  bool get isEditing => widget.institution != null;

  @override
  void initState() {
    super.initState();
    if (widget.institution != null) {
      _loadInstitutionData();
    }
  }

  @override
  void dispose() {
    _nombreController.dispose();
    _direccionController.dispose();
    _telefonoController.dispose();
    _emailController.dispose();
    super.dispose();
  }

  void _loadInstitutionData() {
    final institution = widget.institution!;
    _nombreController.text = institution.nombre;
    _direccionController.text = institution.direccion ?? '';
    _telefonoController.text = institution.telefono ?? '';
    _emailController.text = institution.email ?? '';
    _activa = institution.activa;
  }

  Future<void> _saveInstitution() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);

      final institutionData = {
        'nombre': _nombreController.text.trim(),
        'direccion': _direccionController.text.trim(),
        'telefono': _telefonoController.text.trim(),
        'email': _emailController.text.trim(),
        'activa': _activa,
      };

      bool success;
      if (widget.institution == null) {
        success = await institutionProvider.createInstitution(
          authProvider.accessToken!,
          institutionData,
        );
      } else {
        success = await institutionProvider.updateInstitution(
          authProvider.accessToken!,
          widget.institution!.id,
          nombre: institutionData['nombre'] as String?,
          direccion: institutionData['direccion'] as String?,
          telefono: institutionData['telefono'] as String?,
          email: institutionData['email'] as String?,
          activa: institutionData['activa'] as bool?,
        );
      }

      if (success && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              widget.institution == null
                  ? 'InstituciÃ³n creada correctamente'
                  : 'InstituciÃ³n actualizada correctamente',
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onPrimary),
            ),
            backgroundColor: Theme.of(context).colorScheme.primary,
          ),
        );
        context.pop();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              'Error: ${e.toString()}',
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onError),
            ),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return _isLoading
        ? const Center(child: CircularProgressIndicator())
        : SingleChildScrollView(
            padding: EdgeInsets.all(spacing.lg),
            child: Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    isEditing ? 'Editar InstituciÃ³n' : 'Nueva InstituciÃ³n',
                    style: textStyles.headlineMedium.bold,
                  ),
                  SizedBox(height: spacing.lg),
                  _buildFormCard(),
                  SizedBox(height: spacing.xl),
                  _buildActionButtons(),
                ],
              ),
            ),
          );
  }

  Widget _buildFormCard() {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;
    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(spacing.borderRadius),
      ),
      child: Padding(
        padding: EdgeInsets.all(spacing.lg),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'InformaciÃ³n de la InstituciÃ³n',
              style: textStyles.headlineMedium.withColor(colors.primary),
            ),
            SizedBox(height: spacing.lg),
            _buildTextField(
              key: const Key('nombreInstitucionField'),
              controller: _nombreController,
              label: 'Nombre de la InstituciÃ³n',
              hint: 'Ingrese el nombre completo',
              validator: (value) {
                if (value == null || value.trim().isEmpty) {
                  return 'El nombre es obligatorio';
                }
                if (value.trim().length < 3) {
                  return 'El nombre debe tener al menos 3 caracteres';
                }
                return null;
              },
              prefixIcon: Icons.business,
            ),
            SizedBox(height: spacing.lg),
            _buildTextField(
              controller: _direccionController,
              label: 'DirecciÃ³n',
              hint: 'DirecciÃ³n completa de la instituciÃ³n',
              maxLines: 3,
              prefixIcon: Icons.location_on,
            ),
            SizedBox(height: spacing.lg),
            _buildTextField(
              controller: _telefonoController,
              label: 'TelÃ©fono',
              hint: '+56912345678',
              keyboardType: TextInputType.phone,
              prefixIcon: Icons.phone,
            ),
            SizedBox(height: spacing.lg),
            _buildTextField(
              key: const Key('emailInstitucionField'),
              controller: _emailController,
              label: 'Email',
              hint: 'contacto@institucion.cl',
              keyboardType: TextInputType.emailAddress,
              validator: (value) {
                if (value != null && value.isNotEmpty) {
                  final emailRegex = RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$');
                  if (!emailRegex.hasMatch(value)) {
                    return 'Ingrese un email vÃ¡lido';
                  }
                }
                return null;
              },
              prefixIcon: Icons.email,
            ),
            SizedBox(height: spacing.lg),
            SwitchListTile(
              title: Text('InstituciÃ³n Activa', style: textStyles.titleMedium),
              subtitle: Text('Determina si la instituciÃ³n estÃ¡ operativa', style: textStyles.bodySmall),
              value: _activa,
              onChanged: (value) => setState(() => _activa = value),
              activeColor: colors.primary,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTextField({
    Key? key,
    required TextEditingController controller,
    required String label,
    required String hint,
    String? Function(String?)? validator,
    TextInputType? keyboardType,
    int maxLines = 1,
    IconData? prefixIcon,
  }) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;
    return TextFormField(
      key: key,
      controller: controller,
      style: textStyles.bodyLarge,
      decoration: InputDecoration(
        labelText: label,
        hintText: hint,
        labelStyle: textStyles.bodyMedium.withColor(colors.textSecondary),
        hintStyle: textStyles.bodyMedium.withColor(colors.textMuted),
        prefixIcon: prefixIcon != null ? Icon(prefixIcon, color: colors.textSecondary) : null,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(spacing.borderRadius),
          borderSide: BorderSide(color: colors.border),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(spacing.borderRadius),
          borderSide: BorderSide(color: colors.borderLight),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(spacing.borderRadius),
          borderSide: BorderSide(color: colors.primary, width: 2),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(spacing.borderRadius),
          borderSide: BorderSide(color: colors.error),
        ),
        focusedErrorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(spacing.borderRadius),
          borderSide: BorderSide(color: colors.error, width: 2),
        ),
        filled: true,
        fillColor: colors.surface,
      ),
      validator: validator,
      keyboardType: keyboardType,
      maxLines: maxLines,
    );
  }

  Widget _buildActionButtons() {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;
    return Row(
      children: [
        Expanded(
          child: OutlinedButton(
            key: const Key('cancelButton'),
            onPressed: _isLoading ? null : () => context.pop(),
            style: OutlinedButton.styleFrom(
              padding: EdgeInsets.symmetric(vertical: spacing.lg),
              side: BorderSide(color: colors.primary),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(spacing.borderRadius),
              ),
            ),
            child: Text('Cancelar', style: textStyles.labelLarge.withColor(colors.primary)),
          ),
        ),
        SizedBox(width: spacing.lg),
        Expanded(
          child: ElevatedButton(
            key: const Key('formSaveButton'),
            onPressed: _isLoading ? null : _saveInstitution,
            style: ElevatedButton.styleFrom(
              padding: EdgeInsets.symmetric(vertical: spacing.lg),
              backgroundColor: colors.primary,

              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(spacing.borderRadius),
              ),
            ),
            child: Text(isEditing ? 'Actualizar' : 'Crear', style: textStyles.button),
          ),
        ),
      ],
    );
  }
}
/* Fin lib\screens\institutions\institution_form_screen.dart */

/* Inicio lib\screens\institution_selection_screen.dart */
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../utils/app_routes.dart';
import '../utils/responsive_utils.dart';
import '../models/institution.dart';

class InstitutionSelectionScreen extends StatefulWidget {
  const InstitutionSelectionScreen({super.key});

  @override
  State<InstitutionSelectionScreen> createState() => _InstitutionSelectionScreenState();
}

class _InstitutionSelectionScreenState extends State<InstitutionSelectionScreen> {
  String? _selectedInstitutionId;
  bool _isLoading = false;

  Map<String, dynamic> _getResponsiveValues(BoxConstraints constraints) {
    return ResponsiveUtils.getResponsiveValues(constraints);
  }

  Widget _buildMainTitle(Map<String, dynamic> responsive) {
    final titleFontSize = responsive['titleFontSize'] as double;

    return Builder(
      builder: (context) {
        final colors = context.colors;
        return Text(
          'Seleccionar InstituciÃ³n',
          style: TextStyle(
            fontSize: titleFontSize,
            fontWeight: FontWeight.bold,
            color: colors.textPrimary,
          ),
          textAlign: TextAlign.center,
        );
      },
    );
  }

  Widget _buildSubtitle(Map<String, dynamic> responsive, Color textMuted) {
    final subtitleFontSize = responsive['subtitleFontSize'] as double;

    return Text(
      'Elija la instituciÃ³n con la que desea trabajar',
      style: TextStyle(
        color: textMuted,
        fontSize: subtitleFontSize,
      ),
      textAlign: TextAlign.center,
    );
  }

  Widget _buildInstitutionList(List<Institution> institutions, Map<String, dynamic> responsive) {
    final bodyFontSize = responsive['bodyFontSize'] as double;

    return ListView.builder(
      shrinkWrap: true,
      itemCount: institutions.length,
      itemBuilder: (context, index) {
        final institution = institutions[index];
        final isSelected = _selectedInstitutionId == institution.id;

        return Card(
          margin: const EdgeInsets.symmetric(vertical: 8),
          color: isSelected ? Theme.of(context).colorScheme.primaryContainer : Theme.of(context).colorScheme.surface,
          child: ListTile(
            leading: Radio<String>(
              value: institution.id,
              groupValue: _selectedInstitutionId,
              onChanged: (value) {
                setState(() {
                  _selectedInstitutionId = value;
                });
              },
            ),
            title: Text(
              institution.name,
              style: TextStyle(
                fontSize: bodyFontSize,
                color: isSelected ? Theme.of(context).colorScheme.onPrimaryContainer : Theme.of(context).colorScheme.onSurface,
              ),
            ),
            subtitle: institution.role != null
                ? Text('Rol: ${institution.role}', style: TextStyle(fontSize: bodyFontSize * 0.9))
                : null,
            onTap: () {
              setState(() {
                _selectedInstitutionId = institution.id;
              });
            },
          ),
        );
      },
    );
  }

  Widget _buildContinueButton(Map<String, dynamic> responsive) {
    final buttonWidth = responsive['buttonWidth'] as double;

    return SizedBox(
      width: buttonWidth,
      child: ElevatedButton(
        onPressed: _isLoading || _selectedInstitutionId == null ? null : _continue,
        child: Text(_isLoading ? 'Continuando...' : 'Continuar'),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final authProvider = Provider.of<AuthProvider>(context);
    final institutions = authProvider.institutions;

    if (institutions == null || institutions.isEmpty) {
      return const Scaffold(
        body: Center(
          child: Text('No hay instituciones disponibles'),
        ),
      );
    }

    return Scaffold(
      backgroundColor: colors.background,
      body: SafeArea(
        child: ResponsiveUtils.buildResponsiveContainer(
          context: context,
          child: SingleChildScrollView(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                LayoutBuilder(
                  builder: (context, constraints) {
                    final responsive = _getResponsiveValues(constraints);
                    final elementSpacing = responsive['elementSpacing'] as double;

                    return Column(
                      children: [
                        _buildMainTitle(responsive),
                        SizedBox(height: elementSpacing),

                        _buildSubtitle(responsive, colors.textMuted),
                        SizedBox(height: elementSpacing * 1.5),

                        _buildInstitutionList(institutions, responsive),
                        SizedBox(height: elementSpacing * 2),

                        _buildContinueButton(responsive),
                      ],
                    );
                  },
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _continue() async {
    if (_selectedInstitutionId == null) return;

    setState(() {
      _isLoading = true;
    });

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      authProvider.selectInstitution(_selectedInstitutionId!);

      if (mounted) {
        final authProvider = Provider.of<AuthProvider>(context, listen: false);
        final user = authProvider.user;
        final userRole = user?['rol'] as String?;

        final route = AppRoutes.getDashboardRouteForRole(userRole ?? '');
        context.go(route);
      }
    } catch (e) {
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }
}
/* Fin lib\screens\institution_selection_screen.dart */

/* Inicio lib\screens\login_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../utils/responsive_utils.dart';

class LoginScreen extends StatefulWidget {
  const LoginScreen({super.key});

  @override
  State<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {

  final _emailController = TextEditingController(text: 'superadmin@asistapp.com');
  final _passwordController = TextEditingController(text: 'Admin123!');
  bool _isLoading = false;
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Widget _buildMainTitle(Map<String, dynamic> responsive) {
    final titleFontSize = responsive['titleFontSize'] as double;

    return Builder(
      builder: (context) {
        final colors = context.colors;
        return Text(
          'AsistApp',
          key: const Key('appTitle'),
          style: TextStyle(
            fontSize: titleFontSize,
            fontWeight: FontWeight.bold,
            color: colors.textPrimary,
          ),
          textAlign: TextAlign.center,
        );
      },
    );
  }

  Widget _buildSubtitle(Map<String, dynamic> responsive, Color textMuted) {
    final subtitleFontSize = responsive['subtitleFontSize'] as double;

    return Text(
      'Sistema de Registro de Asistencia Escolar',
      style: TextStyle(
        color: textMuted,
        fontSize: subtitleFontSize,
      ),
      textAlign: TextAlign.center,
    );
  }

  Widget _buildEmailField() {
    return TextFormField(
      key: const Key('emailField'),
      controller: _emailController,
      decoration: const InputDecoration(
        labelText: 'Correo electrÃ³nico',
      ),
      keyboardType: TextInputType.emailAddress,
    );
  }

  Widget _buildPasswordField() {
    return TextFormField(
      key: const Key('passwordField'),
      controller: _passwordController,
      decoration: const InputDecoration(
        labelText: 'ContraseÃ±a',
      ),
      obscureText: true,
    );
  }

  Widget _buildLoginButton(Map<String, dynamic> responsive) {
    final buttonWidth = responsive['buttonWidth'] as double;

    return SizedBox(
      width: buttonWidth,
      child: ElevatedButton(
        key: const Key('loginButton'),
        onPressed: _isLoading ? null : _login,
        child: Text(_isLoading ? 'Iniciando sesiÃ³n...' : 'Iniciar SesiÃ³n'),
      ),
    );
  }

  Widget _buildTestUsersSection(Map<String, dynamic> responsive) {
    final bodyFontSize = responsive['bodyFontSize'] as double;

    return Builder(
      builder: (context) {
        final colors = context.colors;
        return Column(
          children: [
            const SizedBox(height: 32),
            Text(
              'Usuarios de Prueba (Desarrollo)',
              style: TextStyle(
                fontSize: bodyFontSize,
                fontWeight: FontWeight.bold,
                color: colors.textSecondary,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 16),
            Wrap(
              spacing: 8,
              runSpacing: 8,
              alignment: WrapAlignment.center,
              children: [
                _buildTestUserButton(
                  'Super Admin',
                  'superadmin@asistapp.com',
                  'Admin123!',
                  'super_admin',
                  'Todas',
                  responsive,
                ),
                _buildTestUserButton(
                  'Admin Multi',
                  'multi@asistapp.com',
                  'Multi123!',
                  'admin_institucion',
                  '2 instituciones',
                  responsive,
                ),
                _buildTestUserButton(
                  'Admin San JosÃ©',
                  'admin@sanjose.edu',
                  'SanJose123!',
                  'admin_institucion',
                  '1 instituciÃ³n',
                  responsive,
                ),
                _buildTestUserButton(
                  'Profesor',
                  'pedro.garcia@sanjose.edu',
                  'Prof123!',
                  'profesor',
                  '1 instituciÃ³n',
                  responsive,
                ),
                _buildTestUserButton(
                  'Estudiante',
                  'juan.perez@sanjose.edu',
                  'Est123!',
                  'estudiante',
                  '1 instituciÃ³n',
                  responsive,
                ),
              ],
            ),
          ],
        );
      },
    );
  }

  Widget _buildTestUserButton(
    String name,
    String email,
    String password,
    String role,
    String institutions,
    Map<String, dynamic> responsive,
  ) {
    final isSmallScreen = responsive['isSmallScreen'] as bool;
    final buttonWidth = isSmallScreen ? 140.0 : 160.0;

    return Builder(
      builder: (context) {
        final colors = context.colors;
        final textStyles = context.textStyles;

        return SizedBox(
          width: buttonWidth,
          child: OutlinedButton(
            onPressed: () {
              setState(() {
                _emailController.text = email;
                _passwordController.text = password;
                _errorMessage = null;
              });
            },
            style: OutlinedButton.styleFrom(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 12),
              side: BorderSide(color: colors.primary.withValues(alpha: 0.5)),
            ),
            child: Column(
              children: [
                Text(
                  name,
                  style: textStyles.labelMedium.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 2),
                Text(
                  role,
                  style: textStyles.bodySmall,
                  textAlign: TextAlign.center,
                ),
                Text(
                  institutions,
                  style: textStyles.bodySmall.copyWith(
                    fontStyle: FontStyle.italic,
                    color: colors.textMuted,
                  ),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildErrorMessage() {
    if (_errorMessage == null) return const SizedBox.shrink();

    return Builder(
      builder: (context) {
        final textStyles = context.textStyles;
        final colors = context.colors;
        return Text(
          _errorMessage!,
          style: textStyles.bodyMedium.copyWith(color: colors.error),  // Usar estilo del tema
          textAlign: TextAlign.center,
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;

    return Scaffold(
      backgroundColor: colors.background,
      body: SafeArea(
        child: LayoutBuilder(
          builder: (context, constraints) {
            final responsive = ResponsiveUtils.getResponsiveValues(constraints);

            return SingleChildScrollView(
              child: ConstrainedBox(
                constraints: BoxConstraints(maxWidth: responsive['maxWidth']),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    Padding(
                      padding: EdgeInsets.symmetric(
                        horizontal: responsive['horizontalPadding'],
                        vertical: responsive['verticalPadding'],
                      ),
                      child: Column(
                        children: [
                          _buildMainTitle(responsive),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildSubtitle(responsive, colors.textMuted),
                          SizedBox(height: responsive['elementSpacing'] * 1.5),

                          _buildEmailField(),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildPasswordField(),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildErrorMessage(),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildLoginButton(responsive),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildTestUsersSection(responsive),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            );
          },
        ),
      ),
    );
  }

  Future<void> _login() async {
    if (_emailController.text.isEmpty ||
        _passwordController.text.isEmpty) {
      setState(() {
        _errorMessage = 'Por favor complete todos los campos';
      });
      return;
    }

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final success = await authProvider.login(
        _emailController.text.trim(),
        _passwordController.text,
      );

      if (success) {

        debugPrint('Login exitoso, AuthWrapper manejarÃ¡ la navegaciÃ³n');
      } else {
        setState(() {
          _errorMessage = 'Credenciales incorrectas';
        });
      }
    } catch (e) {
      setState(() {
        _errorMessage = 'Error de conexiÃ³n. Intente nuevamente.';
      });
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }
}
/* Fin lib\screens\login_screen.dart */

/* Inicio lib\screens\student_dashboard.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../widgets/role_guard.dart';
import '../utils/role_enum.dart';
import '../utils/responsive_utils.dart';
import '../utils/app_routes.dart';
import '../widgets/dashboard_widgets.dart';

class StudentDashboard extends StatelessWidget {
  const StudentDashboard({super.key});

  Widget _buildUserGreeting(String userName, AuthProvider authProvider, Map<String, dynamic> responsive) {
    final selectedInstitution = authProvider.selectedInstitution;

    return UserGreetingWidget(
      userName: userName,
      responsive: responsive,
      subtitle: selectedInstitution?.name,
    );
  }

  Widget _buildDashboardOptions(BuildContext context, Map<String, dynamic> responsive) {
    final colors = context.colors;

    return Column(
      children: [
        const SizedBox(height: 32),
        Wrap(
          spacing: 12,
          runSpacing: 12,
          alignment: WrapAlignment.center,
          children: [
            DashboardFeatureCard(
              icon: Icons.qr_code,
              title: 'Mi CÃ³digo QR',
              description: 'Mostrar cÃ³digo para asistencia',
              color: colors.primary,  // Usar color primario consistente
              responsive: responsive,
            ),
            RoleGuard(
              allowedRoles: [UserRole.estudiante],
              child: DashboardFeatureCard(
                icon: Icons.calendar_today,
                title: 'Mi Horario',
                description: 'Ver clases del dÃ­a',
                color: colors.primary,  // Usar color primario consistente
                responsive: responsive,
              ),
            ),
            DashboardFeatureCard(
              icon: Icons.assignment,
              title: 'Asistencia',
              description: 'Historial de mi asistencia',
              color: colors.primary,  // Usar color primario consistente
              responsive: responsive,
            ),
            DashboardFeatureCard(
              icon: Icons.bar_chart,
              title: 'EstadÃ­sticas',
              description: 'Mi rendimiento acadÃ©mico',
              color: colors.primary,  // Usar color primario consistente
              responsive: responsive,
            ),
            DashboardFeatureCard(
              icon: Icons.notifications,
              title: 'Notificaciones',
              description: 'Avisos de padres/profesores',
              color: colors.secondary,  // Usar secundario para variar ligeramente
              responsive: responsive,
            ),
            DashboardFeatureCard(
              icon: Icons.contact_phone,
              title: 'Contacto',
              description: 'InformaciÃ³n de contacto',
              color: colors.info,  // Info para acciones informativas
              responsive: responsive,
            ),
          ],
        ),
      ],
    );
  }

  PreferredSizeWidget _buildAppBar(BuildContext context, AuthProvider authProvider, Color primaryColor, String userRole) {
    return DashboardAppBar(
      backgroundColor: primaryColor,
      actions: [
        DashboardAppBarActions(
          userRole: userRole,
          roleIcon: Icons.person,
          onLogout: () async {
            await authProvider.logout();
            if (context.mounted) {
              context.go(AppRoutes.login);
            }
          },
        ),
      ],
    );
  }

  Widget _buildBody(BuildContext context, String userName, AuthProvider authProvider, Map<String, dynamic> responsive) {
    return DashboardBody(
      userGreeting: _buildUserGreeting(userName, authProvider, responsive),
      dashboardOptions: _buildDashboardOptions(context, responsive),
      responsive: responsive,
    );
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final colors = context.colors;

    final user = authProvider.user;
    final userName = user?['nombres'] ?? 'Usuario';
    final userRole = 'Estudiante';

    return Scaffold(
      backgroundColor: colors.background,
      appBar: _buildAppBar(context, authProvider, colors.primary, userRole),
      body: LayoutBuilder(
        builder: (ctx, constraints) {
          final responsive = ResponsiveUtils.getResponsiveValues(constraints);
          return _buildBody(context, userName, authProvider, responsive);
        },
      ),
    );
  }
}
/* Fin lib\screens\student_dashboard.dart */

/* Inicio lib\screens\super_admin_dashboard.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../utils/responsive_utils.dart';
import '../utils/app_routes.dart';
import '../widgets/dashboard_widgets.dart';

class SuperAdminDashboard extends StatelessWidget {
  const SuperAdminDashboard({super.key});

  Widget _buildDashboardOptions(BuildContext context, Map<String, dynamic> responsive) {
    final colors = context.colors;

    final cards = [
      DashboardFeatureCard(
        icon: Icons.business,
        title: 'Instituciones',
        description: 'Gestionar todas las instituciones del sistema',
        color: colors.primary,  // Usar color primario consistente
        responsive: responsive,
        onTap: () => context.go(AppRoutes.institutionsList),
      ),
      DashboardFeatureCard(
        icon: Icons.people,
        title: 'Usuarios Globales',
        description: 'Administrar usuarios de todo el sistema',
        color: colors.primary,  // Usar color primario consistente
        responsive: responsive,
      ),
      DashboardFeatureCard(
        icon: Icons.security,
        title: 'Permisos',
        description: 'Configurar permisos y roles del sistema',
        color: colors.primary,  // Usar color primario consistente
        responsive: responsive,
      ),
      DashboardFeatureCard(
        icon: Icons.analytics,
        title: 'Reportes Globales',
        description: 'EstadÃ­sticas y mÃ©tricas del sistema completo',
        color: colors.primary,  // Usar color primario consistente
        responsive: responsive,
      ),
      DashboardFeatureCard(
        icon: Icons.settings,
        title: 'ConfiguraciÃ³n',
        description: 'Ajustes globales del sistema',
        color: colors.primary,  // Usar color primario consistente
        responsive: responsive,
      ),
      DashboardFeatureCard(
        icon: Icons.backup,
        title: 'Backup & Restore',
        description: 'GestiÃ³n de respaldos del sistema',
        color: colors.error,  // Este puede mantener error para destacar su criticidad
        responsive: responsive,
      ),
    ];

    return DashboardOptionsGrid(
      cards: cards,
      responsive: responsive,
    );
  }

  PreferredSizeWidget _buildAppBar(BuildContext context, AuthProvider authProvider, Color primaryColor, String userRole) {
    return DashboardAppBar(
      backgroundColor: primaryColor,
      actions: [
        DashboardAppBarActions(
          userRole: userRole,
          roleIcon: Icons.verified_user,
          onLogout: () async {
            await authProvider.logout();
            if (context.mounted) {
              context.go(AppRoutes.login);
            }
          },
        ),
      ],
    );
  }

  Widget _buildBody(BuildContext context, String userName, Map<String, dynamic> responsive) {
    return DashboardBody(
      userGreeting: UserGreetingWidget(
        userName: userName,
        responsive: responsive,
      ),
      dashboardOptions: _buildDashboardOptions(context, responsive),
      responsive: responsive,
    );
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final colors = context.colors;

    final user = authProvider.user;
    final userName = user?['nombres'] ?? 'Usuario';
    final userRole = 'Super Admin';

    return Scaffold(
      backgroundColor: colors.background,
      appBar: _buildAppBar(context, authProvider, colors.primary, userRole),
      body: LayoutBuilder(
        builder: (context, constraints) {
          final responsive = ResponsiveUtils.getResponsiveValues(constraints);
          return _buildBody(context, userName, responsive);
        },
      ),
    );
  }
}
/* Fin lib\screens\super_admin_dashboard.dart */

/* Inicio lib\screens\teacher_dashboard.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../widgets/role_guard.dart';
import '../utils/role_enum.dart';
import '../utils/responsive_utils.dart';
import '../utils/app_routes.dart';
import '../widgets/dashboard_widgets.dart';

class TeacherDashboard extends StatelessWidget {
  const TeacherDashboard({super.key});

  Widget _buildUserGreeting(String userName, AuthProvider authProvider, Map<String, dynamic> responsive) {
    final selectedInstitution = authProvider.selectedInstitution;

    return UserGreetingWidget(
      userName: userName,
      responsive: responsive,
      subtitle: selectedInstitution?.name,
    );
  }

  Widget _buildDashboardOptions(BuildContext context, Map<String, dynamic> responsive) {
    final colors = context.colors;

    return Column(
      children: [
        const SizedBox(height: 32),
        Wrap(
          spacing: 12,
          runSpacing: 12,
          alignment: WrapAlignment.center,
          children: [
            DashboardFeatureCard(
              icon: Icons.qr_code_scanner,
              title: 'Tomar Asistencia',
              description: 'Registrar asistencia con QR',
              color: colors.primary,  // Usar color primario consistente
              responsive: responsive,
            ),
            DashboardFeatureCard(
              icon: Icons.assignment,
              title: 'Mis Clases',
              description: 'Ver horarios y grupos asignados',
              color: colors.primary,  // Usar color primario consistente
              responsive: responsive,
            ),
            DashboardFeatureCard(
              icon: Icons.people,
              title: 'Estudiantes',
              description: 'Lista de estudiantes por grupo',
              color: colors.primary,  // Usar color primario consistente
              responsive: responsive,
            ),
            DashboardFeatureCard(
              icon: Icons.bar_chart,
              title: 'Reportes',
              description: 'EstadÃ­sticas de asistencia',
              color: colors.primary,  // Usar color primario consistente
              responsive: responsive,
            ),
            RoleGuard(
              allowedRoles: [UserRole.profesor],
              child: DashboardFeatureCard(
                icon: Icons.notifications,
                title: 'Notificaciones',
                description: 'Enviar avisos a padres',
                color: colors.primary,  // Usar color primario consistente
                responsive: responsive,
              ),
            ),
            DashboardFeatureCard(
              icon: Icons.calendar_today,
              title: 'Horario',
              description: 'Mi horario de clases',
              color: colors.primary,  // Usar color primario consistente
              responsive: responsive,
            ),
          ],
        ),
      ],
    );
  }

  PreferredSizeWidget _buildAppBar(BuildContext context, AuthProvider authProvider, Color primaryColor, String userRole) {
    return DashboardAppBar(
      backgroundColor: primaryColor,
      actions: [
        DashboardAppBarActions(
          userRole: userRole,
          roleIcon: Icons.school,
          onLogout: () async {
            await authProvider.logout();
            if (context.mounted) {
              context.go(AppRoutes.login);
            }
          },
        ),
      ],
    );
  }

  Widget _buildBody(BuildContext context, String userName, AuthProvider authProvider, Map<String, dynamic> responsive) {
    return DashboardBody(
      userGreeting: _buildUserGreeting(userName, authProvider, responsive),
      dashboardOptions: _buildDashboardOptions(context, responsive),
      responsive: responsive,
    );
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final colors = context.colors;

    final user = authProvider.user;
    final userName = user?['nombres'] ?? 'Usuario';
    final userRole = 'Profesor';

    return Scaffold(
      backgroundColor: colors.background,
      appBar: _buildAppBar(context, authProvider, colors.primary, userRole),
      body: LayoutBuilder(
        builder: (ctx, constraints) {
          final responsive = ResponsiveUtils.getResponsiveValues(constraints);
          return _buildBody(context, userName, authProvider, responsive);
        },
      ),
    );
  }
}
/* Fin lib\screens\teacher_dashboard.dart */

/* Inicio lib\screens\teacher_dashboard_with_scroll.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../widgets/scroll_state_keeper.dart';
import '../utils/app_routes.dart';
import '../utils/responsive_utils.dart';
class TeacherDashboardWithScroll extends StatelessWidget {
  const TeacherDashboardWithScroll({super.key});

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final colors = context.colors;
    final textStyles = context.textStyles;

    return Scaffold(
      backgroundColor: colors.background,
      appBar: AppBar(
        title: const Text('Profesor - AsistApp'),
        backgroundColor: colors.primary,
        actions: [
          IconButton(
            icon: const Icon(Icons.logout),
            onPressed: () async {
              await authProvider.logout();
            },
          ),
        ],
      ),
      body: SafeArea(
        child: ScrollStateKeeper(
          routeKey: AppRoutes.teacherDashboard,
          keepScrollPosition: true,
          builder: (context, scrollController) {
            return LayoutBuilder(
              builder: (context, constraints) {
                final responsive = ResponsiveUtils.getResponsiveValues(constraints);

                return SingleChildScrollView(
                  controller: scrollController, // â† El scroll se guarda automÃ¡ticamente
                  child: ConstrainedBox(
                    constraints: BoxConstraints(
                      maxWidth: responsive['maxWidth'],
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.center,
                      children: [
                        Padding(
                          padding: EdgeInsets.symmetric(
                            horizontal: responsive['horizontalPadding'],
                            vertical: responsive['verticalPadding'],
                          ),
                          child: Column(
                            children: [
                              Text(
                                'Panel del Profesor',
                                style: textStyles.displayLarge.copyWith(
                                  fontSize: responsive['isSmallScreen'] ? 28 : 42,
                                ),
                                textAlign: TextAlign.center,
                              ),
                              const SizedBox(height: 16),

                              ...List.generate(20, (index) => Card(
                                margin: const EdgeInsets.symmetric(vertical: 8),
                                child: ListTile(
                                  leading: CircleAvatar(child: Text('${index + 1}')),
                                  title: Text('Clase ${index + 1}'),
                                  subtitle: Text('Grupo ${index % 5 + 1}'),
                                  trailing: const Icon(Icons.arrow_forward_ios),
                                ),
                              )),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ),
                );
              },
            );
          },
        ),
      ),
    );
  }
}

/* Fin lib\screens\teacher_dashboard_with_scroll.dart */

/* Inicio lib\screens\users\create_professor_screen.dart */
import 'package:flutter/material.dart';
import 'user_form_screen.dart';

class CreateProfessorScreen extends StatelessWidget {
  const CreateProfessorScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return UserFormScreen(userRole: 'profesor');
  }
}
/* Fin lib\screens\users\create_professor_screen.dart */

/* Inicio lib\screens\users\create_student_screen.dart */
import 'package:flutter/material.dart';
import 'user_form_screen.dart';

class CreateStudentScreen extends StatelessWidget {
  const CreateStudentScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return UserFormScreen(userRole: 'estudiante');
  }
}
/* Fin lib\screens\users\create_student_screen.dart */

/* Inicio lib\screens\users\users_list_screen.dart */
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import 'package:flutter_speed_dial/flutter_speed_dial.dart';
import '../../models/user.dart';
import '../../providers/auth_provider.dart';
import '../../providers/user_provider.dart';
import '../../theme/theme_extensions.dart';
import '../../theme/app_text_styles.dart';
import '../../widgets/common/management_scaffold.dart';

class UsersListScreen extends StatefulWidget {
  const UsersListScreen({super.key});

  @override
  State<UsersListScreen> createState() => _UsersListScreenState();
}

class _UsersListScreenState extends State<UsersListScreen> {
  final TextEditingController _searchController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  Timer? _searchDebounceTimer;
  String _searchQuery = '';
  String _selectedRoleFilter = '';
  bool? _statusFilter = true
  bool _isSearching = false;

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final userRole = authProvider.user?['rol'] as String?;
      if (userRole == 'admin_institucion') {
        setState(() {
          _selectedRoleFilter = ''
        });
      }
      _loadUsers();
    });
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _searchController.dispose();
    _searchDebounceTimer?.cancel();
    super.dispose();
  }

  void _onScroll() {
    if (_isSearching) return

    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final userProvider = Provider.of<UserProvider>(context, listen: false);

    if (_scrollController.position.pixels >= _scrollController.position.maxScrollExtent * 0.9) {
      final userRole = authProvider.user?['rol'] as String?;
      _loadMoreUsers(userProvider, authProvider.accessToken, userRole);
    }
  }

  Future<void> _loadUsers() async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final userProvider = Provider.of<UserProvider>(context, listen: false);
    final userRole = authProvider.user?['rol'] as String?;

    if (authProvider.accessToken == null) {
      debugPrint('Error: No hay token de acceso para cargar usuarios.');
      return;
    }
    if (userRole == 'super_admin') {
      debugPrint('Cargando usuarios (admin_institucion y super_admin) como super_admin...');
      final roles = (_selectedRoleFilter.isEmpty)
          ? ['super_admin', 'admin_institucion']
          : [_selectedRoleFilter];

      await userProvider.loadUsers(
        authProvider.accessToken!,
        page: 1,
        limit: 15,
        search: _searchQuery.isEmpty ? null : _searchQuery,
        activo: _statusFilter,
        roles: roles,
      );
    } else if (userRole == 'admin_institucion') {
      if (authProvider.selectedInstitutionId != null) {
        debugPrint('Cargando usuarios para la instituciÃ³n: ${authProvider.selectedInstitutionId}');
        await userProvider.loadUsersByInstitution(
          authProvider.accessToken!,
          authProvider.selectedInstitutionId!,
          page: 1,
          limit: 5,
          role: _selectedRoleFilter.isEmpty ? null : _selectedRoleFilter,
          activo: _statusFilter,
          search: _searchQuery.isEmpty ? null : _searchQuery,
        );
      } else {
        debugPrint('Admin de instituciÃ³n sin instituciÃ³n seleccionada. No se cargarÃ¡n usuarios.');
        userProvider.clearData()
      }
    }
  }

  Future<void> _loadMoreUsers(UserProvider provider, String? accessToken, String? userRole) async {
    if (accessToken == null || provider.isLoadingMore || !provider.hasMoreData) return;
    if (userRole == 'super_admin') {
      final roles = (_selectedRoleFilter.isEmpty)
          ? ['super_admin', 'admin_institucion']
          : [_selectedRoleFilter];

      await provider.loadMoreUsers(
        accessToken,
        activo: _statusFilter,
        search: _searchQuery.isEmpty ? null : _searchQuery,
        roles: roles,
      );
    } else {
      await provider.loadMoreUsers(accessToken);
    }
  }

  void _onSearchChanged(String query) {
    _searchDebounceTimer?.cancel();

    setState(() {
      _isSearching = query.isNotEmpty;
    });
    _searchDebounceTimer = Timer(const Duration(milliseconds: 500), () {
      setState(() {
        _searchQuery = query.trim();
      });
      _loadUsers();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Consumer2<AuthProvider, UserProvider>(
      builder: (context, authProvider, userProvider, child) {
        final userRole = authProvider.user?['rol'] as String?;
        final title = userRole == 'admin_institucion'
          ? 'GestiÃ³n de Profesores'
          : 'GestiÃ³n de Usuarios';

        return ManagementScaffold(
          title: title,
          isLoading: userProvider.isLoading && userProvider.users.isEmpty,
          hasError: userProvider.hasError,
          errorMessage: userProvider.errorMessage ?? 'Error desconocido',
          itemCount: userProvider.users.length,
          itemBuilder: (context, index) => _buildUserCard(
            userProvider.users[index],
            userProvider,
            context,
          ),
          hasMoreData: userProvider.hasMoreData,
          onRefresh: () => _loadUsers(),
          scrollController: _scrollController,
          floatingActionButton: Consumer<AuthProvider>(
            builder: (context, authProvider, child) {
              final userRole = authProvider.user?['rol'] as String?;
              final canCreateUsers = userRole == 'admin_institucion' || userRole == 'super_admin';

              if (!canCreateUsers) return const SizedBox.shrink();
              if (userRole == 'super_admin') {
                return SpeedDial(
                  icon: Icons.add,
                  activeIcon: Icons.close,
                  backgroundColor: context.colors.primary,
                  foregroundColor: context.colors.getTextColorForBackground(context.colors.primary),
                  children: [
                    SpeedDialChild(
                      child: Icon(Icons.admin_panel_settings, color: context.colors.getTextColorForBackground(context.colors.primary)),
                      backgroundColor: context.colors.primary,
                      label: 'Crear Admin InstituciÃ³n',
                      onTap: _navigateToCreateAdminInstitution,
                    ),
                    SpeedDialChild(
                      child: Icon(Icons.shield, color: context.colors.getTextColorForBackground(context.colors.primary)),
                      backgroundColor: context.colors.primary,
                      label: 'Crear Super Admin',
                      onTap: _navigateToCreateSuperAdmin,
                    ),
                  ],
                );
              } else {
                return SpeedDial(
                  icon: Icons.add,
                  activeIcon: Icons.close,
                  backgroundColor: context.colors.primary,
                  foregroundColor: context.colors.getTextColorForBackground(context.colors.primary),
                  children: [
                    SpeedDialChild(
                      child: Icon(Icons.school, color: context.colors.getTextColorForBackground(context.colors.primary)),
                      backgroundColor: context.colors.primary,
                      label: 'Crear Profesor',
                      onTap: _navigateToCreateProfessor,
                    ),
                    SpeedDialChild(
                      child: Icon(Icons.person, color: context.colors.getTextColorForBackground(context.colors.primary)),
                      backgroundColor: context.colors.primary,
                      label: 'Crear Estudiante',
                      onTap: _navigateToCreateStudent,
                    ),
                  ],
                );
              }
            },
          ),
          filterWidgets: _buildFilterWidgets(context, authProvider),
          statisticWidgets: _buildStatisticWidgets(context, userProvider),
          paginationInfo: null, // No pagination widget for users
          onPageChange: (_) async {}, // Not used
          emptyStateTitle: _isSearching ? 'No se encontraron resultados para tu bÃºsqueda' : 'AÃºn no has creado ningÃºn usuario',
          emptyStateMessage: _isSearching ? 'Intenta con otros tÃ©rminos de bÃºsqueda' : 'Comienza creando tu primer usuario',
          emptyStateIcon: _isSearching ? Icons.search_off : Icons.people,
        );
      },
    );
  }

  List<Widget> _buildFilterWidgets(BuildContext context, AuthProvider authProvider) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return [
      TextField(
        controller: _searchController,
        style: textStyles.bodyLarge,
        decoration: InputDecoration(
          hintText: 'Buscar por nombre, email o telÃ©fono...',
          hintStyle: textStyles.bodyMedium.withColor(colors.textMuted),
          prefixIcon: Icon(Icons.search, color: colors.textSecondary),
          suffixIcon: _isSearching
              ? IconButton(
                  icon: Icon(Icons.clear, color: colors.textSecondary),
                  onPressed: () {
                    _searchController.clear();
                    _onSearchChanged('');
                  },
                )
              : null,
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.border),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.borderLight),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.primary, width: 2),
          ),
          filled: true,
          fillColor: colors.surface,
          contentPadding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
        ),
        onChanged: _onSearchChanged,
      ),
      SizedBox(height: spacing.sm),
      Row(
        children: [
          Text('Mostrar:', style: textStyles.labelMedium),
          SizedBox(width: spacing.md),
          FilterChip(
            label: const Text('Activos'),
            selected: _statusFilter == true && !_isSearching,
            onSelected: !_isSearching ? (selected) {
              setState(() => _statusFilter = selected ? true : null);
              _loadUsers();
            } : null,
          ),
          SizedBox(width: spacing.md),
          FilterChip(
            label: const Text('Inactivos'),
            selected: _statusFilter == false && !_isSearching,
            onSelected: !_isSearching ? (selected) {
              setState(() => _statusFilter = selected ? false : null);
              _loadUsers();
            } : null,
          ),
          SizedBox(width: spacing.md),
          FilterChip(
            label: const Text('Todos'),
            selected: _statusFilter == null && !_isSearching,
            onSelected: !_isSearching ? (selected) {
              setState(() => _statusFilter = selected ? null : true);
              _loadUsers();
            } : null,
          ),
          SizedBox(width: spacing.md),
          Expanded(
            child: Consumer<AuthProvider>(
              builder: (context, authProvider, child) {
                final userRole = authProvider.user?['rol'] as String?;
                final isAdminInstitucion = userRole == 'admin_institucion';
                final isSuperAdmin = userRole == 'super_admin';

                return DropdownButtonFormField<String>(
                  value: _selectedRoleFilter.isEmpty ? null : _selectedRoleFilter,
                  hint: Text('Filtrar por rol', style: textStyles.bodyMedium),
                  items: isSuperAdmin ? [
                    DropdownMenuItem(value: '', child: Text('Todos los roles', style: textStyles.bodyMedium)),
                    DropdownMenuItem(value: 'admin_institucion', child: Text('Admins InstituciÃ³n', style: textStyles.bodyMedium)),
                    DropdownMenuItem(value: 'super_admin', child: Text('Super Admins', style: textStyles.bodyMedium)),
                  ] : isAdminInstitucion ? [
                    DropdownMenuItem(value: '', child: Text('Todos los usuarios', style: textStyles.bodyMedium)),
                    DropdownMenuItem(value: 'profesor', child: Text('Solo Profesores', style: textStyles.bodyMedium)),
                    DropdownMenuItem(value: 'estudiante', child: Text('Solo Estudiantes', style: textStyles.bodyMedium)),
                  ] : [
                    DropdownMenuItem(value: '', child: Text('Todos los roles', style: textStyles.bodyMedium)),
                    DropdownMenuItem(value: 'profesor', child: Text('Profesores', style: textStyles.bodyMedium)),
                    DropdownMenuItem(value: 'estudiante', child: Text('Estudiantes', style: textStyles.bodyMedium)),
                    DropdownMenuItem(value: 'admin_institucion', child: Text('Admins InstituciÃ³n', style: textStyles.bodyMedium)),
                  ],
                  onChanged: (value) {
                    setState(() => _selectedRoleFilter = value ?? '');
                    _loadUsers();
                  },
                  decoration: InputDecoration(
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(spacing.borderRadius),
                    ),
                    contentPadding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
                  ),
                );
              },
            ),
          ),
        ],
      ),
    ];
  }

  List<Widget> _buildStatisticWidgets(BuildContext context, UserProvider provider) {
    final stats = provider.getUserStatistics();

    return [
      _buildCompactStat(
        'Total',
        stats['total'].toString(),
        Icons.people,
        context.colors.primary,
        context.textStyles,
      ),
      Container(
        height: 24,
        width: 1,
        color: context.colors.border,
      ),
      _buildCompactStat(
        'Activos',
        stats['activos'].toString(),
        Icons.check_circle,
        context.colors.success,
        context.textStyles,
      ),
      Container(
        height: 24,
        width: 1,
        color: context.colors.border,
      ),
      _buildCompactStat(
        'Profesores',
        stats['profesores'].toString(),
        Icons.school,
        context.colors.info,
        context.textStyles,
      ),
      Container(
        height: 24,
        width: 1,
        color: context.colors.border,
      ),
      _buildCompactStat(
        'Estudiantes',
        stats['estudiantes'].toString(),
        Icons.person,
        context.colors.warning,
        context.textStyles,
      ),
    ];
  }

  Widget _buildCompactStat(String title, String value, IconData icon, Color color, AppTextStyles textStyles) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(icon, size: 20, color: color),
        const SizedBox(width: 6),
        Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              value,
              style: textStyles.titleMedium.copyWith(
                color: color,
                fontWeight: FontWeight.bold,
              ),
            ),
            Text(
              title,
              style: textStyles.bodySmall.copyWith(
                color: color.withValues(alpha: 0.7),
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildUserCard(User user, UserProvider provider, BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;
    return Card(
      margin: EdgeInsets.only(bottom: spacing.xs),
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(spacing.borderRadius),
      ),
      child: ListTile(
        leading: CircleAvatar(
          backgroundColor: user.activo ? colors.success : colors.error,
          child: Icon(
            user.activo ? Icons.check : Icons.close,
            color: colors.surface,
          ),
        ),
        title: Text(
          user.nombreCompleto,
          style: textStyles.titleMedium.bold,
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(Icons.email, size: 16, color: colors.textSecondary),
                SizedBox(width: spacing.xs),
                Expanded(
                  child: Text(
                    user.email,
                    style: textStyles.bodySmall,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ],
            ),
            if (user.telefono != null) ...[
              SizedBox(height: spacing.xs),
              Row(
                children: [
                  Icon(Icons.phone, size: 16, color: colors.textSecondary),
                  SizedBox(width: spacing.xs),
                  Expanded(
                    child: Text(
                      user.telefono!,
                      style: textStyles.bodySmall,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
            ],
            SizedBox(height: spacing.xs),
            Chip(
              label: Text(
                _getRoleDisplayName(user.rol),
                style: textStyles.bodySmall.withColor(colors.primary),
              ),
              backgroundColor: colors.primary.withValues(alpha: 0.1),
              side: BorderSide(color: colors.primary.withValues(alpha: 0.3)),
              materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
              padding: EdgeInsets.zero,
            ),
          ],
        ),
        trailing: Consumer<AuthProvider>(
          builder: (context, authProvider, child) {
            final userRole = authProvider.user?['rol'] as String?;
            final canEditUsers = userRole == 'admin_institucion' || userRole == 'super_admin';

            if (!canEditUsers) return const SizedBox.shrink();

            return PopupMenuButton<String>(
              onSelected: (value) => _handleMenuAction(value, user, provider),
              itemBuilder: (context) => [
                PopupMenuItem(
                  value: 'edit',
                  child: Row(
                    children: [
                      Icon(Icons.edit, color: context.colors.textSecondary),
                      SizedBox(width: context.spacing.sm),
                      Text('Editar', style: context.textStyles.bodyMedium),
                    ],
                  ),
                ),
                PopupMenuItem(
                  value: 'toggle_status',
                  child: Row(
                    children: [
                      Icon(Icons.toggle_on, color: context.colors.textSecondary),
                      SizedBox(width: context.spacing.sm),
                      Text('Cambiar Estado', style: context.textStyles.bodyMedium),
                    ],
                  ),
                ),
                PopupMenuItem(
                  value: 'delete',
                  child: Row(
                    children: [
                      Icon(Icons.delete, color: context.colors.error),
                      SizedBox(width: context.spacing.sm),
                      Text('Eliminar', style: context.textStyles.bodyMedium.withColor(context.colors.error)),
                    ],
                  ),
                ),
              ],
            );
          },
        ),
        onTap: () => _navigateToUserDetail(user),
      ),
    );
  }

  String _getRoleDisplayName(String role) {
    switch (role) {
      case 'profesor':
        return 'Profesor';
      case 'estudiante':
        return 'Estudiante';
      case 'admin_institucion':
        return 'Admin InstituciÃ³n';
      case 'super_admin':
        return 'Super Admin';
      default:
        return role;
    }
  }

  void _handleMenuAction(String action, User user, UserProvider provider) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    switch (action) {
      case 'edit':
        _navigateToUserEdit(user);
        break;

      case 'toggle_status':
        final newStatus = !user.activo;
        final success = await provider.updateUser(
          authProvider.accessToken!,
          user.id,
          UpdateUserRequest(
            activo: newStatus,
            nombres: user.nombres, // Incluir valores actuales para evitar null
            apellidos: user.apellidos,
            email: user.email,
            telefono: user.telefono,
          ),
        );

        if (success && mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                'Usuario ${newStatus ? 'activado' : 'desactivado'} correctamente',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onPrimary),
              ),
              backgroundColor: Theme.of(context).colorScheme.primary,
            ),
          );
          await _loadUsers();
        } else if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                provider.errorMessage ?? 'Error al cambiar estado del usuario',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onError),
              ),
              backgroundColor: Theme.of(context).colorScheme.error,
            ),
          );
        }
        break;

      case 'delete':
        _showDeleteConfirmationDialog(user, provider);
        break;
    }
  }

  void _showDeleteConfirmationDialog(User user, UserProvider provider) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Eliminar Usuario', style: Theme.of(context).textTheme.headlineSmall),
        content: Text(
          'Â¿EstÃ¡s seguro de que quieres eliminar "${user.nombreCompleto}"?\n\n'
          'Esta acciÃ³n no se puede deshacer.',
          style: Theme.of(context).textTheme.bodyMedium,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: Text('Cancelar', style: Theme.of(context).textTheme.labelLarge),
          ),
          TextButton(
            onPressed: () async {
              Navigator.of(context).pop();
              await _deleteUser(user, provider);
            },
            style: TextButton.styleFrom(foregroundColor: Theme.of(context).colorScheme.error),
            child: Text('Eliminar', style: Theme.of(context).textTheme.labelLarge?.copyWith(color: Theme.of(context).colorScheme.error)),
          ),
        ],
      ),
    );
  }

  Future<void> _deleteUser(User user, UserProvider provider) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    final success = await provider.deleteUser(
      authProvider.accessToken!,
      user.id,
      authProvider.user?['rol'] as String? ?? '',
      user.rol,
    );

    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            'Usuario eliminado correctamente',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onPrimary),
          ),
          backgroundColor: Theme.of(context).colorScheme.primary,
        ),
      );
      await _loadUsers();
    } else if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            provider.errorMessage ?? 'Error al eliminar usuario',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onError),
          ),
          backgroundColor: Theme.of(context).colorScheme.error,
        ),
      );
    }
  }

  void _navigateToCreateProfessor() {
    context.push('/users/professor/create');
  }

  void _navigateToCreateStudent() {
    context.push('/users/student/create');
  }

  void _navigateToCreateAdminInstitution() {
    context.push('/users/admin_institucion/create');
  }

  void _navigateToCreateSuperAdmin() {
    context.push('/users/super_admin/create');
  }

  void _navigateToUserEdit(User user) {
    context.push('/users/${user.rol}/create?edit=true&userId=${user.id}');
  }

  void _navigateToUserDetail(User user) {
    context.push('/users/detail/${user.id}', extra: user);
  }
}
/* Fin lib\screens\users\users_list_screen.dart */

/* Inicio lib\screens\users\user_detail_screen.dart */
import 'package:flutter/material.dart';
import '../../models/user.dart';
import '../../theme/theme_extensions.dart';

class UserDetailScreen extends StatelessWidget {
  final User user;

  const UserDetailScreen({
    super.key,
    required this.user,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Scaffold(
      appBar: AppBar(
        title: Text(
          user.nombreCompleto,
          style: textStyles.titleLarge,
        ),
        backgroundColor: colors.primary,
        foregroundColor: Theme.of(context).colorScheme.onPrimary,
        elevation: 0,
      ),
      body: SingleChildScrollView(
        padding: EdgeInsets.all(spacing.lg),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildInfoSection(
              context,
              'InformaciÃ³n BÃ¡sica',
              [
                _buildInfoItem('Nombres', user.nombres),
                _buildInfoItem('Apellidos', user.apellidos),
                _buildInfoItem('Email', user.email),
                _buildInfoItem('TelÃ©fono', user.telefono ?? 'No especificado'),
                _buildInfoItem('Rol', _getRoleDisplayName(user.rol)),
                _buildInfoItem('Estado', user.activo ? 'Activo' : 'Inactivo',
                    valueColor: user.activo ? colors.success : colors.error),
              ],
            ),

            SizedBox(height: spacing.lg),
            if (user.esEstudiante && user.estudiante != null) ...[
              _buildInfoSection(
                context,
                'InformaciÃ³n del Estudiante',
                [
                  _buildInfoItem('IdentificaciÃ³n', user.estudiante!.identificacion),
                  _buildInfoItem('CÃ³digo QR', user.estudiante!.codigoQr),
                  if (user.estudiante!.nombreResponsable != null)
                    _buildInfoItem('Nombre del Responsable', user.estudiante!.nombreResponsable!),
                  if (user.estudiante!.telefonoResponsable != null)
                    _buildInfoItem('TelÃ©fono del Responsable', user.estudiante!.telefonoResponsable!),
                ],
              ),
              SizedBox(height: spacing.lg),
            ],
            if (user.instituciones.isNotEmpty) ...[
              _buildInfoSection(
                context,
                'Instituciones',
                user.instituciones.map((inst) => _buildInfoItem(
                  inst.nombre,
                  inst.rolEnInstitucion ?? 'Sin rol especÃ­fico',
                )).toList(),
              ),
              SizedBox(height: spacing.lg),
            ],
            _buildInfoSection(
              context,
              'InformaciÃ³n del Sistema',
              [
                _buildInfoItem('ID de Usuario', user.id),
                _buildInfoItem('Fecha de CreaciÃ³n', 'No disponible'), // TODO: Agregar campo de fecha si existe
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoSection(BuildContext context, String title, List<Widget> items) {
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(spacing.borderRadius),
      ),
      child: Padding(
        padding: EdgeInsets.all(spacing.lg),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              title,
              style: textStyles.titleMedium.bold,
            ),
            SizedBox(height: spacing.md),
            ...items,
          ],
        ),
      ),
    );
  }

  Widget _buildInfoItem(String label, String value, {Color? valueColor}) {
    return Padding(
      padding: EdgeInsets.symmetric(vertical: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Expanded(
            flex: 2,
            child: Text(
              '$label:',
              style: TextStyle(
                fontWeight: FontWeight.w600,
                color: Colors.grey[700],
              ),
            ),
          ),
          Expanded(
            flex: 3,
            child: Text(
              value,
              style: TextStyle(
                color: valueColor,
                fontWeight: valueColor != null ? FontWeight.w500 : FontWeight.normal,
              ),
            ),
          ),
        ],
      ),
    );
  }

  String _getRoleDisplayName(String role) {
    switch (role) {
      case 'super_admin':
        return 'Super Administrador';
      case 'admin_institucion':
        return 'Administrador de InstituciÃ³n';
      case 'profesor':
        return 'Profesor';
      case 'estudiante':
        return 'Estudiante';
      default:
        return role;
    }
  }
}
/* Fin lib\screens\users\user_detail_screen.dart */

/* Inicio lib\screens\users\user_form_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../models/user.dart';
import '../../providers/auth_provider.dart';
import '../../providers/user_provider.dart';
import '../../providers/institution_provider.dart';
import '../../theme/theme_extensions.dart';
import '../../widgets/form_widgets.dart';

class UserFormScreen extends StatefulWidget {
  final String userRole

  const UserFormScreen({
    super.key,
    required this.userRole,
  });

  @override
  State<UserFormScreen> createState() => _UserFormScreenState();
}

class _UserFormScreenState extends State<UserFormScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nombresController = TextEditingController();
  final _apellidosController = TextEditingController();
  final _emailController = TextEditingController();
  final _telefonoController = TextEditingController();
  final _identificacionController = TextEditingController();
  final _tituloController = TextEditingController();
  final _especialidadController = TextEditingController();
  final _nombreResponsableController = TextEditingController();
  final _telefonoResponsableController = TextEditingController();

  bool _isLoading = false;
  bool _isInitialLoading = false;
  bool _activo = true;
  User? _user
  String? _selectedInstitutionId

  @override
  void initState() {
    super.initState();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _loadUserIfEditing();
    _loadInstitutionsIfNeeded();
  }

  Future<void> _loadUserIfEditing() async {
    if (_user != null || _isInitialLoading) return;

    final uri = GoRouterState.of(context).uri;
    final queryParams = uri.queryParameters;

    final isEdit = queryParams['edit'] == 'true';
    final userId = queryParams['userId'];

    if (isEdit && userId != null) {
      setState(() => _isInitialLoading = true);

      try {
        final authProvider = Provider.of<AuthProvider>(context, listen: false);
        final userProvider = Provider.of<UserProvider>(context, listen: false);

        await userProvider.loadUserById(
          authProvider.accessToken!,
          userId,
        );

        final user = userProvider.selectedUser;
        if (user != null && mounted) {
          setState(() => _user = user);
          _fillFormWithUserData();
        }
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                'Error al cargar usuario: ${e.toString()}',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  color: Theme.of(context).colorScheme.onError,
                ),
              ),
              backgroundColor: Theme.of(context).colorScheme.error,
            ),
          );
          context.go('/users');
        }
      } finally {
        if (mounted) {
          setState(() => _isInitialLoading = false);
        }
      }
    }
  }

  Future<void> _loadInstitutionsIfNeeded() async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final userRole = authProvider.user?['rol'] as String?;
    if (userRole == 'super_admin' && widget.userRole == 'admin_institucion') {
      final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);
      if (institutionProvider.institutions.isEmpty) {
        await institutionProvider.loadInstitutions(
          authProvider.accessToken!,
          page: 1,
          limit: 100, // Cargar todas para el dropdown
        );
      }
    }
  }

  void _fillFormWithUserData() {
    final user = _user!;
    _nombresController.text = user.nombres;
    _apellidosController.text = user.apellidos;
    _emailController.text = user.email;
    _telefonoController.text = user.telefono ?? '';
    _activo = user.activo;
    if (user.instituciones.isNotEmpty) {
      _selectedInstitutionId = user.instituciones.first.id;
    }

    if (user.estudiante != null) {
      _identificacionController.text = user.estudiante!.identificacion;
      _nombreResponsableController.text = user.estudiante!.nombreResponsable ?? '';
      _telefonoResponsableController.text = user.estudiante!.telefonoResponsable ?? '';
    }
  }

  @override
  void dispose() {
    _nombresController.dispose();
    _apellidosController.dispose();
    _emailController.dispose();
    _telefonoController.dispose();
    _identificacionController.dispose();
    _tituloController.dispose();
    _especialidadController.dispose();
    _nombreResponsableController.dispose();
    _telefonoResponsableController.dispose();
    super.dispose();
  }

  Future<void> _saveUser() async {
    if (!_formKey.currentState!.validate()) return;
    if (widget.userRole == 'admin_institucion' && _selectedInstitutionId == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            'Debe seleccionar una instituciÃ³n',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
              color: Theme.of(context).colorScheme.onError,
            ),
          ),
          backgroundColor: Theme.of(context).colorScheme.error,
        ),
      );
      return;
    }

    setState(() => _isLoading = true);

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final userProvider = Provider.of<UserProvider>(context, listen: false);

      if (_user != null) {
        final updateRequest = UpdateUserRequest(
          email: _emailController.text.trim(),
          nombres: _nombresController.text.trim(),
          apellidos: _apellidosController.text.trim(),
          telefono: _telefonoController.text.trim().isNotEmpty ? _telefonoController.text.trim() : null,
          identificacion: widget.userRole == 'estudiante' ? _identificacionController.text.trim() : null,
          nombreResponsable: widget.userRole == 'estudiante' ? _nombreResponsableController.text.trim().isNotEmpty ? _nombreResponsableController.text.trim() : null : null,
          telefonoResponsable: widget.userRole == 'estudiante' ? _telefonoResponsableController.text.trim().isNotEmpty ? _telefonoResponsableController.text.trim() : null : null,
          activo: _activo,
        );

        final success = await userProvider.updateUser(
          authProvider.accessToken!,
          _user!.id,
          updateRequest,
        );

        if (success && mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                '${_getRoleDisplayName(widget.userRole)} actualizado exitosamente',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  color: Theme.of(context).colorScheme.onPrimary,
                ),
              ),
              backgroundColor: Theme.of(context).colorScheme.primary,
            ),
          );
          context.go('/users');
        }
      } else {
        final createRequest = CreateUserRequest(
          email: _emailController.text.trim(),
          password: 'TempPass123!', // TODO: Implementar generaciÃ³n de contraseÃ±a segura o pedir al usuario
          nombres: _nombresController.text.trim(),
          apellidos: _apellidosController.text.trim(),
          telefono: _telefonoController.text.trim().isNotEmpty ? _telefonoController.text.trim() : null,
          identificacion: widget.userRole == 'estudiante' ? _identificacionController.text.trim() : null,
          rol: widget.userRole,
          titulo: widget.userRole == 'profesor' ? _tituloController.text.trim() : null,
          especialidad: widget.userRole == 'profesor' ? _especialidadController.text.trim() : null,
          nombreResponsable: widget.userRole == 'estudiante' ? _nombreResponsableController.text.trim().isNotEmpty ? _nombreResponsableController.text.trim() : null : null,
          telefonoResponsable: widget.userRole == 'estudiante' ? _telefonoResponsableController.text.trim().isNotEmpty ? _telefonoResponsableController.text.trim() : null : null,
          institucionId: widget.userRole == 'admin_institucion' ? _selectedInstitutionId : authProvider.selectedInstitutionId,
          rolEnInstitucion: widget.userRole == 'admin_institucion' ? 'admin' : null,
        );

        final success = await userProvider.createUser(
          authProvider.accessToken!,
          createRequest,
        );

        if (success && mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                '${_getRoleDisplayName(widget.userRole)} creado exitosamente',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  color: Theme.of(context).colorScheme.onPrimary,
                ),
              ),
              backgroundColor: Theme.of(context).colorScheme.primary,
            ),
          );
          context.go('/users');
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              'Error al ${_user != null ? 'actualizar' : 'crear'} ${_getRoleDisplayName(widget.userRole)}: ${e.toString()}',
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onError,
              ),
            ),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  String _getRoleDisplayName(String role) {
    switch (role) {
      case 'profesor':
        return 'Profesor';
      case 'estudiante':
        return 'Estudiante';
      case 'admin_institucion':
        return 'Administrador de InstituciÃ³n';
      case 'super_admin':
        return 'Super Administrador';
      default:
        return 'Usuario';
    }
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;
    final title = _user != null ? 'Editar Usuario' : 'Crear ${_getRoleDisplayName(widget.userRole)}';

    if (_isInitialLoading) {
      return Scaffold(
        backgroundColor: colors.background,
        appBar: AppBar(
          title: Text(title),
        ),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: const [
              CircularProgressIndicator(),
              SizedBox(height: 16),
              Text('Cargando usuario...'),
            ],
          ),
        ),
      );
    }

    return Scaffold(
      backgroundColor: colors.background,
      appBar: AppBar(
        title: Text(title),
      ),
      body: SingleChildScrollView(
        padding: EdgeInsets.all(spacing.lg),
        child: Form(
        key: _formKey,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            SizedBox(height: spacing.lg),
            LayoutBuilder(
              builder: (context, constraints) {
                final isWide = constraints.maxWidth > 600;
                return isWide
                  ? Row(
                      children: [
                        Expanded(
                          child: CustomTextFormField(
                            key: const Key('user_form_nombres'),
                            controller: _nombresController,
                            labelText: 'Nombres',
                            hintText: 'Ingrese los nombres',
                            validator: (value) {
                              if (value == null || value.trim().isEmpty) {
                                return 'Los nombres son requeridos';
                              }
                              if (value.trim().length < 2) {
                                return 'Los nombres deben tener al menos 2 caracteres';
                              }
                              return null;
                            },
                          ),
                        ),
                        SizedBox(width: spacing.md),
                        Expanded(
                          child: CustomTextFormField(
                            key: const Key('user_form_apellidos'),
                            controller: _apellidosController,
                            labelText: 'Apellidos',
                            hintText: 'Ingrese los apellidos',
                            validator: (value) {
                              if (value == null || value.trim().isEmpty) {
                                return 'Los apellidos son requeridos';
                              }
                              if (value.trim().length < 2) {
                                return 'Los apellidos deben tener al menos 2 caracteres';
                              }
                              return null;
                            },
                          ),
                        ),
                      ],
                    )
                  : Column(
                      children: [
                        CustomTextFormField(
                          key: const Key('nombresUsuarioField'),
                          controller: _nombresController,
                          labelText: 'Nombres',
                          hintText: 'Ingrese los nombres',
                          validator: (value) {
                            if (value == null || value.trim().isEmpty) {
                              return 'Los nombres son requeridos';
                            }
                            if (value.trim().length < 2) {
                              return 'Los nombres deben tener al menos 2 caracteres';
                            }
                            return null;
                          },
                        ),
                        SizedBox(height: spacing.md),
                        CustomTextFormField(
                          key: const Key('apellidosUsuarioField'),
                          controller: _apellidosController,
                          labelText: 'Apellidos',
                          hintText: 'Ingrese los apellidos',
                          validator: (value) {
                            if (value == null || value.trim().isEmpty) {
                              return 'Los apellidos son requeridos';
                            }
                            if (value.trim().length < 2) {
                              return 'Los apellidos deben tener al menos 2 caracteres';
                            }
                            return null;
                          },
                        ),
                      ],
                    );
              },
            ),
            SizedBox(height: spacing.md),
            CustomTextFormField(
              key: const Key('emailUsuarioField'),
              controller: _emailController,
              labelText: 'Email',
              hintText: '${widget.userRole}@ejemplo.com',
              keyboardType: TextInputType.emailAddress,
              validator: (value) {
                if (value == null || value.trim().isEmpty) {
                  return 'El email es requerido';
                }
                final emailRegex = RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$');
                if (!emailRegex.hasMatch(value.trim())) {
                  return 'Ingrese un email vÃ¡lido';
                }
                return null;
              },
            ),
            SizedBox(height: spacing.md),
            if (widget.userRole == 'admin_institucion') ...[
              Consumer2<AuthProvider, InstitutionProvider>(
                builder: (context, authProvider, institutionProvider, child) {
                  final userRole = authProvider.user?['rol'] as String?;
                  final isSuperAdmin = userRole == 'super_admin';

                  if (!isSuperAdmin) return const SizedBox.shrink();

                  return CustomDropdownFormField<String>(
                    key: const Key('institucionDropdown'),
                    value: _selectedInstitutionId,
                    labelText: 'InstituciÃ³n',
                    hintText: 'Seleccione una instituciÃ³n',
                    items: institutionProvider.institutions.map((institution) {
                      return DropdownMenuItem<String>(
                        value: institution.id,
                        child: Text(institution.nombre),
                      );
                    }).toList(),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'Debe seleccionar una instituciÃ³n';
                      }
                      return null;
                    },
                    onChanged: (value) {
                      setState(() {
                        _selectedInstitutionId = value;
                      });
                    },
                  );
                },
              ),
              SizedBox(height: spacing.md),
            ],
            LayoutBuilder(
              builder: (context, constraints) {
                final isWide = constraints.maxWidth > 600;
                return isWide
                  ? Row(
                      children: [
                        Expanded(
                          child: CustomTextFormField(
                            key: const Key('user_form_telefono'),
                            controller: _telefonoController,
                            labelText: 'TelÃ©fono',
                            hintText: '+57 300 123 4567',
                            keyboardType: TextInputType.phone,
                            validator: (value) {
                              if (value != null && value.trim().isNotEmpty) {
                                final phoneRegex = RegExp(r'^\+?[0-9\s\-\(\)]+$');
                                if (!phoneRegex.hasMatch(value.trim())) {
                                  return 'Ingrese un telÃ©fono vÃ¡lido';
                                }
                              }
                              return null;
                            },
                          ),
                        ),
                        SizedBox(width: spacing.md),
                        Expanded(
                          child: CustomTextFormField(
                            key: const Key('user_form_identificacion'),
                            controller: _identificacionController,
                            labelText: 'IdentificaciÃ³n',
                            hintText: 'CÃ©dula o documento',
                            validator: (value) {
                              if (widget.userRole == 'admin_institucion' || widget.userRole == 'super_admin') {
                                return null;
                              }

                              if (value == null || value.trim().isEmpty) {
                                return 'La identificaciÃ³n es requerida';
                              }
                              if (value.trim().length < 5) {
                                return 'La identificaciÃ³n debe tener al menos 5 caracteres';
                              }
                              return null;
                            },
                          ),
                        ),
                      ],
                    )
                  : Column(
                      children: [
                        CustomTextFormField(
                          key: const Key('user_form_telefono'),
                          controller: _telefonoController,
                          labelText: 'TelÃ©fono',
                          hintText: '+57 300 123 4567',
                          keyboardType: TextInputType.phone,
                          validator: (value) {
                            if (value != null && value.trim().isNotEmpty) {
                              final phoneRegex = RegExp(r'^\+?[0-9\s\-\(\)]+$');
                              if (!phoneRegex.hasMatch(value.trim())) {
                                return 'Ingrese un telÃ©fono vÃ¡lido';
                              }
                            }
                            return null;
                          },
                        ),
                        SizedBox(height: spacing.md),
                        CustomTextFormField(
                          key: const Key('user_form_identificacion'),
                          controller: _identificacionController,
                          labelText: 'IdentificaciÃ³n',
                          hintText: 'CÃ©dula o documento',
                          validator: (value) {
                            if (widget.userRole == 'admin_institucion' || widget.userRole == 'super_admin') {
                              return null;
                            }

                            if (value == null || value.trim().isEmpty) {
                              return 'La identificaciÃ³n es requerida';
                            }
                            if (value.trim().length < 5) {
                              return 'La identificaciÃ³n debe tener al menos 5 caracteres';
                            }
                            return null;
                          },
                        ),
                      ],
                    );
              },
            ),
            SizedBox(height: spacing.lg),

            if (widget.userRole == 'profesor') ...[
              Text(
                'InformaciÃ³n AcadÃ©mica',
                style: textStyles.headlineMedium.bold,
              ),
              SizedBox(height: spacing.lg),
              LayoutBuilder(
                builder: (context, constraints) {
                  final isWide = constraints.maxWidth > 600;
                  return isWide
                    ? Row(
                        children: [
                          Expanded(
                            child: CustomTextFormField(
                              controller: _tituloController,
                              labelText: 'TÃ­tulo AcadÃ©mico',
                              hintText: 'Licenciado en..., MagÃ­ster en...',
                              validator: (value) {
                                if (value == null || value.trim().isEmpty) {
                                  return 'El tÃ­tulo acadÃ©mico es requerido';
                                }
                                if (value.trim().length < 3) {
                                  return 'El tÃ­tulo debe tener al menos 3 caracteres';
                                }
                                return null;
                              },
                            ),
                          ),
                          SizedBox(width: spacing.md),
                          Expanded(
                            child: CustomTextFormField(
                              controller: _especialidadController,
                              labelText: 'Especialidad',
                              hintText: 'MatemÃ¡ticas, FÃ­sica, etc.',
                              validator: (value) {
                                if (value == null || value.trim().isEmpty) {
                                  return 'La especialidad es requerida';
                                }
                                if (value.trim().length < 3) {
                                  return 'La especialidad debe tener al menos 3 caracteres';
                                }
                                return null;
                              },
                            ),
                          ),
                        ],
                      )
                    : Column(
                        children: [
                          CustomTextFormField(
                            controller: _tituloController,
                            labelText: 'TÃ­tulo AcadÃ©mico',
                            hintText: 'Licenciado en..., MagÃ­ster en...',
                            validator: (value) {
                              if (value == null || value.trim().isEmpty) {
                                return 'El tÃ­tulo acadÃ©mico es requerido';
                              }
                              if (value.trim().length < 3) {
                                return 'El tÃ­tulo debe tener al menos 3 caracteres';
                              }
                              return null;
                            },
                          ),
                          SizedBox(height: spacing.md),
                          CustomTextFormField(
                            controller: _especialidadController,
                            labelText: 'Especialidad',
                            hintText: 'MatemÃ¡ticas, FÃ­sica, etc.',
                            validator: (value) {
                              if (value == null || value.trim().isEmpty) {
                                return 'La especialidad es requerida';
                              }
                              if (value.trim().length < 3) {
                                return 'La especialidad debe tener al menos 3 caracteres';
                              }
                              return null;
                            },
                          ),
                        ],
                      );
                  },
                ),
                SizedBox(height: spacing.lg),
              ],

              if (widget.userRole == 'estudiante') ...[
                Text(
                  'InformaciÃ³n del Responsable',
                  style: textStyles.headlineMedium.bold,
                ),
                SizedBox(height: spacing.lg),
                CustomTextFormField(
                  controller: _nombreResponsableController,
                  labelText: 'Nombre del Responsable',
                  hintText: 'Padre, madre o tutor',
                  validator: (value) {
                    return null;
                  },
                ),
                SizedBox(height: spacing.md),
                CustomTextFormField(
                  controller: _telefonoResponsableController,
                  labelText: 'TelÃ©fono del Responsable',
                  hintText: '+57 300 123 4567',
                  keyboardType: TextInputType.phone,
                  validator: (value) {
                    if (value != null && value.trim().isNotEmpty) {
                      final phoneRegex = RegExp(r'^\+?[0-9\s\-\(\)]+$');
                      if (!phoneRegex.hasMatch(value.trim())) {
                        return 'Ingrese un telÃ©fono vÃ¡lido';
                      }
                    }
                    return null;
                  },
                ),
                SizedBox(height: spacing.lg),
              ],
              Card(
                elevation: 2,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(spacing.borderRadius),
                ),
                child: Padding(
                  padding: EdgeInsets.all(spacing.md),
                  child: Row(
                    children: [
                      Icon(
                        _activo ? Icons.check_circle : Icons.cancel,
                        color: _activo ? colors.success : colors.error,
                      ),
                      SizedBox(width: spacing.md),
                      Expanded(
                        child: Text(
                          'Usuario Activo',
                          style: textStyles.bodyLarge,
                        ),
                      ),
                      Switch(
                        value: _activo,
                        onChanged: (value) {
                          setState(() => _activo = value);
                        },
                        activeColor: colors.primary,
                      ),
                    ],
                  ),
                ),
              ),
              SizedBox(height: spacing.xl),
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      key: const Key('cancelButton'),
                      onPressed: _isLoading ? null : () => context.pop(),
                      style: OutlinedButton.styleFrom(
                        padding: EdgeInsets.symmetric(vertical: spacing.md),
                        side: BorderSide(color: colors.primary),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(spacing.borderRadius),
                        ),
                      ),
                      child: Text(
                        'Cancelar',
                        style: textStyles.button.withColor(colors.primary),
                      ),
                    ),
                  ),
                  SizedBox(width: spacing.md),
                  Expanded(
                    child: ElevatedButton(
                      key: const Key('formSaveButton'),
                      onPressed: _isLoading ? null : _saveUser,
                      style: ElevatedButton.styleFrom(
                        padding: EdgeInsets.symmetric(vertical: spacing.md),
                        backgroundColor: colors.primary,
                        foregroundColor: Theme.of(context).colorScheme.onPrimary,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(spacing.borderRadius),
                        ),
                      ),
                      child: _isLoading
                          ? SizedBox(
                              height: 20,
                              width: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                valueColor: AlwaysStoppedAnimation<Color>(
                                  Theme.of(context).colorScheme.onPrimary,
                                ),
                              ),
                            )
                          : Text(_user != null ? 'Actualizar' : 'Crear', style: textStyles.button),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}
/* Fin lib\screens\users\user_form_screen.dart */

/* Inicio lib\screens\welcome_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../utils/responsive_utils.dart';

class WelcomeScreen extends StatelessWidget {
  const WelcomeScreen({super.key});

  Widget _buildUserName(AuthProvider authProvider, TextStyle headlineMedium, Color primary, bool isSmallScreen) {
    final user = authProvider.user;
    final userName = user?['name'] ?? user?['email'] ?? 'Usuario';

    return Text(
      userName,
      style: headlineMedium.copyWith(
        color: primary,
        fontSize: isSmallScreen ? 18 : 24,
      ),
      textAlign: TextAlign.center,
    );
  }

  Widget _buildSignOutButton(AuthProvider authProvider) {
    return ElevatedButton(
      onPressed: () async {
        await authProvider.logout();
      },
      child: const Text('Cerrar SesiÃ³n'),
    );
  }

  Widget _buildBody(AuthProvider authProvider, dynamic textStyles, Color primaryColor, Map<String, dynamic> responsive) {
    return SafeArea(
      child: LayoutBuilder(
        builder: (context, constraints) {
          return Center(
            child: SingleChildScrollView(
              child: ConstrainedBox(
                constraints: BoxConstraints(maxWidth: responsive['maxWidth']),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    Padding(
                      padding: EdgeInsets.symmetric(
                        horizontal: responsive['horizontalPadding'],
                        vertical: responsive['verticalPadding'],
                      ),
                      child: Column(
                        children: [
                          _buildUserName(authProvider, textStyles.headlineMedium, primaryColor, responsive['isSmallScreen']),
                          SizedBox(height: responsive['elementSpacing']),

                          const Text(
                            'Has iniciado sesiÃ³n correctamente',
                            textAlign: TextAlign.center,
                          ),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildSignOutButton(authProvider),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
          );
        },
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final colors = context.colors;
    final textStyles = context.textStyles;

    return Scaffold(
      backgroundColor: colors.background,
      body: LayoutBuilder(
        builder: (context, constraints) {
          final responsive = ResponsiveUtils.getResponsiveValues(constraints);
          return _buildBody(authProvider, textStyles, colors.primary, responsive);
        },
      ),
    );
  }
}
/* Fin lib\screens\welcome_screen.dart */

/* Inicio lib\services\auth_service.dart */
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';

class LoginResponse {
  final String accessToken;
  final String refreshToken;
  final Map<String, dynamic> user;
  final int? expiresIn;

  LoginResponse({
    required this.accessToken,
    required this.refreshToken,
    required this.user,
    this.expiresIn,
  });

  factory LoginResponse.fromJson(Map<String, dynamic> json) {

    final data = json['data'] ?? json;

    final usuario = data['usuario'] ?? data['user'];

    return LoginResponse(
      accessToken: data['accessToken'] as String,
      refreshToken: data['refreshToken'] as String,
      user: usuario is Map<String, dynamic> ? usuario : {},
      expiresIn: data['expiresIn'] as int?,
    );
  }
}

class RefreshResponse {
  final String accessToken;
  final String refreshToken;

  RefreshResponse({
    required this.accessToken,
    required this.refreshToken,
  });

  factory RefreshResponse.fromJson(Map<String, dynamic> json) {
    return RefreshResponse(
      accessToken: json['accessToken'],
      refreshToken: json['refreshToken'],
    );
  }
}

class AuthService {

  static Future<String> _getLocalIp() async {
    try {

      if (kIsWeb) {
        return 'localhost';
      }

      return '192.168.20.22'
    } catch (e) {
      debugPrint('Error obteniendo IP local: $e');
      return 'localhost'
    }
  }

  static Future<String> get baseUrl async {
    final ip = await _getLocalIp();
    return 'http://$ip:3000';
  }

  Future<LoginResponse?> login(String email, String password) async {
    try {
      final baseUrlValue = await baseUrl;
      final url = '$baseUrlValue/auth/login';

      final requestBody = jsonEncode({
        'email': email,
        'password': password,
      });

      final response = await http.post(
        Uri.parse(url),
        headers: {'Content-Type': 'application/json'},
        body: requestBody,
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('   Status: ${response.statusCode}');
      debugPrint('   Body: ${response.body}');
      debugPrint('========================================');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);

        final data = responseData['data'] ?? responseData;

        if (data['accessToken'] == null || data['refreshToken'] == null) {
          debugPrint('   accessToken: ${data['accessToken']}');
          debugPrint('   refreshToken: ${data['refreshToken']}');
          debugPrint('   usuario: ${data['usuario']}');
          return null;
        }

        return LoginResponse.fromJson(responseData);
      } else {
        debugPrint('   Response: ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error: $e');
      debugPrint('StackTrace: $stackTrace');
      debugPrint('====================================');
      return null;
    }
  }

  Future<RefreshResponse?> refreshToken(String refreshToken) async {
    try {
      final baseUrlValue = await baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/auth/refresh'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'refreshToken': refreshToken,
        }),
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        return RefreshResponse.fromJson(data);
      } else {
        debugPrint('Refresh failed: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e) {
      debugPrint('Refresh error: $e');
      return null;
    }
  }

  Future<bool> logout(String refreshToken) async {
    try {
      final baseUrlValue = await baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/auth/logout'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'refreshToken': refreshToken,
        }),
      );

      return response.statusCode == 200;
    } catch (e) {
      debugPrint('Logout error: $e');
      return false;
    }
  }

  Future<List<Map<String, dynamic>>?> getUserInstitutions(String accessToken) async {
    try {
      final baseUrlValue = await baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/auth/instituciones'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        if (data['success'] == true) {
          final institutions = data['data'] as List;
          return institutions.map((e) => e as Map<String, dynamic>).toList();
        }
      } else {
        debugPrint('Get user institutions failed: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e) {
      debugPrint('Get user institutions error: $e');
      return null;
    }
    return null;
  }
}
/* Fin lib\services\auth_service.dart */

/* Inicio lib\services\institution_service.dart */
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';
import '../models/institution.dart';
import '../models/user.dart';

class PaginatedInstitutionResponse {
  final List<Institution> institutions;
  final PaginationInfo pagination;

  PaginatedInstitutionResponse({
    required this.institutions,
    required this.pagination,
  });
}

class InstitutionService {
  static Future<String> _getLocalIp() async {
    try {
      if (kIsWeb) {
        return 'localhost';
      }
      return '192.168.20.22'
    } catch (e) {
      debugPrint('Error obteniendo IP local: $e');
      return 'localhost';
    }
  }

  static Future<String> get baseUrl async {
    final ip = await _getLocalIp();
    return 'http://$ip:3000';
  }
  Future<PaginatedInstitutionResponse?> getAllInstitutions(String accessToken, {int? page, int? limit, bool? activa, String? search}) async {
    try {
      final baseUrlValue = await baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      if (limit != null) queryParams['limit'] = limit.toString();
      if (activa != null) queryParams['activa'] = activa.toString();
      if (search != null && search.isNotEmpty) queryParams['search'] = search;

      final uri = Uri.parse('$baseUrlValue/instituciones').replace(queryParameters: queryParams);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /instituciones - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final institutions = (responseData['data'] as List)
              .map((institutionJson) => Institution.fromJson(institutionJson))
              .toList();
          final pagination = PaginationInfo.fromJson(responseData['pagination']);
          return PaginatedInstitutionResponse(institutions: institutions, pagination: pagination);
        }
      } else {
        debugPrint('Error getting institutions: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting institutions: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Institution?> getInstitutionById(String accessToken, String id) async {
    try {
      final baseUrlValue = await baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/instituciones/$id'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /instituciones/$id - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Institution.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error getting institution: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting institution: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Institution?> createInstitution(
    String accessToken, {
    required String nombre,
    String? direccion,
    String? telefono,
    String? email,
  }) async {
    try {
      final baseUrlValue = await baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/instituciones'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode({
          'nombre': nombre,
          if (direccion != null) 'direccion': direccion,
          if (telefono != null) 'telefono': telefono,
          if (email != null) 'email': email,
        }),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('POST /instituciones - Status: ${response.statusCode}');

      if (response.statusCode == 201) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Institution.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error creating institution: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error creating institution: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Institution?> updateInstitution(
    String accessToken,
    String id, {
    String? nombre,
    String? direccion,
    String? telefono,
    String? email,
    bool? activa,
  }) async {
    try {
      final baseUrlValue = await baseUrl;
      final response = await http.put(
        Uri.parse('$baseUrlValue/instituciones/$id'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode({
          if (nombre != null) 'nombre': nombre,
          if (direccion != null) 'direccion': direccion,
          if (telefono != null) 'telefono': telefono,
          if (email != null) 'email': email,
          if (activa != null) 'activa': activa,
        }),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PUT /instituciones/$id - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Institution.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error updating institution: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error updating institution: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<bool> deleteInstitution(String accessToken, String id) async {
    try {
      final baseUrlValue = await baseUrl;
      final response = await http.delete(
        Uri.parse('$baseUrlValue/instituciones/$id'),
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('DELETE /instituciones/$id - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      } else {
        debugPrint('Error deleting institution: ${response.statusCode} - ${response.body}');
        return false;
      }
    } catch (e, stackTrace) {
      debugPrint('Error deleting institution: $e');
      debugPrint('StackTrace: $stackTrace');
      return false;
    }
  }
}
/* Fin lib\services\institution_service.dart */

/* Inicio lib\services\profesor_service.dart */
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';
import '../models/user.dart';
import '../utils/app_constants.dart';

class PaginatedUserResponse {
  final List<User> users;
  final PaginationInfo pagination;

  PaginatedUserResponse({
    required this.users,
    required this.pagination,
  });
}

class ProfesorService {
  static Future<String> _getLocalIp() async {
    try {
      if (kIsWeb) {
        return 'localhost';
      }
      return '192.168.20.22'
    } catch (e) {
      debugPrint('Error obteniendo IP local: $e');
      return 'localhost';
    }
  }

  static Future<String> get baseUrl async {
    final ip = await _getLocalIp();
    return 'http://$ip:3000';
  }
  Future<PaginatedUserResponse?> getAllProfesores(String accessToken, {int? page, int? limit, String? search, bool? activo}) async {
    try {
      final baseUrlValue = await baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      if (limit != null) queryParams['limit'] = limit.toString();
      if (search != null && search.isNotEmpty) queryParams['search'] = search;
      if (activo != null) queryParams['activo'] = activo.toString();

      final uri = Uri.parse('$baseUrlValue/institution-admin/profesores').replace(queryParameters: queryParams.isNotEmpty ? queryParams : null);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /institution-admin/profesores - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final profesores = (responseData['data'] as List)
              .map((userJson) => User.fromJson(userJson))
              .toList();
          final pagination = responseData['pagination'] != null
              ? PaginationInfo.fromJson(responseData['pagination'])
              : PaginationInfo(
                  page: page ?? 1,
                  limit: limit ?? AppConstants.itemsPerPage,
                  total: profesores.length,
                  totalPages: 1,
                  hasNext: false,
                  hasPrev: false,
                );

          return PaginatedUserResponse(users: profesores, pagination: pagination);
        }
      } else {
        debugPrint('Error getting profesores: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting profesores: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<User?> getProfesorById(String accessToken, String profesorId) async {
    try {
      final baseUrlValue = await baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/institution-admin/profesores/$profesorId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /institution-admin/profesores/$profesorId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return User.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error getting profesor: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting profesor: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<User?> createProfesor(String accessToken, CreateUserRequest profesorData) async {
    try {
      final baseUrlValue = await baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/institution-admin/profesores'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode({
          'nombres': profesorData.nombres,
          'apellidos': profesorData.apellidos,
          'email': profesorData.email,
          'password': profesorData.password,
          'telefono': profesorData.telefono,
          'grupoId': profesorData.rolEnInstitucion, // Puede ser usado como grupoId
        }),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('POST /institution-admin/profesores - Status: ${response.statusCode}');

      if (response.statusCode == 201) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return User.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error creating profesor: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error creating profesor: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<User?> updateProfesor(String accessToken, String profesorId, UpdateUserRequest profesorData) async {
    try {
      final baseUrlValue = await baseUrl;
      final Map<String, dynamic> updateData = {};
      if (profesorData.nombres != null) updateData['nombres'] = profesorData.nombres;
      if (profesorData.apellidos != null) updateData['apellidos'] = profesorData.apellidos;
      if (profesorData.email != null) updateData['email'] = profesorData.email;
      if (profesorData.telefono != null) updateData['telefono'] = profesorData.telefono;
      if (profesorData.activo != null) updateData['activo'] = profesorData.activo;

      final response = await http.put(
        Uri.parse('$baseUrlValue/institution-admin/profesores/$profesorId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(updateData),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PUT /institution-admin/profesores/$profesorId - Status: ${response.statusCode}');
      debugPrint('Update data sent: $updateData');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return User.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error updating profesor: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error updating profesor: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<bool> deleteProfesor(String accessToken, String profesorId) async {
    try {
      final baseUrlValue = await baseUrl;
      final response = await http.delete(
        Uri.parse('$baseUrlValue/institution-admin/profesores/$profesorId'),
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('DELETE /institution-admin/profesores/$profesorId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      } else {
        debugPrint('Error deleting profesor: ${response.statusCode} - ${response.body}');
        return false;
      }
    } catch (e, stackTrace) {
      debugPrint('Error deleting profesor: $e');
      debugPrint('StackTrace: $stackTrace');
      return false;
    }
  }
  Future<User?> toggleProfesorStatus(String accessToken, String profesorId) async {
    try {
      final baseUrlValue = await baseUrl;
      final response = await http.patch(
        Uri.parse('$baseUrlValue/institution-admin/profesores/$profesorId/toggle-status'),
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PATCH /institution-admin/profesores/$profesorId/toggle-status - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return User.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error toggling profesor status: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error toggling profesor status: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
}
/* Fin lib\services\profesor_service.dart */

/* Inicio lib\services\user_service.dart */
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';
import '../models/user.dart';

class PaginatedUserResponse {
  final List<User> users;
  final PaginationInfo pagination;

  PaginatedUserResponse({
    required this.users,
    required this.pagination,
  });
}

class UserService {
  static Future<String> _getLocalIp() async {
    try {
      if (kIsWeb) {
        return 'localhost';
      }
      return '192.168.20.22'
    } catch (e) {
      debugPrint('Error obteniendo IP local: $e');
      return 'localhost';
    }
  }

  static Future<String> get baseUrl async {
    final ip = await _getLocalIp();
    return 'http://$ip:3000';
  }
  Future<PaginatedUserResponse?> getAllUsers(String accessToken, {int? page, int? limit, bool? activo, String? search, List<String>? roles}) async {
    try {
      final baseUrlValue = await baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      if (limit != null) queryParams['limit'] = limit.toString();
      if (activo != null) queryParams['activo'] = activo.toString();
      if (search != null && search.isNotEmpty) queryParams['search'] = search;
      if (roles != null && roles.isNotEmpty) queryParams['rol'] = roles.join(',');

  final uri = Uri.parse('$baseUrlValue/usuarios').replace(queryParameters: queryParams);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /usuarios - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final users = (responseData['data'] as List)
              .map((userJson) => User.fromJson(userJson))
              .toList();
          final pagination = PaginationInfo.fromJson(responseData['pagination']);
          return PaginatedUserResponse(users: users, pagination: pagination);
        }
      } else {
        debugPrint('Error getting users: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting users: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<User?> getUserById(String accessToken, String userId) async {
    try {
      final baseUrlValue = await baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/usuarios/$userId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /usuarios/$userId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return User.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error getting user: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting user: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<PaginatedUserResponse?> getUsersByRole(String accessToken, String role, {int? page, int? limit}) async {
    debugPrint('WARNING: getUsersByRole using institution route as fallback');
    debugPrint('getUsersByRole: Route /usuarios/rol/$role not implemented, returning null');
    return null;
  }
  Future<PaginatedUserResponse?> getUsersByInstitution(String accessToken, String institutionId, {int? page, int limit = 5, String? role, bool? activo, String? search}) async {
    try {
      final baseUrlValue = await baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      queryParams['limit'] = limit.toString();
      if (role != null && role.isNotEmpty) queryParams['rol'] = role;
      if (activo != null) queryParams['activo'] = activo.toString();
      if (search != null && search.isNotEmpty) queryParams['search'] = search;

      final uri = Uri.parse('$baseUrlValue/usuarios/institucion/$institutionId').replace(queryParameters: queryParams);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /usuarios/institucion/$institutionId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final users = (responseData['data'] as List)
              .map((userJson) => User.fromJson(userJson))
              .toList();
          final pagination = PaginationInfo.fromJson(responseData['pagination']);
          return PaginatedUserResponse(users: users, pagination: pagination);
        }
      } else {
        debugPrint('Error getting users by institution: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting users by institution: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<List<User>?> getAdminsByInstitution(String accessToken, String institutionId) async {
    try {
      final baseUrlValue = await baseUrl;
      final uri = Uri.parse('$baseUrlValue/instituciones/$institutionId/admins');

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(const Duration(seconds: 10));

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final list = (responseData['data'] as List)
              .map((item) {
                if (item is Map && item.containsKey('usuario')) {
                  return User.fromJson(item['usuario']);
                }
                if (item is Map && item.containsKey('email')) {
                  final usuarioJson = {
                    'id': item['usuarioId'] ?? item['id'],
                    'email': item['email'],
                    'nombres': item['nombres'],
                    'apellidos': item['apellidos'],
                    'rol': 'admin_institucion',
                    'telefono': item['telefono'],
                    'activo': item['activo'] ?? true,
                    'usuarioInstituciones': [
                      {
                        'institucion': {
                          'id': item['institucionId'],
                          'nombre': '',
                        },
                        'rolEnInstitucion': item['rolEnInstitucion'],
                        'activo': item['activo'] ?? true,
                      }
                    ],
                  };
                  return User.fromJson(usuarioJson);
                }
                return null;
              })
              .whereType<User>()
              .toList();

          return list;
        }
      }
      return null;
    } catch (e, st) {
      debugPrint('Error getting admins by institution: $e');
      debugPrint('StackTrace: $st');
      return null;
    }
  }
  Future<User?> assignAdminToInstitution(String accessToken, String institutionId, String userId) async {
    try {
      final baseUrlValue = await baseUrl;
      final uri = Uri.parse('$baseUrlValue/instituciones/$institutionId/admins');

      final response = await http.post(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode({'userId': userId}),
      ).timeout(const Duration(seconds: 10));

      if (response.statusCode == 201 || response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final data = responseData['data'];
          if (data is Map && data['id'] != null) {
            return User.fromJson(data as Map<String, dynamic>);
          }
        }
      }
      return null;
    } catch (e, st) {
      debugPrint('Error assigning admin to institution: $e');
      debugPrint('StackTrace: $st');
      return null;
    }
  }
  Future<bool?> removeAdminFromInstitution(String accessToken, String institutionId, String userId) async {
    try {
      final baseUrlValue = await baseUrl;
      final uri = Uri.parse('$baseUrlValue/instituciones/$institutionId/admins/$userId');

      final response = await http.delete(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(const Duration(seconds: 10));

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      }
      return null;
    } catch (e, st) {
      debugPrint('Error removing admin from institution: $e');
      debugPrint('StackTrace: $st');
      return null;
    }
  }
  Future<User?> createUser(String accessToken, CreateUserRequest userData) async {
    try {
      final baseUrlValue = await baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/usuarios'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(userData.toJson()),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('POST /usuarios - Status: ${response.statusCode}');

      if (response.statusCode == 201) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return User.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error creating user: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error creating user: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<User?> updateUser(String accessToken, String userId, UpdateUserRequest userData) async {
    try {
      final baseUrlValue = await baseUrl;
      final response = await http.put(
        Uri.parse('$baseUrlValue/usuarios/$userId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(userData.toJson()),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PUT /usuarios/$userId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return User.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error updating user: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error updating user: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<bool> deleteUser(String accessToken, String userId) async {
    try {
      final baseUrlValue = await baseUrl;
      final response = await http.delete(
        Uri.parse('$baseUrlValue/usuarios/$userId'),
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('DELETE /usuarios/$userId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      } else {
        debugPrint('Error deleting user: ${response.statusCode} - ${response.body}');
        return false;
      }
    } catch (e, stackTrace) {
      debugPrint('Error deleting user: $e');
      debugPrint('StackTrace: $stackTrace');
      return false;
    }
  }
}
/* Fin lib\services\user_service.dart */

/* Inicio lib\theme\app_colors.dart */
import 'package:flutter/material.dart';
class AppColors {

  AppColors._();

  static final AppColors instance = AppColors._();

  static const Color _primaryBase = Color(0xFF2563EB)
  static const Color _secondaryBase = Color(0xFF38BDF8)
  static const Color _surfaceBase = Color(0xFFFFFFFF)
  static const Color _backgroundBase = Color(0xFFF9FAFB)

  final Color primary = _primaryBase;
  final Color primaryDark = const Color(0xFF1E40AF)
  final Color primaryLight = const Color(0xFF60A5FA)
  final Color primaryContainer = const Color(0xFFE0F2FE)

  final Color secondary = _secondaryBase;
  final Color secondaryLight = const Color(0xFF7DD3FC)
  final Color secondaryContainer = const Color(0xFFE0F7FA)
  final Color success = const Color(0xFF16A34A)
  final Color warning = const Color(0xFFFACC15)
  final Color error = const Color(0xFFDC2626)
  final Color info = const Color(0xFF3B82F6)
  final Color featureUsers = const Color(0xFF6366F1)
  final Color featureInstitutions = const Color(0xFF0EA5E9)
  final Color featureAttendance = const Color(0xFFF59E0B)
  final Color featureReports = const Color(0xFFE11D48)
  final Color featureSchedule = const Color(0xFF14B8A6)
  final Color featureSettings = const Color(0xFF475569)
  final Color featureNotifications = const Color(0xFFF97316)
  final Color featureClasses = const Color(0xFFEF4444)
  final Color featureGrades = const Color(0xFF84CC16)
  final Color featureStudents = const Color(0xFF2563EB)
  final Color stateNoData = const Color(0xFF94A3B8)
  final Color stateInDevelopment = const Color(0xFF6366F1)
  final Color stateSuccess = const Color(0xFF22C55E)
  final Color stateInactive = const Color(0xFFE2E8F0)

  final Color surface = _surfaceBase;
  final Color surfaceLight = const Color(0xFFF9FAFB)
  final Color surfaceContainer = const Color(0xFFFFFFFF)
  final Color background = _backgroundBase;
  final Color backgroundLight = const Color(0xFFFFFFFF)
  final Color textPrimary = const Color(0xFF0F172A)
  final Color textSecondary = const Color(0xFF334155)
  final Color textMuted = const Color(0xFF64748B)
  final Color textDisabled = const Color(0xFF94A3B8)
  final Color textOnDark = const Color(0xFFF8FAFC);
  final Color textOnDarkSecondary = const Color(0xFFE2E8F0);
  final Color textOnDarkMuted = const Color(0xFFCBD5E1);
  final Color border = const Color(0xFFE2E8F0);
  final Color borderLight = const Color(0xFFF1F5F9);
  final Color divider = const Color(0xFFE2E8F0);
  final Color shadow = const Color(0x0A000000);

  final Color transparent = const Color(0x00000000);
  final Color shadowLight = const Color(0x05000000);
  final Color scrim = const Color(0x0F000000);

  final Color white = const Color(0xFFFFFFFF);
  final Color black = const Color(0xFF000000);
  final Color grey = const Color(0xFF94A3B8);
  final Color greyDark = const Color(0xFF475569);
  final Color greyLight = const Color(0xFFE2E8F0);
  Color get primaryWithOpacity => primary.withValues(alpha: 0.9);
  Color get surfaceWithOpacity => surface.withValues(alpha: 0.95);
  Color get textSecondaryWithOpacity => textSecondary.withValues(alpha: 0.8);
  Color get warningBackground => warning.withValues(alpha: 0.08);
  Color get warningBorder => warning.withValues(alpha: 0.2);
  Color get infoBackground => info.withValues(alpha: 0.08);
  Color get infoBorder => info.withValues(alpha: 0.2);
  Color get errorBackground => error.withValues(alpha: 0.08);
  Color get errorBorder => error.withValues(alpha: 0.2);
  Color get successBackground => success.withValues(alpha: 0.08);
  Color get successBorder => success.withValues(alpha: 0.2);
  Color get roleBadgeBackground => white.withValues(alpha: 0.15);
  Color get roleBadgeText => white;
  Color get roleBadgeIcon => white;
  Color getTextColorForBackground(Color backgroundColor) {
    final luminance = backgroundColor.computeLuminance();
    return luminance > 0.5 ? textPrimary : textOnDark;
  }

  Color getSecondaryTextColorForBackground(Color backgroundColor) {
    final luminance = backgroundColor.computeLuminance();
    return luminance > 0.5 ? textSecondary : textOnDarkSecondary;
  }

  Color getMutedTextColorForBackground(Color backgroundColor) {
    final luminance = backgroundColor.computeLuminance();
    return luminance > 0.5 ? textMuted : textOnDarkMuted;
  }
}

/* Fin lib\theme\app_colors.dart */

/* Inicio lib\theme\app_constants.dart */

class AppConstants {

  AppConstants._();

  static final AppConstants instance = AppConstants._();
  final double mobileSmall = 480;
  final double mobileLarge = 768;
  final double tablet = 1024;
  final double desktop = 1440;
  final double maxWidthMobile = 480;
  final double maxWidthTablet = 768;
  final double maxWidthDesktop = 1024;
  final double maxWidthLargeDesktop = 1400;

  final double logoSize = 80;
  final double spinnerSize = 20;
  final double buttonBorderRadius = 8;
  final double cardBorderRadius = 8;
  final double logoBorderRadius = 20;
  final double errorLoggerWidthCollapsed = 60;
  final double errorLoggerHeightCollapsed = 60;
  final double errorLoggerWidthExpanded = 300;
  final double errorLoggerHeightExpanded = 200;

  final double defaultFontSize = 14;
  final double logoFontSize = 48;
  final double shadowBlurRadius = 8;
  final double shadowOffsetY = 2;
  final double errorLoggerShadowBlur = 8;
  final double errorLoggerShadowOffsetY = 4;
  final double borderWidthThin = 0.5;
  final double borderWidthNormal = 1;
  final double borderWidthThick = 1.5;

  final double shadowOpacity = 0.1
  final double surfaceTintOpacity = 0.1;
  double getMaxWidth(double screenWidth) {
    if (screenWidth <= mobileSmall) return maxWidthMobile;
    if (screenWidth <= mobileLarge) return maxWidthTablet;
    if (screenWidth <= tablet) return maxWidthDesktop;
    return maxWidthLargeDesktop;
  }
  ScreenType getScreenType(double width) {
    if (width <= mobileSmall) return ScreenType.mobileSmall;
    if (width <= mobileLarge) return ScreenType.mobileLarge;
    if (width <= tablet) return ScreenType.tablet;
    if (width <= desktop) return ScreenType.desktop;
    return ScreenType.largeDesktop;
  }
}

enum ScreenType {
  mobileSmall,    // <= 480px
  mobileLarge,    // 481-768px
  tablet,         // 769-1024px
  desktop,        // 1025-1440px
  largeDesktop,   // > 1440px
}
/* Fin lib\theme\app_constants.dart */

/* Inicio lib\theme\app_spacing.dart */

class AppSpacing {
  AppSpacing._();
  static final AppSpacing instance = AppSpacing._();
  static const double _baseUnit = 4;
  final double xs = _baseUnit
  final double sm = _baseUnit * 2
  final double md = _baseUnit * 4
  final double lg = _baseUnit * 6
  final double xl = _baseUnit * 8
  final double xxl = _baseUnit * 12
  final double xxxl = _baseUnit * 16
  final double buttonPadding = _baseUnit * 4
  final double cardPadding = _baseUnit * 3
  final double screenPadding = _baseUnit * 4
  final double inputPadding = _baseUnit * 3
  final double iconSize = _baseUnit * 6
  final double borderRadius = _baseUnit * 2
  final double borderRadiusLarge = _baseUnit * 3
  final double appBarHeight = _baseUnit * 14
  final double borderWidth = 1
  double multiply(double factor) => _baseUnit * factor;
  double add(double value) => _baseUnit + value;
}
/* Fin lib\theme\app_spacing.dart */

/* Inicio lib\theme\app_text_styles.dart */
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'app_colors.dart';
class AppTextStyles {

  AppTextStyles._();

  static final AppTextStyles instance = AppTextStyles._();

  TextStyle _createStyle({
    required double fontSize,
    required FontWeight fontWeight,
    required double height,
    required double letterSpacing,
    Color? color,
    TextDecoration? decoration,
  }) {
    return GoogleFonts.inter(
      fontSize: fontSize,
      fontWeight: fontWeight,
      height: height,
      letterSpacing: letterSpacing,
      color: color ?? AppColors.instance.textPrimary,
      decoration: decoration,
    );
  }

  TextStyle get displayLarge => _createStyle(
    fontSize: 32,
    fontWeight: FontWeight.bold,
    height: 1.2,
    letterSpacing: 0.4,
  );

  TextStyle get displayMedium => _createStyle(
    fontSize: 28,
    fontWeight: FontWeight.bold,
    height: 1.25,
    letterSpacing: 0.36,
  );

  TextStyle get headlineLarge => _createStyle(
    fontSize: 24,
    fontWeight: FontWeight.w600,
    height: 1.3,
    letterSpacing: 0.35,
  );

  TextStyle get headlineMedium => _createStyle(
    fontSize: 20,
    fontWeight: FontWeight.w600,
    height: 1.4,
    letterSpacing: 0.25,
  );

  TextStyle get titleLarge => _createStyle(
    fontSize: 17,
    fontWeight: FontWeight.w600,
    height: 1.4,
    letterSpacing: -0.41,
  );

  TextStyle get titleMedium => _createStyle(
    fontSize: 15,
    fontWeight: FontWeight.w500,
    height: 1.5,
    letterSpacing: -0.24,
  );

  TextStyle get bodyLarge => _createStyle(
    fontSize: 16,
    fontWeight: FontWeight.normal,
    height: 1.47,
    letterSpacing: -0.41,
    color: AppColors.instance.textPrimary,
  );

  TextStyle get bodyMedium => _createStyle(
    fontSize: 15,
    fontWeight: FontWeight.normal,
    height: 1.47,
    letterSpacing: -0.24,
    color: AppColors.instance.textPrimary,
  );

  TextStyle get bodySmall => _createStyle(
    fontSize: 13,
    fontWeight: FontWeight.normal,
    height: 1.38,
    letterSpacing: -0.08,
    color: AppColors.instance.textMuted,
  );

  TextStyle get labelLarge => _createStyle(
    fontSize: 16,
    fontWeight: FontWeight.w600,
    height: 1.43,
    letterSpacing: -0.5,
     color: AppColors.instance.textSecondary,
  );

  TextStyle get labelMedium => _createStyle(
    fontSize: 14,
    fontWeight: FontWeight.w500,
    height: 1.38,
    letterSpacing: -0.08,
    color: AppColors.instance.textSecondary,
  );

  TextStyle get labelSmall => _createStyle(
    fontSize: 11,
    fontWeight: FontWeight.w500,
    height: 1.36,
    letterSpacing: 0.06,
    color: AppColors.instance.textMuted,
  );

  TextStyle get button => labelLarge.copyWith(
    color: null, // Usar foregroundColor del botÃ³n
  );

  TextStyle get caption => bodySmall.copyWith(
    fontSize: 12,
  );

  TextStyle get overline => labelSmall.copyWith(
    fontSize: 10,
    letterSpacing: 1.5,
    fontWeight: FontWeight.w500,
  );

  TextStyle withColor(Color color) => _createStyle(
    fontSize: 15, // default
    fontWeight: FontWeight.normal,
    height: 1.4,
    letterSpacing: 0,
    color: color,
  );

  TextStyle withWeight(FontWeight weight) => _createStyle(
    fontSize: 15, // default
    fontWeight: weight,
    height: 1.4,
    letterSpacing: 0,
  );

  TextStyle withSize(double size) => _createStyle(
    fontSize: size,
    fontWeight: FontWeight.normal,
    height: 1.4,
    letterSpacing: 0,
  );
}
/* Fin lib\theme\app_text_styles.dart */

/* Inicio lib\theme\app_theme.dart */
import 'package:flutter/material.dart';
import 'app_colors.dart';
import 'app_spacing.dart';
import 'app_text_styles.dart';
class AppTheme {

  AppTheme._();

  static final AppTheme instance = AppTheme._();
  static ThemeData get light => _createTheme(Brightness.light);
  static ThemeData get dark => _createTheme(Brightness.dark);
  static ThemeData get defaultTheme => dark;

  static ThemeData _createTheme(Brightness brightness) {
    final colors = AppColors.instance;
    final textStyles = AppTextStyles.instance;

    return ThemeData(
      brightness: brightness,
      useMaterial3: true,

      colorScheme: ColorScheme(
        brightness: brightness,
        primary: colors.primary,
        onPrimary: colors.white, // Texto blanco sobre primary oscuro
        primaryContainer: colors.primaryContainer,
        onPrimaryContainer: colors.textPrimary,
        secondary: colors.secondary,
        onSecondary: colors.white, // Texto blanco sobre secondary
        secondaryContainer: colors.secondaryContainer,
        onSecondaryContainer: colors.textSecondary,
        tertiary: colors.info,
        onTertiary: colors.white, // Texto blanco sobre info
        error: colors.error,
        onError: colors.white, // Texto blanco sobre error
        surface: colors.surface,
        onSurface: colors.textPrimary,
        surfaceContainerHighest: colors.surfaceLight,
        onSurfaceVariant: colors.textMuted,
        outline: colors.border,
        outlineVariant: colors.borderLight,
        shadow: colors.shadow,
        scrim: colors.scrim,
        inverseSurface: colors.primary,
        onInverseSurface: colors.white,
        inversePrimary: colors.primaryLight,
        surfaceTint: colors.primary.withValues(alpha: 0.05),
      ),

      textTheme: TextTheme(
        displayLarge: textStyles.displayLarge,
        displayMedium: textStyles.displayMedium,
        headlineLarge: textStyles.headlineLarge,
        headlineMedium: textStyles.headlineMedium,
        titleLarge: textStyles.titleLarge,
        titleMedium: textStyles.titleMedium,
        bodyLarge: textStyles.bodyLarge,
        bodyMedium: textStyles.bodyMedium,
        bodySmall: textStyles.bodySmall,
        labelLarge: textStyles.labelLarge,
        labelMedium: textStyles.labelMedium,
        labelSmall: textStyles.labelSmall,
      ),

      appBarTheme: AppBarTheme(
        backgroundColor: colors.primary,
        foregroundColor: colors.white, // Texto blanco en AppBar oscuro
        elevation: 0,
        shadowColor: Colors.transparent,
        surfaceTintColor: Colors.transparent,
        titleTextStyle: textStyles.headlineMedium.copyWith(
          color: colors.white, // Asegurar texto blanco
          fontWeight: FontWeight.bold,
        ),
        iconTheme: IconThemeData(color: colors.white), // Iconos blancos
        actionsIconTheme: IconThemeData(color: colors.white), // Iconos de acciones blancos
        toolbarHeight: AppSpacing.instance.appBarHeight,
        centerTitle: true,
      ),

      cardTheme: CardTheme(
        color: colors.white,
        shadowColor: colors.shadowLight,
        elevation: 1, // ElevaciÃ³n sutil
        margin: EdgeInsets.zero,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          side: BorderSide(color: colors.border, width: 0.5),
        ),
      ),

      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: colors.primary,
          foregroundColor: colors.white,
          elevation: 1, // ElevaciÃ³n sutil
          padding: EdgeInsets.symmetric(
            horizontal: AppSpacing.instance.buttonPadding,
            vertical: AppSpacing.instance.md,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          ),
          textStyle: textStyles.button,
        ),
      ),

      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          foregroundColor: colors.primary,
          side: BorderSide(color: colors.border, width: AppSpacing.instance.borderWidth),
          elevation: 0,
          padding: EdgeInsets.symmetric(
            horizontal: AppSpacing.instance.buttonPadding,
            vertical: AppSpacing.instance.md,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          ),
          textStyle: textStyles.button, // Usar estilo sin color fijo
        ),
      ),

      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: colors.primary,
          padding: EdgeInsets.symmetric(
            horizontal: AppSpacing.instance.sm,
            vertical: AppSpacing.instance.xs,
          ),
          textStyle: textStyles.button, // Usar estilo sin color fijo
        ),
      ),

      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: colors.white,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          borderSide: BorderSide(color: colors.border, width: AppSpacing.instance.borderWidth),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          borderSide: BorderSide(color: colors.border, width: AppSpacing.instance.borderWidth),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          borderSide: BorderSide(color: colors.primaryLight, width: 1.5),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          borderSide: BorderSide(color: colors.error, width: AppSpacing.instance.borderWidth),
        ),
        contentPadding: EdgeInsets.all(AppSpacing.instance.inputPadding),
        labelStyle: textStyles.bodyMedium.copyWith(color: colors.textMuted),
        hintStyle: textStyles.bodyMedium.copyWith(color: colors.textMuted),
        errorStyle: textStyles.bodySmall.copyWith(color: colors.error),
      ),

      dialogTheme: DialogTheme(
        backgroundColor: colors.white,
        elevation: 6, // ElevaciÃ³n media para diÃ¡logos
        shadowColor: colors.shadowLight,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
        ),
      ),

      floatingActionButtonTheme: FloatingActionButtonThemeData(
        backgroundColor: colors.primary,
        foregroundColor: colors.white,
        elevation: 2, // ElevaciÃ³n sutil
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadiusLarge),
        ),
      ),

      chipTheme: ChipThemeData(
        backgroundColor: colors.surfaceLight,
        deleteIconColor: colors.textMuted,
        disabledColor: colors.stateInactive,
        selectedColor: colors.primary,
        secondarySelectedColor: colors.secondary,
        padding: EdgeInsets.symmetric(
          horizontal: AppSpacing.instance.sm,
          vertical: AppSpacing.instance.xs,
        ),
        labelStyle: textStyles.bodyMedium.copyWith(color: colors.textPrimary),
        secondaryLabelStyle: textStyles.bodyMedium.copyWith(color: colors.white),
        brightness: brightness,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          side: BorderSide(color: colors.border),
        ),
      ),

      scaffoldBackgroundColor: colors.background,
      dividerColor: colors.divider,
      shadowColor: colors.shadow,

      typography: Typography.material2021(),
    );
  }
}

/* Fin lib\theme\app_theme.dart */

/* Inicio lib\theme\index.dart */
export 'app_theme.dart';
export 'app_colors.dart';
export 'app_spacing.dart';
export 'app_text_styles.dart';
export 'theme_extensions.dart';
/* Fin lib\theme\index.dart */

/* Inicio lib\theme\theme_extensions.dart */
import 'package:flutter/material.dart';
import 'app_colors.dart';
import 'app_spacing.dart';
import 'app_text_styles.dart';
extension ThemeExtensions on BuildContext {
  AppColors get colors => AppColors.instance;
  AppTextStyles get textStyles => AppTextStyles.instance;
  AppSpacing get spacing => AppSpacing.instance;
  ThemeData get theme => Theme.of(this);
  TextTheme get textTheme => theme.textTheme;
  ColorScheme get colorScheme => theme.colorScheme;
}
extension TextStyleExtensions on TextStyle {
  TextStyle get bold => copyWith(fontWeight: FontWeight.bold);
  TextStyle get semiBold => copyWith(fontWeight: FontWeight.w600);
  TextStyle get medium => copyWith(fontWeight: FontWeight.w500);
  TextStyle get regular => copyWith(fontWeight: FontWeight.normal);
  TextStyle get light => copyWith(fontWeight: FontWeight.w300);

  TextStyle withColor(Color color) => copyWith(color: color);
  TextStyle withSize(double size) => copyWith(fontSize: size);
  TextStyle withWeight(FontWeight weight) => copyWith(fontWeight: weight);
  TextStyle get underlined => copyWith(decoration: TextDecoration.underline);
  TextStyle get lineThrough => copyWith(decoration: TextDecoration.lineThrough);
}
extension EdgeInsetsExtensions on EdgeInsets {
  static EdgeInsets get xs => EdgeInsets.all(AppSpacing.instance.xs);
  static EdgeInsets get sm => EdgeInsets.all(AppSpacing.instance.sm);
  static EdgeInsets get md => EdgeInsets.all(AppSpacing.instance.md);
  static EdgeInsets get lg => EdgeInsets.all(AppSpacing.instance.lg);
  static EdgeInsets get xl => EdgeInsets.all(AppSpacing.instance.xl);

  static EdgeInsets horizontal(double value) => EdgeInsets.symmetric(horizontal: value);
  static EdgeInsets vertical(double value) => EdgeInsets.symmetric(vertical: value);

  static EdgeInsets get cardPadding => EdgeInsets.all(AppSpacing.instance.cardPadding);
  static EdgeInsets get screenPadding => EdgeInsets.all(AppSpacing.instance.screenPadding);
  static EdgeInsets get buttonPadding => EdgeInsets.symmetric(
    horizontal: AppSpacing.instance.buttonPadding,
    vertical: AppSpacing.instance.sm,
  );
}
/* Fin lib\theme\theme_extensions.dart */

/* Inicio lib\ui\widgets\app_button.dart */
import 'package:flutter/widgets.dart';
import '../../theme/theme_extensions.dart';
import '../../theme/app_colors.dart';
import '../../theme/app_constants.dart';
class AppButton extends StatefulWidget {
  final String label;
  final VoidCallback onPressed;
  final bool isLoading;
  final bool isEnabled;
  final double? width;
  final EdgeInsets? padding;

  const AppButton({
    required this.label,
    required this.onPressed,
    this.isLoading = false,
    this.isEnabled = true,
    this.width,
    this.padding,
    super.key,
  });

  @override
  State<AppButton> createState() => _AppButtonState();
}

class _AppButtonState extends State<AppButton> {
  bool _isPressed = false;

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    final buttonChild = Container(
      constraints: widget.width != null
          ? BoxConstraints(minWidth: widget.width!)
          : const BoxConstraints(minWidth: 0),
      padding: widget.padding ??
          EdgeInsets.symmetric(
            horizontal: spacing.md,
            vertical: spacing.md,
          ),
      decoration: BoxDecoration(
        color: widget.isEnabled
            ? (_isPressed ? colors.primaryDark : colors.primary)
            : colors.grey,
        borderRadius: BorderRadius.circular(AppConstants.instance.buttonBorderRadius),
      ),
      child: Center(
        child: widget.isLoading
            ? SizedBox(
                width: AppConstants.instance.spinnerSize,
                height: AppConstants.instance.spinnerSize,
                child: _buildLoadingSpinner(context),
              )
            : Text(
                widget.label,
                style: textStyles.labelLarge.copyWith(
                  color: colors.white, // Texto blanco sobre fondo primario
                ),
              ),
      ),
    );

    return GestureDetector(
      onTapDown: widget.isEnabled && !widget.isLoading
          ? (_) => setState(() => _isPressed = true)
          : null,
      onTapUp: widget.isEnabled && !widget.isLoading
          ? (_) {
              setState(() => _isPressed = false);
              widget.onPressed();
            }
          : null,
      onTapCancel: widget.isEnabled && !widget.isLoading
          ? () => setState(() => _isPressed = false)
          : null,
      child: buttonChild,
    );
  }

  Widget _buildLoadingSpinner(BuildContext context) {
    final colors = context.colors;

    return Center(
      child: SizedBox(
        width: AppConstants.instance.spinnerSize,
        height: AppConstants.instance.spinnerSize,
        child: CustomPaint(
          painter: _SpinnerPainter(colors: colors),
        ),
      ),
    );
  }
}
class AppSecondaryButton extends StatefulWidget {
  final String label;
  final VoidCallback onPressed;
  final bool isEnabled;
  final double? width;

  const AppSecondaryButton({
    required this.label,
    required this.onPressed,
    this.isEnabled = true,
    this.width,
    super.key,
  });

  @override
  State<AppSecondaryButton> createState() => _AppSecondaryButtonState();
}

class _AppSecondaryButtonState extends State<AppSecondaryButton> {
  bool _isPressed = false;

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    final buttonChild = Container(
      constraints: widget.width != null
          ? BoxConstraints(minWidth: widget.width!)
          : const BoxConstraints(minWidth: 0),
      padding: EdgeInsets.symmetric(
        horizontal: spacing.md,
        vertical: spacing.md,
      ),
      decoration: BoxDecoration(
        border: Border.all(
          color: widget.isEnabled ? colors.primary : colors.grey,
          width: AppConstants.instance.borderWidthNormal,
        ),
        borderRadius: BorderRadius.circular(AppConstants.instance.buttonBorderRadius),
        color: _isPressed && widget.isEnabled
            ? colors.surfaceLight
            : colors.transparent,
      ),
      child: Center(
        child: Text(
          widget.label,
          style: textStyles.labelLarge.copyWith(
            color: widget.isEnabled
                ? colors.primary // Texto primario sobre fondo transparente
                : colors.grey,
          ),
        ),
      ),
    );

    return GestureDetector(
      onTapDown: widget.isEnabled
          ? (_) => setState(() => _isPressed = true)
          : null,
      onTapUp: widget.isEnabled
          ? (_) {
              setState(() => _isPressed = false);
              widget.onPressed();
            }
          : null,
      onTapCancel: widget.isEnabled
          ? () => setState(() => _isPressed = false)
          : null,
      child: buttonChild,
    );
  }
}
class _SpinnerPainter extends CustomPainter {
  final AppColors colors;

  _SpinnerPainter({required this.colors});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = colors.white // Spinner blanco sobre fondo primario
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;

    final radius = size.width / 2;
    final center = Offset(size.width / 2, size.height / 2);
    canvas.drawCircle(center, radius, paint);
    final rect = Rect.fromCircle(center: center, radius: radius);
    canvas.drawArc(rect, 0, 1.5, false, paint);
  }

  @override
  bool shouldRepaint(_SpinnerPainter oldDelegate) => true;
}

/* Fin lib\ui\widgets\app_button.dart */

/* Inicio lib\ui\widgets\app_components.dart */
import 'package:flutter/material.dart';
import '../../theme/theme_extensions.dart';
class AppCard extends StatelessWidget {
  final Widget child;
  final EdgeInsets? padding;
  final VoidCallback? onTap;
  final Color? backgroundColor;
  final double? elevation;
  final BorderRadius? borderRadius;

  const AppCard({
    required this.child,
    this.padding,
    this.onTap,
    this.backgroundColor,
    this.elevation,
    this.borderRadius,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;

    return Card(
      color: backgroundColor ?? colors.surface,
      elevation: elevation ?? 2,
      shadowColor: colors.shadow,
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(
        borderRadius: borderRadius ?? BorderRadius.circular(spacing.borderRadius),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: borderRadius ?? BorderRadius.circular(spacing.borderRadius),
        child: Padding(
          padding: padding ?? EdgeInsets.all(spacing.cardPadding),
          child: child,
        ),
      ),
    );
  }
}
class AppScaffold extends StatelessWidget {
  final String? title;
  final Widget body;
  final Widget? floatingActionButton;
  final List<Widget>? actions;
  final bool showBackButton;
  final VoidCallback? onBackPressed;
  final PreferredSizeWidget? appBar;

  const AppScaffold({
    this.title,
    required this.body,
    this.floatingActionButton,
    this.actions,
    this.showBackButton = false,
    this.onBackPressed,
    this.appBar,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return Scaffold(
      backgroundColor: colors.background,
      appBar: appBar ?? (title != null ? AppBar(
        backgroundColor: colors.surface,
        foregroundColor: colors.textPrimary,
        elevation: 0,
        shadowColor: colors.shadow,
        surfaceTintColor: Colors.transparent,
        titleTextStyle: textStyles.headlineMedium,
        title: Text(title!),
        leading: showBackButton ? IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: onBackPressed ?? () => Navigator.maybePop(context),
        ) : null,
        actions: actions,
      ) : null),
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.all(spacing.screenPadding),
          child: body,
        ),
      ),
      floatingActionButton: floatingActionButton,
    );
  }
}
class AppText extends StatelessWidget {
  final String text;
  final TextStyle? style;
  final TextAlign? textAlign;
  final int? maxLines;
  final TextOverflow? overflow;
  final bool? softWrap;

  const AppText(
    this.text, {
    this.style,
    this.textAlign,
    this.maxLines,
    this.overflow,
    this.softWrap,
    super.key,
  });
  const AppText.headlineLarge(
    this.text, {
    this.textAlign,
    this.maxLines,
    this.overflow,
    this.softWrap,
    super.key,
  }) : style = null;

  const AppText.headlineMedium(
    this.text, {
    this.textAlign,
    this.maxLines,
    this.overflow,
    this.softWrap,
    super.key,
  }) : style = null;

  const AppText.bodyLarge(
    this.text, {
    this.textAlign,
    this.maxLines,
    this.overflow,
    this.softWrap,
    super.key,
  }) : style = null;

  const AppText.bodyMedium(
    this.text, {
    this.textAlign,
    this.maxLines,
    this.overflow,
    this.softWrap,
    super.key,
  }) : style = null;

  @override
  Widget build(BuildContext context) {
    final textStyles = context.textStyles;

    TextStyle resolvedStyle;
    if (style != null) {
      resolvedStyle = style!;
    } else {
      final constructorName = runtimeType.toString();
      if (constructorName.contains('headlineLarge')) {
        resolvedStyle = textStyles.headlineLarge;
      } else if (constructorName.contains('headlineMedium')) {
        resolvedStyle = textStyles.headlineMedium;
      } else if (constructorName.contains('bodyLarge')) {
        resolvedStyle = textStyles.bodyLarge;
      } else {
        resolvedStyle = textStyles.bodyMedium;
      }
    }

    return Text(
      text,
      style: resolvedStyle,
      textAlign: textAlign,
      maxLines: maxLines,
      overflow: overflow,
      softWrap: softWrap,
    );
  }
}
class AppSpacer extends StatelessWidget {
  final double? width;
  final double? height;

  const AppSpacer({this.width, this.height, super.key});
  const AppSpacer.xs({super.key}) : width = null, height = null;
  const AppSpacer.sm({super.key}) : width = null, height = null;
  const AppSpacer.md({super.key}) : width = null, height = null;
  const AppSpacer.lg({super.key}) : width = null, height = null;
  const AppSpacer.xl({super.key}) : width = null, height = null;

  @override
  Widget build(BuildContext context) {
    final spacing = context.spacing;

    double resolvedWidth = width ?? 0;
    double resolvedHeight = height ?? 0;
    if (width == null && height == null) {
      final constructorName = runtimeType.toString();
      if (constructorName.contains('xs')) {
        resolvedHeight = spacing.xs;
      } else if (constructorName.contains('sm')) {
        resolvedHeight = spacing.sm;
      } else if (constructorName.contains('md')) {
        resolvedHeight = spacing.md;
      } else if (constructorName.contains('lg')) {
        resolvedHeight = spacing.lg;
      } else if (constructorName.contains('xl')) {
        resolvedHeight = spacing.xl;
      }
    }

    return SizedBox(
      width: resolvedWidth,
      height: resolvedHeight,
    );
  }
}
/* Fin lib\ui\widgets\app_components.dart */

/* Inicio lib\ui\widgets\error_logger.dart */
import 'package:flutter/material.dart';
import '../../theme/theme_extensions.dart';
class ErrorLoggerWidget extends StatefulWidget {
  ErrorLoggerWidget() : super(key: errorLoggerKey);

  @override
  State<ErrorLoggerWidget> createState() => ErrorLoggerWidgetState();
}

class ErrorLoggerWidgetState extends State<ErrorLoggerWidget> {
  final List<String> _logs = [];
  bool _isExpanded = false;
  bool _isVisible = false;

  @override
  void initState() {
    super.initState();

  }

  void addLog(String message) {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        _addLog(message);
      }
    });
  }

  void _addLog(String message) {
    setState(() {
      final timestamp = DateTime.now().toString().substring(11, 19)
      _logs.add('[$timestamp] $message');
      if (_logs.length > 50) {
        _logs.removeAt(0)
      }
      _isVisible = true;
    });
  }

  void _clearLogs() {
    setState(() {
      _logs.clear();
      _isVisible = false;
    });
  }

  @override
  Widget build(BuildContext context) {
    if (!_isVisible) return const SizedBox.shrink();

    final colors = context.colors;

    return Positioned(
      bottom: 20,
      right: 20,
      child: Material(
        color: Colors.transparent,
        child: Container(
          width: _isExpanded ? 300 : 60,
          height: _isExpanded ? 200 : 60,
          decoration: BoxDecoration(
            color: colors.surface,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: colors.border),
            boxShadow: const [
              BoxShadow(
                color: Color.fromRGBO(0, 0, 0, 0.3),
                blurRadius: 8,
                offset: Offset(0, 4),
              ),
            ],
          ),
          child: _isExpanded ? _buildExpandedView(context) : _buildCollapsedView(context),
        ),
      ),
    );
  }

  Widget _buildCollapsedView(BuildContext context) {
    final colors = context.colors;
    final errorCount = _logs.where((log) => log.contains('ERROR')).length;

    return GestureDetector(
      onTap: () => setState(() => _isExpanded = true),
      child: Container(
        padding: const EdgeInsets.all(12),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              errorCount > 0 ? Icons.error : Icons.bug_report,
              color: errorCount > 0 ? colors.error : colors.warning,
              size: 24,
            ),
            if (errorCount > 0)
              Container(
                margin: const EdgeInsets.only(top: 4),
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                decoration: BoxDecoration(
                  color: colors.error,
                  borderRadius: BorderRadius.circular(10),
                ),
                child: Text(
                  errorCount.toString(),
                  style: TextStyle(
                    color: colors.getTextColorForBackground(colors.error),
                    fontSize: 10,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildExpandedView(BuildContext context) {
    final colors = context.colors;
    final textStyles = context.textStyles;

    return Column(
      children: [

        Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
          decoration: BoxDecoration(
            color: colors.surfaceLight,
            borderRadius: const BorderRadius.only(
              topLeft: Radius.circular(12),
              topRight: Radius.circular(12),
            ),
          ),
          child: Row(
            children: [
              Text(
                'Logs de Debug',
                style: textStyles.labelLarge,
              ),
              const Spacer(),
              GestureDetector(
                onTap: _clearLogs,
                child: const Padding(
                  padding: EdgeInsets.all(4),
                  child: Icon(Icons.clear_all, size: 16),
                ),
              ),
              GestureDetector(
                onTap: () => setState(() => _isExpanded = false),
                child: const Padding(
                  padding: EdgeInsets.all(4),
                  child: Icon(Icons.close, size: 16),
                ),
              ),
            ],
          ),
        ),

        Expanded(
          child: Container(
            padding: const EdgeInsets.all(8),
            child: _logs.isEmpty
                ? Center(
                    child: Text(
                      'No hay logs',
                      style: textStyles.bodySmall,
                    ),
                  )
                : ListView.builder(
                    itemCount: _logs.length,
                    itemBuilder: (context, index) {
                      final log = _logs[_logs.length - 1 - index]
                      final isError = log.contains('ERROR');
                      return Padding(
                        padding: const EdgeInsets.only(bottom: 4),
                        child: Text(
                          log,
                          style: TextStyle(
                            fontSize: 10,
                            color: isError ? colors.error : colors.textSecondary,
                            fontFamily: 'monospace',
                          ),
                        ),
                      );
                    },
                  ),
          ),
        ),
      ],
    );
  }
}
final GlobalKey<ErrorLoggerWidgetState> errorLoggerKey = GlobalKey<ErrorLoggerWidgetState>();

void addDebugLog(String message) {
  debugPrint(message);
  errorLoggerKey.currentState?.addLog(message);
}
/* Fin lib\ui\widgets\error_logger.dart */

/* Inicio lib\ui\widgets\index.dart */
export 'app_button.dart';
export 'app_components.dart';
export 'error_logger.dart';

/* Fin lib\ui\widgets\index.dart */

/* Inicio lib\utils\app_constants.dart */

class AppConstants {
  static const int itemsPerPage = 5;
  static const int httpTimeoutSeconds = 10;
  static const int maxRetries = 3;
}
/* Fin lib\utils\app_constants.dart */

/* Inicio lib\utils\app_router.dart */
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../screens/login_screen.dart';
import '../screens/institution_selection_screen.dart';
import '../screens/home_screen.dart';
import '../screens/super_admin_dashboard.dart';
import '../screens/admin_dashboard.dart';
import '../screens/teacher_dashboard.dart';
import '../screens/student_dashboard.dart';
import '../screens/users/users_list_screen.dart';
import '../screens/users/user_form_screen.dart';
import '../screens/users/user_detail_screen.dart';
import '../screens/institutions/institutions_list_screen.dart';
import '../screens/institutions/institution_admins_screen.dart';
import '../screens/app_shell.dart';
import '../models/user.dart';
final _dashboardNavigatorKey = GlobalKey<NavigatorState>(debugLabel: 'Dashboard');
final _institutionsNavigatorKey = GlobalKey<NavigatorState>(debugLabel: 'Institutions');
final _usersNavigatorKey = GlobalKey<NavigatorState>(debugLabel: 'Users');
class AppRouter {
  final AuthProvider authProvider;

  AppRouter({
    required this.authProvider,
  });

  late final GoRouter router = GoRouter(
    debugLogDiagnostics: true,
    refreshListenable: authProvider,
    initialLocation: _getStartRoute(),
    redirect: _checkAuth,
    routes: _allRoutes(),
    errorBuilder: _errorPage,
  );
  String _getStartRoute() {
    if (authProvider.isAuthenticated) {
      return '/dashboard';
    }
    return '/login';
  }
  String? _checkAuth(BuildContext context, GoRouterState state) {
    final isLoggedIn = authProvider.isAuthenticated;
    final currentRoute = state.matchedLocation;
    if (currentRoute == '/login') {
      if (isLoggedIn) {
        final institutions = authProvider.institutions;
        final selected = authProvider.selectedInstitutionId;
        if (institutions != null && institutions.length > 1 && selected == null) {
          return '/institution-selection';
        }
        return '/dashboard';
      }
      return null
    }
    if (!isLoggedIn) {
      return '/login';
    }
    final institutions = authProvider.institutions;
    final selected = authProvider.selectedInstitutionId;
    final needsSelection = institutions != null &&
                          institutions.length > 1 &&
                          selected == null &&
                          currentRoute != '/institution-selection';

    if (needsSelection) {
      return '/institution-selection';
    }

    return null
  }
  List<RouteBase> _allRoutes() {
    return [
      GoRoute(
        path: '/login',
        name: 'login',
        pageBuilder: (context, state) => _fadePage(
          context,
          state,
          const LoginScreen(),
        ),
      ),

      GoRoute(
        path: '/institution-selection',
        name: 'institution-selection',
        pageBuilder: (context, state) => _fadePage(
          context,
          state,
          const InstitutionSelectionScreen(),
        ),
      ),
      GoRoute(
        path: '/users/professor/create',
        name: 'create-professor',
        pageBuilder: (context, state) => MaterialPage(
          fullscreenDialog: true,
          name: 'Crear Profesor',
          child: UserFormScreen(userRole: 'profesor'),
        ),
      ),
      GoRoute(
        path: '/users/student/create',
        name: 'create-student',
        pageBuilder: (context, state) => MaterialPage(
          fullscreenDialog: true,
          name: 'Crear Estudiante',
          child: UserFormScreen(userRole: 'estudiante'),
        ),
      ),
      GoRoute(
        path: '/users/admin_institucion/create',
        name: 'create-admin-institucion',
        pageBuilder: (context, state) => MaterialPage(
          fullscreenDialog: true,
          name: 'Crear Admin InstituciÃ³n',
          child: UserFormScreen(userRole: 'admin_institucion'),
        ),
      ),
      GoRoute(
        path: '/users/super_admin/create',
        name: 'create-super-admin',
        pageBuilder: (context, state) => MaterialPage(
          fullscreenDialog: true,
          name: 'Crear Super Admin',
          child: UserFormScreen(userRole: 'super_admin'),
        ),
      ),
      GoRoute(
        path: '/users/detail/:id',
        name: 'user-detail',
        builder: (context, state) {
          final user = state.extra as User;
          return UserDetailScreen(user: user);
        },
      ),
      StatefulShellRoute.indexedStack(
        builder: (context, state, navigationShell) {
          return AppShell(navigationShell: navigationShell);
        },
        branches: [
          StatefulShellBranch(
            navigatorKey: _dashboardNavigatorKey,
            routes: [
              GoRoute(
                path: '/dashboard',
                name: 'dashboard',
                pageBuilder: (context, state) => NoTransitionPage(
                  child: _getDashboardForRole(),
                ),
              ),
            ],
          ),
          StatefulShellBranch(
            navigatorKey: _institutionsNavigatorKey,
            routes: [
              GoRoute(
                path: '/institutions',
                name: 'institutions-list',
                pageBuilder: (context, state) => NoTransitionPage(
                  child: const InstitutionsListScreen(),
                ),
              ),
              GoRoute(
                path: '/institutions/:id/admins',
                name: 'institution-admins',
                pageBuilder: (context, state) {
                  final segments = state.uri.pathSegments;
                  final id = segments.length >= 2 ? segments[1] : '';
                  return MaterialPage(
                    fullscreenDialog: false,
                    name: 'Institution Admins',
                    child: InstitutionAdminsScreen(institutionId: id),
                  );
                },
              ),
            ],
          ),
          StatefulShellBranch(
            navigatorKey: _usersNavigatorKey,
            routes: [
              GoRoute(
                path: '/users',
                name: 'users-list',
                pageBuilder: (context, state) => NoTransitionPage(
                  child: const UsersListScreen(),
                ),
              ),
            ],
          ),
        ],
      ),
    ];
  }
  Widget _getDashboardForRole() {
    final role = authProvider.user?['rol'] as String?;
    switch (role) {
      case 'super_admin':
        return const SuperAdminDashboard();
      case 'admin_institucion':
        return const AdminDashboard();
      case 'profesor':
        return const TeacherDashboard();
      case 'estudiante':
        return const StudentDashboard();
      default:
        return const HomeScreen();
    }
  }
  Page _fadePage(BuildContext context, GoRouterState state, Widget child) {
    return CustomTransitionPage(
      key: state.pageKey,
      child: child,
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        return FadeTransition(opacity: animation, child: child);
      },
    );
  }
  Widget _errorPage(BuildContext context, GoRouterState state) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, size: 48, color: Colors.red),
            const SizedBox(height: 16),
            const Text('Error de NavegaciÃ³n',
              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
            const SizedBox(height: 8),
            Text('${state.error}'),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () => context.go('/login'),
              child: const Text('Ir al inicio'),
            ),
          ],
        ),
      ),
    );
  }
  void dispose() {
    router.dispose();
  }
}

/* Fin lib\utils\app_router.dart */

/* Inicio lib\utils\app_routes.dart */

class AppRoutes {
  AppRoutes._()

  static const String login = '/login';

  static const String institutionSelection = '/institution-selection';
  static const String superAdminDashboard = '/super-admin-dashboard';
  static const String adminDashboard = '/admin-dashboard';
  static const String teacherDashboard = '/teacher-dashboard';
  static const String studentDashboard = '/student-dashboard';
  static const String home = '/home';
  static const String institutionsList = '/institutions';
  static const String institutionForm = '/institutions/form';
  static const String institutionDetail = '/institutions/:id';
  static const String usersList = '/users';
  static const String userForm = '/users/form';
  static const String userDetail = '/users/:id';
  static const String createProfessor = '/users/professor/create';
  static const String createStudent = '/users/student/create';
  static String getDashboardRouteForRole(String role) {
    switch (role) {
      case 'super_admin':
        return superAdminDashboard;
      case 'admin_institucion':
        return adminDashboard;
      case 'profesor':
        return teacherDashboard;
      case 'estudiante':
        return studentDashboard;
      default:
        return home;
    }
  }
  static bool requiresAuth(String route) {
    return route != login;
  }
  static bool isDashboard(String route) {
    return [
      superAdminDashboard,
      adminDashboard,
      teacherDashboard,
      studentDashboard,
      home,
    ].contains(route);
  }
}

/* Fin lib\utils\app_routes.dart */

/* Inicio lib\utils\responsive_utils.dart */
import 'package:flutter/material.dart';
import '../theme/app_constants.dart';
class ResponsiveUtils {
  static final AppConstants _constants = AppConstants.instance;
  static Map<String, dynamic> getResponsiveValues(BoxConstraints constraints) {
    final screenType = _constants.getScreenType(constraints.maxWidth);
    final maxWidth = _constants.getMaxWidth(constraints.maxWidth);
    final horizontalPadding = switch (screenType) {
      ScreenType.mobileSmall => 16.0,
      ScreenType.mobileLarge => 24.0,
      ScreenType.tablet => 32.0,
      ScreenType.desktop => 48.0,
      ScreenType.largeDesktop => 64.0,
    };
    final verticalPadding = switch (screenType) {
      ScreenType.mobileSmall => 24.0,
      ScreenType.mobileLarge => 32.0,
      ScreenType.tablet => 48.0,
      ScreenType.desktop => 64.0,
      ScreenType.largeDesktop => 80.0,
    };
    final elementSpacing = switch (screenType) {
      ScreenType.mobileSmall => 16.0,
      ScreenType.mobileLarge => 20.0,
      ScreenType.tablet => 24.0,
      ScreenType.desktop => 32.0,
      ScreenType.largeDesktop => 40.0,
    };
    final titleFontSize = switch (screenType) {
      ScreenType.mobileSmall => 24.0,
      ScreenType.mobileLarge => 28.0,
      ScreenType.tablet => 32.0,
      ScreenType.desktop => 40.0,
      ScreenType.largeDesktop => 48.0,
    };

    final subtitleFontSize = switch (screenType) {
      ScreenType.mobileSmall => 14.0,
      ScreenType.mobileLarge => 16.0,
      ScreenType.tablet => 18.0,
      ScreenType.desktop => 20.0,
      ScreenType.largeDesktop => 24.0,
    };

    final bodyFontSize = switch (screenType) {
      ScreenType.mobileSmall => 14.0,
      ScreenType.mobileLarge => 16.0,
      ScreenType.tablet => 16.0,
      ScreenType.desktop => 18.0,
      ScreenType.largeDesktop => 20.0,
    };
    final buttonWidth = switch (screenType) {
      ScreenType.mobileSmall => double.infinity,
      ScreenType.mobileLarge => 280.0,
      ScreenType.tablet => 320.0,
      ScreenType.desktop => 360.0,
      ScreenType.largeDesktop => 400.0,
    };
    final minHeight = switch (screenType) {
      ScreenType.mobileSmall => 600.0,
      ScreenType.mobileLarge => 700.0,
      ScreenType.tablet => 800.0,
      ScreenType.desktop => 900.0,
      ScreenType.largeDesktop => 1000.0,
    };

    return {
      'screenType': screenType,
      'maxWidth': maxWidth,
      'horizontalPadding': horizontalPadding,
      'verticalPadding': verticalPadding,
      'elementSpacing': elementSpacing,
      'titleFontSize': titleFontSize,
      'subtitleFontSize': subtitleFontSize,
      'bodyFontSize': bodyFontSize,
      'buttonWidth': buttonWidth,
      'minHeight': minHeight,
      'isSmallScreen': screenType == ScreenType.mobileSmall,
      'isMobile': screenType == ScreenType.mobileSmall || screenType == ScreenType.mobileLarge,
      'isTablet': screenType == ScreenType.tablet,
      'isDesktop': screenType == ScreenType.desktop || screenType == ScreenType.largeDesktop,
      'isLargeDesktop': screenType == ScreenType.largeDesktop,
    };
  }
  static Widget buildResponsiveContainer({
    required BuildContext context,
    required Widget child,
    double? maxWidth,
    EdgeInsets? padding,
    bool centerContent = true,
  }) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final responsive = getResponsiveValues(constraints);
        final containerMaxWidth = maxWidth ?? responsive['maxWidth'];
        final containerPadding = padding ?? EdgeInsets.symmetric(
          horizontal: responsive['horizontalPadding'],
          vertical: responsive['verticalPadding'],
        );

        final content = ConstrainedBox(
          constraints: BoxConstraints(maxWidth: containerMaxWidth),
          child: child,
        );

        return Container(
          width: double.infinity,
          padding: containerPadding,
          constraints: BoxConstraints(minHeight: responsive['minHeight']),
          child: centerContent ? Center(child: content) : content,
        );
      },
    );
  }
  static TextStyle getResponsiveTextStyle(
    TextStyle baseStyle,
    ScreenType screenType, {
    double? fontSize,
  }) {
    final scaleFactor = switch (screenType) {
      ScreenType.mobileSmall => 0.8,
      ScreenType.mobileLarge => 0.9,
      ScreenType.tablet => 1.0,
      ScreenType.desktop => 1.1,
      ScreenType.largeDesktop => 1.2,
    };

    final scaledFontSize = fontSize ?? (baseStyle.fontSize ?? 14.0) * scaleFactor;

    return baseStyle.copyWith(fontSize: scaledFontSize);
  }
  static SliverGridDelegate getResponsiveGridDelegate(ScreenType screenType) {
    return switch (screenType) {
      ScreenType.mobileSmall => const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 1,
          crossAxisSpacing: 16,
          mainAxisSpacing: 16,
          childAspectRatio: 1.2,
        ),
      ScreenType.mobileLarge => const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 2,
          crossAxisSpacing: 16,
          mainAxisSpacing: 16,
          childAspectRatio: 1.1,
        ),
      ScreenType.tablet => const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 3,
          crossAxisSpacing: 20,
          mainAxisSpacing: 20,
          childAspectRatio: 1.0,
        ),
      ScreenType.desktop => const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 4,
          crossAxisSpacing: 24,
          mainAxisSpacing: 24,
          childAspectRatio: 0.9,
        ),
      ScreenType.largeDesktop => const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 5,
          crossAxisSpacing: 28,
          mainAxisSpacing: 28,
          childAspectRatio: 0.8,
        ),
    };
  }
}
/* Fin lib\utils\responsive_utils.dart */

/* Inicio lib\utils\role_enum.dart */

enum UserRole {
  superAdmin,       // Administrador global del sistema
  adminInstitucion, // Administrador de una instituciÃ³n
  profesor,         // Profesor de clases
  estudiante,       // Estudiante
}
extension UserRoleExtension on UserRole {
  String get value {
    switch (this) {
      case UserRole.superAdmin:
        return 'super_admin';
      case UserRole.adminInstitucion:
        return 'admin_institucion';
      case UserRole.profesor:
        return 'profesor';
      case UserRole.estudiante:
        return 'estudiante';
    }
  }
  String get displayName {
    switch (this) {
      case UserRole.superAdmin:
        return 'Super Administrador';
      case UserRole.adminInstitucion:
        return 'Administrador';
      case UserRole.profesor:
        return 'Profesor';
      case UserRole.estudiante:
        return 'Estudiante';
    }
  }
  static UserRole fromString(String role) {
    switch (role) {
      case 'super_admin':
        return UserRole.superAdmin;
      case 'admin_institucion':
        return UserRole.adminInstitucion;
      case 'profesor':
        return UserRole.profesor;
      case 'estudiante':
        return UserRole.estudiante;
      default:
        throw ArgumentError('Rol desconocido: $role');
    }
  }
  bool get isAdmin {
    return this == UserRole.superAdmin || this == UserRole.adminInstitucion;
  }
  bool get isSuperAdmin {
    return this == UserRole.superAdmin;
  }
}
/* Fin lib\utils\role_enum.dart */

/* Inicio lib\utils\route_guards.dart */
import 'package:flutter/widgets.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';

class RouteGuards {
  static bool requireAuth(BuildContext context) {
    final authProvider = context.read<AuthProvider>();
    return authProvider.isAuthenticated;
  }
  static bool isPublic(BuildContext context) {
    final authProvider = context.read<AuthProvider>();
    return !authProvider.isAuthenticated;
  }
}
class ProtectedRoute extends StatelessWidget {
  final Widget child;
  final bool Function(BuildContext) guard;
  final Widget fallback;

  const ProtectedRoute({
    required this.child,
    required this.guard,
    required this.fallback,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    return guard(context) ? child : fallback;
  }
}

/* Fin lib\utils\route_guards.dart */

/* Inicio lib\widgets\common\empty_state_widget.dart */
import 'package:flutter/material.dart';
import '../../theme/theme_extensions.dart';

class EmptyStateWidget extends StatelessWidget {
  final IconData icon;
  final String title;
  final String message;

  const EmptyStateWidget({
    super.key,
    required this.icon,
    required this.title,
    required this.message,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            icon,
            size: 64,
            color: colors.textMuted,
          ),
          SizedBox(height: spacing.lg),
          Text(
            title,
            style: textStyles.headlineMedium.withColor(colors.textSecondary),
            textAlign: TextAlign.center,
          ),
          SizedBox(height: spacing.md),
          Text(
            message,
            style: textStyles.bodyMedium.withColor(colors.textSecondary),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }
}
/* Fin lib\widgets\common\empty_state_widget.dart */

/* Inicio lib\widgets\common\management_scaffold.dart */
import 'package:flutter/material.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';
import '../../models/user.dart';
import '../../theme/theme_extensions.dart';
import '../../widgets/common/empty_state_widget.dart';
import '../../widgets/common/shimmer_list_widget.dart';
import '../../widgets/pagination_widget.dart';

class ManagementScaffold extends StatelessWidget {
  final String title;
  final bool isLoading;
  final bool hasError;
  final String errorMessage;
  final int itemCount;
  final Widget Function(BuildContext, int) itemBuilder;
  final bool hasMoreData;
  final VoidCallback onRefresh;
  final ScrollController scrollController;
  final Widget? floatingActionButton;
  final List<Widget>? filterWidgets;
  final List<Widget>? statisticWidgets;
  final PaginationInfo? paginationInfo;
  final Future<void> Function(int) onPageChange;
  final String? emptyStateTitle;
  final String? emptyStateMessage;
  final IconData emptyStateIcon;

  const ManagementScaffold({
    super.key,
    required this.title,
    required this.isLoading,
    required this.hasError,
    required this.errorMessage,
    required this.itemCount,
    required this.itemBuilder,
    required this.hasMoreData,
    required this.onRefresh,
    required this.scrollController,
    this.floatingActionButton,
    this.filterWidgets,
    this.statisticWidgets,
    this.paginationInfo,
    required this.onPageChange,
    this.emptyStateTitle,
    this.emptyStateMessage,
    this.emptyStateIcon = Icons.business,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Scaffold(
      backgroundColor: colors.background,
      appBar: AppBar(
        title: Text(title, style: textStyles.headlineMedium.copyWith(color: colors.surface)),
        backgroundColor: colors.primary,
        elevation: 2,
      ),
      body: SafeArea(
        child: Column(
          children: [
            if (filterWidgets != null && filterWidgets!.isNotEmpty)
              Card(
                margin: EdgeInsets.symmetric(horizontal: spacing.lg, vertical: spacing.md),
                elevation: 2,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(spacing.borderRadius),
                ),
                child: ExpansionTile(
                  title: Text('Filtros y BÃºsqueda', style: textStyles.titleMedium),
                  children: [
                    Material(
                      color: colors.surface,
                      child: Padding(
                        padding: EdgeInsets.all(spacing.md),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: filterWidgets!,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            if (statisticWidgets != null && statisticWidgets!.isNotEmpty)
              Container(
                margin: EdgeInsets.symmetric(horizontal: spacing.lg),
                padding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
                decoration: BoxDecoration(
                  color: colors.surface,
                  borderRadius: BorderRadius.circular(spacing.borderRadius),
                  border: Border.all(color: colors.borderLight),
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: statisticWidgets!,
                ),
              ),
            Expanded(
              child: _buildListContent(context),
            ),
            if (paginationInfo != null)
              PaginationWidget(
                currentPage: paginationInfo!.page,
                totalPages: paginationInfo!.totalPages,
                totalItems: paginationInfo!.total,
                onPageChange: onPageChange,
                isLoading: isLoading,
              ),
          ],
        ),
      ),
      floatingActionButton: floatingActionButton,
    );
  }

  Widget _buildListContent(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;
    if (isLoading && itemCount == 0) {
      return ShimmerListWidget(
        itemCount: 5,
        cardBuilder: (context) => _buildShimmerCard(context),
      );
    }

    if (hasError) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline, size: 64, color: colors.error),
            SizedBox(height: spacing.lg),
            Text(
              'Error al cargar datos',
              style: textStyles.headlineMedium,
              textAlign: TextAlign.center,
            ),
            SizedBox(height: spacing.md),
            Text(
              errorMessage,
              style: textStyles.bodyMedium.withColor(colors.textSecondary),
              textAlign: TextAlign.center,
            ),
            SizedBox(height: spacing.lg),
            ElevatedButton(
              onPressed: onRefresh,
              style: ElevatedButton.styleFrom(
                backgroundColor: colors.primary,
                foregroundColor: Theme.of(context).colorScheme.onPrimary,
                padding: EdgeInsets.symmetric(
                  horizontal: spacing.lg,
                  vertical: spacing.md,
                ),
              ),
              child: Text('Reintentar', style: textStyles.button),
            ),
          ],
        ),
      );
    }

    if (itemCount == 0) {
      return EmptyStateWidget(
        icon: emptyStateIcon,
        title: emptyStateTitle ?? 'No hay elementos',
        message: emptyStateMessage ?? 'Comienza creando tu primer elemento',
      );
    }

    return AnimationLimiter(
      child: ListView.builder(
        controller: scrollController,
        padding: EdgeInsets.symmetric(horizontal: spacing.lg),
        itemCount: itemCount,
        itemBuilder: (context, index) {
          return AnimationConfiguration.staggeredList(
            position: index,
            duration: const Duration(milliseconds: 375),
            child: SlideAnimation(
              verticalOffset: 50.0,
              child: FadeInAnimation(
                child: itemBuilder(context, index),
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildShimmerCard(BuildContext context) {
    final spacing = context.spacing;
    return Card(
      margin: EdgeInsets.only(bottom: spacing.xs),
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(spacing.borderRadius),
      ),
      child: const ListTile(
        leading: CircleAvatar(),
        title: SizedBox(height: 16),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            SizedBox(height: 12),
            SizedBox(height: 12),
          ],
        ),
        trailing: SizedBox(width: 24, height: 24),
      ),
    );
  }
}
/* Fin lib\widgets\common\management_scaffold.dart */

/* Inicio lib\widgets\common\shimmer_list_widget.dart */
import 'package:flutter/material.dart';
import 'package:shimmer/shimmer.dart';
import '../../theme/theme_extensions.dart';

class ShimmerListWidget extends StatelessWidget {
  final Widget Function(BuildContext) cardBuilder;
  final int itemCount;

  const ShimmerListWidget({
    super.key,
    required this.cardBuilder,
    this.itemCount = 5,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;

    return Shimmer.fromColors(
      baseColor: colors.surface,
      highlightColor: colors.borderLight,
      child: ListView.builder(
        padding: EdgeInsets.symmetric(horizontal: spacing.lg, vertical: spacing.sm),
        itemCount: itemCount,
        itemBuilder: (context, index) {
          return cardBuilder(context);
        },
      ),
    );
  }
}
/* Fin lib\widgets\common\shimmer_list_widget.dart */

/* Inicio lib\widgets\dashboard_widgets.dart */
import 'package:flutter/material.dart';
import '../utils/responsive_utils.dart';
import '../theme/app_constants.dart';
import '../theme/theme_extensions.dart';
class DashboardFeatureCard extends StatelessWidget {
  final IconData icon;
  final String title;
  final String description;
  final Color color;
  final Map<String, dynamic> responsive;
  final VoidCallback? onTap;

  const DashboardFeatureCard({
    super.key,
    required this.icon,
    required this.title,
    required this.description,
    required this.color,
    required this.responsive,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final bodyFontSize = responsive['bodyFontSize'] as double;
    final isDesktop = responsive['isDesktop'] as bool;
    final colors = context.colors;

    return Card(
      elevation: 4,
      margin: const EdgeInsets.all(8),
      child: InkWell(
        onTap: onTap ?? () {
        },
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: EdgeInsets.all(isDesktop ? 24 : 16),
          child: SizedBox(
            height: isDesktop ? 140 : 120, // Altura fija para evitar overflow
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  icon,
                  size: isDesktop ? 48 : 32,
                  color: color,
                ),
                SizedBox(height: isDesktop ? 12 : 8),
                Text(
                  title,
                  style: TextStyle(
                    fontSize: bodyFontSize,
                    fontWeight: FontWeight.bold,
                    color: colors.textPrimary,
                  ),
                  textAlign: TextAlign.center,
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
                SizedBox(height: isDesktop ? 6 : 4),
                Expanded(
                  child: Text(
                    description,
                    style: TextStyle(
                      fontSize: bodyFontSize * 0.9,
                      color: colors.textSecondary,
                    ),
                    textAlign: TextAlign.center,
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
class UserGreetingWidget extends StatelessWidget {
  final String userName;
  final Map<String, dynamic> responsive;
  final String? subtitle;

  const UserGreetingWidget({
    super.key,
    required this.userName,
    required this.responsive,
    this.subtitle,
  });

  @override
  Widget build(BuildContext context) {
    final subtitleFontSize = responsive['subtitleFontSize'] as double;
    final colors = context.colors;

    return Column(
      children: [
        if (subtitle != null) ...[
          Text(
            subtitle!,
            style: TextStyle(
              fontSize: subtitleFontSize,
              color: colors.textSecondary,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ],
    );
  }
}
class DashboardOptionsGrid extends StatelessWidget {
  final List<DashboardFeatureCard> cards;
  final Map<String, dynamic> responsive;

  const DashboardOptionsGrid({
    super.key,
    required this.cards,
    required this.responsive,
  });

  @override
  Widget build(BuildContext context) {
    final screenType = responsive['screenType'] as ScreenType;

    return Column(
      children: [
        const SizedBox(height: 32),
        LayoutBuilder(
          builder: (context, constraints) {
            final gridDelegate = ResponsiveUtils.getResponsiveGridDelegate(screenType);

            return GridView(
              gridDelegate: gridDelegate,
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              children: cards,
            );
          },
        ),
      ],
    );
  }
}
class DashboardAppBar extends StatelessWidget implements PreferredSizeWidget {
  final String title;
  final Color backgroundColor;
  final List<Widget> actions;

  const DashboardAppBar({
    super.key,
    this.title = 'AsistApp',
    required this.backgroundColor,
    required this.actions,
  });

  @override
  Widget build(BuildContext context) {
    return AppBar(
      title: Text(title),
      backgroundColor: backgroundColor,
      actions: actions,
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}
class DashboardAppBarActions extends StatelessWidget {
  final String userRole;
  final IconData roleIcon;
  final VoidCallback? onLogout;

  const DashboardAppBarActions({
    super.key,
    required this.userRole,
    required this.roleIcon,
    this.onLogout,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;

    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(
          margin: const EdgeInsets.only(right: 8),
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          constraints: const BoxConstraints(maxWidth: 120), // Limitar ancho mÃ¡ximo
          decoration: BoxDecoration(
            color: colors.roleBadgeBackground,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(roleIcon, size: 14, color: colors.roleBadgeIcon),
              const SizedBox(width: 4),
              Flexible(
                child: Text(
                  userRole,
                  style: TextStyle(
                    color: colors.roleBadgeText,
                    fontSize: 11,
                    fontWeight: FontWeight.w500,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ),
            ],
          ),
        ),
        IconButton(
          icon: const Icon(Icons.logout),
          onPressed: onLogout ?? () async {
          },
        ),
      ],
    );
  }
}
class DashboardBody extends StatelessWidget {
  final Widget userGreeting;
  final Widget dashboardOptions;
  final Map<String, dynamic> responsive;

  const DashboardBody({
    super.key,
    required this.userGreeting,
    required this.dashboardOptions,
    required this.responsive,
  });

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: SingleChildScrollView(
        child: ConstrainedBox(
          constraints: BoxConstraints(maxWidth: responsive['maxWidth']),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Padding(
                padding: EdgeInsets.symmetric(
                  horizontal: responsive['horizontalPadding'],
                  vertical: responsive['verticalPadding'],
                ),
                child: Column(
                  children: [
                    userGreeting,
                    SizedBox(height: responsive['elementSpacing']),
                    dashboardOptions,
                    SizedBox(height: responsive['elementSpacing'] * 2),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
/* Fin lib\widgets\dashboard_widgets.dart */

/* Inicio lib\widgets\form_widgets.dart */
import 'package:flutter/material.dart';
import '../theme/theme_extensions.dart';

class CustomTextFormField extends StatelessWidget {
  final TextEditingController controller;
  final String labelText;
  final String hintText;
  final TextInputType keyboardType;
  final bool obscureText;
  final String? Function(String?)? validator;
  final int? maxLines;
  final int? minLines;
  final Widget? prefixIcon;
  final Widget? suffixIcon;
  final bool enabled;
  final void Function(String)? onChanged;
  final void Function()? onTap;
  final String? initialValue;

  const CustomTextFormField({
    super.key,
    required this.controller,
    required this.labelText,
    required this.hintText,
    this.keyboardType = TextInputType.text,
    this.obscureText = false,
    this.validator,
    this.maxLines = 1,
    this.minLines,
    this.prefixIcon,
    this.suffixIcon,
    this.enabled = true,
    this.onChanged,
    this.onTap,
    this.initialValue,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Material(
      color: Colors.transparent,
      child: TextFormField(
        controller: controller,
        initialValue: initialValue,
        keyboardType: keyboardType,
        obscureText: obscureText,
        maxLines: maxLines,
        minLines: minLines,
        enabled: enabled,
        onChanged: onChanged,
        onTap: onTap,
        validator: validator,
        style: textStyles.bodyLarge,
        decoration: InputDecoration(
          labelText: labelText,
          hintText: hintText,
          hintStyle: textStyles.bodyMedium.withColor(colors.textMuted),
          prefixIcon: prefixIcon,
          suffixIcon: suffixIcon,
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.border),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.borderLight),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.primary, width: 2),
          ),
          errorBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.error),
          ),
          focusedErrorBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.error, width: 2),
          ),
          filled: true,
          fillColor: enabled ? colors.surface : colors.surface.withValues(alpha: 0.5),
          contentPadding: EdgeInsets.symmetric(
            horizontal: spacing.md,
            vertical: spacing.sm,
          ),
          labelStyle: textStyles.bodyMedium.withColor(colors.textSecondary),
        ),
      ),
    );
  }
}

class CustomDropdownFormField<T> extends StatelessWidget {
  final T? value;
  final String labelText;
  final String hintText;
  final List<DropdownMenuItem<T>> items;
  final String? Function(T?)? validator;
  final void Function(T?)? onChanged;
  final bool enabled;

  const CustomDropdownFormField({
    super.key,
    this.value,
    required this.labelText,
    required this.hintText,
    required this.items,
    this.validator,
    this.onChanged,
    this.enabled = true,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Material(
      color: Colors.transparent,
      child: DropdownButtonFormField<T>(
        value: value,
        items: items,
        onChanged: enabled ? onChanged : null,
        validator: validator,
        style: textStyles.bodyLarge,
        decoration: InputDecoration(
          labelText: labelText,
          hintText: hintText,
          hintStyle: textStyles.bodyMedium.withColor(colors.textMuted),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.border),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.borderLight),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.primary, width: 2),
          ),
          errorBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.error),
          ),
          focusedErrorBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.error, width: 2),
          ),
          filled: true,
          fillColor: enabled ? colors.surface : colors.surface.withValues(alpha: 0.5),
          contentPadding: EdgeInsets.symmetric(
            horizontal: spacing.md,
            vertical: spacing.sm,
          ),
          labelStyle: textStyles.bodyMedium.withColor(colors.textSecondary),
        ),
        dropdownColor: colors.surface,
      ),
    );
  }
}

class CustomCheckboxFormField extends StatelessWidget {
  final bool value;
  final String title;
  final String? subtitle;
  final void Function(bool?)? onChanged;
  final String? Function(bool?)? validator;
  final bool enabled;

  const CustomCheckboxFormField({
    super.key,
    required this.value,
    required this.title,
    this.subtitle,
    this.onChanged,
    this.validator,
    this.enabled = true,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return FormField<bool>(
      initialValue: value,
      validator: validator,
      builder: (FormFieldState<bool> state) {
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            CheckboxListTile(
              value: state.value ?? false,
              onChanged: enabled ? (bool? newValue) {
                state.didChange(newValue);
                onChanged?.call(newValue);
              } : null,
              title: Text(
                title,
                style: textStyles.bodyLarge,
              ),
              subtitle: subtitle != null
                  ? Text(
                      subtitle!,
                      style: textStyles.bodySmall.withColor(colors.textSecondary),
                    )
                  : null,
              controlAffinity: ListTileControlAffinity.leading,
              activeColor: colors.primary,
              checkColor: Theme.of(context).colorScheme.onPrimary,
              tileColor: colors.surface,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(spacing.borderRadius),
              ),
              side: BorderSide(color: colors.borderLight),
            ),
            if (state.hasError)
              Padding(
                padding: EdgeInsets.only(left: spacing.lg, top: spacing.xs),
                child: Text(
                  state.errorText!,
                  style: textStyles.bodySmall.withColor(colors.error),
                ),
              ),
          ],
        );
      },
    );
  }
}

class CustomSwitchFormField extends StatelessWidget {
  final bool value;
  final String title;
  final String? subtitle;
  final void Function(bool)? onChanged;
  final bool enabled;

  const CustomSwitchFormField({
    super.key,
    required this.value,
    required this.title,
    this.subtitle,
    this.onChanged,
    this.enabled = true,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Material(
      color: Colors.transparent,
      child: Card(
        elevation: 1,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(spacing.borderRadius),
        ),
        child: Padding(
          padding: EdgeInsets.all(spacing.md),
          child: Row(
            children: [
              Icon(
                value ? Icons.check_circle : Icons.cancel,
                color: value ? colors.success : colors.error,
              ),
              SizedBox(width: spacing.md),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      style: textStyles.bodyLarge,
                    ),
                    if (subtitle != null)
                      Text(
                        subtitle!,
                        style: textStyles.bodySmall.withColor(colors.textSecondary),
                      ),
                  ],
                ),
              ),
              Switch(
                value: value,
                onChanged: enabled ? onChanged : null,
                activeColor: colors.primary,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
/* Fin lib\widgets\form_widgets.dart */

/* Inicio lib\widgets\index.dart */
export 'pagination_widget.dart';
/* Fin lib\widgets\index.dart */

/* Inicio lib\widgets\pagination_widget.dart */
import 'package:flutter/material.dart';
import '../theme/theme_extensions.dart';
import '../theme/app_colors.dart';
import '../theme/app_spacing.dart';
import '../theme/app_text_styles.dart';
import '../utils/app_constants.dart';
typedef OnPageChangeCallback = Future<void> Function(int page);
class PaginationWidget extends StatelessWidget {
  final int currentPage;
  final int totalPages;
  final int totalItems;
  final OnPageChangeCallback onPageChange;
  final bool isLoading;
  final int maxPageButtons;

  const PaginationWidget({
    super.key,
    required this.currentPage,
    required this.totalPages,
    required this.totalItems,
    required this.onPageChange,
    this.isLoading = false,
    this.maxPageButtons = 5,
  });

  bool get _canGoPrevious => currentPage > 1;
  bool get _canGoNext => currentPage < totalPages;
  bool get _showPagination => totalPages > 1;

  Future<void> _handlePageChange(int page) async {
    if (page != currentPage && page >= 1 && page <= totalPages) {
      await onPageChange(page);
    }
  }

  List<int> _getVisiblePages() {
    final pages = <int>[];

    if (totalPages <= maxPageButtons) {
      pages.addAll(List.generate(totalPages, (i) => i + 1));
    } else {
      if (currentPage <= maxPageButtons ~/ 2 + 1) {
        pages.addAll(List.generate(maxPageButtons, (i) => i + 1));
      } else if (currentPage >= totalPages - maxPageButtons ~/ 2) {
        pages.addAll(List.generate(
          maxPageButtons,
          (i) => totalPages - maxPageButtons + i + 1,
        ));
      } else {
        final center = maxPageButtons ~/ 2;
        pages.addAll(List.generate(
          maxPageButtons,
          (i) => currentPage - center + i,
        ));
      }
    }

    return pages;
  }

  @override
  Widget build(BuildContext context) {
    if (!_showPagination) {
      return const SizedBox.shrink();
    }

    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Container(
      margin: EdgeInsets.symmetric(horizontal: spacing.lg, vertical: spacing.md),
      decoration: BoxDecoration(
        color: colors.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: colors.borderLight, width: 1),
        boxShadow: [
          BoxShadow(
            color: colors.textMuted.withValues(alpha: 0.08),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            padding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
            decoration: BoxDecoration(
              color: colors.primaryContainer.withValues(alpha: 0.3),
              borderRadius: const BorderRadius.only(
                topLeft: Radius.circular(12),
                topRight: Radius.circular(12),
              ),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.library_books_outlined,
                  size: 16,
                  color: colors.primary,
                ),
                SizedBox(width: spacing.xs),
                Text(
                  'PÃ¡gina $currentPage de $totalPages',
                  style: textStyles.bodyMedium.bold.copyWith(color: colors.primary),
                ),
                SizedBox(width: spacing.sm),
                Container(
                  padding: EdgeInsets.symmetric(horizontal: spacing.sm, vertical: 2),
                  decoration: BoxDecoration(
                    color: colors.primary.withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(
                    '$totalItems items',
                    style: textStyles.bodySmall.copyWith(
                      color: colors.primary,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
              ],
            ),
          ),
          Padding(
            padding: EdgeInsets.all(spacing.md),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                _buildPageSelector(colors, spacing, textStyles),

                SizedBox(height: spacing.md),
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    _buildNavigationButton(
                      icon: Icons.first_page,
                      label: 'Primera',
                      enabled: _canGoPrevious && !isLoading,
                      onPressed: () => _handlePageChange(1),
                      colors: colors,
                      spacing: spacing,
                      textStyles: textStyles,
                      compact: true,
                    ),

                    SizedBox(width: spacing.sm),
                    _buildNavigationButton(
                      icon: Icons.chevron_left,
                      label: 'Anterior',
                      enabled: _canGoPrevious && !isLoading,
                      onPressed: () => _handlePageChange(currentPage - 1),
                      colors: colors,
                      spacing: spacing,
                      textStyles: textStyles,
                    ),

                    SizedBox(width: spacing.md),
                    _buildNavigationButton(
                      icon: Icons.chevron_right,
                      label: 'Siguiente',
                      enabled: _canGoNext && !isLoading,
                      onPressed: () => _handlePageChange(currentPage + 1),
                      colors: colors,
                      spacing: spacing,
                      textStyles: textStyles,
                      iconOnRight: true,
                    ),

                    SizedBox(width: spacing.sm),
                    _buildNavigationButton(
                      icon: Icons.last_page,
                      label: 'Ãšltima',
                      enabled: _canGoNext && !isLoading,
                      onPressed: () => _handlePageChange(totalPages),
                      colors: colors,
                      spacing: spacing,
                      textStyles: textStyles,
                      iconOnRight: true,
                      compact: true,
                    ),
                  ],
                ),
                if (isLoading) ...[
                  SizedBox(height: spacing.sm),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      SizedBox(
                        width: 16,
                        height: 16,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          valueColor: AlwaysStoppedAnimation<Color>(colors.primary),
                        ),
                      ),
                      SizedBox(width: spacing.sm),
                      Text(
                        'Cargando...',
                        style: textStyles.bodySmall.copyWith(color: colors.textSecondary),
                      ),
                    ],
                  ),
                ],
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildNavigationButton({
    required IconData icon,
    required String label,
    required bool enabled,
    required VoidCallback onPressed,
    required AppColors colors,
    required AppSpacing spacing,
    required AppTextStyles textStyles,
    bool iconOnRight = false,
    bool compact = false,
  }) {
    return AnimatedOpacity(
      opacity: enabled ? 1.0 : 0.5,
      duration: const Duration(milliseconds: 200),
      child: ElevatedButton(
        onPressed: enabled ? onPressed : null,
        style: ElevatedButton.styleFrom(
          backgroundColor: colors.primary,
          disabledBackgroundColor: colors.borderLight,
          foregroundColor: colors.getTextColorForBackground(colors.primary),
          disabledForegroundColor: colors.textMuted,
          padding: EdgeInsets.symmetric(
            horizontal: compact ? spacing.sm : spacing.md,
            vertical: spacing.sm,
          ),
          elevation: enabled ? 2 : 0,
          shadowColor: colors.primary.withValues(alpha: 0.4),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ).copyWith(
          overlayColor: WidgetStateProperty.all(
            colors.getTextColorForBackground(colors.primary).withValues(alpha: 0.1),
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            if (!iconOnRight) ...[
              Icon(icon, size: 18),
              if (!compact) SizedBox(width: spacing.xs),
            ],
            if (!compact)
              Text(
                label,
                style: textStyles.bodySmall.bold,
              ),
            if (iconOnRight) ...[
              if (!compact) SizedBox(width: spacing.xs),
              Icon(icon, size: 18),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildPageSelector(AppColors colors, AppSpacing spacing, AppTextStyles textStyles) {
    if (totalPages <= 1) {
      return const SizedBox.shrink();
    }

    final pages = _getVisiblePages();

    return Container(
      padding: EdgeInsets.symmetric(horizontal: spacing.sm, vertical: spacing.xs),
      decoration: BoxDecoration(
        color: colors.backgroundLight,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: colors.borderLight.withValues(alpha: 0.5)),
      ),
      child: SingleChildScrollView(
        scrollDirection: Axis.horizontal,
        child: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            for (int i = 0; i < pages.length; i++) ...[
              _buildPageButton(
                pageNumber: pages[i],
                isCurrentPage: pages[i] == currentPage,
                colors: colors,
                spacing: spacing,
                textStyles: textStyles,
              ),
              if (i != pages.length - 1) SizedBox(width: spacing.xs / 2),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildPageButton({
    required int pageNumber,
    required bool isCurrentPage,
    required AppColors colors,
    required AppSpacing spacing,
    required AppTextStyles textStyles,
  }) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: !isLoading && !isCurrentPage
            ? () => _handlePageChange(pageNumber)
            : null,
        borderRadius: BorderRadius.circular(8),
        splashColor: colors.primary.withValues(alpha: 0.1),
        highlightColor: colors.primary.withValues(alpha: 0.05),
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          curve: Curves.easeInOut,
          constraints: const BoxConstraints(
            minWidth: 36,
            minHeight: 36,
          ),
          padding: EdgeInsets.symmetric(
            horizontal: spacing.sm,
            vertical: spacing.xs,
          ),
          decoration: BoxDecoration(
            color: isCurrentPage
                ? colors.primary
                : Colors.transparent,
            borderRadius: BorderRadius.circular(8),
            border: Border.all(
              color: isCurrentPage
                  ? colors.primary
                  : colors.borderLight.withValues(alpha: 0.3),
              width: isCurrentPage ? 2 : 1,
            ),
            boxShadow: isCurrentPage
                ? [
                    BoxShadow(
                      color: colors.primary.withValues(alpha: 0.3),
                      blurRadius: 8,
                      offset: const Offset(0, 2),
                    ),
                  ]
                : null,
          ),
          child: Center(
            child: Text(
              '$pageNumber',
              style: textStyles.bodyMedium.copyWith(
                color: isCurrentPage
                    ? colors.getTextColorForBackground(colors.primary)
                    : colors.textSecondary,
                fontWeight: isCurrentPage ? FontWeight.bold : FontWeight.w500,
              ),
            ),
          ),
        ),
      ),
    );
  }
}
class PaginationState {
  final int currentPage;
  final int totalPages;
  final int totalItems;
  final int itemsPerPage;
  final bool isLoading;

  PaginationState({
    this.currentPage = 1,
    this.totalPages = 1,
    this.totalItems = 0,
    this.itemsPerPage = AppConstants.itemsPerPage,
    this.isLoading = false,
  });

  bool get hasNextPage => currentPage < totalPages;
  bool get hasPreviousPage => currentPage > 1;
  bool get isFirstPage => currentPage == 1;
  bool get isLastPage => currentPage == totalPages;
  PaginationState copyWith({
    int? currentPage,
    int? totalPages,
    int? totalItems,
    int? itemsPerPage,
    bool? isLoading,
  }) {
    return PaginationState(
      currentPage: currentPage ?? this.currentPage,
      totalPages: totalPages ?? this.totalPages,
      totalItems: totalItems ?? this.totalItems,
      itemsPerPage: itemsPerPage ?? this.itemsPerPage,
      isLoading: isLoading ?? this.isLoading,
    );
  }

  @override
  String toString() =>
      'PaginationState(page: $currentPage/$totalPages, items: $totalItems, perPage: $itemsPerPage)';
}

/* Fin lib\widgets\pagination_widget.dart */

/* Inicio lib\widgets\role_guard.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../utils/role_enum.dart';
class RoleGuard extends StatelessWidget {
  final List<UserRole> allowedRoles
  final Widget child
  final Widget? fallback

  const RoleGuard({
    super.key,
    required this.allowedRoles,
    required this.child,
    this.fallback,
  });

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final userRoleString = authProvider.user?['rol'] as String?;

    if (userRoleString == null) {
      return fallback ?? const SizedBox.shrink();
    }

    UserRole? userRole;
    try {
      userRole = UserRoleExtension.fromString(userRoleString);
    } catch (e) {
      return fallback ?? const SizedBox.shrink();
    }

    if (allowedRoles.contains(userRole)) {
      return child;
    } else {
      return fallback ?? const SizedBox.shrink();
    }
  }
}
/* Fin lib\widgets\role_guard.dart */

/* Inicio lib\widgets\scroll_state_keeper.dart */
import 'package:flutter/material.dart';
class ScrollStateKeeper extends StatefulWidget {
  final String routeKey;
  final bool keepScrollPosition;
  final Widget Function(BuildContext, ScrollController) builder;

  const ScrollStateKeeper({
    super.key,
    required this.routeKey,
    this.keepScrollPosition = true,
    required this.builder,
  });

  @override
  State<ScrollStateKeeper> createState() => _ScrollStateKeeperState();
}

class _ScrollStateKeeperState extends State<ScrollStateKeeper> {
  final ScrollController _scrollController = ScrollController();

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return widget.builder(context, _scrollController);
  }
}
/* Fin lib\widgets\scroll_state_keeper.dart */

/* Inicio lib\widgets\session_info_footer.dart */
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';

class SessionInfoFooter extends StatelessWidget {
  const SessionInfoFooter({super.key});

  Future<void> _copyToClipboard(BuildContext context, String text) async {
    await Clipboard.setData(ClipboardData(text: text));

    if (context.mounted) {
      final colors = context.colors;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            'Token copiado al portapapeles',
            style: TextStyle(color: colors.getTextColorForBackground(colors.success)),
          ),
          duration: const Duration(seconds: 2),
          backgroundColor: colors.success,
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final authProvider = Provider.of<AuthProvider>(context);
    final accessToken = authProvider.accessToken;

    if (accessToken == null) return const SizedBox.shrink();

    return Container(
      width: double.infinity,
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: colors.primary,
        boxShadow: [
          BoxShadow(
            color: colors.shadow,
            blurRadius: 4,
            offset: const Offset(0, -2),
          ),
        ],
      ),
      child: Row(
        children: [
          Icon(
            Icons.security,
            size: 16,
            color: colors.success,
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              'Token: ${accessToken.substring(0, 20)}...',
              style: TextStyle(
                color: colors.textOnDark,
                fontSize: 12,
                fontFamily: 'monospace',
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
          const SizedBox(width: 8),
          IconButton(
            icon: const Icon(Icons.copy, size: 16),
            color: colors.textOnDarkSecondary,
            tooltip: 'Copiar token',
            onPressed: () => _copyToClipboard(context, accessToken),
          ),
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
            decoration: BoxDecoration(
              color: colors.success.withValues(alpha: 0.2),
              borderRadius: BorderRadius.circular(4),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(
                  Icons.timer,
                  size: 14,
                  color: colors.success,
                ),
                const SizedBox(width: 4),
                Text(
                  'Activo',
                  style: TextStyle(
                    color: colors.getTextColorForBackground(colors.success),
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
/* Fin lib\widgets\session_info_footer.dart */

/* Inicio backend\dist\config\app.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.config = void 0;
exports.config = {
    port: parseInt(process.env.PORT || '3000', 10),
    host: process.env.HOST || '0.0.0.0',
    jwtSecret: process.env.JWT_SECRET || 'asistapp_secret_key_2025',
    jwtExpiresIn: process.env.JWT_EXPIRES_IN || '24h',
    nodeEnv: process.env.NODE_ENV || 'development',
    logLevel: process.env.LOG_LEVEL || 'info',
};
exports.default = exports.config;

/* Fin backend\dist\config\app.js */

/* Inicio backend\dist\config\database.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prisma = exports.databaseService = void 0;
const client_1 = require("@prisma/client");
class DatabaseService {
    constructor() {
        this.prisma = null;
    }
    static getInstance() {
        if (!DatabaseService.instance) {
            DatabaseService.instance = new DatabaseService();
        }
        return DatabaseService.instance;
    }
    getClient() {
        if (!this.prisma) {
            console.log('ðŸ”„ Creando cliente Prisma...');
            this.prisma = new client_1.PrismaClient({
                log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
            });
            console.log('âœ… Cliente Prisma creado');
        }
        return this.prisma;
    }
    async disconnect() {
        if (this.prisma) {
            await this.prisma.$disconnect();
            this.prisma = null;
            console.log('ðŸ”Œ Cliente Prisma desconectado');
        }
    }
    async connect() {
        const client = this.getClient();
        await client.$connect();
        console.log('ðŸ”— Conectado a la base de datos');
    }
}
exports.databaseService = DatabaseService.getInstance();
exports.prisma = exports.databaseService.getClient();

/* Fin backend\dist\config\database.js */

/* Inicio backend\dist\config\jwt.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JWTService = void 0;
const crypto_1 = __importDefault(require("crypto"));
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const app_1 = require("./app");
class JWTService {
    static signAccessToken(payload) {
        return jsonwebtoken_1.default.sign(payload, this.accessSecret, { expiresIn: this.accessExpiresIn });
    }
    static verifyAccessToken(token) {
        try {
            const decoded = jsonwebtoken_1.default.verify(token, this.accessSecret);
            return decoded;
        }
        catch (error) {
            throw new Error('Access token invÃ¡lido o expirado');
        }
    }
    static signRefreshToken(payload) {
        const tokenPayload = {
            ...payload,
            jti: crypto_1.default.randomUUID(), // JWT ID Ãºnico para evitar colisiones
        };
        return jsonwebtoken_1.default.sign(tokenPayload, this.refreshSecret, { expiresIn: this.refreshExpiresIn });
    }
    static verifyRefreshToken(token) {
        try {
            const decoded = jsonwebtoken_1.default.verify(token, this.refreshSecret);
            return decoded;
        }
        catch (error) {
            throw new Error('Refresh token invÃ¡lido o expirado');
        }
    }
    static sign(payload) {
        return this.signAccessToken(payload);
    }
    static verify(token) {
        return this.verifyAccessToken(token);
    }
    static decode(token) {
        try {
            return jsonwebtoken_1.default.decode(token);
        }
        catch (error) {
            return null;
        }
    }
}
exports.JWTService = JWTService;
JWTService.accessSecret = app_1.config.jwtSecret;
JWTService.refreshSecret = app_1.config.jwtSecret + '_refresh'
JWTService.accessExpiresIn = app_1.config.jwtExpiresIn;
JWTService.refreshExpiresIn = '7d'
exports.default = JWTService;

/* Fin backend\dist\config\jwt.js */

/* Inicio backend\dist\controllers\admin-institucion.controller.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AdminInstitucionController = void 0;
const admin_institucion_service_1 = __importDefault(require("../services/admin-institucion.service"));
const types_1 = require("../types");

class AdminInstitucionController {

    static async getAll(request, reply) {
        try {
            const { page, limit } = request.query;
            const pagination = {};
            if (page)
                pagination.page = parseInt(page, 10);
            if (limit)
                pagination.limit = parseInt(limit, 10);
            const result = await admin_institucion_service_1.default.getAll(pagination);
            return reply.code(200).send({
                success: true,
                data: result.data,
                pagination: result.pagination,
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async getById(request, reply) {
        try {
            const { id } = request.params;
            const admin = await admin_institucion_service_1.default.getById(id);
            if (!admin) {
                throw new types_1.NotFoundError('Admin de InstituciÃ³n');
            }
            return reply.code(200).send({
                success: true,
                data: admin,
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async create(request, reply) {
        try {
            const adminData = request.body;
            const newAdmin = await admin_institucion_service_1.default.create(adminData);
            return reply.code(201).send({
                success: true,
                data: newAdmin,
                message: 'Admin de instituciÃ³n creado exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async update(request, reply) {
        try {
            const { id } = request.params;
            const adminData = request.body;
            const updatedAdmin = await admin_institucion_service_1.default.update(id, adminData);
            if (!updatedAdmin) {
                throw new types_1.NotFoundError('Admin de InstituciÃ³n');
            }
            return reply.code(200).send({
                success: true,
                data: updatedAdmin,
                message: 'Admin de instituciÃ³n actualizado exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async delete(request, reply) {
        try {
            const { id } = request.params;
            const deleted = await admin_institucion_service_1.default.delete(id);
            if (!deleted) {
                throw new types_1.NotFoundError('Admin de InstituciÃ³n');
            }
            return reply.code(200).send({
                success: true,
                data: null,
                message: 'Admin de instituciÃ³n eliminado exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }
}
exports.AdminInstitucionController = AdminInstitucionController;
exports.default = AdminInstitucionController;

/* Fin backend\dist\controllers\admin-institucion.controller.js */

/* Inicio backend\dist\controllers\auth.controller.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthController = void 0;
const database_1 = require("../config/database");
const auth_service_1 = __importDefault(require("../services/auth.service"));
const types_1 = require("../types");
class AuthController {

    static async login(request, reply) {
        try {
            const credentials = request.body;
            if (!credentials.email || !credentials.password) {
                throw new types_1.ValidationError('Email y contraseÃ±a son requeridos');
            }
            const result = await auth_service_1.default.login(credentials);
            return reply.code(200).send({
                success: true,
                data: {
                    accessToken: result.accessToken,
                    refreshToken: result.refreshToken,
                    expiresIn: result.expiresIn,
                    usuario: result.usuario
                }
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async getUserInstitutions(request, reply) {
        try {
            const user = request.user;
            if (!user) {
                throw new types_1.AuthenticationError('Usuario no autenticado');
            }
            const usuario = await database_1.prisma.usuario.findUnique({
                where: { id: user.id },
                include: {
                    usuarioInstituciones: {
                        where: { activo: true },
                        include: {
                            institucion: true,
                        },
                    },
                },
            });
            if (!usuario) {
                throw new types_1.NotFoundError('Usuario');
            }
            const instituciones = usuario.usuarioInstituciones.map((ui) => ({
                id: ui.institucion.id,
                nombre: ui.institucion.nombre,
                rolEnInstitucion: ui.rolEnInstitucion,
            }));
            return reply.code(200).send({
                success: true,
                data: instituciones,
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async logout(request, reply) {
        try {
            const refreshToken = request.body.refreshToken;
            const authReq = request;
            const user = authReq.user;
            if (!user) {
                throw new types_1.AuthenticationError('Usuario no autenticado');
            }
            await auth_service_1.default.revokeRefreshTokens(user.id, refreshToken);
            return reply.code(200).send({
                success: true,
                message: 'SesiÃ³n cerrada exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async refreshToken(request, reply) {
        try {
            const refreshToken = request.body.refreshToken;
            if (!refreshToken) {
                throw new types_1.ValidationError('Refresh token es requerido');
            }
            const result = await auth_service_1.default.refreshToken(refreshToken);
            return reply.code(200).send({
                success: true,
                data: {
                    accessToken: result.accessToken,
                    refreshToken: result.refreshToken,
                    expiresIn: result.expiresIn,
                },
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async verify(request, reply) {
        try {
            const user = request.user;
            return reply.code(200).send({
                success: true,
                data: {
                    usuario: user,
                    valid: true,
                },
            });
        }
        catch (error) {
            throw error;
        }
    }
}
exports.AuthController = AuthController;
exports.default = AuthController;

/* Fin backend\dist\controllers\auth.controller.js */

/* Inicio backend\dist\controllers\institucion.controller.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstitucionController = void 0;
const institucion_service_1 = __importDefault(require("../services/institucion.service"));
const types_1 = require("../types");
class InstitucionController {
    static async getAll(request, reply) {
        try {
            const { page, limit, activa, search } = request.query;
            const pagination = {
                page: page ? parseInt(page, 10) : 1,
                limit: limit ? parseInt(limit, 10) : 10,
            };
            const filters = {
                activa: activa !== undefined ? activa === 'true' : undefined,
                search: search || undefined,
            };
            const result = await institucion_service_1.default.getAllInstitutions(pagination, filters);
            return reply.code(200).send({
                success: true,
                data: result.data,
                pagination: result.pagination,
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async getById(request, reply) {
        try {
            const { id } = request.params;
            const institution = await institucion_service_1.default.getInstitutionById(id);
            if (!institution) {
                throw new types_1.NotFoundError('InstituciÃ³n');
            }
            return reply.code(200).send({
                success: true,
                data: institution,
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async create(request, reply) {
        try {
            const data = request.body;
            const institution = await institucion_service_1.default.createInstitution(data);
            return reply.code(201).send({
                success: true,
                data: institution,
                message: 'InstituciÃ³n creada exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async update(request, reply) {
        try {
            const { id } = request.params;
            const data = request.body;
            const institution = await institucion_service_1.default.updateInstitution(id, data);
            if (!institution) {
                throw new types_1.NotFoundError('InstituciÃ³n');
            }
            return reply.code(200).send({
                success: true,
                data: institution,
                message: 'InstituciÃ³n actualizada exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async delete(request, reply) {
        try {
            const { id } = request.params;
            const success = await institucion_service_1.default.deleteInstitution(id);
            return reply.code(200).send({
                success: true,
                message: 'InstituciÃ³n eliminada exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }
}
exports.InstitucionController = InstitucionController;
exports.default = InstitucionController;

/* Fin backend\dist\controllers\institucion.controller.js */

/* Inicio backend\dist\controllers\institution-admin.controller.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstitutionAdminController = void 0;
const database_1 = require("../config/database");
const profesor_service_1 = __importDefault(require("../services/profesor.service"));
const types_1 = require("../types");

class InstitutionAdminController {

    static async getAllProfesores(request, reply) {
        try {
            const user = request.user;
            const { page, limit, activo, search } = request.query;

            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: {
                    usuarioId: user.id,
                    activo: true,
                },
                include: {
                    institucion: true,
                },
            });
            if (!usuarioInstitucion) {
                return reply.code(403).send({
                    success: false,
                    message: 'No tienes una instituciÃ³n asignada',
                });
            }
            const institucionId = usuarioInstitucion.institucionId;

            const pagination = {};
            if (page)
                pagination.page = parseInt(page, 10);
            if (limit)
                pagination.limit = parseInt(limit, 10);

            const filters = { institucionId };
            if (activo !== undefined && activo !== null) {
                filters.activo = String(activo).toLowerCase() === 'true';
            }
            if (search)
                filters.search = search;

            const result = await profesor_service_1.default.getAll(institucionId, pagination, filters);
            return reply.code(200).send({
                success: true,
                data: result.data,
                pagination: result.pagination,
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async getProfesorById(request, reply) {
        try {
            const user = request.user;
            const { id } = request.params;

            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: {
                    usuarioId: user.id,
                    activo: true,
                },
                include: {
                    institucion: true,
                },
            });
            if (!usuarioInstitucion) {
                return reply.code(403).send({
                    success: false,
                    message: 'No tienes una instituciÃ³n asignada',
                });
            }
            const institucionId = usuarioInstitucion.institucionId;
            const profesor = await profesor_service_1.default.getById(id, institucionId);
            if (!profesor) {
                throw new types_1.NotFoundError('Profesor');
            }
            return reply.code(200).send({
                success: true,
                data: profesor,
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async createProfesor(request, reply) {
        try {
            const user = request.user;
            const profesorData = request.body;

            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: {
                    usuarioId: user.id,
                    activo: true,
                },
                include: {
                    institucion: true,
                },
            });
            if (!usuarioInstitucion) {
                return reply.code(403).send({
                    success: false,
                    message: 'No tienes una instituciÃ³n asignada',
                });
            }
            const institucionId = usuarioInstitucion.institucionId;

            const newProfesor = await profesor_service_1.default.create({
                nombres: profesorData.nombres,
                apellidos: profesorData.apellidos,
                email: profesorData.email,
                password: profesorData.password,
                institucionId: institucionId,
                grupoId: profesorData.grupoId,
            }, user.id);
            return reply.code(201).send({
                success: true,
                data: newProfesor,
                message: 'Profesor creado exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async updateProfesor(request, reply) {
        try {
            const user = request.user;
            const { id } = request.params;
            const profesorData = request.body;

            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: {
                    usuarioId: user.id,
                    activo: true,
                },
                include: {
                    institucion: true,
                },
            });
            if (!usuarioInstitucion) {
                return reply.code(403).send({
                    success: false,
                    message: 'No tienes una instituciÃ³n asignada',
                });
            }
            const institucionId = usuarioInstitucion.institucionId;
            const updatedProfesor = await profesor_service_1.default.update(id, institucionId, profesorData);
            if (!updatedProfesor) {
                throw new types_1.NotFoundError('Profesor');
            }
            return reply.code(200).send({
                success: true,
                data: updatedProfesor,
                message: 'Profesor actualizado exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async deleteProfesor(request, reply) {
        try {
            const user = request.user;
            const { id } = request.params;

            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: {
                    usuarioId: user.id,
                    activo: true,
                },
                include: {
                    institucion: true,
                },
            });
            if (!usuarioInstitucion) {
                return reply.code(403).send({
                    success: false,
                    message: 'No tienes una instituciÃ³n asignada',
                });
            }
            const institucionId = usuarioInstitucion.institucionId;
            const deleted = await profesor_service_1.default.delete(id, institucionId);
            if (!deleted) {
                throw new types_1.NotFoundError('Profesor');
            }
            return reply.code(200).send({
                success: true,
                data: null,
                message: 'Profesor eliminado exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async toggleProfesorStatus(request, reply) {
        try {
            const user = request.user;
            const { id } = request.params;

            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: {
                    usuarioId: user.id,
                    activo: true,
                },
                include: {
                    institucion: true,
                },
            });
            if (!usuarioInstitucion) {
                return reply.code(403).send({
                    success: false,
                    message: 'No tienes una instituciÃ³n asignada',
                });
            }
            const institucionId = usuarioInstitucion.institucionId;
            const profesor = await profesor_service_1.default.toggleStatus(id, institucionId);
            if (!profesor) {
                throw new types_1.NotFoundError('Profesor');
            }
            return reply.code(200).send({
                success: true,
                data: profesor,
                message: `Profesor ${profesor.activo ? 'activado' : 'desactivado'} exitosamente`,
            });
        }
        catch (error) {
            throw error;
        }
    }
}
exports.InstitutionAdminController = InstitutionAdminController;
exports.default = InstitutionAdminController;

/* Fin backend\dist\controllers\institution-admin.controller.js */

/* Inicio backend\dist\controllers\user.controller.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserController = void 0;
const user_service_1 = __importDefault(require("../services/user.service"));
const types_1 = require("../types");

class UserController {

    static async getAllUsers(request, reply) {
        try {
            const { page, limit, rol, institucionId, activo, search } = request.query;

            const pagination = {};
            if (page)
                pagination.page = parseInt(page, 10);
            if (limit)
                pagination.limit = parseInt(limit, 10);

            const filters = {};
            if (rol)
                filters.rol = rol;
            if (institucionId)
                filters.institucionId = institucionId;
            if (activo !== undefined)
                filters.activo = activo === 'true';
            if (search)
                filters.search = search;
            const result = await user_service_1.default.getAllUsers(pagination, filters);
            return reply.code(200).send({
                success: true,
                data: result.data,
                pagination: result.pagination,
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async getUserById(request, reply) {
        try {
            const { id } = request.params;
            const user = await user_service_1.default.getUserById(id);
            if (!user) {
                throw new types_1.NotFoundError('Usuario');
            }
            return reply.code(200).send({
                success: true,
                data: user,
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async getUsersByRole(request, reply) {
        try {
            const { role } = request.params;
            const { page, limit, institucionId, activo, search } = request.query;

            const pagination = {};
            if (page)
                pagination.page = parseInt(page, 10);
            if (limit)
                pagination.limit = parseInt(limit, 10);

            const filters = {};
            if (institucionId)
                filters.institucionId = institucionId;
            if (activo !== undefined)
                filters.activo = activo === 'true';
            if (search)
                filters.search = search;
            const result = await user_service_1.default.getUsersByRole(role, pagination, filters);
            return reply.code(200).send({
                success: true,
                data: result.data,
                pagination: result.pagination,
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async getUsersByInstitution(request, reply) {
        try {
            const { institucionId } = request.params;
            const { page, limit, rol, activo, search } = request.query;

            const pagination = {};
            if (page)
                pagination.page = parseInt(page, 10);
            if (limit)
                pagination.limit = parseInt(limit, 10);

            const filters = {};
            if (rol)
                filters.rol = rol;
            if (activo !== undefined)
                filters.activo = activo === 'true';
            if (search)
                filters.search = search;
            const result = await user_service_1.default.getUsersByInstitution(institucionId, pagination, filters);
            return reply.code(200).send({
                success: true,
                data: result.data,
                pagination: result.pagination,
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async createUser(request, reply) {
        try {
            const userData = request.body;
            const invokerRole = request.user?.rol;
            if (!invokerRole) {
                throw new Error('Usuario no autenticado');
            }
            const result = await user_service_1.default.createUser(userData, invokerRole);
            return reply.code(201).send({
                success: true,
                data: result,
                message: 'Usuario creado exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async updateUser(request, reply) {
        try {
            const { id } = request.params;
            const userData = request.body;
            const result = await user_service_1.default.updateUser(id, userData);
            if (!result) {
                throw new types_1.NotFoundError('Usuario');
            }
            return reply.code(200).send({
                success: true,
                data: result,
                message: 'Usuario actualizado exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async deleteUser(request, reply) {
        try {
            const { id } = request.params;
            const result = await user_service_1.default.deleteUser(id);
            return reply.code(200).send({
                success: true,
                data: { deleted: result },
                message: 'Usuario eliminado exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }
}
exports.UserController = UserController;
exports.default = UserController;

/* Fin backend\dist\controllers\user.controller.js */

/* Inicio backend\dist\index.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cors_1 = __importDefault(require("@fastify/cors"));
const formbody_1 = __importDefault(require("@fastify/formbody"));
const fastify_1 = __importDefault(require("fastify"));
const app_1 = require("./config/app");
const database_1 = require("./config/database");
const errorHandler_1 = __importDefault(require("./middleware/errorHandler"));
const routes_1 = __importDefault(require("./routes"));
const auth_service_1 = __importDefault(require("./services/auth.service"));
const fastify = (0, fastify_1.default)({
    logger: app_1.config.nodeEnv === 'development',
});
fastify.register(cors_1.default, {
    origin: true, // Permite cualquier origen
    credentials: true, // Permite el envÃ­o de cookies y credenciales
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization'],
});
fastify.register(formbody_1.default);

(0, errorHandler_1.default)(fastify);
fastify.register(routes_1.default);
const start = async () => {
    try {
        console.log('ðŸš€ Iniciando AsistApp Backend v2.0...');
        await database_1.databaseService.connect();
        await auth_service_1.default.ensureAdminUser();
        console.log('ðŸŒ Iniciando servidor...');
        await fastify.listen({
            port: app_1.config.port,
            host: app_1.config.host
        });
        console.log('âœ… Servidor corriendo en:');
        console.log(`   - Local:   http://localhost:${app_1.config.port}`);
        console.log(`   - Red:     http://192.168.20.22:${app_1.config.port}`);
        console.log('ðŸŽ¯ API lista para recibir conexiones');
        console.log('ðŸ“š DocumentaciÃ³n disponible en las URLs anteriores');
        if (app_1.config.nodeEnv === 'production') {
            setInterval(() => {
                console.log('ðŸ’“ Servidor activo...');
            }, 300000)
        }
    }
    catch (err) {
        console.error('âŒ Error al iniciar servidor:', err);
        fastify.log.error(err);
        process.exit(1);
    }
};
process.on('SIGINT', async () => {
    console.log('\nðŸ›‘ Recibida seÃ±al SIGINT, cerrando servidor...');
});
process.on('SIGTERM', async () => {
    console.log('\nðŸ›‘ Recibida seÃ±al SIGTERM, cerrando servidor...');
    await gracefulShutdown();
});
const gracefulShutdown = async () => {
    try {
        console.log('ï¿½ Cerrando conexiones...');
        await fastify.close();
        await database_1.databaseService.disconnect();
        console.log('âœ… Servidor cerrado correctamente');
        process.exit(0);
    }
    catch (error) {
        console.error('âŒ Error durante el cierre:', error);
        process.exit(1);
    }
};
process.on('uncaughtException', (err) => {
    console.error('âŒ Uncaught Exception:', err);
    process.exit(1);
});
process.on('unhandledRejection', (reason, promise) => {
    console.error('âŒ Unhandled Rejection at:', promise, 'reason:', reason);
    process.exit(1);
});
start();
exports.default = fastify;

/* Fin backend\dist\index.js */

/* Inicio backend\dist\middleware\auth.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.optionalAuthenticate = exports.authorize = exports.authenticate = void 0;
const auth_service_1 = __importDefault(require("../services/auth.service"));
const types_1 = require("../types");

const authenticate = async (request, reply) => {
    try {
        const authHeader = request.headers.authorization;
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            throw new types_1.AuthenticationError('Token de autenticaciÃ³n requerido');
        }
        const token = authHeader.substring(7)
        if (!token) {
            throw new types_1.AuthenticationError('Token de autenticaciÃ³n requerido');
        }
        const decoded = await auth_service_1.default.verifyToken(token);
        request.user = decoded;
    }
    catch (error) {
        if (error instanceof types_1.AuthenticationError) {
            return reply.code(error.statusCode).send({
                success: false,
                error: error.message,
                code: error.code,
            });
        }
        if (error instanceof Error && (error.message.includes('invÃ¡lido') || error.message.includes('expirado'))) {
            return reply.code(401).send({
                success: false,
                error: 'Token de autenticaciÃ³n invÃ¡lido',
                code: 'AUTHENTICATION_ERROR',
            });
        }
        throw error;
    }
};
exports.authenticate = authenticate;

const authorize = (allowedRoles) => {
    return async (request, reply) => {
        try {
            if (!request.user) {
                throw new types_1.AuthenticationError('Usuario no autenticado');
            }
            if (!allowedRoles.includes(request.user.rol)) {
                throw new types_1.AuthorizationError('Acceso denegado: rol insuficiente');
            }
        }
        catch (error) {
            if (error instanceof types_1.AuthenticationError || error instanceof types_1.AuthorizationError) {
                return reply.code(error.statusCode).send({
                    success: false,
                    error: error.message,
                    code: error.code,
                });
            }
            throw error;
        }
    };
};
exports.authorize = authorize;

const optionalAuthenticate = async (request, reply) => {
    try {
        const authHeader = request.headers.authorization;
        if (authHeader && authHeader.startsWith('Bearer ')) {
            const token = authHeader.substring(7);
            if (token) {
                const decoded = await auth_service_1.default.verifyToken(token);
                request.user = decoded;
            }
        }
    }
    catch (error) {
        console.warn('Error en autenticaciÃ³n opcional:', error);
    }
};
exports.optionalAuthenticate = optionalAuthenticate;
exports.default = {
    authenticate: exports.authenticate,
    authorize: exports.authorize,
    optionalAuthenticate: exports.optionalAuthenticate,
};

/* Fin backend\dist\middleware\auth.js */

/* Inicio backend\dist\middleware\errorHandler.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupErrorHandler = void 0;
const types_1 = require("../types");

const setupErrorHandler = (fastify) => {
    fastify.setErrorHandler((error, request, reply) => {
        fastify.log.error(error);
        if (error instanceof types_1.AppError) {
            return reply.code(error.statusCode).send({
                success: false,
                error: error.message,
                code: error.code,
            });
        }
        if ('validation' in error && error.validation) {
            return reply.code(400).send({
                success: false,
                error: 'Datos de entrada invÃ¡lidos',
                code: 'VALIDATION_ERROR',
                details: error.validation,
            });
        }
        if (error instanceof Error && 'code' in error && typeof error.code === 'string') {
            const prismaError = error;
            if ('code' in prismaError) {
                if (prismaError.code === 'P2003') {
                    return reply.code(400).send({
                        success: false,
                        error: 'Datos de referencia invÃ¡lidos',
                        code: 'FOREIGN_KEY_ERROR',
                    });
                }
                if (prismaError.code === 'P2002') {
                    return reply.code(409).send({
                        success: false,
                        error: 'El registro ya existe',
                        code: 'UNIQUE_CONSTRAINT_ERROR',
                    });
                }
                if (prismaError.code === 'P2025') {
                    return reply.code(404).send({
                        success: false,
                        error: 'Registro no encontrado',
                        code: 'NOT_FOUND_ERROR',
                    });
                }
                if (prismaError.code === 'P2000' || prismaError.code === 'P2001') {
                    return reply.code(400).send({
                        success: false,
                        error: 'Datos invÃ¡lidos',
                        code: 'VALIDATION_ERROR',
                    });
                }
            }
        }
        if (error.message) {
            let statusCode = 500;
            let code = 'INTERNAL_ERROR';
            if (error.message.includes('Credenciales invÃ¡lidas') || error.message.includes('Usuario inactivo')) {
                statusCode = 401;
                code = 'AUTHENTICATION_ERROR';
            }
            else if (error.message.includes('Refresh token') || error.message.includes('Token invÃ¡lido')) {
                statusCode = 401;
                code = 'AUTHENTICATION_ERROR';
            }
            else if (error.message.includes('Acceso denegado')) {
                statusCode = 403;
                code = 'AUTHORIZATION_ERROR';
            }
            else if (error.message.includes('no encontrado')) {
                statusCode = 404;
                code = 'NOT_FOUND_ERROR';
            }
            return reply.code(statusCode).send({
                success: false,
                error: error.message,
                code,
            });
        }
        return reply.code(500).send({
            success: false,
            error: 'Error interno del servidor',
            code: 'INTERNAL_ERROR',
        });
    });
    fastify.setNotFoundHandler((request, reply) => {
        return reply.code(404).send({
            success: false,
            error: 'Ruta no encontrada',
            code: 'NOT_FOUND_ERROR',
        });
    });
};
exports.setupErrorHandler = setupErrorHandler;
exports.default = exports.setupErrorHandler;

/* Fin backend\dist\middleware\errorHandler.js */

/* Inicio backend\dist\routes\admin-institucion.routes.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = adminInstitucionRoutes;
const admin_institucion_controller_1 = __importDefault(require("../controllers/admin-institucion.controller"));
const auth_1 = require("../middleware/auth");
async function adminInstitucionRoutes(fastify) {
    fastify.register(async function (adminInstitucionRoutes) {
        adminInstitucionRoutes.addHook('preHandler', auth_1.authenticate);
        adminInstitucionRoutes.addHook('preHandler', (0, auth_1.authorize)(['super_admin']));
        adminInstitucionRoutes.get('/', {
            handler: admin_institucion_controller_1.default.getAll,
        });
        adminInstitucionRoutes.get('/:id', {
            handler: admin_institucion_controller_1.default.getById,
        });
        adminInstitucionRoutes.post('/', {
            handler: admin_institucion_controller_1.default.create,
        });
        adminInstitucionRoutes.put('/:id', {
            handler: admin_institucion_controller_1.default.update,
        });
        adminInstitucionRoutes.delete('/:id', {
            handler: admin_institucion_controller_1.default.delete,
        });
    });
}

/* Fin backend\dist\routes\admin-institucion.routes.js */

/* Inicio backend\dist\routes\auth.routes.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = authRoutes;
const auth_controller_1 = __importDefault(require("../controllers/auth.controller"));
const auth_1 = require("../middleware/auth");
async function authRoutes(fastify) {
    fastify.register(async function (authRoutes) {
        authRoutes.post('/login', {
            handler: auth_controller_1.default.login,
        });
        authRoutes.post('/login-test', {
            handler: auth_controller_1.default.login,
        });
        authRoutes.get('/verify', {
            preHandler: auth_1.authenticate,
            handler: auth_controller_1.default.verify,
        });
        authRoutes.get('/instituciones', {
            preHandler: auth_1.authenticate,
            handler: auth_controller_1.default.getUserInstitutions,
        });
        authRoutes.post('/logout', {
            preHandler: auth_1.authenticate,
            handler: auth_controller_1.default.logout,
        });
        authRoutes.post('/refresh', {
            config: {
                rateLimit: {
                    max: 10,
                    timeWindow: '15 minutes',
                },
            },
            handler: auth_controller_1.default.refreshToken,
        });
    });
}

/* Fin backend\dist\routes\auth.routes.js */

/* Inicio backend\dist\routes\index.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = routes;
const admin_institucion_routes_1 = __importDefault(require("./admin-institucion.routes"));
const auth_routes_1 = __importDefault(require("./auth.routes"));
const institucion_routes_1 = __importDefault(require("./institucion.routes"));
const institution_admin_routes_1 = __importDefault(require("./institution-admin.routes"));
const user_routes_1 = __importDefault(require("./user.routes"));
async function routes(fastify) {
    fastify.get('/', async (request, reply) => {
        return {
            success: true,
            message: 'Hola Mundo desde AsistApp Backend v2.0!',
            timestamp: new Date().toISOString(),
        };
    });
    fastify.get('/health', async (request, reply) => {
        return reply.code(200).send({
            success: true,
            status: 'healthy',
            timestamp: new Date().toISOString(),
            services: {
                server: 'running'
            },
            uptime: process.uptime()
        });
    });
    fastify.get('/test', async (request, reply) => {
        return reply.code(200).send({
            success: true,
            data: {
                accessToken: 'test_token',
                refreshToken: 'test_refresh_token',
                expiresIn: 86400,
                usuario: {
                    id: 'test_id',
                    nombres: 'Test',
                    apellidos: 'User',
                    rol: 'estudiante',
                    institucionId: null,
                    institucion: null
                }
            }
        });
    });
    await fastify.register(auth_routes_1.default, { prefix: '/auth' });
    await fastify.register(user_routes_1.default, { prefix: '/usuarios' });
    await fastify.register(admin_institucion_routes_1.default, { prefix: '/admin-institucion' });
    await fastify.register(institution_admin_routes_1.default, { prefix: '/institution-admin' });
    await fastify.register(institucion_routes_1.default, { prefix: '/instituciones' });
}

/* Fin backend\dist\routes\index.js */

/* Inicio backend\dist\routes\institucion.routes.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = institucionRoutes;
const institucion_controller_1 = __importDefault(require("../controllers/institucion.controller"));
const auth_1 = require("../middleware/auth");
async function institucionRoutes(fastify) {
    fastify.register(async function (institucionRoutes) {
        institucionRoutes.addHook('preHandler', auth_1.authenticate);
        institucionRoutes.addHook('preHandler', (0, auth_1.authorize)(['super_admin']));
        institucionRoutes.get('/', {
            handler: institucion_controller_1.default.getAll,
        });
        institucionRoutes.get('/:id', {
            handler: institucion_controller_1.default.getById,
        });
        institucionRoutes.post('/', {
            handler: institucion_controller_1.default.create,
        });
        institucionRoutes.put('/:id', {
            handler: institucion_controller_1.default.update,
        });
        institucionRoutes.delete('/:id', {
            handler: institucion_controller_1.default.delete,
        });
    });
}

/* Fin backend\dist\routes\institucion.routes.js */

/* Inicio backend\dist\routes\institution-admin.routes.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = institutionAdminRoutes;
const institution_admin_controller_1 = __importDefault(require("../controllers/institution-admin.controller"));
const auth_1 = require("../middleware/auth");

async function institutionAdminRoutes(fastify) {

    fastify.addHook('preHandler', auth_1.authenticate);
    fastify.addHook('preHandler', (0, auth_1.authorize)(['admin_institucion']));

    fastify.get('/profesores', institution_admin_controller_1.default.getAllProfesores);

    fastify.get('/profesores/:id', institution_admin_controller_1.default.getProfesorById);

    fastify.post('/profesores', institution_admin_controller_1.default.createProfesor);

    fastify.put('/profesores/:id', institution_admin_controller_1.default.updateProfesor);

    fastify.delete('/profesores/:id', institution_admin_controller_1.default.deleteProfesor);

    fastify.patch('/profesores/:id/toggle-status', institution_admin_controller_1.default.toggleProfesorStatus);

}

/* Fin backend\dist\routes\institution-admin.routes.js */

/* Inicio backend\dist\routes\user.routes.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = userRoutes;
const user_controller_1 = __importDefault(require("../controllers/user.controller"));
const auth_1 = require("../middleware/auth");

async function userRoutes(fastify) {

    fastify.addHook('preHandler', auth_1.authenticate);

    fastify.get('/', {
        preHandler: (0, auth_1.authorize)(['super_admin']),
        handler: user_controller_1.default.getAllUsers,
    });

    fastify.get('/:id', user_controller_1.default.getUserById);

    fastify.get('/rol/:role', user_controller_1.default.getUsersByRole);

    fastify.get('/institucion/:institucionId', user_controller_1.default.getUsersByInstitution);

    fastify.post('/', {
        preHandler: (0, auth_1.authorize)(['super_admin', 'admin_institucion']),
        handler: user_controller_1.default.createUser,
    });

    fastify.put('/:id', {
        preHandler: (0, auth_1.authorize)(['super_admin', 'admin_institucion']),
        handler: user_controller_1.default.updateUser,
    });

    fastify.delete('/:id', {
        preHandler: (0, auth_1.authorize)(['super_admin', 'admin_institucion']),
        handler: user_controller_1.default.deleteUser,
    });

}

/* Fin backend\dist\routes\user.routes.js */

/* Inicio backend\dist\scripts\cleanup-tokens.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const database_1 = require("../config/database");

async function cleanupExpiredRefreshTokens() {
    try {
        console.log('ðŸ§¹ Iniciando limpieza de refresh tokens expirados...');
        const prisma = database_1.databaseService.getClient();
        const result = await prisma.refreshToken.deleteMany({
            where: {
                OR: [
                    { expiresAt: { lt: new Date() } }, // Expirados
                    { revoked: true }, // Revocados
                ],
            },
        });
        console.log(`âœ… Eliminados ${result.count} refresh tokens expirados/revocados`);
        const remainingTokens = await prisma.refreshToken.count();
        console.log(`ðŸ“Š Tokens restantes en DB: ${remainingTokens}`);
    }
    catch (error) {
        console.error('âŒ Error durante la limpieza:', error);
        process.exit(1);
    }
    finally {
        await database_1.databaseService.disconnect();
    }
}
if (require.main === module) {
    cleanupExpiredRefreshTokens();
}
exports.default = cleanupExpiredRefreshTokens;

/* Fin backend\dist\scripts\cleanup-tokens.js */

/* Inicio backend\dist\services\admin-institucion.service.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AdminInstitucionService = void 0;
const bcryptjs_1 = __importDefault(require("bcryptjs"));
const database_1 = require("../config/database");
const types_1 = require("../types");
class AdminInstitucionService {

    static async getAll(pagination) {
        try {
            const page = pagination?.page || 1;
            const limit = pagination?.limit || 20;
            const skip = (page - 1) * limit;

            const total = await database_1.prisma.usuario.count({
                where: { rol: 'admin_institucion' },
            });

            const admins = await database_1.prisma.usuario.findMany({
                where: { rol: 'admin_institucion' },
                include: {
                    usuarioInstituciones: {
                        where: { activo: true },
                        include: {
                            institucion: true,
                        },
                    },
                },
                orderBy: {
                    createdAt: 'desc',
                },
                skip,
                take: limit,
            });
            const totalPages = Math.ceil(total / limit);
            const data = admins.map((admin) => ({
                id: admin.id,
                email: admin.email,
                nombres: admin.nombres,
                apellidos: admin.apellidos,
                telefono: admin.telefono,
                activo: admin.activo,
                institucion: admin.usuarioInstituciones[0] ? {
                    id: admin.usuarioInstituciones[0].institucion.id,
                    nombre: admin.usuarioInstituciones[0].institucion.nombre,
                } : { id: '', nombre: '' },
                createdAt: admin.createdAt.toISOString(),
                updatedAt: admin.updatedAt.toISOString(),
            }));
            return {
                data,
                pagination: {
                    page,
                    limit,
                    total,
                    totalPages,
                    hasNext: page < totalPages,
                    hasPrev: page > 1,
                },
            };
        }
        catch (error) {
            console.error('Error al obtener admins de instituciÃ³n:', error);
            throw error;
        }
    }

    static async getById(id) {
        try {
            const admin = await database_1.prisma.usuario.findFirst({
                where: {
                    id,
                    rol: 'admin_institucion',
                },
                include: {
                    usuarioInstituciones: {
                        where: { activo: true },
                        include: {
                            institucion: true,
                        },
                    },
                },
            });
            if (!admin) {
                return null;
            }
            return {
                id: admin.id,
                email: admin.email,
                nombres: admin.nombres,
                apellidos: admin.apellidos,
                telefono: admin.telefono,
                activo: admin.activo,
                institucion: admin.usuarioInstituciones[0] ? {
                    id: admin.usuarioInstituciones[0].institucion.id,
                    nombre: admin.usuarioInstituciones[0].institucion.nombre,
                } : { id: '', nombre: '' },
                createdAt: admin.createdAt.toISOString(),
                updatedAt: admin.updatedAt.toISOString(),
            };
        }
        catch (error) {
            console.error(`Error al obtener admin de instituciÃ³n ${id}:`, error);
            throw error;
        }
    }

    static async create(data) {
        try {

            if (!data.email || !data.password || !data.nombres || !data.apellidos || !data.institucionId) {
                throw new types_1.ValidationError('Campos requeridos faltantes');
            }

            const institucion = await database_1.prisma.institucion.findUnique({
                where: { id: data.institucionId },
            });
            if (!institucion) {
                throw new types_1.ValidationError('InstituciÃ³n no encontrada');
            }

            const existingAdmin = await database_1.prisma.usuarioInstitucion.findFirst({
                where: {
                    institucionId: data.institucionId,
                    rolEnInstitucion: 'admin',
                    activo: true,
                },
            });
            if (existingAdmin) {
                throw new types_1.ConflictError('Ya existe un admin para esta instituciÃ³n');
            }

            const emailExists = await database_1.prisma.usuario.findUnique({
                where: { email: data.email.toLowerCase() },
            });
            if (emailExists) {
                throw new types_1.ConflictError('El email ya estÃ¡ registrado');
            }

            const hashedPassword = await bcryptjs_1.default.hash(data.password, 10);

            const result = await database_1.prisma.$transaction(async (tx) => {
                const admin = await tx.usuario.create({
                    data: {
                        email: data.email.toLowerCase(),
                        passwordHash: hashedPassword,
                        nombres: data.nombres,
                        apellidos: data.apellidos,
                        rol: 'admin_institucion',
                        telefono: data.telefono,
                    },
                });
                await tx.usuarioInstitucion.create({
                    data: {
                        usuarioId: admin.id,
                        institucionId: data.institucionId,
                        rolEnInstitucion: 'admin',
                    },
                });
                return admin;
            });

            return await this.getById(result.id);
        }
        catch (error) {
            console.error('Error al crear admin de instituciÃ³n:', error);
            throw error;
        }
    }

    static async update(id, data) {
        try {

            const existingAdmin = await this.getById(id);
            if (!existingAdmin) {
                throw new types_1.ValidationError('Admin de instituciÃ³n no encontrado');
            }

            if (data.email && data.email !== existingAdmin.email) {
                const emailExists = await database_1.prisma.usuario.findUnique({
                    where: { email: data.email.toLowerCase() },
                });
                if (emailExists) {
                    throw new types_1.ConflictError('El email ya estÃ¡ registrado');
                }
            }

            await database_1.prisma.usuario.update({
                where: { id },
                data: {
                    email: data.email?.toLowerCase(),
                    nombres: data.nombres,
                    apellidos: data.apellidos,
                    telefono: data.telefono,
                    activo: data.activo,
                },
            });
            return await this.getById(id);
        }
        catch (error) {
            console.error(`Error al actualizar admin de instituciÃ³n ${id}:`, error);
            throw error;
        }
    }

    static async delete(id) {
        try {
            const existingAdmin = await this.getById(id);
            if (!existingAdmin) {
                throw new types_1.ValidationError('Admin de instituciÃ³n no encontrado');
            }
            await database_1.prisma.usuario.update({
                where: { id },
                data: { activo: false },
            });
            return true;
        }
        catch (error) {
            console.error(`Error al eliminar admin de instituciÃ³n ${id}:`, error);
            throw error;
        }
    }

    static async isAdminOfInstitution(userId, institucionId) {
        try {
            const relacion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: {
                    usuarioId: userId,
                    institucionId,
                    rolEnInstitucion: 'admin',
                    activo: true,
                },
            });
            return !!relacion;
        }
        catch (error) {
            console.error(`Error al verificar admin de instituciÃ³n ${userId}:`, error);
            return false;
        }
    }
}
exports.AdminInstitucionService = AdminInstitucionService;
exports.default = AdminInstitucionService;

/* Fin backend\dist\services\admin-institucion.service.js */

/* Inicio backend\dist\services\auth.service.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthService = void 0;
const bcryptjs_1 = __importDefault(require("bcryptjs"));
const crypto_1 = __importDefault(require("crypto"));
const database_1 = require("../config/database");
const jwt_1 = __importDefault(require("../config/jwt"));
const types_1 = require("../types");
class AuthService {

    static async login(credentials) {
        const { email, password } = credentials;
        const usuario = await database_1.prisma.usuario.findUnique({
            where: { email },
            include: {
                usuarioInstituciones: {
                    where: { activo: true },
                    include: {
                        institucion: true,
                    },
                },
            },
        });
        if (!usuario) {
            throw new types_1.AuthenticationError('Credenciales invÃ¡lidas');
        }
        if (!usuario.activo) {
            throw new types_1.AuthenticationError('Usuario inactivo');
        }
        const passwordMatch = await bcryptjs_1.default.compare(password, usuario.passwordHash);
        if (!passwordMatch) {
            throw new types_1.AuthenticationError('Credenciales invÃ¡lidas');
        }
        const accessToken = jwt_1.default.signAccessToken({
            id: usuario.id,
            rol: usuario.rol,
            email: usuario.email,
            tokenVersion: usuario.tokenVersion,
        });
        const refreshToken = jwt_1.default.signRefreshToken({
            id: usuario.id,
            rol: usuario.rol,
            email: usuario.email,
            tokenVersion: usuario.tokenVersion,
        });
        try {
            const decodedRefresh = jwt_1.default.decode(refreshToken);
            const exp = decodedRefresh?.exp
            const expiresAt = exp ? new Date(exp * 1000) : new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);
            const hashed = crypto_1.default.createHash('sha256').update(refreshToken).digest('hex');
            await database_1.prisma.refreshToken.create({
                data: {
                    usuarioId: usuario.id,
                    token: hashed,
                    expiresAt,
                },
            });
        }
        catch (err) {
            console.warn('No se pudo guardar refresh token en DB:', err);
        }
        const expiresIn = 24 * 60 * 60
        return {
            accessToken,
            refreshToken,
            usuario: {
                id: usuario.id,
                nombres: usuario.nombres,
                apellidos: usuario.apellidos,
                rol: usuario.rol,
                instituciones: usuario.usuarioInstituciones.map((ui) => ({
                    id: ui.institucion.id,
                    nombre: ui.institucion.nombre,
                    rolEnInstitucion: ui.rolEnInstitucion,
                })),
            },
            expiresIn,
        };
    }

    static async verifyToken(token) {
        const decoded = jwt_1.default.verify(token);
        const usuario = await database_1.prisma.usuario.findUnique({
            where: { id: decoded.id },
            select: { tokenVersion: true, activo: true },
        });
        if (!usuario || !usuario.activo) {
            throw new types_1.AuthenticationError('Usuario no encontrado o inactivo');
        }
        if (usuario.tokenVersion !== decoded.tokenVersion) {
            throw new types_1.AuthenticationError('Token revocado por cambio de versiÃ³n');
        }
        return decoded;
    }

    static async refreshToken(refreshToken) {
        try {
            const decoded = jwt_1.default.verifyRefreshToken(refreshToken);
            const hashed = crypto_1.default.createHash('sha256').update(refreshToken).digest('hex');
            const tokenRecord = await database_1.prisma.refreshToken.findFirst({
                where: {
                    usuarioId: decoded.id,
                    token: hashed,
                    revoked: false,
                },
            });
            if (!tokenRecord) {
                throw new types_1.AuthenticationError('Refresh token invÃ¡lido o revocado');
            }
            if (tokenRecord.expiresAt <= new Date()) {
                await database_1.prisma.refreshToken.update({ where: { id: tokenRecord.id }, data: { revoked: true } });
                throw new types_1.AuthenticationError('Refresh token expirado');
            }
            const usuario = await database_1.prisma.usuario.findUnique({
                where: { id: decoded.id },
                include: {
                    usuarioInstituciones: {
                        where: { activo: true },
                        include: {
                            institucion: true,
                        },
                    },
                },
            });
            if (!usuario || !usuario.activo) {
                throw new types_1.AuthenticationError('Usuario no encontrado o inactivo');
            }
            if (usuario.tokenVersion !== decoded.tokenVersion) {
                throw new types_1.AuthenticationError('Refresh token revocado por cambio de versiÃ³n');
            }
            await database_1.prisma.refreshToken.update({ where: { id: tokenRecord.id }, data: { revoked: true } });
            const newAccessToken = jwt_1.default.signAccessToken({
                id: usuario.id,
                rol: usuario.rol,
                email: usuario.email,
                tokenVersion: usuario.tokenVersion,
            });
            const newRefreshToken = jwt_1.default.signRefreshToken({
                id: usuario.id,
                rol: usuario.rol,
                email: usuario.email,
                tokenVersion: usuario.tokenVersion,
            });
            try {
                const decodedNew = jwt_1.default.decode(newRefreshToken);
                const exp = decodedNew?.exp;
                const expiresAt = exp ? new Date(exp * 1000) : new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);
                const hashedNew = crypto_1.default.createHash('sha256').update(newRefreshToken).digest('hex');
                await database_1.prisma.refreshToken.create({
                    data: {
                        usuarioId: usuario.id,
                        token: hashedNew,
                        expiresAt,
                    },
                });
            }
            catch (err) {
                console.warn('No se pudo guardar nuevo refresh token en DB:', err);
            }
            const expiresIn = 24 * 60 * 60
            return {
                accessToken: newAccessToken,
                refreshToken: newRefreshToken,
                expiresIn,
            };
        }
        catch (error) {
            if (error instanceof types_1.AuthenticationError) {
                throw error;
            }
            throw new types_1.AuthenticationError(error instanceof Error ? error.message : 'Refresh token invÃ¡lido');
        }
    }

    static async revokeRefreshTokens(usuarioId, refreshToken) {
        if (refreshToken) {
            const hashed = crypto_1.default.createHash('sha256').update(refreshToken).digest('hex');
            await database_1.prisma.refreshToken.updateMany({ where: { usuarioId, token: hashed }, data: { revoked: true } });
            return;
        }
        await database_1.prisma.refreshToken.updateMany({ where: { usuarioId, revoked: false }, data: { revoked: true } });
    }

    static async revokeAllUserTokens(usuarioId) {
        await database_1.prisma.usuario.update({
            where: { id: usuarioId },
            data: { tokenVersion: { increment: 1 } },
        });
    }

    static async hashPassword(password) {
        const saltRounds = 10;
        return bcryptjs_1.default.hash(password, saltRounds);
    }

    static async ensureAdminUser() {
        try {
            console.log('ðŸ” Verificando usuario administrador...');
            const adminExists = await database_1.prisma.usuario.findUnique({
                where: { email: 'admin@asistapp.com' }
            });
            if (!adminExists) {
                console.log('âš ï¸ No se encontrÃ³ usuario administrador. Creando usuario por defecto...');
                const adminPassword = await this.hashPassword('pollo');
                const admin = await database_1.prisma.usuario.create({
                    data: {
                        email: 'admin@asistapp.com',
                        passwordHash: adminPassword,
                        nombres: 'Administrador',
                        apellidos: 'Sistema',
                        rol: 'super_admin',
                        activo: true,
                    },
                });
                console.log('âœ… Usuario administrador creado exitosamente:', admin.email);
            }
            else {
                console.log('âœ… Usuario administrador ya existe:', adminExists.email);
            }
        }
        catch (error) {
            console.error('âŒ Error al verificar/crear usuario administrador:', error);
            throw error;
        }
    }
}
exports.AuthService = AuthService;
exports.default = AuthService;

/* Fin backend\dist\services\auth.service.js */

/* Inicio backend\dist\services\institucion.service.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstitucionService = void 0;
const database_1 = require("../config/database");
const types_1 = require("../types");
class InstitucionService {

    static async getAllInstitutions(pagination, filters) {
        try {
            const page = pagination?.page || 1;
            const limit = pagination?.limit || 10;
            const skip = (page - 1) * limit;

            const where = {};
            if (filters?.activa !== undefined) {
                where.activa = filters.activa;
            }
            if (filters?.search) {
                where.OR = [
                    { nombre: { contains: filters.search, mode: 'insensitive' } },

                    { email: { contains: filters.search, mode: 'insensitive' } },
                ];
            }

            const total = await database_1.prisma.institucion.count({ where });

            const institutions = await database_1.prisma.institucion.findMany({
                orderBy: {
                    createdAt: 'desc',
                },
                skip,
                take: limit,
                where,
            });
            const totalPages = Math.ceil(total / limit);
            const data = institutions.map((inst) => ({
                id: inst.id,
                nombre: inst.nombre,
                direccion: inst.direccion,
                telefono: inst.telefono,
                email: inst.email,
                activa: inst.activa,
                createdAt: inst.createdAt.toISOString(),
                updatedAt: inst.updatedAt.toISOString(),
            }));
            const result = {
                data,
                pagination: {
                    page,
                    limit,
                    total,
                    totalPages,
                    hasNext: page < totalPages,
                    hasPrev: page > 1,
                },
            };
            return result;
        }
        catch (error) {
            console.error('Error al obtener todas las instituciones:', error);
            throw error;
        }
    }

    static async getInstitutionById(id) {
        try {
            if (!id || typeof id !== 'string') {
                throw new types_1.ValidationError('ID de instituciÃ³n invÃ¡lido');
            }
            const institution = await database_1.prisma.institucion.findUnique({
                where: { id },
            });
            if (!institution) {
                return null;
            }
            return {
                id: institution.id,
                nombre: institution.nombre,
                direccion: institution.direccion,
                telefono: institution.telefono,
                email: institution.email,
                activa: institution.activa,
                createdAt: institution.createdAt.toISOString(),
                updatedAt: institution.updatedAt.toISOString(),
            };
        }
        catch (error) {
            console.error(`Error al obtener instituciÃ³n con ID ${id}:`, error);
            throw error;
        }
    }

    static async createInstitution(data) {
        try {

            if (!data.nombre) {
                throw new types_1.ValidationError('Nombre es requerido');
            }
            const institution = await database_1.prisma.institucion.create({
                data: {
                    nombre: data.nombre,
                    direccion: data.direccion,
                    telefono: data.telefono,
                    email: data.email,
                },
            });
            return {
                id: institution.id,
                nombre: institution.nombre,
                direccion: institution.direccion,
                telefono: institution.telefono,
                email: institution.email,
                activa: institution.activa,
                createdAt: institution.createdAt.toISOString(),
                updatedAt: institution.updatedAt.toISOString(),
            };
        }
        catch (error) {
            console.error('Error al crear instituciÃ³n:', error);
            throw error;
        }
    }

    static async updateInstitution(id, data) {
        try {
            if (!id || typeof id !== 'string') {
                throw new types_1.ValidationError('ID de instituciÃ³n invÃ¡lido');
            }

            const existingInstitution = await this.getInstitutionById(id);
            if (!existingInstitution) {
                throw new types_1.ValidationError('InstituciÃ³n no encontrada');
            }
            const institution = await database_1.prisma.institucion.update({
                where: { id },
                data: {
                    nombre: data.nombre,
                    direccion: data.direccion,
                    telefono: data.telefono,
                    email: data.email,
                    activa: data.activa,
                },
            });
            return {
                id: institution.id,
                nombre: institution.nombre,
                direccion: institution.direccion,
                telefono: institution.telefono,
                email: institution.email,
                activa: institution.activa,
                createdAt: institution.createdAt.toISOString(),
                updatedAt: institution.updatedAt.toISOString(),
            };
        }
        catch (error) {
            console.error(`Error al actualizar instituciÃ³n con ID ${id}:`, error);
            throw error;
        }
    }

    static async deleteInstitution(id) {
        try {
            if (!id || typeof id !== 'string') {
                throw new types_1.ValidationError('ID de instituciÃ³n invÃ¡lido');
            }

            const existingInstitution = await this.getInstitutionById(id);
            if (!existingInstitution) {
                throw new types_1.ValidationError('InstituciÃ³n no encontrada');
            }

            const usuariosCount = await database_1.prisma.usuarioInstitucion.count({
                where: { institucionId: id, activo: true },
            });
            if (usuariosCount > 0) {
                throw new types_1.ConflictError('No se puede eliminar la instituciÃ³n porque tiene usuarios activos asociados');
            }
            await database_1.prisma.institucion.delete({
                where: { id },
            });
            return true;
        }
        catch (error) {
            console.error(`Error al eliminar instituciÃ³n con ID ${id}:`, error);
            throw error;
        }
    }
}
exports.InstitucionService = InstitucionService;
exports.default = InstitucionService;

/* Fin backend\dist\services\institucion.service.js */

/* Inicio backend\dist\services\profesor.service.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProfesorService = void 0;
const client_1 = require("@prisma/client");
const bcryptjs_1 = __importDefault(require("bcryptjs"));
const types_1 = require("../types");
const prisma = new client_1.PrismaClient();

class ProfesorService {

    static async getAll(institucionId, pagination, filters) {
        const page = pagination?.page || 1;
        const limit = pagination?.limit || 10;
        const skip = (page - 1) * limit;

        const where = {
            rol: 'profesor',
            usuarioInstituciones: {
                some: {
                    institucionId,
                    activo: true,
                },
            },
        };
        if (filters?.activo !== undefined) {
            where.activo = filters.activo;
        }
        if (filters?.search) {
            where.OR = [
                { nombres: { contains: filters.search, mode: 'insensitive' } },
                { apellidos: { contains: filters.search, mode: 'insensitive' } },
                { email: { contains: filters.search, mode: 'insensitive' } },
            ];
        }

        const total = await prisma.usuario.count({ where });

        const profesores = await prisma.usuario.findMany({
            where,
            skip,
            take: limit,
            include: {
                usuarioInstituciones: {
                    where: {
                        institucionId,
                        activo: true,
                    },
                    include: {
                        institucion: {
                            select: {
                                id: true,
                                nombre: true,
                            },
                        },
                    },
                },
            },
            orderBy: {
                apellidos: 'asc',
            },
        });

        const formattedProfesores = profesores.map((profesor) => ({
            id: profesor.id,
            nombres: profesor.nombres,
            apellidos: profesor.apellidos,
            email: profesor.email,
            telefono: profesor.telefono,
            activo: profesor.activo,
            institucion: profesor.usuarioInstituciones[0]?.institucion,
            createdAt: profesor.createdAt,
        }));
        return {
            data: formattedProfesores,
            pagination: {
                page,
                limit,
                total,
                totalPages: Math.ceil(total / limit),
            },
        };
    }

    static async getById(id, institucionId) {
        const profesor = await prisma.usuario.findFirst({
            where: {
                id,
                rol: 'profesor',
                usuarioInstituciones: {
                    some: {
                        institucionId,
                        activo: true,
                    },
                },
            },
            include: {
                usuarioInstituciones: {
                    where: {
                        institucionId,
                        activo: true,
                    },
                    include: {
                        institucion: {
                            select: {
                                id: true,
                                nombre: true,
                            },
                        },
                    },
                },
            },
        });
        if (!profesor)
            return null;
        return {
            id: profesor.id,
            nombres: profesor.nombres,
            apellidos: profesor.apellidos,
            email: profesor.email,
            telefono: profesor.telefono,
            activo: profesor.activo,
            institucion: profesor.usuarioInstituciones[0]?.institucion,
            createdAt: profesor.createdAt,
        };
    }

    static async create(data, createdBy) {

        const existingUser = await prisma.usuario.findUnique({
            where: { email: data.email },
        });
        if (existingUser) {
            throw new types_1.ValidationError('El email ya estÃ¡ registrado');
        }

        const institucion = await prisma.institucion.findUnique({
            where: { id: data.institucionId },
        });
        if (!institucion) {
            throw new types_1.NotFoundError('InstituciÃ³n');
        }

        const hashedPassword = await bcryptjs_1.default.hash(data.password, 10);

        const newProfesor = await prisma.usuario.create({
            data: {
                email: data.email,
                passwordHash: hashedPassword,
                nombres: data.nombres,
                apellidos: data.apellidos,
                rol: 'profesor',
                activo: true,
            },
        });

        await prisma.usuarioInstitucion.create({
            data: {
                usuarioId: newProfesor.id,
                institucionId: data.institucionId,
                activo: true,
            },
        });

        const profesorWithInstitucion = await this.getById(newProfesor.id, data.institucionId);
        return profesorWithInstitucion;
    }

    static async update(id, institucionId, data) {

        const existingProfesor = await prisma.usuario.findFirst({
            where: {
                id,
                rol: 'profesor',
                usuarioInstituciones: {
                    some: {
                        institucionId,
                        activo: true,
                    },
                },
            },
        });
        if (!existingProfesor) {
            throw new types_1.NotFoundError('Profesor');
        }

        if (data.email && data.email !== existingProfesor.email) {
            const emailExists = await prisma.usuario.findUnique({
                where: { email: data.email },
            });
            if (emailExists) {
                throw new types_1.ValidationError('El email ya estÃ¡ registrado para otro usuario');
            }
        }
        const updatedProfesor = await prisma.usuario.update({
            where: { id },
            data: {
                nombres: data.nombres,
                apellidos: data.apellidos,
                email: data.email,
                activo: data.activo,
            },
            include: {
                usuarioInstituciones: {
                    where: {
                        institucionId,
                        activo: true,
                    },
                    include: {
                        institucion: {
                            select: {
                                id: true,
                                nombre: true,
                            },
                        },
                    },
                },
            },
        });
        return {
            id: updatedProfesor.id,
            nombres: updatedProfesor.nombres,
            apellidos: updatedProfesor.apellidos,
            email: updatedProfesor.email,
            telefono: updatedProfesor.telefono,
            activo: updatedProfesor.activo,
            institucion: updatedProfesor.usuarioInstituciones[0]?.institucion,
            createdAt: updatedProfesor.createdAt,
        };
    }

    static async delete(id, institucionId) {

        const existingProfesor = await prisma.usuario.findFirst({
            where: {
                id,
                rol: 'profesor',
                usuarioInstituciones: {
                    some: {
                        institucionId,
                        activo: true,
                    },
                },
            },
        });
        if (!existingProfesor) {
            return false;
        }

        await prisma.usuario.update({
            where: { id },
            data: { activo: false },
        });
        return true;
    }

    static async toggleStatus(id, institucionId) {

        const existingProfesor = await prisma.usuario.findFirst({
            where: {
                id,
                rol: 'profesor',
                usuarioInstituciones: {
                    some: {
                        institucionId,
                        activo: true,
                    },
                },
            },
        });
        if (!existingProfesor) {
            throw new types_1.NotFoundError('Profesor');
        }
        const updatedProfesor = await prisma.usuario.update({
            where: { id },
            data: { activo: !existingProfesor.activo },
            include: {
                usuarioInstituciones: {
                    where: {
                        institucionId,
                        activo: true,
                    },
                    include: {
                        institucion: {
                            select: {
                                id: true,
                                nombre: true,
                            },
                        },
                    },
                },
            },
        });
        return {
            id: updatedProfesor.id,
            nombres: updatedProfesor.nombres,
            apellidos: updatedProfesor.apellidos,
            email: updatedProfesor.email,
            telefono: updatedProfesor.telefono,
            activo: updatedProfesor.activo,
            institucion: updatedProfesor.usuarioInstituciones[0]?.institucion,
            createdAt: updatedProfesor.createdAt,
        };
    }
}
exports.ProfesorService = ProfesorService;
exports.default = ProfesorService;

/* Fin backend\dist\services\profesor.service.js */

/* Inicio backend\dist\services\user.service.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserService = void 0;
const bcryptjs_1 = __importDefault(require("bcryptjs"));
const crypto_1 = require("crypto");
const database_1 = require("../config/database");
const types_1 = require("../types");
class UserService {

    static async getAllUsers(pagination, filters) {
        try {
            const page = pagination?.page || 1;
            const limit = pagination?.limit || 50
            const skip = (page - 1) * limit;

            const where = {};
            if (filters?.activo !== undefined) {
                where.activo = filters.activo;
            }
            if (filters?.rol) {

                const rolFilter = filters.rol;
                if (Array.isArray(rolFilter)) {
                    where.rol = { in: rolFilter };
                }
                else if (typeof rolFilter === 'string' && rolFilter.includes(',')) {
                    where.rol = { in: rolFilter.split(',').map(r => r.trim()) };
                }
                else {
                    where.rol = rolFilter;
                }
            }
            if (filters?.institucionId) {
                where.usuarioInstituciones = {
                    some: { institucionId: filters.institucionId, activo: true },
                };
            }
            if (filters?.search) {
                where.OR = [
                    { nombres: { contains: filters.search, mode: 'insensitive' } },
                    { apellidos: { contains: filters.search, mode: 'insensitive' } },
                    { email: { contains: filters.search, mode: 'insensitive' } },
                ];
            }

            const total = await database_1.prisma.usuario.count({ where });

            const users = await database_1.prisma.usuario.findMany({
                include: {
                    usuarioInstituciones: {
                        where: { activo: true },
                        include: {
                            institucion: true,
                        },
                    },
                },
                orderBy: {
                    createdAt: 'desc',
                },
                skip,
                take: limit,
                where,
            });
            const totalPages = Math.ceil(total / limit);
            return {
                data: users,
                pagination: {
                    page,
                    limit,
                    total,
                    totalPages,
                    hasNext: page < totalPages,
                    hasPrev: page > 1,
                },
            };
        }
        catch (error) {
            console.error('Error al obtener todos los usuarios:', error);
            throw error;
        }
    }

    static async getUserById(id) {
        try {
            if (!id || typeof id !== 'string') {
                throw new types_1.ValidationError('ID de usuario invÃ¡lido');
            }
            const user = await database_1.prisma.usuario.findUnique({
                where: { id },
                include: {
                    usuarioInstituciones: {
                        where: { activo: true },
                        include: {
                            institucion: true,
                        },
                    },
                    estudiante: true,
                },
            });
            return user;
        }
        catch (error) {
            console.error(`Error al obtener usuario con ID ${id}:`, error);
            throw error;
        }
    }

    static async getUserByEmail(email) {
        try {
            if (!email || typeof email !== 'string' || !email.includes('@')) {
                throw new types_1.ValidationError('Email invÃ¡lido');
            }
            const user = await database_1.prisma.usuario.findUnique({
                where: { email: email.toLowerCase() },
                include: {
                    usuarioInstituciones: {
                        where: { activo: true },
                        include: {
                            institucion: true,
                        },
                    },
                },
            });
            return user;
        }
        catch (error) {
            console.error(`Error al obtener usuario con email ${email}:`, error);
            throw error;
        }
    }

    static async getUsersByRole(role, pagination, filters) {
        const combinedFilters = { ...filters, rol: role };
        return this.getAllUsers(pagination, combinedFilters);
    }

    static async getUsersByInstitution(institucionId, pagination, filters) {
        const combinedFilters = { ...filters, institucionId };
        return this.getAllUsers(pagination, combinedFilters);
    }

    static async createUser(userData, invokerRole) {
        try {

            if (invokerRole === 'super_admin' && userData.rol !== 'admin_institucion' && userData.rol !== 'super_admin') {
                throw new types_1.AuthorizationError('Un Super Admin solo puede crear usuarios de tipo Administrador de InstituciÃ³n o Super Admin.');
            }
            if (invokerRole === 'super_admin' && userData.rol === 'admin_institucion' && !userData.institucionId) {
                throw new types_1.ValidationError('Se requiere un institucionId para crear un Administrador de InstituciÃ³n.');
            }
            if (invokerRole === 'admin_institucion' && (userData.rol !== 'profesor' && userData.rol !== 'estudiante')) {
                throw new types_1.AuthorizationError('Un Administrador de InstituciÃ³n solo puede crear profesores o estudiantes.');
            }

            if (!userData.email || !userData.password || !userData.nombres || !userData.apellidos || !userData.rol) {
                throw new types_1.ValidationError('Campos requeridos faltantes');
            }
            const validRoles = ['super_admin', 'admin_institucion', 'profesor', 'estudiante'];
            if (!validRoles.includes(userData.rol)) {
                throw new types_1.ValidationError('Rol invÃ¡lido');
            }

            const emailAvailable = await this.isEmailAvailable(userData.email);
            if (!emailAvailable) {
                throw new types_1.ConflictError('El email ya estÃ¡ registrado');
            }

            const hashedPassword = await bcryptjs_1.default.hash(userData.password, 10);

            let codigoQr;
            if (userData.rol === 'estudiante') {
                if (!userData.identificacion) {
                    throw new types_1.ValidationError('La identificaciÃ³n es requerida para estudiantes');
                }
                codigoQr = this.generateUniqueQRCode();
            }

            const result = await database_1.prisma.$transaction(async (tx) => {

                const newUser = await tx.usuario.create({
                    data: {
                        email: userData.email.toLowerCase(),
                        passwordHash: hashedPassword,
                        nombres: userData.nombres,
                        apellidos: userData.apellidos,
                        rol: userData.rol,
                        telefono: userData.telefono,
                    },
                });

                if (userData.institucionId) {
                    await tx.usuarioInstitucion.create({
                        data: {
                            usuarioId: newUser.id,
                            institucionId: userData.institucionId,
                            rolEnInstitucion: userData.rolEnInstitucion,
                        },
                    });
                }

                let estudianteData = null;
                if (userData.rol === 'estudiante' && userData.identificacion) {
                    estudianteData = await tx.estudiante.create({
                        data: {
                            usuarioId: newUser.id,
                            identificacion: userData.identificacion,
                            codigoQr: codigoQr,
                            nombreResponsable: userData.nombreResponsable,
                            telefonoResponsable: userData.telefonoResponsable,
                        },
                    });
                }
                return { newUser, estudianteData };
            });

            const userWithRelations = await this.getUserById(result.newUser.id);
            if (!userWithRelations) {
                throw new Error('Error al obtener usuario creado');
            }

            const response = {
                id: userWithRelations.id,
                email: userWithRelations.email,
                nombres: userWithRelations.nombres,
                apellidos: userWithRelations.apellidos,
                rol: userWithRelations.rol,
                telefono: userWithRelations.telefono,
                activo: userWithRelations.activo,
                instituciones: userWithRelations.usuarioInstituciones?.map(ui => ({
                    id: ui.institucion.id,
                    nombre: ui.institucion.nombre,
                    rolEnInstitucion: ui.rolEnInstitucion,
                    activo: ui.activo,
                })) || [],
            };
            if (result.estudianteData) {
                response.estudiante = {
                    id: result.estudianteData.id,
                    identificacion: result.estudianteData.identificacion,
                    codigoQr: result.estudianteData.codigoQr,
                    nombreResponsable: result.estudianteData.nombreResponsable,
                    telefonoResponsable: result.estudianteData.telefonoResponsable,
                };
            }
            return response;
        }
        catch (error) {
            console.error('Error al crear usuario:', error);
            throw error;
        }
    }

    static async updateUser(id, userData) {
        try {
            if (!id || typeof id !== 'string') {
                throw new types_1.ValidationError('ID de usuario invÃ¡lido');
            }

            const existingUser = await this.getUserById(id);
            if (!existingUser) {
                throw new types_1.ValidationError('Usuario no encontrado');
            }

            if (userData.email && userData.email !== existingUser.email) {
                const emailAvailable = await this.isEmailAvailable(userData.email, id);
                if (!emailAvailable) {
                    throw new types_1.ConflictError('El email ya estÃ¡ registrado');
                }
            }

            const result = await database_1.prisma.$transaction(async (tx) => {

                const updateData = {};
                if (userData.email !== undefined)
                    updateData.email = userData.email.toLowerCase();
                if (userData.nombres !== undefined)
                    updateData.nombres = userData.nombres;
                if (userData.apellidos !== undefined)
                    updateData.apellidos = userData.apellidos;
                if (userData.telefono !== undefined)
                    updateData.telefono = userData.telefono;
                if (userData.activo !== undefined)
                    updateData.activo = userData.activo;
                const updatedUser = await tx.usuario.update({
                    where: { id },
                    data: updateData,
                });

                if (existingUser.rol === 'estudiante' && (userData.identificacion || userData.nombreResponsable || userData.telefonoResponsable)) {
                    const estudianteUpdateData = {};
                    if (userData.identificacion !== undefined)
                        estudianteUpdateData.identificacion = userData.identificacion;
                    if (userData.nombreResponsable !== undefined)
                        estudianteUpdateData.nombreResponsable = userData.nombreResponsable;
                    if (userData.telefonoResponsable !== undefined)
                        estudianteUpdateData.telefonoResponsable = userData.telefonoResponsable;
                    await tx.estudiante.update({
                        where: { usuarioId: id },
                        data: estudianteUpdateData,
                    });
                }
                return updatedUser;
            });

            return await this.getUserById(id);
        }
        catch (error) {
            console.error(`Error al actualizar usuario con ID ${id}:`, error);
            throw error;
        }
    }

    static async deleteUser(id) {
        try {
            if (!id || typeof id !== 'string') {
                throw new types_1.ValidationError('ID de usuario invÃ¡lido');
            }

            const existingUser = await this.getUserById(id);
            if (!existingUser) {
                throw new types_1.ValidationError('Usuario no encontrado');
            }

            await database_1.prisma.usuario.update({
                where: { id },
                data: { activo: false },
            });
            return true;
        }
        catch (error) {
            console.error(`Error al eliminar usuario con ID ${id}:`, error);
            throw error;
        }
    }

    static generateUniqueQRCode() {
        return (0, crypto_1.randomBytes)(16).toString('hex').toUpperCase();
    }

    static async userExists(id) {
        try {
            if (!id || typeof id !== 'string') {
                return false;
            }
            const count = await database_1.prisma.usuario.count({
                where: { id },
            });
            return count > 0;
        }
        catch (error) {
            console.error(`Error al verificar existencia de usuario ${id}:`, error);
            return false;
        }
    }

    static async isEmailAvailable(email, excludeUserId) {
        try {
            if (!email || typeof email !== 'string' || !email.includes('@')) {
                return false;
            }
            const whereClause = { email: email.toLowerCase() };
            if (excludeUserId) {
                whereClause.id = { not: excludeUserId };
            }
            const count = await database_1.prisma.usuario.count({
                where: whereClause,
            });
            return count === 0;
        }
        catch (error) {
            console.error(`Error al verificar disponibilidad de email ${email}:`, error);
            return false;
        }
    }
}
exports.UserService = UserService;
exports.default = UserService;

/* Fin backend\dist\services\user.service.js */

/* Inicio backend\dist\types\index.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConflictError = exports.NotFoundError = exports.AuthorizationError = exports.AuthenticationError = exports.ValidationError = exports.AppError = void 0;
class AppError extends Error {
    constructor(message, statusCode = 500, code = 'INTERNAL_ERROR') {
        super(message);
        this.statusCode = statusCode;
        this.code = code;
        this.isOperational = true;
        Error.captureStackTrace(this, this.constructor);
    }
}
exports.AppError = AppError;
class ValidationError extends AppError {
    constructor(message) {
        super(message, 400, 'VALIDATION_ERROR');
    }
}
exports.ValidationError = ValidationError;
class AuthenticationError extends AppError {
    constructor(message = 'No autorizado') {
        super(message, 401, 'AUTHENTICATION_ERROR');
    }
}
exports.AuthenticationError = AuthenticationError;
class AuthorizationError extends AppError {
    constructor(message = 'Acceso denegado') {
        super(message, 403, 'AUTHORIZATION_ERROR');
    }
}
exports.AuthorizationError = AuthorizationError;
class NotFoundError extends AppError {
    constructor(resource = 'Recurso') {
        super(`${resource} no encontrado`, 404, 'NOT_FOUND_ERROR');
    }
}
exports.NotFoundError = NotFoundError;
class ConflictError extends AppError {
    constructor(message) {
        super(message, 409, 'CONFLICT_ERROR');
    }
}
exports.ConflictError = ConflictError;

/* Fin backend\dist\types\index.js */

/* Inicio backend\dist\utils\index.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormatUtil = exports.ValidationUtil = exports.ResponseUtil = void 0;

class ResponseUtil {

    static success(data, message) {
        return {
            success: true,
            data,
            message,
        };
    }

    static error(message, code) {
        return {
            success: false,
            error: message,
            message: code,
        };
    }

    static paginated(data, total, page, limit, message) {
        return {
            success: true,
            data: {
                items: data,
                pagination: {
                    total,
                    page,
                    limit,
                    totalPages: Math.ceil(total / limit),
                },
            },
            message,
        };
    }
}
exports.ResponseUtil = ResponseUtil;

class ValidationUtil {

    static isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }

    static isNotEmpty(value) {
        return Boolean(value && value.trim().length > 0);
    }

    static hasMinLength(value, minLength) {
        return Boolean(value && value.length >= minLength);
    }
}
exports.ValidationUtil = ValidationUtil;

class FormatUtil {

    static capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
    }

    static snakeToCamel(str) {
        return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
    }

    static camelToSnake(str) {
        return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
    }
}
exports.FormatUtil = FormatUtil;
exports.default = {
    ResponseUtil,
    ValidationUtil,
    FormatUtil,
};

/* Fin backend\dist\utils\index.js */

/* Inicio backend\jest.unit.config.js */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src', '<rootDir>/tests'],
  testMatch: ['**/__tests__*.ts', '**/?(*.)+(spec|test).ts'],
  transform: {
    '^.+\\.ts$': ['ts-jest', { tsconfig: 'tsconfig.test.json' }]
  },
  setupFilesAfterEnv: [],
  collectCoverageFrom: [],
  moduleFileExtensions: ['ts', 'js', 'json'],
  extensionsToTreatAsEsm: [],
};
/* Fin backend\jest.unit.config.js */

/* Inicio backend\prisma\seed.ts */
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';

const prisma = new PrismaClient();

async function main() {
  console.log('ðŸŒ± Iniciando seed de AsistApp V2...');

  console.log('ðŸ« Creando instituciones...');
  const institucionesExistentes = await prisma.institucion.findMany({
    where: {
      OR: [
        { nombre: 'Colegio San JosÃ©' },
        { nombre: 'IE Francisco de Paula Santander' }
      ]
    }
  });

  const instituciones = [];
  if (institucionesExistentes.length === 0) {
    const nuevasInstituciones = await Promise.all([
      prisma.institucion.create({
        data: {
          nombre: 'Colegio San JosÃ©',
          direccion: 'Calle 123 #45-67',
          email: 'admin@sanjose.edu',
          telefono: '555-0101',
          activa: true,
        },
      }),
      prisma.institucion.create({
        data: {
          nombre: 'IE Francisco de Paula Santander',
          direccion: 'Carrera 10 #20-30',
          email: 'admin@fps.edu',
          telefono: '555-0202',
          activa: true,
        },
      }),
    ]);
    instituciones.push(...nuevasInstituciones);
  } else {
    instituciones.push(...institucionesExistentes);
  }

  console.log('âœ… Instituciones creadas:', instituciones.length);

  console.log('ðŸ‘‘ Creando super admin...');

  const superAdminPassword = await bcrypt.hash('Admin123!', 10);

  const superAdmin = await prisma.usuario.upsert({
    where: { email: 'superadmin@asistapp.com' },
    update: {},
    create: {
      email: 'superadmin@asistapp.com',
      passwordHash: superAdminPassword,
      nombres: 'Super',
      apellidos: 'Admin',
      rol: 'super_admin',
      activo: true,
    },
  });

  console.log('âœ… Super admin creado:', superAdmin.email);

  console.log('ðŸ‘¥ Creando usuario multi-instituciÃ³n...');

  const multiUserPassword = await bcrypt.hash('Multi123!', 10);

  const multiUser = await prisma.usuario.upsert({
    where: { email: 'multi@asistapp.com' },
    update: {},
    create: {
      email: 'multi@asistapp.com',
      passwordHash: multiUserPassword,
      nombres: 'Usuario',
      apellidos: 'Multi',
      rol: 'admin_institucion',
      activo: true,
    },
  });

  await Promise.all([
    prisma.usuarioInstitucion.upsert({
      where: {
        usuarioId_institucionId: {
          usuarioId: multiUser.id,
          institucionId: instituciones[0].id,
        },
      },
      update: {},
      create: {
        usuarioId: multiUser.id,
        institucionId: instituciones[0].id,
        rolEnInstitucion: 'admin',
        activo: true,
      },
    }),
    prisma.usuarioInstitucion.upsert({
      where: {
        usuarioId_institucionId: {
          usuarioId: multiUser.id,
          institucionId: instituciones[1].id,
        },
      },
      update: {},
      create: {
        usuarioId: multiUser.id,
        institucionId: instituciones[1].id,
        rolEnInstitucion: 'admin',
        activo: true,
      },
    }),
  ]);

  console.log('âœ… Usuario multi-instituciÃ³n creado:', multiUser.email);

  console.log('ðŸ‘¨â€ðŸ’¼ Creando admins de instituciÃ³n...');

  const adminSanJosePassword = await bcrypt.hash('SanJose123!', 10);
  const adminFpsPassword = await bcrypt.hash('Fps123!', 10);

  const adminsInstitucion = await Promise.all([
    prisma.usuario.upsert({
      where: { email: 'admin@sanjose.edu' },
      update: {},
      create: {
        email: 'admin@sanjose.edu',
        passwordHash: adminSanJosePassword,
        nombres: 'MarÃ­a',
        apellidos: 'GonzÃ¡lez',
        rol: 'admin_institucion',
        telefono: '555-0103',
        activo: true,
      },
    }),
    prisma.usuario.upsert({
      where: { email: 'admin@fps.edu' },
      update: {},
      create: {
        email: 'admin@fps.edu',
        passwordHash: adminFpsPassword,
        nombres: 'Carlos',
        apellidos: 'RodrÃ­guez',
        rol: 'admin_institucion',
        telefono: '555-0203',
        activo: true,
      },
    }),
  ]);

  await Promise.all([
    prisma.usuarioInstitucion.upsert({
      where: {
        usuarioId_institucionId: {
          usuarioId: adminsInstitucion[0].id,
          institucionId: instituciones[0].id,
        },
      },
      update: {},
      create: {
        usuarioId: adminsInstitucion[0].id,
        institucionId: instituciones[0].id,
        rolEnInstitucion: 'admin',
        activo: true,
      },
    }),
    prisma.usuarioInstitucion.upsert({
      where: {
        usuarioId_institucionId: {
          usuarioId: adminsInstitucion[1].id,
          institucionId: instituciones[1].id,
        },
      },
      update: {},
      create: {
        usuarioId: adminsInstitucion[1].id,
        institucionId: instituciones[1].id,
        rolEnInstitucion: 'admin',
        activo: true,
      },
    }),
  ]);

  console.log('âœ… Admins de instituciÃ³n creados:', adminsInstitucion.length);

  console.log('ðŸ‘¨â€ðŸ« Creando profesores...');

  const profesor1Password = await bcrypt.hash('Prof123!', 10);
  const profesor2Password = await bcrypt.hash('Prof456!', 10);

  const profesores = await Promise.all([
    prisma.usuario.upsert({
      where: { email: 'pedro.garcia@sanjose.edu' },
      update: {},
      create: {
        email: 'pedro.garcia@sanjose.edu',
        passwordHash: profesor1Password,
        nombres: 'Pedro',
        apellidos: 'GarcÃ­a',
        rol: 'profesor',
        telefono: '555-0104',
        activo: true,
      },
    }),
    prisma.usuario.upsert({
      where: { email: 'ana.lopez@sanjose.edu' },
      update: {},
      create: {
        email: 'ana.lopez@sanjose.edu',
        passwordHash: profesor2Password,
        nombres: 'Ana',
        apellidos: 'LÃ³pez',
        rol: 'profesor',
        telefono: '555-0105',
        activo: true,
      },
    }),
  ]);

  await Promise.all([
    prisma.usuarioInstitucion.upsert({
      where: {
        usuarioId_institucionId: {
          usuarioId: profesores[0].id,
          institucionId: instituciones[0].id,
        },
      },
      update: {},
      create: {
        usuarioId: profesores[0].id,
        institucionId: instituciones[0].id,
        rolEnInstitucion: 'profesor',
        activo: true,
      },
    }),
    prisma.usuarioInstitucion.upsert({
      where: {
        usuarioId_institucionId: {
          usuarioId: profesores[1].id,
          institucionId: instituciones[0].id,
        },
      },
      update: {},
      create: {
        usuarioId: profesores[1].id,
        institucionId: instituciones[0].id,
        rolEnInstitucion: 'profesor',
        activo: true,
      },
    }),
  ]);

  console.log('âœ… Profesores creados:', profesores.length);

  console.log('ðŸ‘¨â€ðŸŽ“ Creando estudiantes...');

  const estudiantesData = [
    { nombres: 'Juan', apellidos: 'PÃ©rez', identificacion: '12345678', responsable: 'MarÃ­a PÃ©rez', telResponsable: '300-111-0001' },
    { nombres: 'MarÃ­a', apellidos: 'GarcÃ­a', identificacion: '12345679', responsable: 'Carlos GarcÃ­a', telResponsable: '300-111-0002' },
    { nombres: 'Carlos', apellidos: 'LÃ³pez', identificacion: '12345680', responsable: 'Ana LÃ³pez', telResponsable: '300-111-0003' },
    { nombres: 'Laura', apellidos: 'MartÃ­nez', identificacion: '12345681', responsable: 'Pedro MartÃ­nez', telResponsable: '300-111-0004' },
    { nombres: 'Miguel', apellidos: 'RodrÃ­guez', identificacion: '12345682', responsable: 'Sofia RodrÃ­guez', telResponsable: '300-111-0005' },
  ];

  const estudiantes = [];
  for (const estudianteData of estudiantesData) {
    const estudiantePassword = await bcrypt.hash('Est123!', 10);

    const usuario = await prisma.usuario.upsert({
      where: { email: `${estudianteData.nombres.toLowerCase()}.${estudianteData.apellidos.toLowerCase()}@sanjose.edu` },
      update: {},
      create: {
        email: `${estudianteData.nombres.toLowerCase()}.${estudianteData.apellidos.toLowerCase()}@sanjose.edu`,
        passwordHash: estudiantePassword,
        nombres: estudianteData.nombres,
        apellidos: estudianteData.apellidos,
        rol: 'estudiante',
        activo: true,
      },
    });

    await prisma.usuarioInstitucion.upsert({
      where: {
        usuarioId_institucionId: {
          usuarioId: usuario.id,
          institucionId: instituciones[0].id,
        },
      },
      update: {},
      create: {
        usuarioId: usuario.id,
        institucionId: instituciones[0].id,
        rolEnInstitucion: 'estudiante',
        activo: true,
      },
    });

    const estudiante = await prisma.estudiante.upsert({
      where: { identificacion: estudianteData.identificacion },
      update: {},
      create: {
        usuarioId: usuario.id,
        identificacion: estudianteData.identificacion,
        codigoQr: `QR-${estudianteData.identificacion}`,
        nombreResponsable: estudianteData.responsable,
        telefonoResponsable: estudianteData.telResponsable,
      },
    });

    estudiantes.push({ usuario, estudiante });
  }

  console.log('âœ… Estudiantes creados:', estudiantes.length);

  console.log('ðŸ“… Creando periodos acadÃ©micos...');

  console.log('ðŸ“… Periodos acadÃ©micos saltados temporalmente');

  const periodos = [{ id: 'temp-id' }]

  console.log('ðŸ‘¥ Creando grupos...');

  console.log('ðŸ‘¥ Grupos saltados temporalmente');

  const grupos = [{ id: 'temp-id' }]

  console.log('ðŸ“š Creando materias...');

  console.log('ðŸ“š Materias saltadas temporalmente');

  const materias = [{ id: 'temp-id' }]

  console.log('â° Creando horarios...');

  console.log('â° Horarios saltados temporalmente');

  console.log('ðŸ”— Asignando estudiantes a grupos...');

  console.log('ðŸ”— Estudiantes asignados a grupos (saltado)');

  console.log('ðŸ“ Creando asistencias de ejemplo...');

  console.log('ðŸ“ Asistencias de ejemplo creadas (saltado)');

  console.log('âš™ï¸ Creando configuraciones...');

  console.log('âš™ï¸ Configuraciones creadas (saltado)');

  console.log('\nðŸŽ‰ Seed completado exitosamente!');
  console.log('\nðŸ“Š Resumen de datos creados:');
  console.log('ðŸ« Instituciones:', instituciones.length);
  console.log('ðŸ‘‘ Super Admin:', 1);
  console.log('ðŸ‘¨â€ðŸ’¼ Admins de instituciÃ³n:', adminsInstitucion.length);
  console.log('ðŸ‘¨â€ðŸ« Profesores:', profesores.length);
  console.log('ðŸ‘¨â€ðŸŽ“ Estudiantes:', estudiantes.length);
  console.log('ðŸ“… Periodos acadÃ©micos:', 0)
  console.log('ðŸ‘¥ Grupos:', 0)
  console.log('ðŸ“š Materias:', 0)
  console.log('â° Horarios:', 0)
  console.log('ðŸ“ Asistencias:', 0)
  console.log('âš™ï¸ Configuraciones:', 0)

  console.log('\nðŸ” Credenciales de acceso:');
  console.log('Super Admin: superadmin@asistapp.com / Admin123!');
  console.log('Admin San JosÃ©: admin@sanjose.edu / SanJose123!');
  console.log('Admin FPS: admin@fps.edu / Fps123!');
  console.log('Usuario Multi-instituciÃ³n: multi@asistapp.com / Multi123!');
  console.log('Profesor Pedro: pedro.garcia@sanjose.edu / Prof123!');
  console.log('Estudiantes: [nombre].[apellido]@sanjose.edu / Est123!');
}

main()
  .catch((e) => {
    console.error('âŒ Error durante el seed:', e);
    throw e;
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
/* Fin backend\prisma\seed.ts */

/* Inicio backend\src\config\app.ts */
import { AppConfig } from '../types';

export const config: AppConfig = {
  port: parseInt(process.env.PORT || '3000', 10),
  host: process.env.HOST || '0.0.0.0',
  jwtSecret: process.env.JWT_SECRET || 'asistapp_secret_key_2025',
  jwtExpiresIn: process.env.JWT_EXPIRES_IN || '24h',
  nodeEnv: process.env.NODE_ENV || 'development',
  logLevel: process.env.LOG_LEVEL || 'info',
};

export default config;
/* Fin backend\src\config\app.ts */

/* Inicio backend\src\config\database.ts */
import { PrismaClient } from '@prisma/client';

class DatabaseService {
  private static instance: DatabaseService;
  private prisma: PrismaClient | null = null;

  private constructor() {}

  public static getInstance(): DatabaseService {
    if (!DatabaseService.instance) {
      DatabaseService.instance = new DatabaseService();
    }
    return DatabaseService.instance;
  }

  public getClient(): PrismaClient {
    if (!this.prisma) {
      console.log('ðŸ”„ Creando cliente Prisma...');
      this.prisma = new PrismaClient({
        log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
      });
      console.log('âœ… Cliente Prisma creado');
    }
    return this.prisma;
  }

  public async disconnect(): Promise<void> {
    if (this.prisma) {
      await this.prisma.$disconnect();
      this.prisma = null;
      console.log('ðŸ”Œ Cliente Prisma desconectado');
    }
  }

  public async connect(): Promise<void> {
    const client = this.getClient();
    await client.$connect();
    console.log('ðŸ”— Conectado a la base de datos');
  }
}

export const databaseService = DatabaseService.getInstance();
export const prisma = databaseService.getClient();
/* Fin backend\src\config\database.ts */

/* Inicio backend\src\config\jwt.ts */
import crypto from 'crypto';
import jwt, { SignOptions } from 'jsonwebtoken';
import { JWTPayload } from '../types';
import { config } from './app';

export class JWTService {
  private static accessSecret: string = config.jwtSecret;
  private static refreshSecret: string = config.jwtSecret + '_refresh'
  private static accessExpiresIn: string = config.jwtExpiresIn;
  private static refreshExpiresIn: string = '7d'

  public static signAccessToken(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {
    return jwt.sign(payload, this.accessSecret, { expiresIn: this.accessExpiresIn } as SignOptions);
  }

  public static verifyAccessToken(token: string): JWTPayload {
    try {
      const decoded = jwt.verify(token, this.accessSecret) as JWTPayload;
      return decoded;
    } catch (error) {
      throw new Error('Access token invÃ¡lido o expirado');
    }
  }

  public static signRefreshToken(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {
    const tokenPayload = {
      ...payload,
      jti: crypto.randomUUID(), // JWT ID Ãºnico para evitar colisiones
    };
    return jwt.sign(tokenPayload, this.refreshSecret, { expiresIn: this.refreshExpiresIn } as SignOptions);
  }

  public static verifyRefreshToken(token: string): JWTPayload {
    try {
      const decoded = jwt.verify(token, this.refreshSecret) as JWTPayload;
      return decoded;
    } catch (error) {
      throw new Error('Refresh token invÃ¡lido o expirado');
    }
  }

  public static sign(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {
    return this.signAccessToken(payload);
  }

  public static verify(token: string): JWTPayload {
    return this.verifyAccessToken(token);
  }

  public static decode(token: string): JWTPayload | null {
    try {
      return jwt.decode(token) as JWTPayload;
    } catch (error) {
      return null;
    }
  }
}

export default JWTService;
/* Fin backend\src\config\jwt.ts */

/* Inicio backend\src\controllers\admin-institucion.controller.ts */
import { FastifyReply, FastifyRequest } from 'fastify';
import AdminInstitucionService, { CreateAdminInstitucionRequest, UpdateAdminInstitucionRequest } from '../services/admin-institucion.service';
import { ApiResponse, NotFoundError, PaginationParams } from '../types';

export class AdminInstitucionController {

  public static async getAll(request: FastifyRequest<{ Querystring: { page?: string; limit?: string } }>, reply: FastifyReply) {
    try {
      const { page, limit } = request.query;

      const pagination: PaginationParams = {};
      if (page) pagination.page = parseInt(page, 10);
      if (limit) pagination.limit = parseInt(limit, 10);

      const result = await AdminInstitucionService.getAll(pagination);

      return reply.code(200).send({
        success: true,
        data: result.data,
        pagination: result.pagination,
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async getById(request: FastifyRequest<{ Params: { id: string } }>, reply: FastifyReply) {
    try {
      const { id } = request.params;

      const admin = await AdminInstitucionService.getById(id);

      if (!admin) {
        throw new NotFoundError('Admin de InstituciÃ³n');
      }

      return reply.code(200).send({
        success: true,
        data: admin,
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async create(request: FastifyRequest<{ Body: CreateAdminInstitucionRequest }>, reply: FastifyReply) {
    try {
      const adminData = request.body;
      const newAdmin = await AdminInstitucionService.create(adminData);

      return reply.code(201).send({
        success: true,
        data: newAdmin,
        message: 'Admin de instituciÃ³n creado exitosamente',
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async update(request: FastifyRequest<{ Params: { id: string }; Body: UpdateAdminInstitucionRequest }>, reply: FastifyReply) {
    try {
      const { id } = request.params;
      const adminData = request.body;

      const updatedAdmin = await AdminInstitucionService.update(id, adminData);

      if (!updatedAdmin) {
        throw new NotFoundError('Admin de InstituciÃ³n');
      }

      return reply.code(200).send({
        success: true,
        data: updatedAdmin,
        message: 'Admin de instituciÃ³n actualizado exitosamente',
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async delete(request: FastifyRequest<{ Params: { id: string } }>, reply: FastifyReply) {
    try {
      const { id } = request.params;

      const deleted = await AdminInstitucionService.delete(id);

      if (!deleted) {
        throw new NotFoundError('Admin de InstituciÃ³n');
      }

      return reply.code(200).send({
        success: true,
        data: null,
        message: 'Admin de instituciÃ³n eliminado exitosamente',
      } as ApiResponse<null>);
    } catch (error) {
      throw error;
    }
  }
}

export default AdminInstitucionController;
/* Fin backend\src\controllers\admin-institucion.controller.ts */

/* Inicio backend\src\controllers\auth.controller.ts */
import { FastifyReply, FastifyRequest } from 'fastify';
import { prisma } from '../config/database';
import { AuthenticatedRequest } from '../middleware/auth';
import AuthService from '../services/auth.service';
import { ApiResponse, AuthenticationError, LoginRequest, NotFoundError, RefreshTokenResponse, UsuarioConInstituciones, ValidationError } from '../types';

export class AuthController {

  public static async login(request: FastifyRequest<{ Body: LoginRequest }>, reply: FastifyReply) {
    try {
      const credentials = request.body;
      if (!credentials.email || !credentials.password) {
        throw new ValidationError('Email y contraseÃ±a son requeridos');
      }
      const result = await AuthService.login(credentials);
      return reply.code(200).send({
        success: true,
        data: {
          accessToken: result.accessToken,
          refreshToken: result.refreshToken,
          expiresIn: result.expiresIn,
          usuario: result.usuario
        }
      });

    } catch (error) {
      throw error;
    }
  }

  public static async getUserInstitutions(request: AuthenticatedRequest, reply: FastifyReply) {
    try {
      const user = request.user;

      if (!user) {
        throw new AuthenticationError('Usuario no autenticado');
      }

      const usuario = await prisma.usuario.findUnique({
        where: { id: user.id },
        include: {
          usuarioInstituciones: {
            where: { activo: true },
            include: {
              institucion: true,
            },
          },
        },
      }) as UsuarioConInstituciones | null;

      if (!usuario) {
        throw new NotFoundError('Usuario');
      }

      const instituciones = usuario.usuarioInstituciones.map((ui) => ({
        id: ui.institucion.id,
        nombre: ui.institucion.nombre,
        rolEnInstitucion: ui.rolEnInstitucion,
      }));

      return reply.code(200).send({
        success: true,
        data: instituciones,
      });
    } catch (error) {
      throw error;
    }
  }

  public static async logout(request: FastifyRequest<{ Body: { refreshToken?: string } }>, reply: FastifyReply) {
    try {
      const refreshToken = request.body.refreshToken;
      const authReq = request as unknown as AuthenticatedRequest;
      const user = authReq.user;

      if (!user) {
        throw new AuthenticationError('Usuario no autenticado');
      }

      await AuthService.revokeRefreshTokens(user.id, refreshToken);

      return reply.code(200).send({
        success: true,
        message: 'SesiÃ³n cerrada exitosamente',
      });
    } catch (error) {
      throw error;
    }
  }

  public static async refreshToken(request: FastifyRequest<{ Body: { refreshToken: string } }>, reply: FastifyReply) {
    try {
      const refreshToken = request.body.refreshToken;
      if (!refreshToken) {
        throw new ValidationError('Refresh token es requerido');
      }
      const result = await AuthService.refreshToken(refreshToken);

      return reply.code(200).send({
        success: true,
        data: {
          accessToken: result.accessToken,
          refreshToken: result.refreshToken,
          expiresIn: result.expiresIn,
        },
      } as ApiResponse<RefreshTokenResponse>);

    } catch (error) {
      throw error;
    }
  }

  public static async verify(request: AuthenticatedRequest, reply: FastifyReply) {
    try {
      const user = request.user;

      return reply.code(200).send({
        success: true,
        data: {
          usuario: user,
          valid: true,
        },
      });
    } catch (error) {
      throw error;
    }
  }
}

export default AuthController;
/* Fin backend\src\controllers\auth.controller.ts */

/* Inicio backend\src\controllers\institucion.controller.ts */
import { FastifyReply, FastifyRequest } from 'fastify';
import { AuthenticatedRequest } from '../middleware/auth';
import InstitucionService from '../services/institucion.service';
import { NotFoundError } from '../types';

interface GetInstitucionParams {
  id: string;
}

interface CreateInstitucionBody {
  nombre: string;
  direccion?: string;
  telefono?: string;
  email?: string;
}

interface UpdateInstitucionBody {
  nombre?: string;
  direccion?: string;
  telefono?: string;
  email?: string;
  activa?: boolean;
}

export class InstitucionController {
  public static async getAll(request: AuthenticatedRequest, reply: FastifyReply) {
    try {
      const { page, limit, activa, search } = request.query as {
        page?: string;
        limit?: string;
        activa?: string;
        search?: string;
      };

      const pagination = {
        page: page ? parseInt(page, 10) : 1,
        limit: limit ? parseInt(limit, 10) : 10,
      };

      const filters = {
        activa: activa !== undefined ? activa === 'true' : undefined,
        search: search || undefined,
      };

      const result = await InstitucionService.getAllInstitutions(pagination, filters);

      return reply.code(200).send({
        success: true,
        data: result.data,
        pagination: result.pagination,
      });
    } catch (error) {
      throw error;
    }
  }

  public static async getById(request: AuthenticatedRequest & FastifyRequest<{ Params: GetInstitucionParams }>, reply: FastifyReply) {
    try {
      const { id } = request.params;

      const institution = await InstitucionService.getInstitutionById(id);

      if (!institution) {
        throw new NotFoundError('InstituciÃ³n');
      }

      return reply.code(200).send({
        success: true,
        data: institution,
      });
    } catch (error) {
      throw error;
    }
  }

  public static async create(request: AuthenticatedRequest & FastifyRequest<{ Body: CreateInstitucionBody }>, reply: FastifyReply) {
    try {
      const data = request.body;

      const institution = await InstitucionService.createInstitution(data);

      return reply.code(201).send({
        success: true,
        data: institution,
        message: 'InstituciÃ³n creada exitosamente',
      });
    } catch (error) {
      throw error;
    }
  }

  public static async update(request: AuthenticatedRequest & FastifyRequest<{ Params: GetInstitucionParams; Body: UpdateInstitucionBody }>, reply: FastifyReply) {
    try {
      const { id } = request.params;
      const data = request.body;

      const institution = await InstitucionService.updateInstitution(id, data);

      if (!institution) {
        throw new NotFoundError('InstituciÃ³n');
      }

      return reply.code(200).send({
        success: true,
        data: institution,
        message: 'InstituciÃ³n actualizada exitosamente',
      });
    } catch (error) {
      throw error;
    }
  }

  public static async delete(request: AuthenticatedRequest & FastifyRequest<{ Params: GetInstitucionParams }>, reply: FastifyReply) {
    try {
      const { id } = request.params;

      const success = await InstitucionService.deleteInstitution(id);

      return reply.code(200).send({
        success: true,
        message: 'InstituciÃ³n eliminada exitosamente',
      });
    } catch (error) {
      throw error;
    }
  }
  public static async getAdminsByInstitution(request: AuthenticatedRequest & FastifyRequest<{ Params: GetInstitucionParams }>, reply: FastifyReply) {
    try {
      const { id } = request.params;
      const admins = await InstitucionService.getAdminsByInstitution(id);

      return reply.code(200).send({
        success: true,
        data: admins,
      });
    } catch (error) {
      throw error;
    }
  }

  public static async assignAdminToInstitution(request: AuthenticatedRequest & FastifyRequest<{ Params: GetInstitucionParams; Body: { userId: string } }>, reply: FastifyReply) {
    try {
      const { id } = request.params;
      const { userId } = request.body as { userId: string };

      const result = await InstitucionService.assignAdminToInstitution(id, userId);

      return reply.code(201).send({
        success: true,
        data: result,
        message: 'Administrador asignado a la instituciÃ³n exitosamente',
      });
    } catch (error) {
      throw error;
    }
  }

  public static async removeAdminFromInstitution(request: AuthenticatedRequest & FastifyRequest<{ Params: { id: string; userId: string } }>, reply: FastifyReply) {
    try {
      const { id, userId } = request.params;

      const result = await InstitucionService.removeAdminFromInstitution(id, userId);

      return reply.code(200).send({
        success: true,
        data: result,
        message: 'Administrador removido de la instituciÃ³n exitosamente',
      });
    } catch (error) {
      throw error;
    }
  }
}

export default InstitucionController;
/* Fin backend\src\controllers\institucion.controller.ts */

/* Inicio backend\src\controllers\institution-admin.controller.ts */
import { FastifyReply, FastifyRequest } from 'fastify';
import { prisma } from '../config/database';
import ProfesorService, { ProfesorFilters, UpdateProfesorRequest } from '../services/profesor.service';
import { ApiResponse, NotFoundError, PaginationParams } from '../types';

interface CreateProfesorBody {
  nombres: string;
  apellidos: string;
  email: string;
  password: string;
  grupoId?: string;
}

export class InstitutionAdminController {

  public static async getAllProfesores(
    request: FastifyRequest<{
      Querystring: {
        page?: string;
        limit?: string;
        activo?: string;
        search?: string;
      };
    }>,
    reply: FastifyReply
  ) {
    try {
      const user = (request as any).user;
      const { page, limit, activo, search } = request.query;
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: {
          usuarioId: user.id,
          activo: true,
        },
        include: {
          institucion: true,
        },
      });

      if (!usuarioInstitucion) {
        return reply.code(403).send({
          success: false,
          message: 'No tienes una instituciÃ³n asignada',
        });
      }

      const institucionId = usuarioInstitucion.institucionId;
      const pagination: PaginationParams = {};
      if (page) pagination.page = parseInt(page, 10);
      if (limit) pagination.limit = parseInt(limit, 10);
      const filters: ProfesorFilters = { institucionId };
      if (activo !== undefined && activo !== null) {
        filters.activo = String(activo).toLowerCase() === 'true';
      }
      if (search) filters.search = search;
      const result = await ProfesorService.getAll(institucionId, pagination, filters);

      return reply.code(200).send({
        success: true,
        data: result.data,
        pagination: result.pagination,
      });
    } catch (error) {
      throw error;
    }
  }

  public static async getProfesorById(
    request: FastifyRequest<{ Params: { id: string } }>,
    reply: FastifyReply
  ) {
    try {
      const user = (request as any).user;
      const { id } = request.params;
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: {
          usuarioId: user.id,
          activo: true,
        },
        include: {
          institucion: true,
        },
      });

      if (!usuarioInstitucion) {
        return reply.code(403).send({
          success: false,
          message: 'No tienes una instituciÃ³n asignada',
        });
      }

      const institucionId = usuarioInstitucion.institucionId;

      const profesor = await ProfesorService.getById(id, institucionId);

      if (!profesor) {
        throw new NotFoundError('Profesor');
      }

      return reply.code(200).send({
        success: true,
        data: profesor,
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async createProfesor(
    request: FastifyRequest<{ Body: CreateProfesorBody }>,
    reply: FastifyReply
  ) {
    try {
      const user = (request as any).user;
      const profesorData = request.body;
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: {
          usuarioId: user.id,
          activo: true,
        },
        include: {
          institucion: true,
        },
      });

      if (!usuarioInstitucion) {
        return reply.code(403).send({
          success: false,
          message: 'No tienes una instituciÃ³n asignada',
        });
      }

      const institucionId = usuarioInstitucion.institucionId;

      const newProfesor = await ProfesorService.create({
        nombres: profesorData.nombres,
        apellidos: profesorData.apellidos,
        email: profesorData.email,
        password: profesorData.password,
        institucionId: institucionId,
        grupoId: profesorData.grupoId,
      }, user.id);

      return reply.code(201).send({
        success: true,
        data: newProfesor,
        message: 'Profesor creado exitosamente',
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async updateProfesor(
    request: FastifyRequest<{
      Params: { id: string };
      Body: UpdateProfesorRequest;
    }>,
    reply: FastifyReply
  ) {
    try {
      const user = (request as any).user;
      const { id } = request.params;
      const profesorData = request.body;
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: {
          usuarioId: user.id,
          activo: true,
        },
        include: {
          institucion: true,
        },
      });

      if (!usuarioInstitucion) {
        return reply.code(403).send({
          success: false,
          message: 'No tienes una instituciÃ³n asignada',
        });
      }

      const institucionId = usuarioInstitucion.institucionId;

      const updatedProfesor = await ProfesorService.update(id, institucionId, profesorData);

      if (!updatedProfesor) {
        throw new NotFoundError('Profesor');
      }

      return reply.code(200).send({
        success: true,
        data: updatedProfesor,
        message: 'Profesor actualizado exitosamente',
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async deleteProfesor(
    request: FastifyRequest<{ Params: { id: string } }>,
    reply: FastifyReply
  ) {
    try {
      const user = (request as any).user;
      const { id } = request.params;
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: {
          usuarioId: user.id,
          activo: true,
        },
        include: {
          institucion: true,
        },
      });

      if (!usuarioInstitucion) {
        return reply.code(403).send({
          success: false,
          message: 'No tienes una instituciÃ³n asignada',
        });
      }

      const institucionId = usuarioInstitucion.institucionId;

      const deleted = await ProfesorService.delete(id, institucionId);

      if (!deleted) {
        throw new NotFoundError('Profesor');
      }

      return reply.code(200).send({
        success: true,
        data: null,
        message: 'Profesor eliminado exitosamente',
      } as ApiResponse<null>);
    } catch (error) {
      throw error;
    }
  }

  public static async toggleProfesorStatus(
    request: FastifyRequest<{ Params: { id: string } }>,
    reply: FastifyReply
  ) {
    try {
      const user = (request as any).user;
      const { id } = request.params;
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: {
          usuarioId: user.id,
          activo: true,
        },
        include: {
          institucion: true,
        },
      });

      if (!usuarioInstitucion) {
        return reply.code(403).send({
          success: false,
          message: 'No tienes una instituciÃ³n asignada',
        });
      }

      const institucionId = usuarioInstitucion.institucionId;

      const profesor = await ProfesorService.toggleStatus(id, institucionId);

      if (!profesor) {
        throw new NotFoundError('Profesor');
      }

      return reply.code(200).send({
        success: true,
        data: profesor,
        message: `Profesor ${profesor.activo ? 'activado' : 'desactivado'} exitosamente`,
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }
}

export default InstitutionAdminController;
/* Fin backend\src\controllers\institution-admin.controller.ts */

/* Inicio backend\src\controllers\user.controller.ts */
import { FastifyReply, FastifyRequest } from 'fastify';
import UserService from '../services/user.service';
import { ApiResponse, NotFoundError, PaginationParams, UserFilters } from '../types';

export class UserController {

  public static async getAllUsers(
    request: FastifyRequest<{
      Querystring: {
        page?: string;
        limit?: string;
        rol?: string;
        institucionId?: string;
        activo?: string;
        search?: string;
      };
    }>,
    reply: FastifyReply
  ) {
    try {
      const { page, limit, rol, institucionId, activo, search } = request.query;
      const pagination: PaginationParams = {};
      if (page) pagination.page = parseInt(page, 10);
      if (limit) pagination.limit = parseInt(limit, 10);
      const filters: UserFilters = {};
      if (rol) filters.rol = rol as any;
      if (institucionId) filters.institucionId = institucionId;
      if (activo !== undefined) filters.activo = activo === 'true';
      if (search) filters.search = search;

      const result = await UserService.getAllUsers(pagination, filters);

      return reply.code(200).send({
        success: true,
        data: result.data,
        pagination: result.pagination,
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async getUserById(
    request: FastifyRequest<{ Params: { id: string } }>,
    reply: FastifyReply
  ) {
    try {
      const { id } = request.params;

      const user = await UserService.getUserById(id);

      if (!user) {
        throw new NotFoundError('Usuario');
      }

      return reply.code(200).send({
        success: true,
        data: user,
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async getUsersByRole(
    request: FastifyRequest<{
      Params: { role: string };
      Querystring: {
        page?: string;
        limit?: string;
        institucionId?: string;
        activo?: string;
        search?: string;
      };
    }>,
    reply: FastifyReply
  ) {
    try {
      const { role } = request.params;
      const { page, limit, institucionId, activo, search } = request.query;
      const pagination: PaginationParams = {};
      if (page) pagination.page = parseInt(page, 10);
      if (limit) pagination.limit = parseInt(limit, 10);
      const filters: UserFilters = {};
      if (institucionId) filters.institucionId = institucionId;
      if (activo !== undefined) filters.activo = activo === 'true';
      if (search) filters.search = search;

      const result = await UserService.getUsersByRole(role, pagination, filters);

      return reply.code(200).send({
        success: true,
        data: result.data,
        pagination: result.pagination,
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async getUsersByInstitution(
    request: FastifyRequest<{
      Params: { institucionId: string };
      Querystring: {
        page?: string;
        limit?: string;
        rol?: string;
        activo?: string;
        search?: string;
      };
    }>,
    reply: FastifyReply
  ) {
    try {
      const { institucionId } = request.params;
      const { page, limit, rol, activo, search } = request.query;
      const pagination: PaginationParams = {};
      if (page) pagination.page = parseInt(page, 10);
      if (limit) pagination.limit = parseInt(limit, 10);
      const filters: UserFilters = {};
      if (rol) filters.rol = rol as any;
      if (activo !== undefined) filters.activo = activo === 'true';
      if (search) filters.search = search;

      const result = await UserService.getUsersByInstitution(institucionId, pagination, filters);

      return reply.code(200).send({
        success: true,
        data: result.data,
        pagination: result.pagination,
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async createUser(
    request: FastifyRequest<{ Body: any }>,
    reply: FastifyReply
  ) {
    try {
      const userData = request.body as any;
      const invokerRole = (request as any).user?.rol;

      if (!invokerRole) {
        throw new Error('Usuario no autenticado');
      }

      const result = await UserService.createUser(userData, invokerRole);

      return reply.code(201).send({
        success: true,
        data: result,
        message: 'Usuario creado exitosamente',
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async updateUser(
    request: FastifyRequest<{
      Params: { id: string };
      Body: any;
    }>,
    reply: FastifyReply
  ) {
    try {
      const { id } = request.params;
      const userData = request.body as any;

      const result = await UserService.updateUser(id, userData);

      if (!result) {
        throw new NotFoundError('Usuario');
      }

      return reply.code(200).send({
        success: true,
        data: result,
        message: 'Usuario actualizado exitosamente',
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async deleteUser(
    request: FastifyRequest<{ Params: { id: string } }>,
    reply: FastifyReply
  ) {
    try {
      const { id } = request.params;

      const result = await UserService.deleteUser(id);

      return reply.code(200).send({
        success: true,
        data: { deleted: result },
        message: 'Usuario eliminado exitosamente',
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }
}

export default UserController;
/* Fin backend\src\controllers\user.controller.ts */

/* Inicio backend\src\index.ts */
import fastifyCors from '@fastify/cors';
import fastifyFormbody from '@fastify/formbody';
import Fastify from 'fastify';
import { config } from './config/app';
import { databaseService } from './config/database';
import setupErrorHandler from './middleware/errorHandler';
import routes from './routes';
import AuthService from './services/auth.service';

const fastify = Fastify({
  logger: config.nodeEnv === 'development',
});

fastify.register(fastifyCors, {
  origin: true, // Permite cualquier origen
  credentials: true, // Permite el envÃ­o de cookies y credenciales
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
});

fastify.register(fastifyFormbody);

setupErrorHandler(fastify);

fastify.register(routes);

const start = async () => {
  try {
    console.log('ðŸš€ Iniciando AsistApp Backend v2.0...');

    await databaseService.connect();

    await AuthService.ensureAdminUser();

    console.log('ðŸŒ Iniciando servidor...');
    await fastify.listen({
      port: config.port,
      host: config.host
    });

    console.log('âœ… Servidor corriendo en:');
    console.log(`   - Local:   http://localhost:${config.port}`);
    console.log(`   - Red:     http://192.168.20.22:${config.port}`);
    console.log('ðŸŽ¯ API lista para recibir conexiones');
    console.log('ðŸ“š DocumentaciÃ³n disponible en las URLs anteriores');

    if (config.nodeEnv === 'production') {
      setInterval(() => {
        console.log('ðŸ’“ Servidor activo...');
      }, 300000)
    }

  } catch (err) {
    console.error('âŒ Error al iniciar servidor:', err);
    fastify.log.error(err);
    process.exit(1);
  }
};

process.on('SIGINT', async () => {
  console.log('\nðŸ›‘ Recibida seÃ±al SIGINT, cerrando servidor...');

});

process.on('SIGTERM', async () => {
  console.log('\nðŸ›‘ Recibida seÃ±al SIGTERM, cerrando servidor...');
  await gracefulShutdown();
});

const gracefulShutdown = async () => {
  try {
    console.log('ï¿½ Cerrando conexiones...');

    await fastify.close();

    await databaseService.disconnect();

    console.log('âœ… Servidor cerrado correctamente');
    process.exit(0);
  } catch (error) {
    console.error('âŒ Error durante el cierre:', error);
    process.exit(1);
  }
};

process.on('uncaughtException', (err) => {
  console.error('âŒ Uncaught Exception:', err);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('âŒ Unhandled Rejection at:', promise, 'reason:', reason);
  process.exit(1);
});

start();

export default fastify;
/* Fin backend\src\index.ts */

/* Inicio backend\src\middleware\auth.ts */
import { FastifyReply, FastifyRequest } from 'fastify';
import AuthService from '../services/auth.service';
import { AuthenticationError, AuthorizationError, JWTPayload, UserRole } from '../types';

export interface AuthenticatedRequest extends FastifyRequest {
  user?: JWTPayload;
}

export const authenticate = async (request: AuthenticatedRequest, reply: FastifyReply) => {
  try {
    const authHeader = request.headers.authorization;

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      throw new AuthenticationError('Token de autenticaciÃ³n requerido');
    }

    const token = authHeader.substring(7)

    if (!token) {
      throw new AuthenticationError('Token de autenticaciÃ³n requerido');
    }
    const decoded = await AuthService.verifyToken(token);
    request.user = decoded;

  } catch (error) {
    if (error instanceof AuthenticationError) {
      return reply.code(error.statusCode).send({
        success: false,
        error: error.message,
        code: error.code,
      });
    }
    if (error instanceof Error && (error.message.includes('invÃ¡lido') || error.message.includes('expirado'))) {
      return reply.code(401).send({
        success: false,
        error: 'Token de autenticaciÃ³n invÃ¡lido',
        code: 'AUTHENTICATION_ERROR',
      });
    }
    throw error;
  }
};

export const authorize = (allowedRoles: UserRole[]) => {
  return async (request: AuthenticatedRequest, reply: FastifyReply) => {
    try {
      if (!request.user) {
        throw new AuthenticationError('Usuario no autenticado');
      }

      if (!allowedRoles.includes(request.user.rol)) {
        throw new AuthorizationError('Acceso denegado: rol insuficiente');
      }
    } catch (error) {
      if (error instanceof AuthenticationError || error instanceof AuthorizationError) {
        return reply.code(error.statusCode).send({
          success: false,
          error: error.message,
          code: error.code,
        });
      }
      throw error;
    }
  };
};

export const optionalAuthenticate = async (request: AuthenticatedRequest, reply: FastifyReply) => {
  try {
    const authHeader = request.headers.authorization;

    if (authHeader && authHeader.startsWith('Bearer ')) {
      const token = authHeader.substring(7);
      if (token) {
        const decoded = await AuthService.verifyToken(token);
        request.user = decoded;
      }
    }
  } catch (error) {
    console.warn('Error en autenticaciÃ³n opcional:', error);
  }
};

export default {
  authenticate,
  authorize,
  optionalAuthenticate,
};
/* Fin backend\src\middleware\auth.ts */

/* Inicio backend\src\middleware\errorHandler.ts */
import { FastifyInstance } from 'fastify';
import { AppError, DatabaseError } from '../types';

export const setupErrorHandler = (fastify: FastifyInstance) => {
  fastify.setErrorHandler((error: Error | AppError | DatabaseError, request, reply) => {

    fastify.log.error(error);

    if (error instanceof AppError) {
      return reply.code(error.statusCode).send({
        success: false,
        error: error.message,
        code: error.code,
      });
    }

    if ('validation' in error && error.validation) {
      return reply.code(400).send({
        success: false,
        error: 'Datos de entrada invÃ¡lidos',
        code: 'VALIDATION_ERROR',
        details: error.validation,
      });
    }

    if (error instanceof Error && 'code' in error && typeof (error as { code?: unknown }).code === 'string') {
      const prismaError = error as DatabaseError;

      if ('code' in prismaError) {

        if (prismaError.code === 'P2003') {
          return reply.code(400).send({
            success: false,
            error: 'Datos de referencia invÃ¡lidos',
            code: 'FOREIGN_KEY_ERROR',
          });
        }

        if (prismaError.code === 'P2002') {
          return reply.code(409).send({
            success: false,
            error: 'El registro ya existe',
            code: 'UNIQUE_CONSTRAINT_ERROR',
          });
        }

        if (prismaError.code === 'P2025') {
          return reply.code(404).send({
            success: false,
            error: 'Registro no encontrado',
            code: 'NOT_FOUND_ERROR',
          });
        }

        if (prismaError.code === 'P2000' || prismaError.code === 'P2001') {
          return reply.code(400).send({
            success: false,
            error: 'Datos invÃ¡lidos',
            code: 'VALIDATION_ERROR',
          });
        }
      }
    }

    if (error.message) {
      let statusCode = 500;
      let code = 'INTERNAL_ERROR';

      if (error.message.includes('Credenciales invÃ¡lidas') || error.message.includes('Usuario inactivo')) {
        statusCode = 401;
        code = 'AUTHENTICATION_ERROR';
      } else if (error.message.includes('Refresh token') || error.message.includes('Token invÃ¡lido')) {
        statusCode = 401;
        code = 'AUTHENTICATION_ERROR';
      } else if (error.message.includes('Acceso denegado')) {
        statusCode = 403;
        code = 'AUTHORIZATION_ERROR';
      } else if (error.message.includes('no encontrado')) {
        statusCode = 404;
        code = 'NOT_FOUND_ERROR';
      }

      return reply.code(statusCode).send({
        success: false,
        error: error.message,
        code,
      });
    }

    return reply.code(500).send({
      success: false,
      error: 'Error interno del servidor',
      code: 'INTERNAL_ERROR',
    });
  });

  fastify.setNotFoundHandler((request, reply) => {
    return reply.code(404).send({
      success: false,
      error: 'Ruta no encontrada',
      code: 'NOT_FOUND_ERROR',
    });
  });
};

export default setupErrorHandler;
/* Fin backend\src\middleware\errorHandler.ts */

/* Inicio backend\src\routes\admin-institucion.routes.ts */
import { FastifyInstance } from 'fastify';
import AdminInstitucionController from '../controllers/admin-institucion.controller';
import { authenticate, authorize } from '../middleware/auth';

export default async function adminInstitucionRoutes(fastify: FastifyInstance) {

  fastify.register(async function (adminInstitucionRoutes) {

    adminInstitucionRoutes.addHook('preHandler', authenticate);
    adminInstitucionRoutes.addHook('preHandler', authorize(['super_admin']));

    adminInstitucionRoutes.get('/', {
      handler: AdminInstitucionController.getAll,
    });

    adminInstitucionRoutes.get('/:id', {
      handler: AdminInstitucionController.getById,
    });

    adminInstitucionRoutes.post('/', {
      handler: AdminInstitucionController.create,
    });

    adminInstitucionRoutes.put('/:id', {
      handler: AdminInstitucionController.update,
    });

    adminInstitucionRoutes.delete('/:id', {
      handler: AdminInstitucionController.delete,
    });
  });
}
/* Fin backend\src\routes\admin-institucion.routes.ts */

/* Inicio backend\src\routes\auth.routes.ts */
import { FastifyInstance } from 'fastify';
import AuthController from '../controllers/auth.controller';
import { authenticate } from '../middleware/auth';

export default async function authRoutes(fastify: FastifyInstance) {
  fastify.register(async function (authRoutes) {
    authRoutes.post('/login', {
      handler: AuthController.login,
    });
    authRoutes.post('/login-test', {
      handler: AuthController.login,
    });
    authRoutes.get('/verify', {
      preHandler: authenticate,
      handler: AuthController.verify,
    });

    authRoutes.get('/instituciones', {
      preHandler: authenticate,
      handler: AuthController.getUserInstitutions,
    });

    authRoutes.post('/logout', {
      preHandler: authenticate,
      handler: AuthController.logout,
    });
    authRoutes.post('/refresh', {
      config: {
        rateLimit: {
          max: 10,
          timeWindow: '15 minutes',
        },
      },
      handler: AuthController.refreshToken,
    });
  });
}
/* Fin backend\src\routes\auth.routes.ts */

/* Inicio backend\src\routes\index.ts */
import { FastifyInstance } from 'fastify';
import adminInstitucionRoutes from './admin-institucion.routes';
import authRoutes from './auth.routes';
import institucionRoutes from './institucion.routes';
import institutionAdminRoutes from './institution-admin.routes';
import userRoutes from './user.routes';

export default async function routes(fastify: FastifyInstance) {

  fastify.get('/', async (request, reply) => {
    return {
      success: true,
      message: 'Hola Mundo desde AsistApp Backend v2.0!',
      timestamp: new Date().toISOString(),
    };
  });

  fastify.get('/health', async (request, reply) => {
    return reply.code(200).send({
      success: true,
      status: 'healthy',
      timestamp: new Date().toISOString(),
      services: {
        server: 'running'
      },
      uptime: process.uptime()
    });
  });

  fastify.get('/test', async (request, reply) => {
    return reply.code(200).send({
      success: true,
      data: {
        accessToken: 'test_token',
        refreshToken: 'test_refresh_token',
        expiresIn: 86400,
        usuario: {
          id: 'test_id',
          nombres: 'Test',
          apellidos: 'User',
          rol: 'estudiante',
          institucionId: null,
          institucion: null
        }
      }
    });
  });

  await fastify.register(authRoutes, { prefix: '/auth' });
  await fastify.register(userRoutes, { prefix: '/usuarios' });
  await fastify.register(adminInstitucionRoutes, { prefix: '/admin-institucion' });
  await fastify.register(institutionAdminRoutes, { prefix: '/institution-admin' });
  await fastify.register(institucionRoutes, { prefix: '/instituciones' });
}
/* Fin backend\src\routes\index.ts */

/* Inicio backend\src\routes\institucion.routes.ts */
import { FastifyInstance } from 'fastify';
import InstitucionController from '../controllers/institucion.controller';
import { authenticate, authorize } from '../middleware/auth';

export default async function institucionRoutes(fastify: FastifyInstance) {

  fastify.register(async function (institucionRoutes) {

    institucionRoutes.addHook('preHandler', authenticate);
    institucionRoutes.addHook('preHandler', authorize(['super_admin']));

    institucionRoutes.get('/', {
      handler: InstitucionController.getAll,
    });

    institucionRoutes.get('/:id', {
      handler: InstitucionController.getById as any,
    });
    institucionRoutes.get('/:id/admins', {
      handler: InstitucionController.getAdminsByInstitution as any,
    });

    institucionRoutes.post('/:id/admins', {
      handler: InstitucionController.assignAdminToInstitution as any,
    });

    institucionRoutes.delete('/:id/admins/:userId', {
      handler: InstitucionController.removeAdminFromInstitution as any,
    });

    institucionRoutes.post('/', {
      handler: InstitucionController.create as any,
    });

    institucionRoutes.put('/:id', {
      handler: InstitucionController.update as any,
    });

    institucionRoutes.delete('/:id', {
      handler: InstitucionController.delete as any,
    });
  });
}
/* Fin backend\src\routes\institucion.routes.ts */

/* Inicio backend\src\routes\institution-admin.routes.ts */
import { FastifyInstance } from 'fastify';
import InstitutionAdminController from '../controllers/institution-admin.controller';
import { authenticate, authorize } from '../middleware/auth';

export default async function institutionAdminRoutes(fastify: FastifyInstance) {
  fastify.addHook('preHandler', authenticate);
  fastify.addHook('preHandler', authorize(['admin_institucion']));

  fastify.get('/profesores', InstitutionAdminController.getAllProfesores);

  fastify.get('/profesores/:id', InstitutionAdminController.getProfesorById);

  fastify.post('/profesores', InstitutionAdminController.createProfesor);

  fastify.put('/profesores/:id', InstitutionAdminController.updateProfesor);

  fastify.delete('/profesores/:id', InstitutionAdminController.deleteProfesor);

  fastify.patch('/profesores/:id/toggle-status', InstitutionAdminController.toggleProfesorStatus);
}
/* Fin backend\src\routes\institution-admin.routes.ts */

/* Inicio backend\src\routes\user.routes.ts */
import { FastifyInstance } from 'fastify';
import UserController from '../controllers/user.controller';
import { authenticate, authorize } from '../middleware/auth';

export default async function userRoutes(fastify: FastifyInstance) {
  fastify.addHook('preHandler', authenticate);

  fastify.get('/', {
    preHandler: authorize(['super_admin']),
    handler: UserController.getAllUsers,
  });

  fastify.get('/:id', UserController.getUserById);

  fastify.get('/rol/:role', UserController.getUsersByRole);

  fastify.get('/institucion/:institucionId', UserController.getUsersByInstitution);

  fastify.post('/', {
    preHandler: authorize(['super_admin', 'admin_institucion']),
    handler: UserController.createUser,
  });

  fastify.put('/:id', {
    preHandler: authorize(['super_admin', 'admin_institucion']),
    handler: UserController.updateUser,
  });

  fastify.delete('/:id', {
    preHandler: authorize(['super_admin', 'admin_institucion']),
    handler: UserController.deleteUser,
  });
}
/* Fin backend\src\routes\user.routes.ts */

/* Inicio backend\src\scripts\cleanup-tokens.ts */
import { databaseService } from '../config/database';

async function cleanupExpiredRefreshTokens() {
  try {
    console.log('ðŸ§¹ Iniciando limpieza de refresh tokens expirados...');

    const prisma = databaseService.getClient();
    const result = await prisma.refreshToken.deleteMany({
      where: {
        OR: [
          { expiresAt: { lt: new Date() } }, // Expirados
          { revoked: true }, // Revocados
        ],
      },
    });

    console.log(`âœ… Eliminados ${result.count} refresh tokens expirados/revocados`);
    const remainingTokens = await prisma.refreshToken.count();
    console.log(`ðŸ“Š Tokens restantes en DB: ${remainingTokens}`);

  } catch (error) {
    console.error('âŒ Error durante la limpieza:', error);
    process.exit(1);
  } finally {
    await databaseService.disconnect();
  }
}
if (require.main === module) {
  cleanupExpiredRefreshTokens();
}

export default cleanupExpiredRefreshTokens;
/* Fin backend\src\scripts\cleanup-tokens.ts */

/* Inicio backend\src\services\admin-institucion.service.ts */
import bcrypt from 'bcryptjs';
import { prisma } from '../config/database';
import { ConflictError, PaginatedResponse, PaginationParams, ValidationError } from '../types';

export interface CreateAdminInstitucionRequest {
  email: string;
  password: string;
  nombres: string;
  apellidos: string;
  telefono?: string;
  institucionId: string;
}

export interface UpdateAdminInstitucionRequest {
  email?: string;
  nombres?: string;
  apellidos?: string;
  telefono?: string;
  activo?: boolean;
}

export interface AdminInstitucionResponse {
  id: string;
  email: string;
  nombres: string;
  apellidos: string;
  telefono: string | null;
  activo: boolean;
  institucion: {
    id: string;
    nombre: string;
  };
  createdAt: string;
  updatedAt: string;
}

export class AdminInstitucionService {

  public static async getAll(pagination?: PaginationParams): Promise<PaginatedResponse<AdminInstitucionResponse>> {
    try {
      const page = pagination?.page || 1;
      const limit = pagination?.limit || 20;
      const skip = (page - 1) * limit;
      const total = await prisma.usuario.count({
        where: { rol: 'admin_institucion' },
      });
      const admins = await prisma.usuario.findMany({
        where: { rol: 'admin_institucion' },
        include: {
          usuarioInstituciones: {
            where: { activo: true },
            include: {
              institucion: true,
            },
          },
        },
        orderBy: {
          createdAt: 'desc',
        },
        skip,
        take: limit,
      });

      const totalPages = Math.ceil(total / limit);

      const data: AdminInstitucionResponse[] = admins.map((admin: any) => ({
        id: admin.id,
        email: admin.email,
        nombres: admin.nombres,
        apellidos: admin.apellidos,
        telefono: admin.telefono,
        activo: admin.activo,
        institucion: admin.usuarioInstituciones[0] ? {
          id: admin.usuarioInstituciones[0].institucion.id,
          nombre: admin.usuarioInstituciones[0].institucion.nombre,
        } : { id: '', nombre: '' },
        createdAt: admin.createdAt.toISOString(),
        updatedAt: admin.updatedAt.toISOString(),
      }));

      return {
        data,
        pagination: {
          page,
          limit,
          total,
          totalPages,
          hasNext: page < totalPages,
          hasPrev: page > 1,
        },
      };
    } catch (error) {
      console.error('Error al obtener admins de instituciÃ³n:', error);
      throw error;
    }
  }

  public static async getById(id: string): Promise<AdminInstitucionResponse | null> {
    try {
      const admin = await prisma.usuario.findFirst({
        where: {
          id,
          rol: 'admin_institucion',
        },
        include: {
          usuarioInstituciones: {
            where: { activo: true },
            include: {
              institucion: true,
            },
          },
        },
      });

      if (!admin) {
        return null;
      }

      return {
        id: admin.id,
        email: admin.email,
        nombres: admin.nombres,
        apellidos: admin.apellidos,
        telefono: admin.telefono,
        activo: admin.activo,
        institucion: admin.usuarioInstituciones[0] ? {
          id: admin.usuarioInstituciones[0].institucion.id,
          nombre: admin.usuarioInstituciones[0].institucion.nombre,
        } : { id: '', nombre: '' },
        createdAt: admin.createdAt.toISOString(),
        updatedAt: admin.updatedAt.toISOString(),
      };
    } catch (error) {
      console.error(`Error al obtener admin de instituciÃ³n ${id}:`, error);
      throw error;
    }
  }

  public static async create(data: CreateAdminInstitucionRequest): Promise<AdminInstitucionResponse> {
    try {
      if (!data.email || !data.password || !data.nombres || !data.apellidos || !data.institucionId) {
        throw new ValidationError('Campos requeridos faltantes');
      }
      const institucion = await prisma.institucion.findUnique({
        where: { id: data.institucionId },
      });

      if (!institucion) {
        throw new ValidationError('InstituciÃ³n no encontrada');
      }
      const existingAdmin = await prisma.usuarioInstitucion.findFirst({
        where: {
          institucionId: data.institucionId,
          rolEnInstitucion: 'admin',
          activo: true,
        },
      });

      if (existingAdmin) {
        throw new ConflictError('Ya existe un admin para esta instituciÃ³n');
      }
      const emailExists = await prisma.usuario.findUnique({
        where: { email: data.email.toLowerCase() },
      });

      if (emailExists) {
        throw new ConflictError('El email ya estÃ¡ registrado');
      }
      const hashedPassword = await bcrypt.hash(data.password, 10);
      const result = await prisma.$transaction(async (tx: any) => {
        const admin = await tx.usuario.create({
          data: {
            email: data.email.toLowerCase(),
            passwordHash: hashedPassword,
            nombres: data.nombres,
            apellidos: data.apellidos,
            rol: 'admin_institucion',
            telefono: data.telefono,
          },
        });

        await tx.usuarioInstitucion.create({
          data: {
            usuarioId: admin.id,
            institucionId: data.institucionId,
            rolEnInstitucion: 'admin',
          },
        });

        return admin;
      });
      return await this.getById(result.id) as AdminInstitucionResponse;
    } catch (error) {
      console.error('Error al crear admin de instituciÃ³n:', error);
      throw error;
    }
  }

  public static async update(id: string, data: UpdateAdminInstitucionRequest): Promise<AdminInstitucionResponse | null> {
    try {
      const existingAdmin = await this.getById(id);
      if (!existingAdmin) {
        throw new ValidationError('Admin de instituciÃ³n no encontrado');
      }
      if (data.email && data.email !== existingAdmin.email) {
        const emailExists = await prisma.usuario.findUnique({
          where: { email: data.email.toLowerCase() },
        });

        if (emailExists) {
          throw new ConflictError('El email ya estÃ¡ registrado');
        }
      }
      await prisma.usuario.update({
        where: { id },
        data: {
          email: data.email?.toLowerCase(),
          nombres: data.nombres,
          apellidos: data.apellidos,
          telefono: data.telefono,
          activo: data.activo,
        },
      });

      return await this.getById(id);
    } catch (error) {
      console.error(`Error al actualizar admin de instituciÃ³n ${id}:`, error);
      throw error;
    }
  }

  public static async delete(id: string): Promise<boolean> {
    try {
      const existingAdmin = await this.getById(id);
      if (!existingAdmin) {
        throw new ValidationError('Admin de instituciÃ³n no encontrado');
      }

      await prisma.usuario.update({
        where: { id },
        data: { activo: false },
      });

      return true;
    } catch (error) {
      console.error(`Error al eliminar admin de instituciÃ³n ${id}:`, error);
      throw error;
    }
  }

  public static async isAdminOfInstitution(userId: string, institucionId: string): Promise<boolean> {
    try {
      const relacion = await prisma.usuarioInstitucion.findFirst({
        where: {
          usuarioId: userId,
          institucionId,
          rolEnInstitucion: 'admin',
          activo: true,
        },
      });

      return !!relacion;
    } catch (error) {
      console.error(`Error al verificar admin de instituciÃ³n ${userId}:`, error);
      return false;
    }
  }
}

export default AdminInstitucionService;
/* Fin backend\src\services\admin-institucion.service.ts */

/* Inicio backend\src\services\auth.service.ts */
import bcrypt from 'bcryptjs';
import crypto from 'crypto';
import { prisma } from '../config/database';
import JWTService from '../config/jwt';
import { AuthenticationError, JWTPayload, LoginRequest, LoginResponse, RefreshTokenResponse, UserRole } from '../types';

export class AuthService {

  public static async login(credentials: LoginRequest): Promise<LoginResponse> {
    const { email, password } = credentials;

    const usuario = await prisma.usuario.findUnique({
      where: { email },
      include: {
        usuarioInstituciones: {
          where: { activo: true },
          include: {
            institucion: true,
          },
        },
      },
    });

    if (!usuario) {
      throw new AuthenticationError('Credenciales invÃ¡lidas');
    }

    if (!usuario.activo) {
      throw new AuthenticationError('Usuario inactivo');
    }

    const passwordMatch = await bcrypt.compare(password, usuario.passwordHash);
    if (!passwordMatch) {
      throw new AuthenticationError('Credenciales invÃ¡lidas');
    }

    const accessToken = JWTService.signAccessToken({
      id: usuario.id,
      rol: usuario.rol as UserRole,
      email: usuario.email,
      tokenVersion: usuario.tokenVersion,
    });

    const refreshToken = JWTService.signRefreshToken({
      id: usuario.id,
      rol: usuario.rol as UserRole,
      email: usuario.email,
      tokenVersion: usuario.tokenVersion,
    });

    try {
      const decodedRefresh = JWTService.decode(refreshToken) as JWTPayload & { exp?: number };
      const exp = decodedRefresh?.exp
      const expiresAt = exp ? new Date(exp * 1000) : new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);

      const hashed = crypto.createHash('sha256').update(refreshToken).digest('hex');

      await prisma.refreshToken.create({
        data: {
          usuarioId: usuario.id,
          token: hashed,
          expiresAt,
        },
      });
    } catch (err) {

      console.warn('No se pudo guardar refresh token en DB:', err);
    }

    const expiresIn = 24 * 60 * 60

    return {
      accessToken,
      refreshToken,
      usuario: {
        id: usuario.id,
        nombres: usuario.nombres,
        apellidos: usuario.apellidos,
        rol: usuario.rol as UserRole,
        instituciones: usuario.usuarioInstituciones.map((ui: any) => ({
          id: ui.institucion.id,
          nombre: ui.institucion.nombre,
          rolEnInstitucion: ui.rolEnInstitucion,
        })),
      },
      expiresIn,
    };
  }

  public static async verifyToken(token: string) {
    const decoded = JWTService.verify(token);

    const usuario = await prisma.usuario.findUnique({
      where: { id: decoded.id },
      select: { tokenVersion: true, activo: true },
    });

    if (!usuario || !usuario.activo) {
      throw new AuthenticationError('Usuario no encontrado o inactivo');
    }

    if (usuario.tokenVersion !== decoded.tokenVersion) {
      throw new AuthenticationError('Token revocado por cambio de versiÃ³n');
    }

    return decoded;
  }

  public static async refreshToken(refreshToken: string): Promise<RefreshTokenResponse> {
    try {

      const decoded = JWTService.verifyRefreshToken(refreshToken);

      const hashed = crypto.createHash('sha256').update(refreshToken).digest('hex');

      const tokenRecord = await prisma.refreshToken.findFirst({
        where: {
          usuarioId: decoded.id,
          token: hashed,
          revoked: false,
        },
      });

      if (!tokenRecord) {
        throw new AuthenticationError('Refresh token invÃ¡lido o revocado');
      }

      if (tokenRecord.expiresAt <= new Date()) {

        await prisma.refreshToken.update({ where: { id: tokenRecord.id }, data: { revoked: true } });
        throw new AuthenticationError('Refresh token expirado');
      }

      const usuario = await prisma.usuario.findUnique({
        where: { id: decoded.id },
        include: {
          usuarioInstituciones: {
            where: { activo: true },
            include: {
              institucion: true,
            },
          },
        },
      });

      if (!usuario || !usuario.activo) {
        throw new AuthenticationError('Usuario no encontrado o inactivo');
      }

      if (usuario.tokenVersion !== decoded.tokenVersion) {
        throw new AuthenticationError('Refresh token revocado por cambio de versiÃ³n');
      }

      await prisma.refreshToken.update({ where: { id: tokenRecord.id }, data: { revoked: true } });

      const newAccessToken = JWTService.signAccessToken({
        id: usuario.id,
        rol: usuario.rol as UserRole,
        email: usuario.email,
        tokenVersion: usuario.tokenVersion,
      });

      const newRefreshToken = JWTService.signRefreshToken({
        id: usuario.id,
        rol: usuario.rol as UserRole,
        email: usuario.email,
        tokenVersion: usuario.tokenVersion,
      });

      try {
        const decodedNew = JWTService.decode(newRefreshToken) as JWTPayload & { exp?: number };
        const exp = decodedNew?.exp;
        const expiresAt = exp ? new Date(exp * 1000) : new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);
        const hashedNew = crypto.createHash('sha256').update(newRefreshToken).digest('hex');

        await prisma.refreshToken.create({
          data: {
            usuarioId: usuario.id,
            token: hashedNew,
            expiresAt,
          },
        });
      } catch (err) {
        console.warn('No se pudo guardar nuevo refresh token en DB:', err);
      }

      const expiresIn = 24 * 60 * 60

      return {
        accessToken: newAccessToken,
        refreshToken: newRefreshToken,
        expiresIn,
      };
    } catch (error) {
      if (error instanceof AuthenticationError) {
        throw error;
      }
      throw new AuthenticationError(error instanceof Error ? error.message : 'Refresh token invÃ¡lido');
    }
  }

  public static async revokeRefreshTokens(usuarioId: string, refreshToken?: string): Promise<void> {
    if (refreshToken) {
      const hashed = crypto.createHash('sha256').update(refreshToken).digest('hex');
      await prisma.refreshToken.updateMany({ where: { usuarioId, token: hashed }, data: { revoked: true } });
      return;
    }

    await prisma.refreshToken.updateMany({ where: { usuarioId, revoked: false }, data: { revoked: true } });
  }

  public static async revokeAllUserTokens(usuarioId: string): Promise<void> {
    await prisma.usuario.update({
      where: { id: usuarioId },
      data: { tokenVersion: { increment: 1 } },
    });
  }

  public static async hashPassword(password: string): Promise<string> {
    const saltRounds = 10;
    return bcrypt.hash(password, saltRounds);
  }

  public static async ensureAdminUser(): Promise<void> {
    try {
      console.log('ðŸ” Verificando usuario administrador...');

      const adminExists = await prisma.usuario.findUnique({
        where: { email: 'admin@asistapp.com' }
      });

      if (!adminExists) {
        console.log('âš ï¸ No se encontrÃ³ usuario administrador. Creando usuario por defecto...');

        const adminPassword = await this.hashPassword('pollo');

        const admin = await prisma.usuario.create({
          data: {
            email: 'admin@asistapp.com',
            passwordHash: adminPassword,
            nombres: 'Administrador',
            apellidos: 'Sistema',
            rol: 'super_admin',
            activo: true,
          },
        });

        console.log('âœ… Usuario administrador creado exitosamente:', admin.email);
      } else {
        console.log('âœ… Usuario administrador ya existe:', adminExists.email);
      }
    } catch (error) {
      console.error('âŒ Error al verificar/crear usuario administrador:', error);
      throw error;
    }
  }
}

export default AuthService;
/* Fin backend\src\services\auth.service.ts */

/* Inicio backend\src\services\institucion.service.ts */
import { prisma } from '../config/database';
import { ConflictError, PaginatedResponse, PaginationParams, ValidationError } from '../types';

export interface InstitutionFilters {
  activa?: boolean;
  search?: string;
}

export interface CreateInstitutionRequest {
  nombre: string;
  direccion?: string;
  telefono?: string;
  email?: string;
}

export interface UpdateInstitutionRequest {
  nombre?: string;
  direccion?: string;
  telefono?: string;
  email?: string;
  activa?: boolean;
}

export interface InstitutionResponse {
  id: string;
  nombre: string;
  direccion: string | null;
  telefono: string | null;
  email: string | null;
  activa: boolean;
  createdAt: string;
  updatedAt: string;
}

export class InstitucionService {

  public static async getAllInstitutions(pagination?: PaginationParams, filters?: InstitutionFilters): Promise<PaginatedResponse<InstitutionResponse>> {
    try {
      const page = pagination?.page || 1;
      const limit = pagination?.limit || 10;
      const skip = (page - 1) * limit;
      const where: any = {};

      if (filters?.activa !== undefined) {
        where.activa = filters.activa;
      }
      if (filters?.search) {
        where.OR = [
          { nombre: { contains: filters.search, mode: 'insensitive' } },
          { email: { contains: filters.search, mode: 'insensitive' } },
        ];
      }
      const total = await prisma.institucion.count({ where });
      const institutions = await prisma.institucion.findMany({
        orderBy: {
          createdAt: 'desc',
        },
        skip,
        take: limit,
        where,
      });

      const totalPages = Math.ceil(total / limit);

      const data: InstitutionResponse[] = institutions.map((inst: any) => ({
        id: inst.id,
        nombre: inst.nombre,
        direccion: inst.direccion,
        telefono: inst.telefono,
        email: inst.email,
        activa: inst.activa,
        createdAt: inst.createdAt.toISOString(),
        updatedAt: inst.updatedAt.toISOString(),
      }));

      const result = {
        data,
        pagination: {
          page,
          limit,
          total,
          totalPages,
          hasNext: page < totalPages,
          hasPrev: page > 1,
        },
      };

      return result;
    } catch (error) {
      console.error('Error al obtener todas las instituciones:', error);
      throw error;
    }
  }

  public static async getAdminsByInstitution(institutionId: string) {
    try {
      if (!institutionId) throw new ValidationError('ID de instituciÃ³n invÃ¡lido');

      const relations = await prisma.usuarioInstitucion.findMany({
        where: {
          institucionId: institutionId,
          rolEnInstitucion: 'admin',
          activo: true,
        },
        include: {
          usuario: true,
        },
      });
      const admins = relations.map((rel: any) => ({
        usuarioId: rel.usuario.id,
        email: rel.usuario.email,
        nombres: rel.usuario.nombres,
        apellidos: rel.usuario.apellidos,
        telefono: rel.usuario.telefono,
        activo: rel.usuario.activo,
        institucionId: rel.institucionId,
        rolEnInstitucion: rel.rolEnInstitucion,
      }));

      return admins;
    } catch (error) {
      console.error(`Error al obtener admins de la instituciÃ³n ${institutionId}:`, error);
      throw error;
    }
  }

  public static async assignAdminToInstitution(institutionId: string, userId: string) {
    try {
      if (!institutionId || !userId) throw new ValidationError('ParÃ¡metros invÃ¡lidos');
      const institucion = await prisma.institucion.findUnique({ where: { id: institutionId } });
      if (!institucion) throw new ValidationError('InstituciÃ³n no encontrada');
      const usuario = await prisma.usuario.findUnique({ where: { id: userId } });
      if (!usuario) throw new ValidationError('Usuario no encontrado');
      if (usuario.rol !== 'admin_institucion') {
        await prisma.usuario.update({ where: { id: userId }, data: { rol: 'admin_institucion' } });
      }
      const existingRel = await prisma.usuarioInstitucion.findUnique({
        where: { usuarioId_institucionId: { usuarioId: userId, institucionId: institutionId } },
      });

      if (existingRel) {
        await prisma.usuarioInstitucion.update({
          where: { usuarioId_institucionId: { usuarioId: userId, institucionId: institutionId } },
          data: { rolEnInstitucion: 'admin', activo: true },
        });
      } else {
        await prisma.usuarioInstitucion.create({
          data: { usuarioId: userId, institucionId: institutionId, rolEnInstitucion: 'admin', activo: true },
        });
      }
      const updatedUser = await prisma.usuario.findUnique({ where: { id: userId } });
      return updatedUser;
    } catch (error) {
      console.error(`Error al asignar admin ${userId} a instituciÃ³n ${institutionId}:`, error);
      throw error;
    }
  }

  public static async removeAdminFromInstitution(institutionId: string, userId: string) {
    try {
      if (!institutionId || !userId) throw new ValidationError('ParÃ¡metros invÃ¡lidos');

      const rel = await prisma.usuarioInstitucion.findUnique({
        where: { usuarioId_institucionId: { usuarioId: userId, institucionId: institutionId } },
      });

      if (!rel) {
        throw new ValidationError('RelaciÃ³n usuario-instituciÃ³n no encontrada');
      }
      await prisma.usuarioInstitucion.update({
        where: { usuarioId_institucionId: { usuarioId: userId, institucionId: institutionId } },
        data: { activo: false },
      });
      const otherActiveAdmin = await prisma.usuarioInstitucion.findFirst({
        where: { usuarioId: userId, rolEnInstitucion: 'admin', activo: true },
      });

      if (!otherActiveAdmin) {
        const usuario = await prisma.usuario.findUnique({ where: { id: userId } });
        if (usuario && usuario.rol === 'admin_institucion') {
          await prisma.usuario.update({ where: { id: userId }, data: { rol: 'user' } });
        }
      }

  return { usuarioId: userId, institutionId, removed: true };
    } catch (error) {
      console.error(`Error al remover admin ${userId} de instituciÃ³n ${institutionId}:`, error);
      throw error;
    }
  }

  public static async getInstitutionById(id: string): Promise<InstitutionResponse | null> {
    try {
      if (!id || typeof id !== 'string') {
        throw new ValidationError('ID de instituciÃ³n invÃ¡lido');
      }

      const institution = await prisma.institucion.findUnique({
        where: { id },
      });

      if (!institution) {
        return null;
      }

      return {
        id: institution.id,
        nombre: institution.nombre,
        direccion: institution.direccion,
        telefono: institution.telefono,
        email: institution.email,
        activa: institution.activa,
        createdAt: institution.createdAt.toISOString(),
        updatedAt: institution.updatedAt.toISOString(),
      };
    } catch (error) {
      console.error(`Error al obtener instituciÃ³n con ID ${id}:`, error);
      throw error;
    }
  }

  public static async createInstitution(data: CreateInstitutionRequest): Promise<InstitutionResponse> {
    try {
      if (!data.nombre) {
        throw new ValidationError('Nombre es requerido');
      }

      const institution = await prisma.institucion.create({
        data: {
          nombre: data.nombre,
          direccion: data.direccion,
          telefono: data.telefono,
          email: data.email,
        },
      });

      return {
        id: institution.id,
        nombre: institution.nombre,
        direccion: institution.direccion,
        telefono: institution.telefono,
        email: institution.email,
        activa: institution.activa,
        createdAt: institution.createdAt.toISOString(),
        updatedAt: institution.updatedAt.toISOString(),
      };
    } catch (error) {
      console.error('Error al crear instituciÃ³n:', error);
      throw error;
    }
  }

  public static async updateInstitution(id: string, data: UpdateInstitutionRequest): Promise<InstitutionResponse | null> {
    try {
      if (!id || typeof id !== 'string') {
        throw new ValidationError('ID de instituciÃ³n invÃ¡lido');
      }
      const existingInstitution = await this.getInstitutionById(id);
      if (!existingInstitution) {
        throw new ValidationError('InstituciÃ³n no encontrada');
      }

      const institution = await prisma.institucion.update({
        where: { id },
        data: {
          nombre: data.nombre,
          direccion: data.direccion,
          telefono: data.telefono,
          email: data.email,
          activa: data.activa,
        },
      });

      return {
        id: institution.id,
        nombre: institution.nombre,
        direccion: institution.direccion,
        telefono: institution.telefono,
        email: institution.email,
        activa: institution.activa,
        createdAt: institution.createdAt.toISOString(),
        updatedAt: institution.updatedAt.toISOString(),
      };
    } catch (error) {
      console.error(`Error al actualizar instituciÃ³n con ID ${id}:`, error);
      throw error;
    }
  }

  public static async deleteInstitution(id: string): Promise<boolean> {
    try {
      if (!id || typeof id !== 'string') {
        throw new ValidationError('ID de instituciÃ³n invÃ¡lido');
      }
      const existingInstitution = await this.getInstitutionById(id);
      if (!existingInstitution) {
        throw new ValidationError('InstituciÃ³n no encontrada');
      }
      const usuariosCount = await prisma.usuarioInstitucion.count({
        where: { institucionId: id, activo: true },
      });

      if (usuariosCount > 0) {
        throw new ConflictError('No se puede eliminar la instituciÃ³n porque tiene usuarios activos asociados');
      }

      await prisma.institucion.delete({
        where: { id },
      });

      return true;
    } catch (error) {
      console.error(`Error al eliminar instituciÃ³n con ID ${id}:`, error);
      throw error;
    }
  }
}

export default InstitucionService;
/* Fin backend\src\services\institucion.service.ts */

/* Inicio backend\src\services\profesor.service.ts */
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';
import { NotFoundError, ValidationError } from '../types';

const prisma = new PrismaClient();

export interface CreateProfesorRequest {
  nombres: string;
  apellidos: string;
  email: string;
  password: string;
  institucionId: string;
  grupoId?: string;
}

export interface UpdateProfesorRequest {
  nombres?: string;
  apellidos?: string;
  email?: string;
  grupoId?: string;
  activo?: boolean;
}

export interface ProfesorFilters {
  institucionId: string;
  activo?: boolean;
  search?: string;
}

export class ProfesorService {

  public static async getAll(
    institucionId: string,
    pagination?: { page?: number; limit?: number },
    filters?: ProfesorFilters
  ) {
    const page = pagination?.page || 1;
    const limit = pagination?.limit || 10;
    const skip = (page - 1) * limit;
    const where: any = {
      rol: 'profesor',
      usuarioInstituciones: {
        some: {
          institucionId,
          activo: true,
        },
      },
    };

    if (filters?.activo !== undefined) {
      where.activo = filters.activo;
    }

    if (filters?.search) {
      where.OR = [
        { nombres: { contains: filters.search, mode: 'insensitive' } },
        { apellidos: { contains: filters.search, mode: 'insensitive' } },
        { email: { contains: filters.search, mode: 'insensitive' } },
      ];
    }
    const total = await prisma.usuario.count({ where });
    const profesores = await prisma.usuario.findMany({
      where,
      skip,
      take: limit,
      include: {
        usuarioInstituciones: {
          where: {
            institucionId,
            activo: true,
          },
          include: {
            institucion: {
              select: {
                id: true,
                nombre: true,
              },
            },
          },
        },
      },
      orderBy: {
        apellidos: 'asc',
      },
    });
    const formattedProfesores = profesores.map((profesor: any) => ({
      id: profesor.id,
      nombres: profesor.nombres,
      apellidos: profesor.apellidos,
      email: profesor.email,
      telefono: profesor.telefono,
      activo: profesor.activo,
      institucion: profesor.usuarioInstituciones[0]?.institucion,
      createdAt: profesor.createdAt,
    }));

    return {
      data: formattedProfesores,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  public static async getById(id: string, institucionId: string) {
    const profesor = await prisma.usuario.findFirst({
      where: {
        id,
        rol: 'profesor',
        usuarioInstituciones: {
          some: {
            institucionId,
            activo: true,
          },
        },
      },
      include: {
        usuarioInstituciones: {
          where: {
            institucionId,
            activo: true,
          },
          include: {
            institucion: {
              select: {
                id: true,
                nombre: true,
              },
            },
          },
        },
      },
    });

    if (!profesor) return null;

    return {
      id: profesor.id,
      nombres: profesor.nombres,
      apellidos: profesor.apellidos,
      email: profesor.email,
      telefono: profesor.telefono,
      activo: profesor.activo,
      institucion: profesor.usuarioInstituciones[0]?.institucion,
      createdAt: profesor.createdAt,
    };
  }

  public static async create(data: CreateProfesorRequest, createdBy: string) {
    const existingUser = await prisma.usuario.findUnique({
      where: { email: data.email },
    });

    if (existingUser) {
      throw new ValidationError('El email ya estÃ¡ registrado');
    }
    const institucion = await prisma.institucion.findUnique({
      where: { id: data.institucionId },
    });

    if (!institucion) {
      throw new NotFoundError('InstituciÃ³n');
    }
    const hashedPassword = await bcrypt.hash(data.password, 10);
    const newProfesor = await prisma.usuario.create({
      data: {
        email: data.email,
        passwordHash: hashedPassword,
        nombres: data.nombres,
        apellidos: data.apellidos,
        rol: 'profesor',
        activo: true,
      },
    });
    await prisma.usuarioInstitucion.create({
      data: {
        usuarioId: newProfesor.id,
        institucionId: data.institucionId,
        activo: true,
      },
    });
    const profesorWithInstitucion = await this.getById(newProfesor.id, data.institucionId);

    return profesorWithInstitucion;
  }

  public static async update(id: string, institucionId: string, data: UpdateProfesorRequest) {
    const existingProfesor = await prisma.usuario.findFirst({
      where: {
        id,
        rol: 'profesor',
        usuarioInstituciones: {
          some: {
            institucionId,
            activo: true,
          },
        },
      },
    });

    if (!existingProfesor) {
      throw new NotFoundError('Profesor');
    }
    if (data.email && data.email !== existingProfesor.email) {
      const emailExists = await prisma.usuario.findUnique({
        where: { email: data.email },
      });

      if (emailExists) {
        throw new ValidationError('El email ya estÃ¡ registrado para otro usuario');
      }
    }

    const updatedProfesor = await prisma.usuario.update({
      where: { id },
      data: {
        nombres: data.nombres,
        apellidos: data.apellidos,
        email: data.email,
        activo: data.activo,
      },
      include: {
        usuarioInstituciones: {
          where: {
            institucionId,
            activo: true,
          },
          include: {
            institucion: {
              select: {
                id: true,
                nombre: true,
              },
            },
          },
        },
      },
    });

    return {
      id: updatedProfesor.id,
      nombres: updatedProfesor.nombres,
      apellidos: updatedProfesor.apellidos,
      email: updatedProfesor.email,
      telefono: updatedProfesor.telefono,
      activo: updatedProfesor.activo,
      institucion: updatedProfesor.usuarioInstituciones[0]?.institucion,
      createdAt: updatedProfesor.createdAt,
    };
  }

  public static async delete(id: string, institucionId: string) {
    const existingProfesor = await prisma.usuario.findFirst({
      where: {
        id,
        rol: 'profesor',
        usuarioInstituciones: {
          some: {
            institucionId,
            activo: true,
          },
        },
      },
    });

    if (!existingProfesor) {
      return false;
    }
    await prisma.usuario.update({
      where: { id },
      data: { activo: false },
    });

    return true;
  }

  public static async toggleStatus(id: string, institucionId: string) {
    const existingProfesor = await prisma.usuario.findFirst({
      where: {
        id,
        rol: 'profesor',
        usuarioInstituciones: {
          some: {
            institucionId,
            activo: true,
          },
        },
      },
    });

    if (!existingProfesor) {
      throw new NotFoundError('Profesor');
    }

    const updatedProfesor = await prisma.usuario.update({
      where: { id },
      data: { activo: !existingProfesor.activo },
      include: {
        usuarioInstituciones: {
          where: {
            institucionId,
            activo: true,
          },
          include: {
            institucion: {
              select: {
                id: true,
                nombre: true,
              },
            },
          },
        },
      },
    });

    return {
      id: updatedProfesor.id,
      nombres: updatedProfesor.nombres,
      apellidos: updatedProfesor.apellidos,
      email: updatedProfesor.email,
      telefono: updatedProfesor.telefono,
      activo: updatedProfesor.activo,
      institucion: updatedProfesor.usuarioInstituciones[0]?.institucion,
      createdAt: updatedProfesor.createdAt,
    };
  }
}

export default ProfesorService;
/* Fin backend\src\services\profesor.service.ts */

/* Inicio backend\src\services\user.service.ts */
import bcrypt from 'bcryptjs';
import { randomBytes } from 'crypto';
import { prisma } from '../config/database';
import { AuthorizationError, ConflictError, CreateUserRequest, CreateUserResponse, PaginatedResponse, PaginationParams, UpdateUserRequest, UserFilters, UserRole, UsuarioExtendido, ValidationError } from '../types';

export class UserService {

  public static async getAllUsers(pagination?: PaginationParams, filters?: UserFilters): Promise<PaginatedResponse<UsuarioExtendido>> {
    try {
      const page = pagination?.page || 1;
      const limit = pagination?.limit || 50
      const skip = (page - 1) * limit;
      const where: any = {};

      if (filters?.activo !== undefined) {
        where.activo = filters.activo;
      }
      if (filters?.rol) {
        const rolFilter: any = filters.rol as any;
        if (Array.isArray(rolFilter)) {
          where.rol = { in: rolFilter };
        } else if (typeof rolFilter === 'string' && rolFilter.includes(',')) {
          where.rol = { in: rolFilter.split(',').map(r => r.trim()) };
        } else {
          where.rol = rolFilter;
        }
      }
      if (filters?.institucionId) {
        where.usuarioInstituciones = {
          some: { institucionId: filters.institucionId, activo: true },
        };
      }
      if (filters?.search) {
        where.OR = [
          { nombres: { contains: filters.search, mode: 'insensitive' } },
          { apellidos: { contains: filters.search, mode: 'insensitive' } },
          { email: { contains: filters.search, mode: 'insensitive' } },
        ];
      }
      const total = await prisma.usuario.count({ where });
      const users = await prisma.usuario.findMany({
        include: {
          usuarioInstituciones: {
            where: { activo: true },
            include: {
              institucion: true,
            },
          },
        },
        orderBy: {
          createdAt: 'desc',
        },
        skip,
        take: limit,
        where,
      });

      const totalPages = Math.ceil(total / limit);

      return {
        data: users,
        pagination: {
          page,
          limit,
          total,
          totalPages,
          hasNext: page < totalPages,
          hasPrev: page > 1,
        },
      };
    } catch (error) {
      console.error('Error al obtener todos los usuarios:', error);
      throw error;
    }
  }

  public static async getUserById(id: string): Promise<UsuarioExtendido | null> {
    try {
      if (!id || typeof id !== 'string') {
        throw new ValidationError('ID de usuario invÃ¡lido');
      }

      const user = await prisma.usuario.findUnique({
        where: { id },
        include: {
          usuarioInstituciones: {
            where: { activo: true },
            include: {
              institucion: true,
            },
          },
          estudiante: true,
        },
      });

      return user;
    } catch (error) {
      console.error(`Error al obtener usuario con ID ${id}:`, error);
      throw error;
    }
  }

  public static async getUserByEmail(email: string): Promise<UsuarioExtendido | null> {
    try {
      if (!email || typeof email !== 'string' || !email.includes('@')) {
        throw new ValidationError('Email invÃ¡lido');
      }

      const user = await prisma.usuario.findUnique({
        where: { email: email.toLowerCase() },
        include: {
          usuarioInstituciones: {
            where: { activo: true },
            include: {
              institucion: true,
            },
          },
        },
      });

      return user;
    } catch (error) {
      console.error(`Error al obtener usuario con email ${email}:`, error);
      throw error;
    }
  }

  public static async getUsersByRole(role: string, pagination?: PaginationParams, filters?: UserFilters): Promise<PaginatedResponse<UsuarioExtendido>> {
    const combinedFilters = { ...filters, rol: role as UserRole };
    return this.getAllUsers(pagination, combinedFilters);
  }

  public static async getUsersByInstitution(institucionId: string, pagination?: PaginationParams, filters?: UserFilters): Promise<PaginatedResponse<UsuarioExtendido>> {
    const combinedFilters = { ...filters, institucionId };
    return this.getAllUsers(pagination, combinedFilters);
  }

  public static async createUser(userData: CreateUserRequest, invokerRole: UserRole): Promise<CreateUserResponse> {
    try {
      if (invokerRole === 'super_admin' && userData.rol !== 'admin_institucion' && userData.rol !== 'super_admin') {
        throw new AuthorizationError('Un Super Admin solo puede crear usuarios de tipo Administrador de InstituciÃ³n o Super Admin.');
      }
      if (invokerRole === 'super_admin' && userData.rol === 'admin_institucion' && !userData.institucionId) {
        throw new ValidationError('Se requiere un institucionId para crear un Administrador de InstituciÃ³n.');
      }
      if (invokerRole === 'admin_institucion' && (userData.rol !== 'profesor' && userData.rol !== 'estudiante')) {
        throw new AuthorizationError('Un Administrador de InstituciÃ³n solo puede crear profesores o estudiantes.');
      }
      if (!userData.email || !userData.password || !userData.nombres || !userData.apellidos || !userData.rol) {
        throw new ValidationError('Campos requeridos faltantes');
      }

      const validRoles: UserRole[] = ['super_admin', 'admin_institucion', 'profesor', 'estudiante'];
      if (!validRoles.includes(userData.rol)) {
        throw new ValidationError('Rol invÃ¡lido');
      }
      const emailAvailable = await this.isEmailAvailable(userData.email);
      if (!emailAvailable) {
        throw new ConflictError('El email ya estÃ¡ registrado');
      }
      const hashedPassword = await bcrypt.hash(userData.password, 10);
      let codigoQr: string | undefined;
      if (userData.rol === 'estudiante') {
        if (!userData.identificacion) {
          throw new ValidationError('La identificaciÃ³n es requerida para estudiantes');
        }
        codigoQr = this.generateUniqueQRCode();
      }
      const result = await prisma.$transaction(async (tx: any) => {
        const newUser = await tx.usuario.create({
          data: {
            email: userData.email.toLowerCase(),
            passwordHash: hashedPassword,
            nombres: userData.nombres,
            apellidos: userData.apellidos,
            rol: userData.rol,
            telefono: userData.telefono,
          },
        });
        if (userData.institucionId) {
          await tx.usuarioInstitucion.create({
            data: {
              usuarioId: newUser.id,
              institucionId: userData.institucionId,
              rolEnInstitucion: userData.rolEnInstitucion,
            },
          });
        }
        let estudianteData: {
          id: string;
          usuarioId: string;
          identificacion: string;
          codigoQr: string;
          nombreResponsable: string | null;
          telefonoResponsable: string | null;
        } | null = null;
        if (userData.rol === 'estudiante' && userData.identificacion) {
          estudianteData = await tx.estudiante.create({
            data: {
              usuarioId: newUser.id,
              identificacion: userData.identificacion,
              codigoQr: codigoQr!,
              nombreResponsable: userData.nombreResponsable,
              telefonoResponsable: userData.telefonoResponsable,
            },
          });
        }

        return { newUser, estudianteData };
      });
      const userWithRelations = await this.getUserById(result.newUser.id);
      if (!userWithRelations) {
        throw new Error('Error al obtener usuario creado');
      }
      const response: CreateUserResponse = {
        id: userWithRelations.id,
        email: userWithRelations.email,
        nombres: userWithRelations.nombres,
        apellidos: userWithRelations.apellidos,
        rol: userWithRelations.rol as UserRole,
        telefono: userWithRelations.telefono,
        activo: userWithRelations.activo,
        instituciones: userWithRelations.usuarioInstituciones?.map(ui => ({
          id: ui.institucion.id,
          nombre: ui.institucion.nombre,
          rolEnInstitucion: ui.rolEnInstitucion,
          activo: ui.activo,
        })) || [],
      };

      if (result.estudianteData) {
        response.estudiante = {
          id: result.estudianteData.id,
          identificacion: result.estudianteData.identificacion,
          codigoQr: result.estudianteData.codigoQr,
          nombreResponsable: result.estudianteData.nombreResponsable,
          telefonoResponsable: result.estudianteData.telefonoResponsable,
        };
      }

      return response;

    } catch (error) {
      console.error('Error al crear usuario:', error);
      throw error;
    }
  }

  public static async updateUser(id: string, userData: UpdateUserRequest): Promise<UsuarioExtendido | null> {
    try {
      if (!id || typeof id !== 'string') {
        throw new ValidationError('ID de usuario invÃ¡lido');
      }
      const existingUser = await this.getUserById(id);
      if (!existingUser) {
        throw new ValidationError('Usuario no encontrado');
      }
      if (userData.email && userData.email !== existingUser.email) {
        const emailAvailable = await this.isEmailAvailable(userData.email, id);
        if (!emailAvailable) {
          throw new ConflictError('El email ya estÃ¡ registrado');
        }
      }
      const result = await prisma.$transaction(async (tx: any) => {
        const updateData: {
          email?: string;
          nombres?: string;
          apellidos?: string;
          telefono?: string | null;
          activo?: boolean;
        } = {};
        if (userData.email !== undefined) updateData.email = userData.email.toLowerCase();
        if (userData.nombres !== undefined) updateData.nombres = userData.nombres;
        if (userData.apellidos !== undefined) updateData.apellidos = userData.apellidos;
        if (userData.telefono !== undefined) updateData.telefono = userData.telefono;
        if (userData.activo !== undefined) updateData.activo = userData.activo;

        const updatedUser = await tx.usuario.update({
          where: { id },
          data: updateData,
        });
        if (existingUser.rol === 'estudiante' && (userData.identificacion || userData.nombreResponsable || userData.telefonoResponsable)) {
          const estudianteUpdateData: {
            identificacion?: string;
            nombreResponsable?: string | null;
            telefonoResponsable?: string | null;
          } = {};
          if (userData.identificacion !== undefined) estudianteUpdateData.identificacion = userData.identificacion;
          if (userData.nombreResponsable !== undefined) estudianteUpdateData.nombreResponsable = userData.nombreResponsable;
          if (userData.telefonoResponsable !== undefined) estudianteUpdateData.telefonoResponsable = userData.telefonoResponsable;

          await tx.estudiante.update({
            where: { usuarioId: id },
            data: estudianteUpdateData,
          });
        }

        return updatedUser;
      });
      return await this.getUserById(id);

    } catch (error) {
      console.error(`Error al actualizar usuario con ID ${id}:`, error);
      throw error;
    }
  }

  public static async deleteUser(id: string): Promise<boolean> {
    try {
      if (!id || typeof id !== 'string') {
        throw new ValidationError('ID de usuario invÃ¡lido');
      }
      const existingUser = await this.getUserById(id);
      if (!existingUser) {
        throw new ValidationError('Usuario no encontrado');
      }
      await prisma.usuario.update({
        where: { id },
        data: { activo: false },
      });

      return true;

    } catch (error) {
      console.error(`Error al eliminar usuario con ID ${id}:`, error);
      throw error;
    }
  }

  private static generateUniqueQRCode(): string {
    return randomBytes(16).toString('hex').toUpperCase();
  }

  public static async userExists(id: string): Promise<boolean> {
    try {
      if (!id || typeof id !== 'string') {
        return false;
      }

      const count = await prisma.usuario.count({
        where: { id },
      });

      return count > 0;
    } catch (error) {
      console.error(`Error al verificar existencia de usuario ${id}:`, error);
      return false;
    }
  }

  public static async isEmailAvailable(email: string, excludeUserId?: string): Promise<boolean> {
    try {
      if (!email || typeof email !== 'string' || !email.includes('@')) {
        return false;
      }

      const whereClause: {
        email: string;
        id?: { not: string };
      } = { email: email.toLowerCase() };
      if (excludeUserId) {
        whereClause.id = { not: excludeUserId };
      }

      const count = await prisma.usuario.count({
        where: whereClause,
      });

      return count === 0;
    } catch (error) {
      console.error(`Error al verificar disponibilidad de email ${email}:`, error);
      return false;
    }
  }
}

export default UserService;
/* Fin backend\src\services\user.service.ts */

/* Inicio backend\src\types\index.ts */

import { PrismaClientKnownRequestError, PrismaClientValidationError } from '@prisma/client/runtime/library';
export type Institucion = any;
export type Usuario = any;

export type UserRole = 'super_admin' | 'admin_institucion' | 'profesor' | 'estudiante';

export interface LoginRequest {
  email: string;
  password: string;
}

export interface LoginResponse {
  accessToken: string;
  refreshToken: string;
  usuario: {
    id: string;
    nombres: string;
    apellidos: string;
    rol: UserRole;
    instituciones: {
      id: string;
      nombre: string;
      rolEnInstitucion?: string | null;
    }[];
  };
  expiresIn: number
}

export interface RefreshTokenRequest {
  refreshToken: string;
}

export interface RefreshTokenResponse {
  accessToken: string;
  refreshToken: string;
  expiresIn: number;
}

export interface LogoutRequest {
  refreshToken?: string;
}

export interface VerifyTokenResponse {
  usuario: JWTPayload;
  valid: boolean;
}

export interface GetUserByIdRequest {
  id: string;
}

export interface GetUsersByRoleRequest {
  role: UserRole;
}

export interface GetUsersByInstitutionRequest {
  institucionId: string;
}

export interface UserResponse {
  id: string;
  email: string;
  nombres: string;
  apellidos: string;
  rol: UserRole;
  telefono?: string | null;
  activo: boolean;
  instituciones: {
    id: string;
    nombre: string;
    rolEnInstitucion?: string | null;
    activo: boolean;
  }[];
}

export interface UsuarioExtendido extends Omit<Usuario, 'institucionId'> {
  usuarioInstituciones?: {
    institucion: Institucion;
    rolEnInstitucion?: string | null;
    activo: boolean;
  }[];
}

export interface UsuarioConInstituciones extends Usuario {
  usuarioInstituciones: {
    institucion: Institucion;
    rolEnInstitucion?: string | null;
    activo: boolean;
  }[];
}

export interface ApiResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

export class AppError extends Error {
  public readonly statusCode: number;
  public readonly code: string;
  public readonly isOperational: boolean;

  constructor(message: string, statusCode: number = 500, code: string = 'INTERNAL_ERROR') {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }
}

export class ValidationError extends AppError {
  constructor(message: string) {
    super(message, 400, 'VALIDATION_ERROR');
  }
}

export class AuthenticationError extends AppError {
  constructor(message: string = 'No autorizado') {
    super(message, 401, 'AUTHENTICATION_ERROR');
  }
}

export class AuthorizationError extends AppError {
  constructor(message: string = 'Acceso denegado') {
    super(message, 403, 'AUTHORIZATION_ERROR');
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string = 'Recurso') {
    super(`${resource} no encontrado`, 404, 'NOT_FOUND_ERROR');
  }
}

export class ConflictError extends AppError {
  constructor(message: string) {
    super(message, 409, 'CONFLICT_ERROR');
  }
}

export type DatabaseError = PrismaClientKnownRequestError | PrismaClientValidationError;

export interface JWTPayload {
  id: string;
  rol: UserRole;
  email: string;
  tokenVersion: number;
  jti?: string
  iat?: number;
  exp?: number;
}

export interface AppConfig {
  port: number;
  host: string;
  jwtSecret: string;
  jwtExpiresIn: string;
  nodeEnv: string;
  logLevel: string;
}

export interface CreateInstitucionRequest {
  nombre: string;
  direccion?: string;
  telefono?: string;
  email?: string;
}

export interface UpdateInstitucionRequest {
  nombre?: string;
  direccion?: string;
  telefono?: string;
  email?: string;
  activa?: boolean;
}

export interface InstitucionResponse {
  id: string;
  nombre: string;
  direccion?: string | null;
  telefono?: string | null;
  email?: string | null;
  activa: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface CreateUserRequest {
  email: string;
  password: string;
  nombres: string;
  apellidos: string;
  rol: UserRole;
  telefono?: string;
  institucionId?: string
  rolEnInstitucion?: string
  identificacion?: string
  nombreResponsable?: string
  telefonoResponsable?: string
}

export interface UpdateUserRequest {
  email?: string;
  nombres?: string;
  apellidos?: string;
  telefono?: string;
  activo?: boolean;
  identificacion?: string;
  nombreResponsable?: string;
  telefonoResponsable?: string;
}

export interface CreateUserResponse extends UserResponse {
  estudiante?: {
    id: string;
    identificacion: string;
    codigoQr: string;
    nombreResponsable?: string | null;
    telefonoResponsable?: string | null;
  };
}
export interface PaginationParams {
  page?: number;
  limit?: number;
}

export interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}

export interface UserFilters {
  activo?: boolean;
  rol?: UserRole;
  institucionId?: string;
  search?: string;
}
/* Fin backend\src\types\index.ts */

/* Inicio backend\src\utils\index.ts */
import { ApiResponse } from '../types';

export class ResponseUtil {

  public static success<T>(data: T, message?: string): ApiResponse<T> {
    return {
      success: true,
      data,
      message,
    };
  }

  public static error(message: string, code?: string): ApiResponse {
    return {
      success: false,
      error: message,
      message: code,
    };
  }

  public static paginated<T>(
    data: T[],
    total: number,
    page: number,
    limit: number,
    message?: string
  ): ApiResponse<{
    items: T[];
    pagination: {
      total: number;
      page: number;
      limit: number;
      totalPages: number;
    };
  }> {
    return {
      success: true,
      data: {
        items: data,
        pagination: {
          total,
          page,
          limit,
          totalPages: Math.ceil(total / limit),
        },
      },
      message,
    };
  }
}

export class ValidationUtil {

  public static isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  public static isNotEmpty(value: string | undefined | null): boolean {
    return Boolean(value && value.trim().length > 0);
  }

  public static hasMinLength(value: string | undefined | null, minLength: number): boolean {
    return Boolean(value && value.length >= minLength);
  }
}

export class FormatUtil {

  public static capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
  }

  public static snakeToCamel(str: string): string {
    return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
  }

  public static camelToSnake(str: string): string {
    return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
  }
}

export default {
  ResponseUtil,
  ValidationUtil,
  FormatUtil,
};
/* Fin backend\src\utils\index.ts */

/* Inicio backend\test-server.ts */
import Fastify from 'fastify';
const fastify = Fastify({ logger: true });

fastify.get('/', async (request, reply) => {
  return { message: 'Hola Mundo desde AsistApp Backend refactorizado!' };
});

fastify.get('/usuarios', async (request, reply) => {
  return { message: 'Endpoint de usuarios funcionando' };
});

fastify.post('/login', async (request, reply) => {
  return { message: 'Endpoint de login funcionando' };
});
const start = async () => {
  try {
    await fastify.listen({ port: 3000, host: '0.0.0.0' });
    console.log('âœ… Servidor de prueba corriendo en http://localhost:3000');
  } catch (err) {
    fastify.log.error(err);
    process.exit(1);
  }
};

start();
/* Fin backend\test-server.ts */

/* Inicio backend\tests\auth.integration.test.js */
"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fastify_1 = __importDefault(require("fastify"));
const database_1 = require("../src/config/database");
const errorHandler_1 = __importDefault(require("../src/middleware/errorHandler"));
const routes_1 = __importDefault(require("../src/routes"));
const auth_service_1 = __importDefault(require("../src/services/auth.service"));
describe('Auth Integration Tests', () => {
    let fastify;
    beforeAll(async () => {

        fastify = (0, fastify_1.default)({ logger: false });

        (0, errorHandler_1.default)(fastify);
        fastify.register(routes_1.default);

        await database_1.databaseService.connect();
        await auth_service_1.default.ensureAdminUser();
        await fastify.ready();
    });
    afterAll(async () => {
        await fastify.close();
        await database_1.databaseService.disconnect();
    });
    beforeEach(async () => {

        const client = database_1.databaseService.getClient();
        await client.refreshToken.deleteMany();
        await client.usuarioInstitucion.deleteMany();
        await client.usuario.deleteMany({
            where: {
                email: { not: 'admin@asistapp.com' }
            }
        });
        await client.institucion.deleteMany({
            where: {
                codigo: { not: 'DEFAULT' }
            }
        });
    });
    it('should complete full auth flow: login -> get institutions -> refresh -> logout', async () => {

        const institucion = await database_1.databaseService.getClient().institucion.create({
            data: {
                nombre: 'InstituciÃ³n Integration',
                codigo: 'INT001',
                activa: true,
            },
        });

        const hashedPassword = await auth_service_1.default.hashPassword('integrationpass');
        const user = await database_1.databaseService.getClient().usuario.create({
            data: {
                email: 'integration@example.com',
                passwordHash: hashedPassword,
                nombres: 'Integration',
                apellidos: 'Test',
                rol: 'estudiante',
                activo: true,
            },
        });

        await database_1.databaseService.getClient().usuarioInstitucion.create({
            data: {
                usuarioId: user.id,
                institucionId: institucion.id,
                rolEnInstitucion: 'estudiante',
                activo: true,
            },
        });

        const loginResponse = await fastify.inject({
            method: 'POST',
            url: '/auth/login',
            payload: {
                email: 'integration@example.com',
                password: 'integrationpass',
            },
        });
        expect(loginResponse.statusCode).toBe(200);
        const loginBody = JSON.parse(loginResponse.body);
        expect(loginBody.success).toBe(true);
        expect(loginBody.data).toHaveProperty('accessToken');
        expect(loginBody.data).toHaveProperty('refreshToken');
        expect(loginBody.data.usuario).toHaveProperty('instituciones');
        expect(loginBody.data.usuario.instituciones).toHaveLength(1);
        const accessToken = loginBody.data.accessToken;
        const refreshToken = loginBody.data.refreshToken;

        const institutionsResponse = await fastify.inject({
            method: 'GET',
            url: '/auth/instituciones',
            headers: {
                authorization: `Bearer ${accessToken}`,
            },
        });
        expect(institutionsResponse.statusCode).toBe(200);
        const institutionsBody = JSON.parse(institutionsResponse.body);
        expect(institutionsBody.success).toBe(true);
        expect(institutionsBody.data).toHaveLength(1);
        expect(institutionsBody.data[0].id).toBe(institucion.id);

        const verifyResponse = await fastify.inject({
            method: 'GET',
            url: '/auth/verify',
            headers: {
                authorization: `Bearer ${accessToken}`,
            },
        });
        expect(verifyResponse.statusCode).toBe(200);
        const verifyBody = JSON.parse(verifyResponse.body);
        expect(verifyBody.success).toBe(true);
        expect(verifyBody.data.valid).toBe(true);

        const refreshResponse = await fastify.inject({
            method: 'POST',
            url: '/auth/refresh',
            payload: {
                refreshToken: refreshToken,
            },
        });
        expect(refreshResponse.statusCode).toBe(200);
        const refreshBody = JSON.parse(refreshResponse.body);
        expect(refreshBody.success).toBe(true);
        expect(refreshBody.data).toHaveProperty('accessToken');
        expect(refreshBody.data).toHaveProperty('refreshToken');

        expect(refreshBody.data.refreshToken).not.toBe(refreshToken);
        const newAccessToken = refreshBody.data.accessToken;
        const newRefreshToken = refreshBody.data.refreshToken;

        const logoutResponse = await fastify.inject({
            method: 'POST',
            url: '/auth/logout',
            headers: {
                authorization: `Bearer ${newAccessToken}`,
            },
            payload: {
                refreshToken: newRefreshToken,
            },
        });
        expect(logoutResponse.statusCode).toBe(200);
        const logoutBody = JSON.parse(logoutResponse.body);
        expect(logoutBody.success).toBe(true);

        const refreshAfterLogoutResponse = await fastify.inject({
            method: 'POST',
            url: '/auth/refresh',
            payload: {
                refreshToken: newRefreshToken, // Token revocado
            },
        });
        expect(refreshAfterLogoutResponse.statusCode).toBe(401);
    });
});

/* Fin backend\tests\auth.integration.test.js */

/* Inicio backend\tests\auth.integration.test.ts */


import { afterAll, beforeAll, beforeEach, describe, expect, it } from '@jest/globals';
import Fastify from 'fastify';
import { databaseService } from '../src/config/database';
import setupErrorHandler from '../src/middleware/errorHandler';
import routes from '../src/routes';
import AuthService from '../src/services/auth.service';

describe('Auth Integration Tests', () => {
  let fastify: any;

  beforeAll(async () => {

    fastify = Fastify({ logger: false });

    setupErrorHandler(fastify);
    fastify.register(routes);

    await databaseService.connect();
    await AuthService.ensureAdminUser();

    await fastify.ready();
  });

  afterAll(async () => {
    await fastify.close();
    await databaseService.disconnect();
  });

  beforeEach(async () => {

    const client = databaseService.getClient();
    await client.refreshToken.deleteMany();
    await client.usuarioInstitucion.deleteMany();
    await client.usuario.deleteMany({
      where: {
        email: { not: 'admin@asistapp.com' }
      }
    });
    await client.institucion.deleteMany();
  });

  it('should complete full auth flow: login -> get institutions -> refresh -> logout', async () => {

    const institucion = await databaseService.getClient().institucion.create({
      data: {
        nombre: 'InstituciÃ³n Integration',
        activa: true,
      },
    });

    const hashedPassword = await AuthService.hashPassword('integrationpass');
    const user = await databaseService.getClient().usuario.create({
      data: {
        email: 'integration@example.com',
        passwordHash: hashedPassword,
        nombres: 'Integration',
        apellidos: 'Test',
        rol: 'estudiante',
        activo: true,
      },
    });

    await databaseService.getClient().usuarioInstitucion.create({
      data: {
        usuarioId: user.id,
        institucionId: institucion.id,
        rolEnInstitucion: 'estudiante',
        activo: true,
      },
    });

    const loginResponse = await fastify.inject({
      method: 'POST',
      url: '/auth/login',
      payload: {
        email: 'integration@example.com',
        password: 'integrationpass',
      },
    });

    expect(loginResponse.statusCode).toBe(200);
    const loginBody = JSON.parse(loginResponse.body);
    expect(loginBody.success).toBe(true);
    expect(loginBody.data).toHaveProperty('accessToken');
    expect(loginBody.data).toHaveProperty('refreshToken');
    expect(loginBody.data.usuario).toHaveProperty('instituciones');
    expect(loginBody.data.usuario.instituciones).toHaveLength(1);

    const accessToken = loginBody.data.accessToken;
    const refreshToken = loginBody.data.refreshToken;

    const institutionsResponse = await fastify.inject({
      method: 'GET',
      url: '/auth/instituciones',
      headers: {
        authorization: `Bearer ${accessToken}`,
      },
    });

    expect(institutionsResponse.statusCode).toBe(200);
    const institutionsBody = JSON.parse(institutionsResponse.body);
    expect(institutionsBody.success).toBe(true);
    expect(institutionsBody.data).toHaveLength(1);
    expect(institutionsBody.data[0].id).toBe(institucion.id);

    const verifyResponse = await fastify.inject({
      method: 'GET',
      url: '/auth/verify',
      headers: {
        authorization: `Bearer ${accessToken}`,
      },
    });

    expect(verifyResponse.statusCode).toBe(200);
    const verifyBody = JSON.parse(verifyResponse.body);
    expect(verifyBody.success).toBe(true);
    expect(verifyBody.data.valid).toBe(true);

    const refreshResponse = await fastify.inject({
      method: 'POST',
      url: '/auth/refresh',
      payload: {
        refreshToken: refreshToken,
      },
    });

    expect(refreshResponse.statusCode).toBe(200);
    const refreshBody = JSON.parse(refreshResponse.body);
    expect(refreshBody.success).toBe(true);
    expect(refreshBody.data).toHaveProperty('accessToken');
    expect(refreshBody.data).toHaveProperty('refreshToken');

    expect(refreshBody.data.refreshToken).not.toBe(refreshToken);

    const newAccessToken = refreshBody.data.accessToken;
    const newRefreshToken = refreshBody.data.refreshToken;

    const logoutResponse = await fastify.inject({
      method: 'POST',
      url: '/auth/logout',
      headers: {
        authorization: `Bearer ${newAccessToken}`,
      },
      payload: {
        refreshToken: newRefreshToken,
      },
    });

    expect(logoutResponse.statusCode).toBe(200);
    const logoutBody = JSON.parse(logoutResponse.body);
    expect(logoutBody.success).toBe(true);

    const refreshAfterLogoutResponse = await fastify.inject({
      method: 'POST',
      url: '/auth/refresh',
      payload: {
        refreshToken: newRefreshToken, // Token revocado
      },
    });

    expect(refreshAfterLogoutResponse.statusCode).toBe(401);
  });

  it('should handle login with invalid credentials', async () => {
    const response = await fastify.inject({
      method: 'POST',
      url: '/auth/login',
      payload: {
        email: 'nonexistent@example.com',
        password: 'wrongpassword',
      },
    });

    expect(response.statusCode).toBe(401);
    const body = JSON.parse(response.body);
    expect(body.success).toBe(false);
    expect(body.code).toBe('AUTHENTICATION_ERROR');
  });

  it('should handle missing authorization header', async () => {
    const response = await fastify.inject({
      method: 'GET',
      url: '/auth/instituciones',
    });

    expect(response.statusCode).toBe(401);
    const body = JSON.parse(response.body);
    expect(body.success).toBe(false);
    expect(body.code).toBe('AUTHENTICATION_ERROR');
  });

  it('should handle invalid JWT token', async () => {
    const response = await fastify.inject({
      method: 'GET',
      url: '/auth/instituciones',
      headers: {
        authorization: 'Bearer invalid.jwt.token',
      },
    });

    expect(response.statusCode).toBe(401);
    const body = JSON.parse(response.body);
    expect(body.success).toBe(false);
    expect(body.code).toBe('AUTHENTICATION_ERROR');
  });

  it('should handle expired refresh token', async () => {

    const institucion = await databaseService.getClient().institucion.create({
      data: {
        nombre: 'InstituciÃ³n Integration',
        activa: true,
      },
    });

    const hashedPassword = await AuthService.hashPassword('integrationpass');
    const user = await databaseService.getClient().usuario.create({
      data: {
        email: 'integration@example.com',
        passwordHash: hashedPassword,
        nombres: 'Integration',
        apellidos: 'Test',
        rol: 'estudiante',
        activo: true,
      },
    });

    await databaseService.getClient().usuarioInstitucion.create({
      data: {
        usuarioId: user.id,
        institucionId: institucion.id,
        rolEnInstitucion: 'estudiante',
        activo: true,
      },
    });

    const expiredToken = await databaseService.getClient().refreshToken.create({
      data: {
        usuarioId: user.id,
        token: 'expired_token_hash',
        expiresAt: new Date(Date.now() - 1000), // Expirado
        revoked: false,
      },
    });

    const response = await fastify.inject({
      method: 'POST',
      url: '/auth/refresh',
      payload: {
        refreshToken: 'expired_token_hash',
      },
    });

    expect(response.statusCode).toBe(401);
    const body = JSON.parse(response.body);
    expect(body.success).toBe(false);
    expect(body.code).toBe('AUTHENTICATION_ERROR');
  });

  it('should handle revoked refresh token', async () => {

    const institucion = await databaseService.getClient().institucion.create({
      data: {
        nombre: 'InstituciÃ³n Integration',
        activa: true,
      },
    });

    const hashedPassword = await AuthService.hashPassword('integrationpass');
    const user = await databaseService.getClient().usuario.create({
      data: {
        email: 'integration@example.com',
        passwordHash: hashedPassword,
        nombres: 'Integration',
        apellidos: 'Test',
        rol: 'estudiante',
        activo: true,
      },
    });

    await databaseService.getClient().usuarioInstitucion.create({
      data: {
        usuarioId: user.id,
        institucionId: institucion.id,
        rolEnInstitucion: 'estudiante',
        activo: true,
      },
    });

    const revokedToken = await databaseService.getClient().refreshToken.create({
      data: {
        usuarioId: user.id,
        token: 'revoked_token_hash',
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // VÃ¡lido
        revoked: true,
      },
    });

    const response = await fastify.inject({
      method: 'POST',
      url: '/auth/refresh',
      payload: {
        refreshToken: 'revoked_token_hash',
      },
    });

    expect(response.statusCode).toBe(401);
    const body = JSON.parse(response.body);
    expect(body.success).toBe(false);
    expect(body.code).toBe('AUTHENTICATION_ERROR');
  });

  it('should handle login with inactive user', async () => {

    const institucion = await databaseService.getClient().institucion.create({
      data: {
        nombre: 'InstituciÃ³n Integration',
        activa: true,
      },
    });

    const hashedPassword = await AuthService.hashPassword('inactivepass');
    const user = await databaseService.getClient().usuario.create({
      data: {
        email: 'inactive@example.com',
        passwordHash: hashedPassword,
        nombres: 'Inactive',
        apellidos: 'User',
        rol: 'estudiante',
        activo: false, // Usuario inactivo
      },
    });

    await databaseService.getClient().usuarioInstitucion.create({
      data: {
        usuarioId: user.id,
        institucionId: institucion.id,
        rolEnInstitucion: 'estudiante',
        activo: true,
      },
    });

    const response = await fastify.inject({
      method: 'POST',
      url: '/auth/login',
      payload: {
        email: 'inactive@example.com',
        password: 'inactivepass',
      },
    });

    expect(response.statusCode).toBe(401);
    const body = JSON.parse(response.body);
    expect(body.success).toBe(false);
    expect(body.code).toBe('AUTHENTICATION_ERROR');
  });

  it('should handle missing required fields in login', async () => {

    const response1 = await fastify.inject({
      method: 'POST',
      url: '/auth/login',
      payload: {
        password: 'somepassword',
      },
    });

    expect(response1.statusCode).toBe(400);
    const body1 = JSON.parse(response1.body);
    expect(body1.success).toBe(false);
    expect(body1.code).toBe('VALIDATION_ERROR');

    const response2 = await fastify.inject({
      method: 'POST',
      url: '/auth/login',
      payload: {
        email: 'test@example.com',
      },
    });

    expect(response2.statusCode).toBe(400);
    const body2 = JSON.parse(response2.body);
    expect(body2.success).toBe(false);
    expect(body2.code).toBe('VALIDATION_ERROR');
  });

  it('should handle malformed refresh token request', async () => {

    const response = await fastify.inject({
      method: 'POST',
      url: '/auth/refresh',
      payload: {},
    });

    expect(response.statusCode).toBe(400);
    const body = JSON.parse(response.body);
    expect(body.success).toBe(false);
    expect(body.code).toBe('VALIDATION_ERROR');
  });
});
/* Fin backend\tests\auth.integration.test.ts */

/* Inicio backend\tests\auth.service.test.js */
"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const client_1 = require("@prisma/client");
const auth_service_1 = __importDefault(require("../src/services/auth.service"));
const prisma = new client_1.PrismaClient();
describe('AuthService', () => {
    beforeAll(async () => {

        await prisma.$connect();
    });
    afterAll(async () => {
        await prisma.$disconnect();
    });
    beforeEach(async () => {

        await prisma.refreshToken.deleteMany();
        await prisma.usuarioInstitucion.deleteMany();
        await prisma.usuario.deleteMany({
            where: {
                email: { not: 'admin@asistapp.com' }
            }
        });
        await prisma.institucion.deleteMany({
            where: {
                codigo: { not: 'DEFAULT' }
            }
        });
    });
    describe('login', () => {
        it('should login valid user and return tokens with user institutions', async () => {

            const institucion = await prisma.institucion.create({
                data: {
                    nombre: 'InstituciÃ³n Test',
                    codigo: 'TEST001',
                    direccion: 'DirecciÃ³n Test',
                    telefono: '123456789',
                    email: 'test@institucion.com',
                    activa: true,
                },
            });

            const hashedPassword = await auth_service_1.default.hashPassword('testpass');
            const user = await prisma.usuario.create({
                data: {
                    email: 'test@example.com',
                    passwordHash: hashedPassword,
                    nombres: 'Test',
                    apellidos: 'User',
                    rol: 'estudiante',
                    activo: true,
                },
            });

            await prisma.usuarioInstitucion.create({
                data: {
                    usuarioId: user.id,
                    institucionId: institucion.id,
                    rolEnInstitucion: 'estudiante',
                    activo: true,
                },
            });
            const result = await auth_service_1.default.login({ email: 'test@example.com', password: 'testpass' });
            expect(result).toHaveProperty('accessToken');
            expect(result).toHaveProperty('refreshToken');
            expect(result.usuario.id).toBe(user.id);
            expect(result.usuario.instituciones).toBeDefined();
            expect(result.usuario.instituciones).toHaveLength(1);
            expect(result.usuario.instituciones[0].id).toBe(institucion.id);
            expect(result.expiresIn).toBe(24 * 60 * 60);

            const tokens = await prisma.refreshToken.findMany({ where: { usuarioId: user.id } });
            expect(tokens.length).toBe(1);
        });
        it('should throw error for invalid credentials', async () => {
            await expect(auth_service_1.default.login({ email: 'invalid@example.com', password: 'wrong' })).rejects.toThrow('Credenciales invÃ¡lidas');
        });
        it('should throw error for inactive user', async () => {

            const institucion = await prisma.institucion.create({
                data: {
                    nombre: 'InstituciÃ³n Test',
                    codigo: 'TEST002',
                    activa: true,
                },
            });
            const hashedPassword = await auth_service_1.default.hashPassword('testpass');
            const user = await prisma.usuario.create({
                data: {
                    email: 'inactive@example.com',
                    passwordHash: hashedPassword,
                    nombres: 'Inactive',
                    apellidos: 'User',
                    rol: 'estudiante',
                    activo: false,
                },
            });

            await prisma.usuarioInstitucion.create({
                data: {
                    usuarioId: user.id,
                    institucionId: institucion.id,
                    rolEnInstitucion: 'estudiante',
                    activo: true,
                },
            });
            await expect(auth_service_1.default.login({ email: 'inactive@example.com', password: 'testpass' })).rejects.toThrow('Usuario inactivo');
        });
    });
    describe('refreshToken', () => {
        it('should refresh token and rotate it', async () => {

            const hashedPassword = await auth_service_1.default.hashPassword('testpass');
            const user = await prisma.usuario.create({
                data: {
                    email: 'refresh@example.com',
                    passwordHash: hashedPassword,
                    nombres: 'Refresh',
                    apellidos: 'User',
                    rol: 'estudiante',
                    activo: true,
                },
            });
            const loginResult = await auth_service_1.default.login({ email: 'refresh@example.com', password: 'testpass' });
            const oldRefreshToken = loginResult.refreshToken;

            const refreshResult = await auth_service_1.default.refreshToken(oldRefreshToken);
            expect(refreshResult).toHaveProperty('accessToken');
            expect(refreshResult).toHaveProperty('refreshToken');
            expect(refreshResult.refreshToken).not.toBe(oldRefreshToken);

            const oldTokenRecord = await prisma.refreshToken.findFirst({
                where: { usuarioId: user.id, revoked: true },
            });
            expect(oldTokenRecord).toBeTruthy();

            const newTokens = await prisma.refreshToken.findMany({
                where: { usuarioId: user.id, revoked: false },
            });
            expect(newTokens.length).toBe(1);
        });
        it('should throw error for invalid refresh token', async () => {
            await expect(auth_service_1.default.refreshToken('invalid-token')).rejects.toThrow('Refresh token invÃ¡lido');
        });
        it('should throw error for revoked token', async () => {
            const hashedPassword = await auth_service_1.default.hashPassword('testpass');
            const user = await prisma.usuario.create({
                data: {
                    email: 'revoked@example.com',
                    passwordHash: hashedPassword,
                    nombres: 'Revoked',
                    apellidos: 'User',
                    rol: 'estudiante',
                    activo: true,
                },
            });
            const loginResult = await auth_service_1.default.login({ email: 'revoked@example.com', password: 'testpass' });
            const refreshToken = loginResult.refreshToken;

            await auth_service_1.default.revokeRefreshTokens(user.id, refreshToken);

            await expect(auth_service_1.default.refreshToken(refreshToken)).rejects.toThrow('Refresh token invÃ¡lido o revocado');
        });
    });
    describe('revokeRefreshTokens', () => {
        it('should revoke specific token', async () => {
            const hashedPassword = await auth_service_1.default.hashPassword('testpass');
            const user = await prisma.usuario.create({
                data: {
                    email: 'revoke@example.com',
                    passwordHash: hashedPassword,
                    nombres: 'Revoke',
                    apellidos: 'User',
                    rol: 'estudiante',
                    activo: true,
                },
            });
            const loginResult = await auth_service_1.default.login({ email: 'revoke@example.com', password: 'testpass' });
            const refreshToken = loginResult.refreshToken;
            await auth_service_1.default.revokeRefreshTokens(user.id, refreshToken);
            const tokenRecord = await prisma.refreshToken.findFirst({
                where: { usuarioId: user.id },
            });
            expect(tokenRecord?.revoked).toBe(true);
        });
        it('should revoke all tokens for user', async () => {
            const hashedPassword = await auth_service_1.default.hashPassword('testpass');
            const user = await prisma.usuario.create({
                data: {
                    email: 'revokeall@example.com',
                    passwordHash: hashedPassword,
                    nombres: 'Revoke All',
                    apellidos: 'User',
                    rol: 'estudiante',
                    activo: true,
                },
            });

            await auth_service_1.default.login({ email: 'revokeall@example.com', password: 'testpass' });
            await auth_service_1.default.login({ email: 'revokeall@example.com', password: 'testpass' });
            await auth_service_1.default.revokeRefreshTokens(user.id);
            const tokens = await prisma.refreshToken.findMany({
                where: { usuarioId: user.id },
            });
            expect(tokens.every(t => t.revoked)).toBe(true);
        });
    });
});

/* Fin backend\tests\auth.service.test.js */

/* Inicio backend\tests\auth.service.test.ts */


import { afterAll, beforeAll, beforeEach, describe, expect, it } from '@jest/globals';
import AuthService from '../src/services/auth.service';
import { testPrisma } from './test-database';

describe('AuthService', () => {
  beforeAll(async () => {
    await testPrisma.$connect();
  });

  afterAll(async () => {
    await testPrisma.$disconnect();
  });

  beforeEach(async () => {
    await testPrisma.refreshToken.deleteMany();
    await testPrisma.usuarioInstitucion.deleteMany();
    await testPrisma.usuario.deleteMany({
      where: {
        email: { not: 'admin@asistapp.com' }
      }
    });
    await testPrisma.institucion.deleteMany({
      where: {
        codigo: { not: 'DEFAULT' }
      }
    });
  });

  describe('login', () => {
    it('should login valid user and return tokens with user institutions', async () => {
      const institucion = await testPrisma.institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          codigo: 'TEST001',
          direccion: 'DirecciÃ³n Test',
          telefono: '123456789',
          email: 'test@institucion.com',
          activa: true,
        },
      });
      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'test@example.com',
          passwordHash: hashedPassword,
          nombres: 'Test',
          apellidos: 'User',
          rol: 'estudiante',
          activo: true,
        },
      });
      await testPrisma.usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          rolEnInstitucion: 'estudiante',
          activo: true,
        },
      });

      const result = await AuthService.login({ email: 'test@example.com', password: 'testpass' });

      expect(result).toHaveProperty('accessToken');
      expect(result).toHaveProperty('refreshToken');
      expect(result.usuario.id).toBe(user.id);
      expect(result.usuario.instituciones).toBeDefined();
      expect(result.usuario.instituciones).toHaveLength(1);
      expect(result.usuario.instituciones[0].id).toBe(institucion.id);
      expect(result.expiresIn).toBe(24 * 60 * 60);
      const tokens = await testPrisma.refreshToken.findMany({ where: { usuarioId: user.id } });
      expect(tokens.length).toBe(1);
    });

    it('should login valid user without institutions', async () => {
      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'noinst@example.com',
          passwordHash: hashedPassword,
          nombres: 'No Institution',
          apellidos: 'User',
          rol: 'super_admin',
          activo: true,
        },
      });

      const result = await AuthService.login({ email: 'noinst@example.com', password: 'testpass' });

      expect(result).toHaveProperty('accessToken');
      expect(result).toHaveProperty('refreshToken');
      expect(result.usuario.id).toBe(user.id);
      expect(result.usuario.instituciones).toBeDefined();
      expect(result.usuario.instituciones).toHaveLength(0);
      expect(result.expiresIn).toBe(24 * 60 * 60);
    });

    it('should throw error for invalid credentials', async () => {
      await expect(AuthService.login({ email: 'invalid@example.com', password: 'wrong' })).rejects.toThrow('Credenciales invÃ¡lidas');
    });

    it('should throw error for wrong password', async () => {
      const institucion = await testPrisma.institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          codigo: 'TEST002',
          activa: true,
        },
      });

      const hashedPassword = await AuthService.hashPassword('correctpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'wrongpass@example.com',
          passwordHash: hashedPassword,
          nombres: 'Wrong',
          apellidos: 'Password',
          rol: 'estudiante',
          activo: true,
        },
      });
      await testPrisma.usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          rolEnInstitucion: 'estudiante',
          activo: true,
        },
      });

      await expect(AuthService.login({ email: 'wrongpass@example.com', password: 'wrongpass' })).rejects.toThrow('Credenciales invÃ¡lidas');
    });

    it('should throw error for inactive user', async () => {
      const institucion = await testPrisma.institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          codigo: 'TEST003',
          activa: true,
        },
      });

      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'inactive@example.com',
          passwordHash: hashedPassword,
          nombres: 'Inactive',
          apellidos: 'User',
          rol: 'estudiante',
          activo: false,
        },
      });
      await testPrisma.usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          rolEnInstitucion: 'estudiante',
          activo: true,
        },
      });

      await expect(AuthService.login({ email: 'inactive@example.com', password: 'testpass' })).rejects.toThrow('Usuario inactivo');
    });

    it('should throw error for missing email', async () => {
      await expect(AuthService.login({ email: '', password: 'testpass' })).rejects.toThrow('Credenciales invÃ¡lidas');
    });

    it('should throw error for missing password', async () => {
      await expect(AuthService.login({ email: 'test@example.com', password: '' })).rejects.toThrow('Credenciales invÃ¡lidas');
    });
  });

  describe('refreshToken', () => {
    it('should refresh token and rotate it', async () => {
      const institucion = await testPrisma.institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          codigo: 'TEST004',
          activa: true,
        },
      });
      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'refresh@example.com',
          passwordHash: hashedPassword,
          nombres: 'Refresh',
          apellidos: 'User',
          rol: 'estudiante',
          activo: true,
        },
      });
      await testPrisma.usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          rolEnInstitucion: 'estudiante',
          activo: true,
        },
      });

      const loginResult = await AuthService.login({ email: 'refresh@example.com', password: 'testpass' });
      const oldRefreshToken = loginResult.refreshToken;
      const refreshResult = await AuthService.refreshToken(oldRefreshToken);

      expect(refreshResult).toHaveProperty('accessToken');
      expect(refreshResult).toHaveProperty('refreshToken');
      expect(refreshResult.refreshToken).not.toBe(oldRefreshToken);
      const oldTokenRecord = await testPrisma.refreshToken.findFirst({
        where: { usuarioId: user.id, revoked: true },
      });
      expect(oldTokenRecord).toBeTruthy();
      const newTokens = await testPrisma.refreshToken.findMany({
        where: { usuarioId: user.id, revoked: false },
      });
      expect(newTokens.length).toBe(1);
    });

    it('should throw error for invalid refresh token', async () => {
      await expect(AuthService.refreshToken('invalid-token')).rejects.toThrow('Refresh token invÃ¡lido');
    });

    it('should throw error for malformed JWT', async () => {
      await expect(AuthService.refreshToken('not-a-jwt')).rejects.toThrow('Refresh token invÃ¡lido');
    });

    it('should throw error for revoked token', async () => {
      const institucion = await testPrisma.institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          codigo: 'TEST005',
          activa: true,
        },
      });
      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'revoked@example.com',
          passwordHash: hashedPassword,
          nombres: 'Revoked',
          apellidos: 'User',
          rol: 'estudiante',
          activo: true,
        },
      });
      await testPrisma.usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          rolEnInstitucion: 'estudiante',
          activo: true,
        },
      });

      const loginResult = await AuthService.login({ email: 'revoked@example.com', password: 'testpass' });
      const refreshToken = loginResult.refreshToken;
      await AuthService.revokeRefreshTokens(user.id, refreshToken);
      await expect(AuthService.refreshToken(refreshToken)).rejects.toThrow('Refresh token invÃ¡lido o revocado');
    });

    it('should throw error for expired token', async () => {
      const institucion = await testPrisma.institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          codigo: 'TEST006',
          activa: true,
        },
      });
      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'expired@example.com',
          passwordHash: hashedPassword,
          nombres: 'Expired',
          apellidos: 'User',
          rol: 'estudiante',
          activo: true,
        },
      });
      await testPrisma.usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          rolEnInstitucion: 'estudiante',
          activo: true,
        },
      });
      const loginResult = await AuthService.login({ email: 'expired@example.com', password: 'testpass' });
      const refreshToken = loginResult.refreshToken;
      await testPrisma.refreshToken.updateMany({
        where: { usuarioId: user.id },
        data: { expiresAt: new Date(Date.now() - 1000)
      });
      await expect(AuthService.refreshToken(refreshToken)).rejects.toThrow('Refresh token expirado');
    });

    it('should throw error for missing refresh token', async () => {
      await expect(AuthService.refreshToken('')).rejects.toThrow('Refresh token invÃ¡lido');
    });
  });

  describe('revokeRefreshTokens', () => {
    it('should revoke specific token', async () => {
      const institucion = await testPrisma.institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          codigo: 'TEST007',
          activa: true,
        },
      });
      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'revoke@example.com',
          passwordHash: hashedPassword,
          nombres: 'Revoke',
          apellidos: 'User',
          rol: 'estudiante',
          activo: true,
        },
      });
      await testPrisma.usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          rolEnInstitucion: 'estudiante',
          activo: true,
        },
      });

      const loginResult = await AuthService.login({ email: 'revoke@example.com', password: 'testpass' });
      const refreshToken = loginResult.refreshToken;

      await AuthService.revokeRefreshTokens(user.id, refreshToken);

      const tokenRecord = await testPrisma.refreshToken.findFirst({
        where: { usuarioId: user.id },
      });
      expect(tokenRecord?.revoked).toBe(true);
    });

    it('should revoke all tokens for user', async () => {
      const institucion = await testPrisma.institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          codigo: 'TEST008',
          activa: true,
        },
      });
      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'revokeall@example.com',
          passwordHash: hashedPassword,
          nombres: 'Revoke All',
          apellidos: 'User',
          rol: 'estudiante',
          activo: true,
        },
      });
      await testPrisma.usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          rolEnInstitucion: 'estudiante',
          activo: true,
        },
      });
      await AuthService.login({ email: 'revokeall@example.com', password: 'testpass' });
      await AuthService.login({ email: 'revokeall@example.com', password: 'testpass' });

      await AuthService.revokeRefreshTokens(user.id);

      const tokens = await testPrisma.refreshToken.findMany({
        where: { usuarioId: user.id },
      });
      expect(tokens.every(t => t.revoked)).toBe(true);
    });

    it('should handle non-existent token gracefully', async () => {
      const institucion = await testPrisma.institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          codigo: 'TEST009',
          activa: true,
        },
      });
      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'nonexist@example.com',
          passwordHash: hashedPassword,
          nombres: 'Non Exist',
          apellidos: 'User',
          rol: 'estudiante',
          activo: true,
        },
      });
      await testPrisma.usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          rolEnInstitucion: 'estudiante',
          activo: true,
        },
      });
      await expect(AuthService.revokeRefreshTokens(user.id, 'non-existent-token')).resolves.not.toThrow();
    });
  });

  describe('hashPassword', () => {
    it('should hash password correctly', async () => {
      const password = 'testpassword';
      const hashed = await AuthService.hashPassword(password);

      expect(hashed).toBeDefined();
      expect(typeof hashed).toBe('string');
      expect(hashed.length).toBeGreaterThan(0);
      expect(hashed).not.toBe(password)
    });

    it('should generate different hashes for same password', async () => {
      const password = 'testpassword';
      const hash1 = await AuthService.hashPassword(password);
      const hash2 = await AuthService.hashPassword(password);

      expect(hash1).not.toBe(hash2)
    });
  });

  describe('verifyToken', () => {
    it('should verify valid token', async () => {
      const institucion = await testPrisma.institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          codigo: 'TEST010',
          activa: true,
        },
      });
      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'verify@example.com',
          passwordHash: hashedPassword,
          nombres: 'Verify',
          apellidos: 'User',
          rol: 'estudiante',
          activo: true,
        },
      });
      await testPrisma.usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          rolEnInstitucion: 'estudiante',
          activo: true,
        },
      });

      const loginResult = await AuthService.login({ email: 'verify@example.com', password: 'testpass' });
      const accessToken = loginResult.accessToken;

      const decoded = await AuthService.verifyToken(accessToken);

      expect(decoded.id).toBe(user.id);
      expect(decoded.rol).toBe('estudiante');
      expect(decoded.email).toBe('verify@example.com');
    });

    it('should throw error for invalid token', async () => {
      await expect(AuthService.verifyToken('invalid-token')).rejects.toThrow('Access token invÃ¡lido');
    });

    it('should throw error for inactive user', async () => {
      const institucion = await testPrisma.institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          codigo: 'TEST011',
          activa: true,
        },
      });
      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'inactive-verify@example.com',
          passwordHash: hashedPassword,
          nombres: 'Inactive Verify',
          apellidos: 'User',
          rol: 'estudiante',
          activo: true, // Usuario activo inicialmente
        },
      });
      await testPrisma.usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          rolEnInstitucion: 'estudiante',
          activo: true,
        },
      });
      const loginResult = await AuthService.login({ email: 'inactive-verify@example.com', password: 'testpass' });
      const accessToken = loginResult.accessToken;
      await testPrisma.usuario.update({
        where: { id: user.id },
        data: { activo: false },
      });
      await expect(AuthService.verifyToken(accessToken)).rejects.toThrow('Usuario no encontrado o inactivo');
    });
  });
});

/* Fin backend\tests\auth.service.test.ts */

/* Inicio backend\tests\institucion.integration.test.ts */


import { beforeAll, beforeEach, describe, expect, it } from '@jest/globals';
import Fastify from 'fastify';
import { databaseService } from '../src/config/database';
import setupErrorHandler from '../src/middleware/errorHandler';
import routes from '../src/routes';
import AuthService from '../src/services/auth.service';

describe('Institucion Integration Tests', () => {
  let fastify: any;
  let adminToken: string;

  beforeAll(async () => {

    fastify = Fastify({ logger: false });

    setupErrorHandler(fastify);
    fastify.register(routes);

    await databaseService.connect();

    await fastify.ready();
  });

  beforeEach(async () => {

    const client = databaseService.getClient();
    await client.asistencia.deleteMany();
    await client.logNotificacion.deleteMany();
    await client.estudianteGrupo.deleteMany();
    await client.horario.deleteMany();
    await client.grupo.deleteMany();
    await client.materia.deleteMany();
    await client.periodoAcademico.deleteMany();
    await client.configuracion.deleteMany();
    await client.refreshToken.deleteMany();
    await client.usuarioInstitucion.deleteMany();
    await client.estudiante.deleteMany();
    await client.usuario.deleteMany({
      where: {
        email: { not: 'admin@asistapp.com' }
      }
    });
    await client.institucion.deleteMany({
      where: {
        nombre: { not: 'InstituciÃ³n por Defecto' }
      }
    });

    await AuthService.ensureAdminUser();
    const existingDefault = await databaseService.getClient().institucion.findFirst({
      where: { nombre: 'InstituciÃ³n por Defecto' }
    });

    if (!existingDefault) {
      await databaseService.getClient().institucion.create({
        data: {
          nombre: 'InstituciÃ³n por Defecto',
          activa: true,
        },
      });
    }

    const loginResponse = await fastify.inject({
      method: 'POST',
      url: '/auth/login',
      payload: {
        email: 'admin@asistapp.com',
        password: 'pollo',
      },
    });

    const loginBody = JSON.parse(loginResponse.body);
    if (loginBody.success) {
      adminToken = loginBody.data.accessToken;
    } else {
      throw new Error('Could not obtain admin token');
    }
  });

  describe('Token verification', () => {
    it('should verify admin token works', async () => {
      console.log('Testing token:', adminToken.substring(0, 50) + '...');

      const response = await fastify.inject({
        method: 'GET',
        url: '/auth/verify',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      console.log('Verify response status:', response.statusCode);
      console.log('Verify response body:', response.body);

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data.valid).toBe(true);
      expect(body.data.usuario.rol).toBe('super_admin');
    });
  });

  describe('GET /instituciones', () => {
    it('should get all instituciones for super_admin', async () => {

      await databaseService.getClient().institucion.create({
        data: {
          nombre: 'InstituciÃ³n 1',
          activa: true,
        },
      });

      await databaseService.getClient().institucion.create({
        data: {
          nombre: 'InstituciÃ³n 2',
          activa: false,
        },
      });

      const response = await fastify.inject({
        method: 'GET',
        url: '/instituciones',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data).toHaveLength(3)
      expect(body.data[0]).toHaveProperty('id');
      expect(body.data[0]).toHaveProperty('nombre');
      expect(body.data[0]).toHaveProperty('activa');
    });

    it('should deny access to non-super-admin', async () => {

      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await databaseService.getClient().usuario.create({
        data: {
          email: 'test@example.com',
          passwordHash: hashedPassword,
          nombres: 'Test',
          apellidos: 'User',
          rol: 'admin_institucion',
          activo: true,
        },
      });

      const loginResponse = await fastify.inject({
        method: 'POST',
        url: '/auth/login',
        payload: {
          email: 'test@example.com',
          password: 'testpass',
        },
      });

      const loginBody = JSON.parse(loginResponse.body);
      const userToken = loginBody.data.accessToken;

      const response = await fastify.inject({
        method: 'GET',
        url: '/instituciones',
        headers: {
          authorization: `Bearer ${userToken}`,
        },
      });

      expect(response.statusCode).toBe(403);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHORIZATION_ERROR');
    });

    it('should deny access without authentication', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: '/instituciones',
      });

      expect(response.statusCode).toBe(401);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHENTICATION_ERROR');
    });
  });

  describe('GET /instituciones/:id', () => {
    it('should get institucion by id for super_admin', async () => {
      const institucion = await databaseService.getClient().institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          direccion: 'DirecciÃ³n Test',
          telefono: '123456789',
          email: 'test@institucion.com',
          activa: true,
        },
      });

      const response = await fastify.inject({
        method: 'GET',
        url: `/instituciones/${institucion.id}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data.id).toBe(institucion.id);
      expect(body.data.nombre).toBe('InstituciÃ³n Test');
      expect(body.data.direccion).toBe('DirecciÃ³n Test');
      expect(body.data.telefono).toBe('123456789');
      expect(body.data.email).toBe('test@institucion.com');
      expect(body.data.activa).toBe(true);
    });

    it('should return 404 for non-existent institucion', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: '/instituciones/non-existent-id',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(404);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('NOT_FOUND_ERROR');
    });
  });

  describe('POST /instituciones', () => {
    it('should create new institucion for super_admin', async () => {
      const institucionData = {
        nombre: 'Nueva InstituciÃ³n',
        direccion: 'Nueva DirecciÃ³n',
        telefono: '987654321',
        email: 'nueva@institucion.com',
      };

      const response = await fastify.inject({
        method: 'POST',
        url: '/instituciones',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: institucionData,
      });

      expect(response.statusCode).toBe(201);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data.nombre).toBe('Nueva InstituciÃ³n');
      expect(body.data.activa).toBe(true)
      expect(body.message).toBe('InstituciÃ³n creada exitosamente');

      const created = await databaseService.getClient().institucion.findUnique({
        where: { id: body.data.id },
      });
      expect(created).toBeTruthy();
      expect(created?.nombre).toBe('Nueva InstituciÃ³n');
    });

    it('should return 400 for missing required fields', async () => {
      const response = await fastify.inject({
        method: 'POST',
        url: '/instituciones',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: {
        },
      });

      expect(response.statusCode).toBe(400);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('VALIDATION_ERROR');
    });
  });

  describe('PUT /instituciones/:id', () => {
    it('should update institucion for super_admin', async () => {
      const institucion = await databaseService.getClient().institucion.create({
        data: {
          nombre: 'InstituciÃ³n Original',
          activa: true,
        },
      });

      const updateData = {
        nombre: 'InstituciÃ³n Actualizada',
        direccion: 'DirecciÃ³n Actualizada',
        telefono: '111111111',
        email: 'updated@institucion.com',
        activa: false,
      };

      const response = await fastify.inject({
        method: 'PUT',
        url: `/instituciones/${institucion.id}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: updateData,
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data.nombre).toBe('InstituciÃ³n Actualizada');
      expect(body.data.activa).toBe(false);
      expect(body.message).toBe('InstituciÃ³n actualizada exitosamente');

      const updated = await databaseService.getClient().institucion.findUnique({
        where: { id: institucion.id },
      });
      expect(updated?.nombre).toBe('InstituciÃ³n Actualizada');
    });

    it('should return 404 for non-existent institucion', async () => {
      const response = await fastify.inject({
        method: 'PUT',
        url: '/instituciones/non-existent-id',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: {
          nombre: 'ActualizaciÃ³n',
        },
      });

      expect(response.statusCode).toBe(404);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('NOT_FOUND_ERROR');
    });
  });

  describe('DELETE /instituciones/:id', () => {
    it('should delete institucion for super_admin', async () => {
      const institucion = await databaseService.getClient().institucion.create({
        data: {
          nombre: 'InstituciÃ³n a Eliminar',
          activa: true,
        },
      });

      const response = await fastify.inject({
        method: 'DELETE',
        url: `/instituciones/${institucion.id}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.message).toBe('InstituciÃ³n eliminada exitosamente');

      const deleted = await databaseService.getClient().institucion.findUnique({
        where: { id: institucion.id },
      });
      expect(deleted).toBeNull();
    });

    it('should return 404 for non-existent institucion', async () => {
      const response = await fastify.inject({
        method: 'DELETE',
        url: '/instituciones/non-existent-id',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(404);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('NOT_FOUND_ERROR');
    });

    it('should return 409 when trying to delete institucion with active users', async () => {
      const institucion = await databaseService.getClient().institucion.create({
        data: {
          nombre: 'InstituciÃ³n con Usuarios',
          activa: true,
        },
      });

      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await databaseService.getClient().usuario.create({
        data: {
          email: 'user@institucion.com',
          passwordHash: hashedPassword,
          nombres: 'Test',
          apellidos: 'User',
          rol: 'estudiante',
          activo: true,
        },
      });

      await databaseService.getClient().usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          activo: true,
        },
      });

      const response = await fastify.inject({
        method: 'DELETE',
        url: `/instituciones/${institucion.id}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(409);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('CONFLICT_ERROR');
    });
  });
});
/* Fin backend\tests\institucion.integration.test.ts */

/* Inicio backend\tests\setup.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("jest");
const database_1 = require("../src/config/database");

beforeAll(async () => {

    process.env.NODE_ENV = 'test';
    process.env.DATABASE_URL = process.env.DATABASE_URL_TEST || 'postgresql://arroz:pollo@localhost:5432/asistapp_test?schema=public';
    await database_1.databaseService.connect();
});
afterAll(async () => {
    await database_1.databaseService.disconnect();
});

/* Fin backend\tests\setup.js */

/* Inicio backend\tests\setup.ts */
import { afterAll, beforeAll } from '@jest/globals';
import { testDatabaseService } from './test-database';

beforeAll(async () => {

  process.env.NODE_ENV = 'test';
  process.env.DATABASE_URL = 'postgresql://postgres:postgres@localhost:5433/asistapp_test?schema=public';

  await testDatabaseService.connect();
});

afterAll(async () => {
  await testDatabaseService.disconnect();
});


/* Fin backend\tests\setup.ts */

/* Inicio backend\tests\simple-validation.test.js */
#!/usr/bin/env node

const assert = require('assert');
const validateUserData = (data) => {
  if (!data.rol || typeof data.rol !== 'string') {
    throw new Error('Rol invÃ¡lido');
  }

  const validRoles = ['super_admin', 'admin_institucion', 'profesor', 'estudiante'];
  if (!validRoles.includes(data.rol)) {
    throw new Error('Rol invÃ¡lido');
  }
  if (!data.email || !data.password || !data.nombres || !data.apellidos) {
    throw new Error('Campos requeridos faltantes');
  }
  if (data.rol === 'estudiante' && !data.identificacion) {
    throw new Error('La identificaciÃ³n es requerida para estudiantes');
  }
};

const validateEmail = (email) => {
  if (!email || typeof email !== 'string' || !email.includes('@')) {
    throw new Error('Email invÃ¡lido');
  }
};

const validateUserId = (id) => {
  if (!id || typeof id !== 'string') {
    throw new Error('ID de usuario invÃ¡lido');
  }
};

const generateQRCode = () => {
  return 'ABC123DEF456'
};

const hashPassword = async (password) => {
  return `hashed_${password}`;
};
const runTests = async () => {
  const results = {
    passed: 0,
    failed: 0,
    errors: []
  };

  const test = (name, fn) => {
    try {
      fn();
      results.passed++;
      console.log(`âœ“ ${name}`);
    } catch (error) {
      results.failed++;
      results.errors.push({ name, error: error.message });
      console.log(`âœ— ${name}: ${error.message}`);
    }
  };

  console.log('Ejecutando pruebas de validaciÃ³n de usuario...\n');
  test('validateUserData - profesor vÃ¡lido', () => {
    const validData = {
      email: 'profesor@test.com',
      password: 'password123',
      nombres: 'Juan',
      apellidos: 'PÃ©rez',
      rol: 'profesor',
      telefono: '+1234567890',
    };
    validateUserData(validData);
  });

  test('validateUserData - estudiante vÃ¡lido', () => {
    const validData = {
      email: 'estudiante@test.com',
      password: 'password123',
      nombres: 'MarÃ­a',
      apellidos: 'GarcÃ­a',
      rol: 'estudiante',
      identificacion: '123456789',
      nombreResponsable: 'Padre de MarÃ­a',
    };
    validateUserData(validData);
  });

  test('validateUserData - campos requeridos faltantes', () => {
    const invalidData = {
      email: 'test@test.com',
      rol: 'profesor',
    };
    try {
      validateUserData(invalidData);
      throw new Error('DeberÃ­a haber fallado');
    } catch (error) {
      if (error.message !== 'Campos requeridos faltantes') {
        throw new Error(`Error inesperado: ${error.message}`);
      }
    }
  });

  test('validateUserData - rol invÃ¡lido', () => {
    const invalidData = {
      email: 'test@test.com',
      password: 'password123',
      nombres: 'Juan',
      apellidos: 'PÃ©rez',
      rol: 'invalid_role',
    };
    try {
      validateUserData(invalidData);
      throw new Error('DeberÃ­a haber fallado');
    } catch (error) {
      if (error.message !== 'Rol invÃ¡lido') {
        throw new Error(`Error inesperado: ${error.message}`);
      }
    }
  });

  test('validateUserData - estudiante sin identificaciÃ³n', () => {
    const invalidData = {
      email: 'estudiante@test.com',
      password: 'password123',
      nombres: 'MarÃ­a',
      apellidos: 'GarcÃ­a',
      rol: 'estudiante',
    };
    try {
      validateUserData(invalidData);
      throw new Error('DeberÃ­a haber fallado');
    } catch (error) {
      if (error.message !== 'La identificaciÃ³n es requerida para estudiantes') {
        throw new Error(`Error inesperado: ${error.message}`);
      }
    }
  });
  test('validateEmail - email vÃ¡lido', () => {
    validateEmail('test@example.com');
  });

  test('validateEmail - email invÃ¡lido', () => {
    try {
      validateEmail('invalid-email');
      throw new Error('DeberÃ­a haber fallado');
    } catch (error) {
      if (error.message !== 'Email invÃ¡lido') {
        throw new Error(`Error inesperado: ${error.message}`);
      }
    }
  });

  test('validateEmail - email null', () => {
    try {
      validateEmail(null);
      throw new Error('DeberÃ­a haber fallado');
    } catch (error) {
      if (error.message !== 'Email invÃ¡lido') {
        throw new Error(`Error inesperado: ${error.message}`);
      }
    }
  });
  test('validateUserId - ID vÃ¡lido', () => {
    validateUserId('user-123');
  });

  test('validateUserId - ID invÃ¡lido', () => {
    try {
      validateUserId('');
      throw new Error('DeberÃ­a haber fallado');
    } catch (error) {
      if (error.message !== 'ID de usuario invÃ¡lido') {
        throw new Error(`Error inesperado: ${error.message}`);
      }
    }
  });
  test('generateQRCode - genera cÃ³digo QR', () => {
    const qrCode = generateQRCode();
    assert.strictEqual(typeof qrCode, 'string');
    assert(qrCode.length > 0);
    assert.strictEqual(qrCode, 'ABC123DEF456');
  });
  test('hashPassword - hashea contraseÃ±a', async () => {
    const password = 'mypassword123';
    const hashed = await hashPassword(password);
    assert.strictEqual(hashed, `hashed_${password}`);
    assert(hashed.startsWith('hashed_'));
  });
  test('roles vÃ¡lidos - acepta todos los roles', () => {
    const validRoles = ['super_admin', 'admin_institucion', 'profesor', 'estudiante'];

    validRoles.forEach(role => {
      const data = {
        email: 'test@test.com',
        password: 'password123',
        nombres: 'Test',
        apellidos: 'User',
        rol: role,
      };

      if (role === 'estudiante') {
        data.identificacion = '123456789';
      }

      validateUserData(data);
    });
  });

  test('roles invÃ¡lidos - rechaza roles invÃ¡lidos', () => {
    const invalidRoles = ['admin', 'teacher', 'student', 'superuser'];

    invalidRoles.forEach(role => {
      const data = {
        email: 'test@test.com',
        password: 'password123',
        nombres: 'Test',
        apellidos: 'User',
        rol: role,
      };

      try {
        validateUserData(data);
        throw new Error('DeberÃ­a haber fallado');
      } catch (error) {
        if (error.message !== 'Rol invÃ¡lido') {
          throw new Error(`Error inesperado: ${error.message}`);
        }
      }
    });
    const dataWithEmptyRole = {
      email: 'test@test.com',
      password: 'password123',
      nombres: 'Test',
      apellidos: 'User',
      rol: '',
    };

    try {
      validateUserData(dataWithEmptyRole);
      throw new Error('DeberÃ­a haber fallado');
    } catch (error) {
      if (error.message !== 'Rol invÃ¡lido') {
        throw new Error(`Error inesperado: ${error.message}`);
      }
    }
  });
  test('email case sensitivity - maneja mayÃºsculas/minÃºsculas', () => {
    const emails = ['Test@Example.COM', 'TEST@EXAMPLE.COM', 'test@example.com'];

    emails.forEach(email => {
      validateEmail(email);
    });
  });
  test('data sanitization - maneja espacios en blanco', () => {
    const dataWithWhitespace = {
      email: '  test@example.com  ',
      password: 'password123',
      nombres: '  Juan  ',
      apellidos: '  PÃ©rez  ',
      rol: 'profesor',
    };
    validateUserData(dataWithWhitespace);
  });

  console.log(`\nResultados: ${results.passed} pasaron, ${results.failed} fallaron`);

  if (results.failed > 0) {
    console.log('\nErrores:');
    results.errors.forEach(error => {
      console.log(`- ${error.name}: ${error.error}`);
    });
    process.exit(1);
  } else {
    console.log('\nÂ¡Todas las pruebas pasaron! âœ“');
  }
};
runTests().catch(error => {
  console.error('Error ejecutando pruebas:', error);
  process.exit(1);
});
/* Fin backend\tests\simple-validation.test.js */

/* Inicio backend\tests\test-database.ts */
import { PrismaClient } from '@prisma/client';

class TestDatabaseService {
  private static instance: TestDatabaseService;
  private prisma: PrismaClient | null = null;

  private constructor() {}

  public static getInstance(): TestDatabaseService {
    if (!TestDatabaseService.instance) {
      TestDatabaseService.instance = new TestDatabaseService();
    }
    return TestDatabaseService.instance;
  }

  public getClient(): PrismaClient {
    if (!this.prisma) {
      this.prisma = new PrismaClient({
        datasourceUrl: 'file:./test.db',
      });
    }
    return this.prisma;
  }

  public async disconnect(): Promise<void> {
    if (this.prisma) {
      await this.prisma.$disconnect();
      this.prisma = null;
    }
  }

  public async connect(): Promise<void> {
    const client = this.getClient();
    await client.$connect();
  }

  public async reset(): Promise<void> {
    const client = this.getClient();
    await client.logNotificacion.deleteMany();
    await client.asistencia.deleteMany();
    await client.estudianteGrupo.deleteMany();
    await client.horario.deleteMany();
    await client.materia.deleteMany();
    await client.grupo.deleteMany();
    await client.periodoAcademico.deleteMany();
    await client.configuracion.deleteMany();
    await client.usuarioInstitucion.deleteMany();
    await client.refreshToken.deleteMany();
    await client.estudiante.deleteMany();
    await client.usuario.deleteMany();
    await client.institucion.deleteMany();
  }
}

export const testDatabaseService = TestDatabaseService.getInstance();
export const testPrisma = testDatabaseService.getClient();
/* Fin backend\tests\test-database.ts */

/* Inicio backend\tests\user.controller.test.ts */


import { afterEach, beforeEach, describe, expect, it, jest } from '@jest/globals';
import UserController from '../../src/controllers/user.controller';
import UserService from '../../src/services/user.service';
import { ConflictError, CreateUserRequest, UpdateUserRequest, ValidationError } from '../../src/types';
jest.mock('../../src/services/user.service');
const mockRequest = (body?: any, params?: any) => ({
  body,
  params: params || {},
});

const mockReply = () => {
  const res: any = {};
  res.code = jest.fn().mockReturnValue(res);
  res.send = jest.fn().mockReturnValue(res);
  return res;
};

describe('UserController Unit Tests', () => {
  const mockUserService = UserService as jest.Mocked<typeof UserService>;

  beforeEach(() => {
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('createUser', () => {
    const validUserData: CreateUserRequest = {
      email: 'test@example.com',
      password: 'password123',
      nombres: 'Juan',
      apellidos: 'PÃ©rez',
      rol: 'profesor',
      telefono: '+1234567890',
      institucionId: 'inst-123',
      rolEnInstitucion: 'profesor',
    };

    const mockResponse = {
      id: 'user-123',
      email: validUserData.email,
      nombres: validUserData.nombres,
      apellidos: validUserData.apellidos,
      rol: validUserData.rol,
      telefono: validUserData.telefono,
      activo: true,
      instituciones: [{
        id: validUserData.institucionId,
        nombre: 'InstituciÃ³n Test',
        rolEnInstitucion: validUserData.rolEnInstitucion,
        activo: true,
      }],
    };

    it('should create user and return success response', async () => {
      mockUserService.createUser.mockResolvedValue(mockResponse);

      const request = mockRequest(validUserData);
      const reply = mockReply();

      const result = await UserController.createUser(request as any, reply as any);

      expect(mockUserService.createUser).toHaveBeenCalledWith(validUserData);
      expect(reply.code).toHaveBeenCalledWith(201);
      expect(reply.send).toHaveBeenCalledWith({
        success: true,
        data: mockResponse,
        message: 'Usuario creado exitosamente',
      });
    });

    it('should handle ValidationError and throw it', async () => {
      const validationError = new ValidationError('Campos requeridos faltantes');
      mockUserService.createUser.mockRejectedValue(validationError);

      const request = mockRequest({ email: 'test@example.com' });
      const reply = mockReply();

      await expect(UserController.createUser(request as any, reply as any)).rejects.toThrow(ValidationError);
      expect(mockUserService.createUser).toHaveBeenCalled();
    });

    it('should handle ConflictError and throw it', async () => {
      const conflictError = new ConflictError('El email ya estÃ¡ registrado');
      mockUserService.createUser.mockRejectedValue(conflictError);

      const request = mockRequest(validUserData);
      const reply = mockReply();

      await expect(UserController.createUser(request as any, reply as any)).rejects.toThrow(ConflictError);
      expect(mockUserService.createUser).toHaveBeenCalled();
    });
  });

  describe('updateUser', () => {
    const userId = 'user-123';
    const updateData: UpdateUserRequest = {
      nombres: 'Juan Carlos',
      telefono: '+9876543210',
    };

    const mockResponse = {
      id: userId,
      email: 'test@example.com',
      nombres: updateData.nombres,
      apellidos: 'PÃ©rez',
      rol: 'profesor',
      telefono: updateData.telefono,
      activo: true,
      usuarioInstituciones: [],
    };

    it('should update user and return success response', async () => {
      mockUserService.updateUser.mockResolvedValue(mockResponse);

      const request = mockRequest(updateData, { id: userId });
      const reply = mockReply();

      const result = await UserController.updateUser(request as any, reply as any);

      expect(mockUserService.updateUser).toHaveBeenCalledWith(userId, updateData);
      expect(reply.code).toHaveBeenCalledWith(200);
      expect(reply.send).toHaveBeenCalledWith({
        success: true,
        data: mockResponse,
        message: 'Usuario actualizado exitosamente',
      });
    });

    it('should handle ValidationError for invalid user id', async () => {
      const validationError = new ValidationError('ID de usuario invÃ¡lido');
      mockUserService.updateUser.mockRejectedValue(validationError);

      const request = mockRequest(updateData, { id: '' });
      const reply = mockReply();

      await expect(UserController.updateUser(request as any, reply as any)).rejects.toThrow(ValidationError);
      expect(mockUserService.updateUser).toHaveBeenCalledWith('', updateData);
    });

    it('should handle ValidationError for non-existent user', async () => {
      const validationError = new ValidationError('Usuario no encontrado');
      mockUserService.updateUser.mockRejectedValue(validationError);

      const request = mockRequest(updateData, { id: 'non-existent' });
      const reply = mockReply();

      await expect(UserController.updateUser(request as any, reply as any)).rejects.toThrow(ValidationError);
      expect(mockUserService.updateUser).toHaveBeenCalledWith('non-existent', updateData);
    });

    it('should handle ConflictError for duplicate email', async () => {
      const conflictError = new ConflictError('El email ya estÃ¡ registrado');
      mockUserService.updateUser.mockRejectedValue(conflictError);

      const emailUpdate = { email: 'existing@example.com' };
      const request = mockRequest(emailUpdate, { id: userId });
      const reply = mockReply();

      await expect(UserController.updateUser(request as any, reply as any)).rejects.toThrow(ConflictError);
      expect(mockUserService.updateUser).toHaveBeenCalledWith(userId, emailUpdate);
    });
  });

  describe('deleteUser', () => {
    const userId = 'user-123';

    it('should delete user and return success response', async () => {
      mockUserService.deleteUser.mockResolvedValue(true);

      const request = mockRequest(undefined, { id: userId });
      const reply = mockReply();

      const result = await UserController.deleteUser(request as any, reply as any);

      expect(mockUserService.deleteUser).toHaveBeenCalledWith(userId);
      expect(reply.code).toHaveBeenCalledWith(200);
      expect(reply.send).toHaveBeenCalledWith({
        success: true,
        data: null,
        message: 'Usuario eliminado exitosamente',
      });
    });

    it('should handle ValidationError for invalid user id', async () => {
      const validationError = new ValidationError('ID de usuario invÃ¡lido');
      mockUserService.deleteUser.mockRejectedValue(validationError);

      const request = mockRequest(undefined, { id: '' });
      const reply = mockReply();

      await expect(UserController.deleteUser(request as any, reply as any)).rejects.toThrow(ValidationError);
      expect(mockUserService.deleteUser).toHaveBeenCalledWith('');
    });

    it('should handle ValidationError for non-existent user', async () => {
      const validationError = new ValidationError('Usuario no encontrado');
      mockUserService.deleteUser.mockRejectedValue(validationError);

      const request = mockRequest(undefined, { id: 'non-existent' });
      const reply = mockReply();

      await expect(UserController.deleteUser(request as any, reply as any)).rejects.toThrow(ValidationError);
      expect(mockUserService.deleteUser).toHaveBeenCalledWith('non-existent');
    });
  });

  describe('getUserById', () => {
    const userId = 'user-123';
    const mockUser = {
      id: userId,
      email: 'test@example.com',
      nombres: 'Juan',
      apellidos: 'PÃ©rez',
      rol: 'profesor',
      telefono: '+1234567890',
      activo: true,
      usuarioInstituciones: [],
    };

    it('should get user by id and return success response', async () => {
      mockUserService.getUserById.mockResolvedValue(mockUser);

      const request = mockRequest(undefined, { id: userId });
      const reply = mockReply();

      const result = await UserController.getUserById(request as any, reply as any);

      expect(mockUserService.getUserById).toHaveBeenCalledWith(userId);
      expect(reply.code).toHaveBeenCalledWith(200);
      expect(reply.send).toHaveBeenCalledWith({
        success: true,
        data: mockUser,
      });
    });

    it('should handle ValidationError for invalid id', async () => {
      const validationError = new ValidationError('ID de usuario invÃ¡lido');
      mockUserService.getUserById.mockRejectedValue(validationError);

      const request = mockRequest(undefined, { id: '' });
      const reply = mockReply();

      await expect(UserController.getUserById(request as any, reply as any)).rejects.toThrow(ValidationError);
      expect(mockUserService.getUserById).toHaveBeenCalledWith('');
    });

    it('should handle NotFoundError for non-existent user', async () => {
      const notFoundError = new (class NotFoundError extends Error {
        constructor(message: string) {
          super(message);
          this.name = 'NotFoundError';
        }
      })('Usuario no encontrado');
      mockUserService.getUserById.mockRejectedValue(notFoundError);

      const request = mockRequest(undefined, { id: 'non-existent' });
      const reply = mockReply();

      await expect(UserController.getUserById(request as any, reply as any)).rejects.toThrow();
      expect(mockUserService.getUserById).toHaveBeenCalledWith('non-existent');
    });
  });

  describe('getAllUsers', () => {
    const mockUsers = [
      {
        id: 'user-1',
        email: 'user1@example.com',
        nombres: 'Juan',
        apellidos: 'PÃ©rez',
        rol: 'profesor',
        activo: true,
        usuarioInstituciones: [],
      },
      {
        id: 'user-2',
        email: 'user2@example.com',
        nombres: 'MarÃ­a',
        apellidos: 'GarcÃ­a',
        rol: 'estudiante',
        activo: true,
        usuarioInstituciones: [],
        estudiante: {
          id: 'student-1',
          identificacion: '123456789',
          codigoQr: 'QR123',
        },
      },
    ];

    it('should get all users and return success response', async () => {
      mockUserService.getAllUsers.mockResolvedValue(mockUsers);

      const request = mockRequest();
      const reply = mockReply();

      const result = await UserController.getAllUsers(request as any, reply as any);

      expect(mockUserService.getAllUsers).toHaveBeenCalled();
      expect(reply.code).toHaveBeenCalledWith(200);
      expect(reply.send).toHaveBeenCalledWith({
        success: true,
        data: mockUsers,
      });
    });

    it('should handle service errors', async () => {
      const serviceError = new Error('Database connection failed');
      mockUserService.getAllUsers.mockRejectedValue(serviceError);

      const request = mockRequest();
      const reply = mockReply();

      await expect(UserController.getAllUsers(request as any, reply as any)).rejects.toThrow('Database connection failed');
      expect(mockUserService.getAllUsers).toHaveBeenCalled();
    });
  });

  describe('getUsersByRole', () => {
    const role = 'profesor';
    const mockUsers = [
      {
        id: 'user-1',
        email: 'prof1@example.com',
        nombres: 'Juan',
        apellidos: 'PÃ©rez',
        rol: 'profesor',
        activo: true,
        usuarioInstituciones: [],
      },
    ];

    it('should get users by role and return success response', async () => {
      mockUserService.getUsersByRole.mockResolvedValue(mockUsers);

      const request = mockRequest(undefined, { role });
      const reply = mockReply();

      const result = await UserController.getUsersByRole(request as any, reply as any);

      expect(mockUserService.getUsersByRole).toHaveBeenCalledWith(role);
      expect(reply.code).toHaveBeenCalledWith(200);
      expect(reply.send).toHaveBeenCalledWith({
        success: true,
        data: mockUsers,
      });
    });

    it('should handle ValidationError for invalid role', async () => {
      const validationError = new ValidationError('Rol invÃ¡lido');
      mockUserService.getUsersByRole.mockRejectedValue(validationError);

      const request = mockRequest(undefined, { role: 'invalid_role' });
      const reply = mockReply();

      await expect(UserController.getUsersByRole(request as any, reply as any)).rejects.toThrow(ValidationError);
      expect(mockUserService.getUsersByRole).toHaveBeenCalledWith('invalid_role');
    });
  });

  describe('getUsersByInstitution', () => {
    const institucionId = 'inst-123';
    const mockUsers = [
      {
        id: 'user-1',
        email: 'user1@example.com',
        nombres: 'Juan',
        apellidos: 'PÃ©rez',
        rol: 'profesor',
        activo: true,
        usuarioInstituciones: [{
          institucion: { id: institucionId, nombre: 'InstituciÃ³n Test' },
          rolEnInstitucion: 'profesor',
          activo: true,
        }],
      },
    ];

    it('should get users by institution and return success response', async () => {
      mockUserService.getUsersByInstitution.mockResolvedValue(mockUsers);

      const request = mockRequest(undefined, { institucionId });
      const reply = mockReply();

      const result = await UserController.getUsersByInstitution(request as any, reply as any);

      expect(mockUserService.getUsersByInstitution).toHaveBeenCalledWith(institucionId);
      expect(reply.code).toHaveBeenCalledWith(200);
      expect(reply.send).toHaveBeenCalledWith({
        success: true,
        data: mockUsers,
      });
    });

    it('should handle ValidationError for invalid institution id', async () => {
      const validationError = new ValidationError('ID de instituciÃ³n invÃ¡lido');
      mockUserService.getUsersByInstitution.mockRejectedValue(validationError);

      const request = mockRequest(undefined, { institucionId: '' });
      const reply = mockReply();

      await expect(UserController.getUsersByInstitution(request as any, reply as any)).rejects.toThrow(ValidationError);
      expect(mockUserService.getUsersByInstitution).toHaveBeenCalledWith('');
    });
  });
});
/* Fin backend\tests\user.controller.test.ts */

/* Inicio backend\tests\user.integration.test.ts */


import { afterAll, beforeAll, beforeEach, describe, expect, it } from '@jest/globals';
import Fastify, { FastifyInstance } from 'fastify';
import { databaseService } from '../src/config/database';
import setupErrorHandler from '../src/middleware/errorHandler';
import routes from '../src/routes';
import AuthService from '../src/services/auth.service';

describe('User Integration Tests', () => {
  let fastify: FastifyInstance;
  let adminToken: string;
  let institucionId: string;
  let studentUserId: string;

  beforeAll(async () => {

    fastify = Fastify({ logger: false });

    setupErrorHandler(fastify);
    fastify.register(routes);

    await databaseService.connect();
    await AuthService.ensureAdminUser();

    await fastify.ready();
  });

  afterAll(async () => {
    await fastify.close();
    await databaseService.disconnect();
  });

  beforeEach(async () => {

    const client = databaseService.getClient();
    await client.refreshToken.deleteMany();
    await client.usuarioInstitucion.deleteMany();
    await client.usuario.deleteMany({
      where: {
        email: { not: 'admin@asistapp.com' }
      }
    });
    await client.institucion.deleteMany();

    const institucion = await client.institucion.create({
      data: {
        nombre: 'InstituciÃ³n Test',
        activa: true,
      },
    });
    institucionId = institucion.id;

    const hashedPassword = await AuthService.hashPassword('studentpass');
    const student = await client.usuario.create({
      data: {
        email: 'student@test.com',
        passwordHash: hashedPassword,
        nombres: 'Estudiante',
        apellidos: 'Test',
        rol: 'estudiante',
        activo: true,
      },
    });
    studentUserId = student.id;

    await client.usuarioInstitucion.create({
      data: {
        usuarioId: student.id,
        institucionId: institucion.id,
        rolEnInstitucion: 'estudiante',
        activo: true,
      },
    });

    const loginResponse = await fastify.inject({
      method: 'POST',
      url: '/auth/login',
      payload: {
        email: 'admin@asistapp.com',
        password: 'pollo',
      },
    });

    const loginBody = JSON.parse(loginResponse.body);
    adminToken = loginBody.data.accessToken;
  });

  describe('GET /usuarios', () => {
    it('should get all users with admin token', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: '/usuarios',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(Array.isArray(body.data)).toBe(true);
      expect(body.data.length).toBeGreaterThan(0);
    });

    it('should fail without authentication token', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: '/usuarios',
      });

      expect(response.statusCode).toBe(401);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHENTICATION_ERROR');
    });

    it('should fail with student token (insufficient permissions)', async () => {

      const loginResponse = await fastify.inject({
        method: 'POST',
        url: '/auth/login',
        payload: {
          email: 'student@test.com',
          password: 'studentpass',
        },
      });

      const loginBody = JSON.parse(loginResponse.body);
      const studentToken = loginBody.data.accessToken;

      const response = await fastify.inject({
        method: 'GET',
        url: '/usuarios',
        headers: {
          authorization: `Bearer ${studentToken}`,
        },
      });

      expect(response.statusCode).toBe(403);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHORIZATION_ERROR');
    });
  });

  describe('GET /usuarios/:id', () => {
    it('should get user by id with valid token', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: `/usuarios/${studentUserId}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data).toHaveProperty('id', studentUserId);
      expect(body.data).toHaveProperty('email', 'student@test.com');
    });

    it('should fail with invalid user id', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: '/usuarios/invalid-id-123',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(404);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('NOT_FOUND_ERROR');
    });

    it('should fail without authentication token', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: `/usuarios/${studentUserId}`,
      });

      expect(response.statusCode).toBe(401);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHENTICATION_ERROR');
    });
  });

  describe('GET /usuarios/rol/:role', () => {
    it('should get users by role with admin token', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: '/usuarios/rol/estudiante',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(Array.isArray(body.data)).toBe(true);
      expect(body.data.length).toBeGreaterThan(0);
      expect(body.data[0]).toHaveProperty('rol', 'estudiante');
    });

    it('should return empty array for role with no users', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: '/usuarios/rol/profesor',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(Array.isArray(body.data)).toBe(true);
      expect(body.data.length).toBe(0);
    });

    it('should fail without authentication token', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: '/usuarios/rol/estudiante',
      });

      expect(response.statusCode).toBe(401);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHENTICATION_ERROR');
    });

    it('should fail with student token (insufficient permissions)', async () => {

      const loginResponse = await fastify.inject({
        method: 'POST',
        url: '/auth/login',
        payload: {
          email: 'student@test.com',
          password: 'studentpass',
        },
      });

      const loginBody = JSON.parse(loginResponse.body);
      const studentToken = loginBody.data.accessToken;

      const response = await fastify.inject({
        method: 'GET',
        url: '/usuarios/rol/estudiante',
        headers: {
          authorization: `Bearer ${studentToken}`,
        },
      });

      expect(response.statusCode).toBe(403);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHORIZATION_ERROR');
    });
  });

  describe('GET /usuarios/institucion/:institucionId', () => {
    it('should get users by institution with valid token', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: `/usuarios/institucion/${institucionId}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(Array.isArray(body.data)).toBe(true);
      expect(body.data.length).toBeGreaterThan(0);
    });

    it('should return empty array for institution with no users', async () => {

      const emptyInstitution = await databaseService.getClient().institucion.create({
        data: {
          nombre: 'InstituciÃ³n VacÃ­a',
          activa: true,
        },
      });

      const response = await fastify.inject({
        method: 'GET',
        url: `/usuarios/institucion/${emptyInstitution.id}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(Array.isArray(body.data)).toBe(true);
      expect(body.data.length).toBe(0);
    });

    it('should fail without authentication token', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: `/usuarios/institucion/${institucionId}`,
      });

      expect(response.statusCode).toBe(401);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHENTICATION_ERROR');
    });
  });

  describe('POST /usuarios/admin/cleanup-tokens', () => {
    it('should cleanup expired tokens with super_admin token', async () => {
      const response = await fastify.inject({
        method: 'POST',
        url: '/usuarios/admin/cleanup-tokens',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data).toHaveProperty('message');
    });

    it('should fail without authentication token', async () => {
      const response = await fastify.inject({
        method: 'POST',
        url: '/usuarios/admin/cleanup-tokens',
      });

      expect(response.statusCode).toBe(401);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHENTICATION_ERROR');
    });

    it('should fail with student token (insufficient permissions)', async () => {

      const loginResponse = await fastify.inject({
        method: 'POST',
        url: '/auth/login',
        payload: {
          email: 'student@test.com',
          password: 'studentpass',
        },
      });

      const loginBody = JSON.parse(loginResponse.body);
      const studentToken = loginBody.data.accessToken;

      const response = await fastify.inject({
        method: 'POST',
        url: '/usuarios/admin/cleanup-tokens',
        headers: {
          authorization: `Bearer ${studentToken}`,
        },
      });

      expect(response.statusCode).toBe(403);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHORIZATION_ERROR');
    });
  });

  describe('POST /usuarios', () => {
    it('should create a new profesor user with admin token', async () => {
      const newUser = {
        email: 'profesor@test.com',
        password: 'password123',
        nombres: 'Juan',
        apellidos: 'PÃ©rez',
        rol: 'profesor',
        telefono: '+1234567890',
        institucionId: institucionId,
        rolEnInstitucion: 'profesor',
      };

      const response = await fastify.inject({
        method: 'POST',
        url: '/usuarios',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: newUser,
      });

      expect(response.statusCode).toBe(201);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data).toHaveProperty('id');
      expect(body.data.email).toBe(newUser.email);
      expect(body.data.nombres).toBe(newUser.nombres);
      expect(body.data.rol).toBe(newUser.rol);
      expect(body.data.instituciones).toHaveLength(1);
    });

    it('should create a new estudiante user with admin token', async () => {
      const newUser = {
        email: 'estudiante2@test.com',
        password: 'password123',
        nombres: 'MarÃ­a',
        apellidos: 'GarcÃ­a',
        rol: 'estudiante',
        telefono: '+0987654321',
        institucionId: institucionId,
        rolEnInstitucion: 'estudiante',
        identificacion: '123456789',
        nombreResponsable: 'Padre de MarÃ­a',
        telefonoResponsable: '+111111111',
      };

      const response = await fastify.inject({
        method: 'POST',
        url: '/usuarios',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: newUser,
      });

      expect(response.statusCode).toBe(201);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data).toHaveProperty('id');
      expect(body.data.email).toBe(newUser.email);
      expect(body.data.estudiante).toBeDefined();
      expect(body.data.estudiante.identificacion).toBe(newUser.identificacion);
      expect(body.data.estudiante.nombreResponsable).toBe(newUser.nombreResponsable);
    });

    it('should fail to create user with duplicate email', async () => {
      const newUser = {
        email: 'student@test.com', // Email ya existente
        password: 'password123',
        nombres: 'Duplicado',
        apellidos: 'Usuario',
        rol: 'profesor',
      };

      const response = await fastify.inject({
        method: 'POST',
        url: '/usuarios',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: newUser,
      });

      expect(response.statusCode).toBe(409);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('CONFLICT_ERROR');
    });

    it('should fail to create estudiante without identificacion', async () => {
      const newUser = {
        email: 'estudiante3@test.com',
        password: 'password123',
        nombres: 'Pedro',
        apellidos: 'LÃ³pez',
        rol: 'estudiante',
      };

      const response = await fastify.inject({
        method: 'POST',
        url: '/usuarios',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: newUser,
      });

      expect(response.statusCode).toBe(400);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('VALIDATION_ERROR');
    });

    it('should fail without authentication token', async () => {
      const newUser = {
        email: 'test@test.com',
        password: 'password123',
        nombres: 'Test',
        apellidos: 'User',
        rol: 'profesor',
      };

      const response = await fastify.inject({
        method: 'POST',
        url: '/usuarios',
        payload: newUser,
      });

      expect(response.statusCode).toBe(401);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHENTICATION_ERROR');
    });
  });

  describe('PUT /usuarios/:id', () => {
    it('should update user with admin token', async () => {
      const updateData = {
        nombres: 'Estudiante Actualizado',
        telefono: '+555555555',
      };

      const response = await fastify.inject({
        method: 'PUT',
        url: `/usuarios/${studentUserId}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: updateData,
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data.nombres).toBe(updateData.nombres);
      expect(body.data.telefono).toBe(updateData.telefono);
    });

    it('should update estudiante data', async () => {
      const updateData = {
        nombreResponsable: 'Madre Actualizada',
        telefonoResponsable: '+999999999',
      };

      const response = await fastify.inject({
        method: 'PUT',
        url: `/usuarios/${studentUserId}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: updateData,
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data.estudiante.nombreResponsable).toBe(updateData.nombreResponsable);
      expect(body.data.estudiante.telefonoResponsable).toBe(updateData.telefonoResponsable);
    });

    it('should fail to update with duplicate email', async () => {
      const otherUser = await databaseService.getClient().usuario.create({
        data: {
          email: 'other@test.com',
          passwordHash: await AuthService.hashPassword('password'),
          nombres: 'Otro',
          apellidos: 'Usuario',
          rol: 'profesor',
          activo: true,
        },
      });

      const updateData = {
        email: 'student@test.com', // Email ya existente
      };

      const response = await fastify.inject({
        method: 'PUT',
        url: `/usuarios/${otherUser.id}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: updateData,
      });

      expect(response.statusCode).toBe(409);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('CONFLICT_ERROR');
    });

    it('should fail with invalid user id', async () => {
      const updateData = {
        nombres: 'Nombre Actualizado',
      };

      const response = await fastify.inject({
        method: 'PUT',
        url: '/usuarios/invalid-id-123',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: updateData,
      });

      expect(response.statusCode).toBe(404);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('NOT_FOUND_ERROR');
    });

    it('should fail without authentication token', async () => {
      const updateData = {
        nombres: 'Nombre Actualizado',
      };

      const response = await fastify.inject({
        method: 'PUT',
        url: `/usuarios/${studentUserId}`,
        payload: updateData,
      });

      expect(response.statusCode).toBe(401);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHENTICATION_ERROR');
    });
  });

  describe('DELETE /usuarios/:id', () => {
    it('should delete user with super_admin token', async () => {
      const response = await fastify.inject({
        method: 'DELETE',
        url: `/usuarios/${studentUserId}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.message).toBe('Usuario eliminado exitosamente');
      const checkResponse = await fastify.inject({
        method: 'GET',
        url: `/usuarios/${studentUserId}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(checkResponse.statusCode).toBe(200);
      const checkBody = JSON.parse(checkResponse.body);
      expect(checkBody.data.activo).toBe(false);
    });

    it('should fail with invalid user id', async () => {
      const response = await fastify.inject({
        method: 'DELETE',
        url: '/usuarios/invalid-id-123',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(404);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('NOT_FOUND_ERROR');
    });

    it('should fail without authentication token', async () => {
      const response = await fastify.inject({
        method: 'DELETE',
        url: `/usuarios/${studentUserId}`,
      });

      expect(response.statusCode).toBe(401);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHENTICATION_ERROR');
    });
  });
});

/* Fin backend\tests\user.integration.test.ts */

/* Inicio backend\tests\user.logic.test.ts */


import { describe, expect, it } from '@jest/globals';
const validateUserData = (data: any) => {
  if (!data.email || !data.password || !data.nombres || !data.apellidos || !data.rol) {
    throw new Error('Campos requeridos faltantes');
  }

  const validRoles = ['super_admin', 'admin_institucion', 'profesor', 'estudiante'];
  if (!validRoles.includes(data.rol)) {
    throw new Error('Rol invÃ¡lido');
  }

  if (data.rol === 'estudiante' && !data.identificacion) {
    throw new Error('La identificaciÃ³n es requerida para estudiantes');
  }
};

const validateEmail = (email: string) => {
  if (!email || typeof email !== 'string' || !email.includes('@')) {
    throw new Error('Email invÃ¡lido');
  }
};

const validateUserId = (id: string) => {
  if (!id || typeof id !== 'string') {
    throw new Error('ID de usuario invÃ¡lido');
  }
};

const generateQRCode = () => {
  return 'ABC123DEF456'
};

const hashPassword = async (password: string) => {
  return `hashed_${password}`;
};

describe('User Service Validation Logic (Standalone)', () => {
  describe('validateUserData', () => {
    it('should pass validation for valid profesor data', () => {
      const validData = {
        email: 'profesor@test.com',
        password: 'password123',
        nombres: 'Juan',
        apellidos: 'PÃ©rez',
        rol: 'profesor',
        telefono: '+1234567890',
      };

      expect(() => validateUserData(validData)).not.toThrow();
    });

    it('should pass validation for valid estudiante data', () => {
      const validData = {
        email: 'estudiante@test.com',
        password: 'password123',
        nombres: 'MarÃ­a',
        apellidos: 'GarcÃ­a',
        rol: 'estudiante',
        identificacion: '123456789',
        nombreResponsable: 'Padre de MarÃ­a',
      };

      expect(() => validateUserData(validData)).not.toThrow();
    });

    it('should throw error for missing required fields', () => {
      const invalidData = {
        email: 'test@test.com',
      };

      expect(() => validateUserData(invalidData)).toThrow('Campos requeridos faltantes');
    });

    it('should throw error for invalid role', () => {
      const invalidData = {
        email: 'test@test.com',
        password: 'password123',
        nombres: 'Juan',
        apellidos: 'PÃ©rez',
        rol: 'invalid_role',
      };

      expect(() => validateUserData(invalidData)).toThrow('Rol invÃ¡lido');
    });

    it('should throw error for estudiante without identificacion', () => {
      const invalidData = {
        email: 'estudiante@test.com',
        password: 'password123',
        nombres: 'MarÃ­a',
        apellidos: 'GarcÃ­a',
        rol: 'estudiante',
      };

      expect(() => validateUserData(invalidData)).toThrow('La identificaciÃ³n es requerida para estudiantes');
    });
  });

  describe('validateEmail', () => {
    it('should pass validation for valid email', () => {
      const validEmail = 'test@example.com';

      expect(() => validateEmail(validEmail)).not.toThrow();
    });

    it('should throw error for invalid email', () => {
      const invalidEmails = ['', 'invalid-email', 'test@', '@example.com'];

      invalidEmails.forEach(email => {
        expect(() => validateEmail(email)).toThrow('Email invÃ¡lido');
      });
    });

    it('should throw error for null or undefined email', () => {
      expect(() => validateEmail(null as any)).toThrow('Email invÃ¡lido');
      expect(() => validateEmail(undefined as any)).toThrow('Email invÃ¡lido');
    });
  });

  describe('validateUserId', () => {
    it('should pass validation for valid user id', () => {
      const validId = 'user-123';

      expect(() => validateUserId(validId)).not.toThrow();
    });

    it('should throw error for invalid user id', () => {
      const invalidIds = ['', null, undefined, 123];

      invalidIds.forEach(id => {
        expect(() => validateUserId(id as any)).toThrow('ID de usuario invÃ¡lido');
      });
    });
  });

  describe('generateQRCode', () => {
    it('should generate a QR code string', () => {
      const qrCode = generateQRCode();

      expect(typeof qrCode).toBe('string');
      expect(qrCode.length).toBeGreaterThan(0);
      expect(qrCode).toBe('ABC123DEF456');
    });
  });

  describe('hashPassword', () => {
    it('should hash password', async () => {
      const password = 'mypassword123';
      const hashed = await hashPassword(password);

      expect(hashed).toBe(`hashed_${password}`);
      expect(typeof hashed).toBe('string');
      expect(hashed.startsWith('hashed_')).toBe(true);
    });
  });

  describe('User Role Validation', () => {
    const validRoles = ['super_admin', 'admin_institucion', 'profesor', 'estudiante'];

    it('should accept all valid roles', () => {
      validRoles.forEach(role => {
        const data: any = {
          email: 'test@test.com',
          password: 'password123',
          nombres: 'Test',
          apellidos: 'User',
          rol: role,
        };

        if (role === 'estudiante') {
          data.identificacion = '123456789';
        }

        expect(() => validateUserData(data)).not.toThrow();
      });
    });

    it('should reject invalid roles', () => {
      const invalidRoles = ['admin', 'teacher', 'student', 'superuser', ''];

      invalidRoles.forEach(role => {
        const data = {
          email: 'test@test.com',
          password: 'password123',
          nombres: 'Test',
          apellidos: 'User',
          rol: role,
        };

        expect(() => validateUserData(data)).toThrow('Rol invÃ¡lido');
      });
    });
  });

  describe('Email Normalization', () => {
    it('should handle email case sensitivity', () => {
      const emails = ['Test@Example.COM', 'TEST@EXAMPLE.COM', 'test@example.com'];

      emails.forEach(email => {
        expect(() => validateEmail(email)).not.toThrow();
      });
    });
  });

  describe('Password Requirements', () => {
    it('should accept various password formats', () => {
      const passwords = ['password123', 'Password123!', '123456', 'abc'];

      passwords.forEach(async (password) => {
        const hashed = await hashPassword(password);
        expect(hashed).toBe(`hashed_${password}`);
      });
    });
  });

  describe('Data Sanitization', () => {
    it('should handle whitespace in input data', () => {
      const dataWithWhitespace = {
        email: '  test@example.com  ',
        password: 'password123',
        nombres: '  Juan  ',
        apellidos: '  PÃ©rez  ',
        rol: 'profesor',
      };
      expect(() => validateUserData(dataWithWhitespace)).not.toThrow();
    });
  });
});
/* Fin backend\tests\user.logic.test.ts */

/* Inicio backend\tests\user.service.test.ts */


import { afterEach, beforeEach, describe, expect, it, jest } from '@jest/globals';
import { prisma } from '../../src/config/database';
import UserService from '../../src/services/user.service';
import { ConflictError, ValidationError } from '../../src/types';
jest.mock('../../src/config/database', () => ({
  prisma: {
    usuario: {
      create: jest.fn(),
      update: jest.fn(),
      findUnique: jest.fn(),
      findMany: jest.fn(),
      count: jest.fn(),
    },
    estudiante: {
      create: jest.fn(),
      update: jest.fn(),
    },
    usuarioInstitucion: {
      create: jest.fn(),
    },
    $transaction: jest.fn(),
  },
}));
jest.mock('bcryptjs', () => ({
  hash: jest.fn(),
}));
jest.mock('crypto', () => ({
  randomBytes: jest.fn(),
}));

describe('UserService Unit Tests', () => {
  const mockPrisma = prisma as jest.Mocked<typeof prisma>;
  const mockBcrypt = require('bcryptjs');
  const mockCrypto = require('crypto');

  beforeEach(() => {
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.resetAllMocks();
    jest.restoreAllMocks();
  });

  describe('createUser', () => {
    const validUserData = {
      email: 'test@example.com',
      password: 'password123',
      nombres: 'Juan',
      apellidos: 'PÃ©rez',
      rol: 'profesor' as const,
      telefono: '+1234567890',
      institucionId: 'inst-123',
      rolEnInstitucion: 'profesor',
    };

    const validStudentData = {
      email: 'student@example.com',
      password: 'password123',
      nombres: 'MarÃ­a',
      apellidos: 'GarcÃ­a',
      rol: 'estudiante' as const,
      identificacion: '123456789',
      nombreResponsable: 'Padre de MarÃ­a',
      telefonoResponsable: '+0987654321',
      institucionId: 'inst-123',
    };

    it('should create a profesor user successfully', async () => {
      const hashedPassword = 'hashedPassword123';
      const userId = 'user-123';

      mockBcrypt.hash.mockResolvedValue(hashedPassword);
      mockPrisma.$transaction.mockImplementation(async (callback: any) => {
        return callback(mockPrisma);
      });

      mockPrisma.usuario.create.mockResolvedValue({
        id: userId,
        email: validUserData.email,
        passwordHash: hashedPassword,
        nombres: validUserData.nombres,
        apellidos: validUserData.apellidos,
        rol: validUserData.rol,
        telefono: validUserData.telefono,
        activo: true,
        tokenVersion: 1,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      const result = await UserService.createUser(validUserData);

      expect(mockBcrypt.hash).toHaveBeenCalledWith(validUserData.password, 10);
      expect(mockPrisma.usuario.create).toHaveBeenCalledWith({
        data: {
          email: validUserData.email.toLowerCase(),
          passwordHash: hashedPassword,
          nombres: validUserData.nombres,
          apellidos: validUserData.apellidos,
          rol: validUserData.rol,
          telefono: validUserData.telefono,
        },
      });
      expect(mockPrisma.usuarioInstitucion.create).toHaveBeenCalledWith({
        data: {
          usuarioId: userId,
          institucionId: validUserData.institucionId,
          rolEnInstitucion: validUserData.rolEnInstitucion,
        },
      });
      expect(result).toHaveProperty('id', userId);
      expect(result).toHaveProperty('email', validUserData.email);
      expect(result).toHaveProperty('rol', validUserData.rol);
    });

    it('should create a estudiante user successfully', async () => {
      const hashedPassword = 'hashedPassword123';
      const userId = 'user-456';
      const studentId = 'student-456';
      const qrCode = 'ABC123DEF456';

      mockBcrypt.hash.mockResolvedValue(hashedPassword);
      mockCrypto.randomBytes.mockReturnValue({
        toString: jest.fn().mockReturnValue(qrCode),
      });
      mockPrisma.$transaction.mockImplementation(async (callback: any) => {
        return callback(mockPrisma);
      });

      mockPrisma.usuario.create.mockResolvedValue({
        id: userId,
        email: validStudentData.email,
        passwordHash: hashedPassword,
        nombres: validStudentData.nombres,
        apellidos: validStudentData.apellidos,
        rol: validStudentData.rol,
        telefono: null,
        activo: true,
        tokenVersion: 1,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      mockPrisma.estudiante.create.mockResolvedValue({
        id: studentId,
        usuarioId: userId,
        identificacion: validStudentData.identificacion!,
        codigoQr: qrCode,
        nombreResponsable: validStudentData.nombreResponsable,
        telefonoResponsable: validStudentData.telefonoResponsable,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      const result = await UserService.createUser(validStudentData);

      expect(mockCrypto.randomBytes).toHaveBeenCalledWith(16);
      expect(mockPrisma.estudiante.create).toHaveBeenCalledWith({
        data: {
          usuarioId: userId,
          identificacion: validStudentData.identificacion,
          codigoQr: qrCode,
          nombreResponsable: validStudentData.nombreResponsable,
          telefonoResponsable: validStudentData.telefonoResponsable,
        },
      });
      expect(result.estudiante).toBeDefined();
      expect(result.estudiante?.identificacion).toBe(validStudentData.identificacion);
      expect(result.estudiante?.codigoQr).toBe(qrCode);
    });

    it('should throw ValidationError for missing required fields', async () => {
      const invalidData = {
        email: 'test@example.com',
      };

      await expect(UserService.createUser(invalidData as any)).rejects.toThrow(ValidationError);
    });

    it('should throw ValidationError for invalid role', async () => {
      const invalidData = {
        ...validUserData,
        rol: 'invalid_role' as any,
      };

      await expect(UserService.createUser(invalidData)).rejects.toThrow(ValidationError);
    });

    it('should throw ValidationError for estudiante without identificacion', async () => {
      const invalidStudentData = {
        ...validStudentData,
        identificacion: undefined,
      };

      await expect(UserService.createUser(invalidStudentData as any)).rejects.toThrow(ValidationError);
    });

    it('should throw ConflictError for duplicate email', async () => {
      const existingUser = {
        id: 'existing-user',
        email: validUserData.email,
      };

      mockPrisma.usuario.findUnique.mockResolvedValue(existingUser as any);
      jest.spyOn(UserService, 'isEmailAvailable').mockResolvedValue(false);

      await expect(UserService.createUser(validUserData)).rejects.toThrow(ConflictError);
    });
  });

  describe('updateUser', () => {
    const userId = 'user-123';
    const updateData = {
      nombres: 'Juan Carlos',
      telefono: '+9876543210',
    };

    it('should update user successfully', async () => {
      const existingUser = {
        id: userId,
        email: 'test@example.com',
        nombres: 'Juan',
        apellidos: 'PÃ©rez',
        rol: 'profesor',
        activo: true,
      };

      const updatedUser = {
        ...existingUser,
        nombres: updateData.nombres,
        telefono: updateData.telefono,
      };

      mockPrisma.usuario.findUnique
        .mockResolvedValueOnce(existingUser as any
        .mockResolvedValueOnce(updatedUser as any)

      mockPrisma.$transaction.mockImplementation(async (callback: any) => {
        return callback(mockPrisma);
      });

      mockPrisma.usuario.update.mockResolvedValue(updatedUser as any);

      const result = await UserService.updateUser(userId, updateData);

      expect(mockPrisma.usuario.update).toHaveBeenCalledWith({
        where: { id: userId },
        data: updateData,
      });
      expect(result).toHaveProperty('nombres', updateData.nombres);
      expect(result).toHaveProperty('telefono', updateData.telefono);
    });

    it('should update estudiante data', async () => {
      const existingUser = {
        id: userId,
        email: 'student@example.com',
        nombres: 'MarÃ­a',
        apellidos: 'GarcÃ­a',
        rol: 'estudiante',
        activo: true,
      };

      const estudianteUpdateData = {
        nombreResponsable: 'Madre de MarÃ­a',
        telefonoResponsable: '+111111111',
      };

      mockPrisma.usuario.findUnique.mockResolvedValue(existingUser as any);
      mockPrisma.$transaction.mockImplementation(async (callback: any) => {
        return callback(mockPrisma);
      });

      mockPrisma.usuario.update.mockResolvedValue(existingUser as any);
      mockPrisma.estudiante.update.mockResolvedValue({
        id: 'student-123',
        usuarioId: userId,
        ...estudianteUpdateData,
      } as any);

      const result = await UserService.updateUser(userId, estudianteUpdateData);

      expect(mockPrisma.estudiante.update).toHaveBeenCalledWith({
        where: { usuarioId: userId },
        data: estudianteUpdateData,
      });
    });

    it('should throw ValidationError for invalid user id', async () => {
      await expect(UserService.updateUser('', updateData)).rejects.toThrow(ValidationError);
    });

    it('should throw ValidationError for non-existent user', async () => {
      mockPrisma.usuario.findUnique.mockResolvedValue(null);

      await expect(UserService.updateUser(userId, updateData)).rejects.toThrow(ValidationError);
    });

    it('should throw ConflictError for duplicate email', async () => {
      const existingUser = {
        id: userId,
        email: 'test@example.com',
        nombres: 'Juan',
        apellidos: 'PÃ©rez',
        rol: 'profesor',
        activo: true,
      };

      mockPrisma.usuario.findUnique.mockResolvedValue(existingUser as any);
      jest.spyOn(UserService, 'isEmailAvailable').mockResolvedValue(false);

      const emailUpdate = { email: 'existing@example.com' };

      await expect(UserService.updateUser(userId, emailUpdate)).rejects.toThrow(ConflictError);
    });
  });

  describe('deleteUser', () => {
    const userId = 'user-123';

    it('should delete user successfully', async () => {
      const existingUser = {
        id: userId,
        email: 'test@example.com',
        activo: true,
      };

      mockPrisma.usuario.findUnique.mockResolvedValue(existingUser as any);
      mockPrisma.usuario.update.mockResolvedValue({
        ...existingUser,
        activo: false,
      } as any);

      const result = await UserService.deleteUser(userId);

      expect(mockPrisma.usuario.update).toHaveBeenCalledWith({
        where: { id: userId },
        data: { activo: false },
      });
      expect(result).toBe(true);
    });

    it('should throw ValidationError for invalid user id', async () => {
      await expect(UserService.deleteUser('')).rejects.toThrow(ValidationError);
    });

    it('should throw ValidationError for non-existent user', async () => {
      mockPrisma.usuario.findUnique.mockResolvedValue(null);

      await expect(UserService.deleteUser(userId)).rejects.toThrow(ValidationError);
    });
  });

  describe('getUserById', () => {
    it('should return user with estudiante data', async () => {
      const userId = 'user-123';
      const userData = {
        id: userId,
        email: 'student@example.com',
        nombres: 'MarÃ­a',
        apellidos: 'GarcÃ­a',
        rol: 'estudiante',
        activo: true,
        estudiante: {
          id: 'student-123',
          identificacion: '123456789',
          codigoQr: 'QR123',
        },
      };

      mockPrisma.usuario.findUnique.mockResolvedValue(userData as any);

      const result = await UserService.getUserById(userId);

      expect(mockPrisma.usuario.findUnique).toHaveBeenCalledWith({
        where: { id: userId },
        include: {
          usuarioInstituciones: {
            where: { activo: true },
            include: { institucion: true },
          },
          estudiante: true,
        },
      });
      expect(result).toEqual(userData);
    });

    it('should throw ValidationError for invalid id', async () => {
      await expect(UserService.getUserById('')).rejects.toThrow(ValidationError);
    });
  });

  describe('isEmailAvailable', () => {
    it('should return true for available email', async () => {
      mockPrisma.usuario.count.mockResolvedValue(0);

      const result = await UserService.isEmailAvailable('new@example.com');

      expect(mockPrisma.usuario.count).toHaveBeenCalledWith({
        where: { email: 'new@example.com' },
      });
      expect(result).toBe(true);
    });

    it('should return false for taken email', async () => {
      mockPrisma.usuario.count.mockResolvedValue(1);

      const result = await UserService.isEmailAvailable('taken@example.com');

      expect(result).toBe(false);
    });

    it('should exclude user when updating', async () => {
      mockPrisma.usuario.count.mockResolvedValue(0);

      const result = await UserService.isEmailAvailable('test@example.com', 'user-123');

      expect(mockPrisma.usuario.count).toHaveBeenCalledWith({
        where: {
          email: 'test@example.com',
          id: { not: 'user-123' },
        },
      });
      expect(result).toBe(true);
    });

    it('should return false for invalid email', async () => {
      const result = await UserService.isEmailAvailable('invalid-email');

      expect(result).toBe(false);
    });
  });

  describe('userExists', () => {
    it('should return true for existing user', async () => {
      mockPrisma.usuario.count.mockResolvedValue(1);

      const result = await UserService.userExists('user-123');

      expect(mockPrisma.usuario.count).toHaveBeenCalledWith({
        where: { id: 'user-123' },
      });
      expect(result).toBe(true);
    });

    it('should return false for non-existing user', async () => {
      mockPrisma.usuario.count.mockResolvedValue(0);

      const result = await UserService.userExists('non-existent');

      expect(result).toBe(false);
    });

    it('should return false for invalid id', async () => {
      const result = await UserService.userExists('');

      expect(result).toBe(false);
    });
  });
});
/* Fin backend\tests\user.service.test.ts */

/* Inicio backend\tests\user.validation.test.ts */


import { describe, expect, it } from '@jest/globals';
const validateUserData = (data: unknown) => {
  const userData = data as Record<string, unknown>;
  if (!userData.rol || typeof userData.rol !== 'string') {
    throw new Error('Rol invÃ¡lido');
  }

  const validRoles = ['super_admin', 'admin_institucion', 'profesor', 'estudiante'];
  if (!validRoles.includes(userData.rol as string)) {
    throw new Error('Rol invÃ¡lido');
  }
  if (!userData.email || !userData.password || !userData.nombres || !userData.apellidos) {
    throw new Error('Campos requeridos faltantes');
  }
  if (userData.rol === 'estudiante' && !userData.identificacion) {
    throw new Error('La identificaciÃ³n es requerida para estudiantes');
  }
};

const validateEmail = (email: string) => {
  if (!email || typeof email !== 'string' || !email.includes('@') || !email.includes('.')) {
    throw new Error('Email invÃ¡lido');
  }
};

const validateUserId = (id: string) => {
  if (!id || typeof id !== 'string') {
    throw new Error('ID de usuario invÃ¡lido');
  }
};

const generateQRCode = () => {
  return 'ABC123DEF456'
};

const hashPassword = async (password: string) => {
  return `hashed_${password}`;
};

describe('User Service Validation Logic', () => {
  describe('validateUserData', () => {
    it('should pass validation for valid profesor data', () => {
      const validData = {
        email: 'profesor@test.com',
        password: 'password123',
        nombres: 'Juan',
        apellidos: 'PÃ©rez',
        rol: 'profesor',
        telefono: '+1234567890',
      };

      expect(() => validateUserData(validData)).not.toThrow();
    });

    it('should pass validation for valid estudiante data', () => {
      const validData = {
        email: 'estudiante@test.com',
        password: 'password123',
        nombres: 'MarÃ­a',
        apellidos: 'GarcÃ­a',
        rol: 'estudiante',
        identificacion: '123456789',
        nombreResponsable: 'Padre de MarÃ­a',
      };

      expect(() => validateUserData(validData)).not.toThrow();
    });

    it('should throw error for missing required fields', () => {
      const invalidData: Record<string, unknown> = {
        email: 'test@example.com',
        rol: 'profesor',
      };

      expect(() => validateUserData(invalidData)).toThrow('Campos requeridos faltantes');
    });

    it('should throw error for invalid role', () => {
      const invalidData = {
        email: 'test@test.com',
        password: 'password123',
        nombres: 'Juan',
        apellidos: 'PÃ©rez',
        rol: 'invalid_role',
      };

      expect(() => validateUserData(invalidData)).toThrow('Rol invÃ¡lido');
    });

    it('should throw error for estudiante without identificacion', () => {
      const invalidData = {
        email: 'estudiante@test.com',
        password: 'password123',
        nombres: 'MarÃ­a',
        apellidos: 'GarcÃ­a',
        rol: 'estudiante',
      };

      expect(() => validateUserData(invalidData)).toThrow('La identificaciÃ³n es requerida para estudiantes');
    });
  });

  describe('validateEmail', () => {
    it('should pass validation for valid email', () => {
      const validEmail = 'test@example.com';

      expect(() => validateEmail(validEmail)).not.toThrow();
    });

    it('should throw error for invalid email', () => {
      expect(() => validateEmail('invalid-email')).toThrow('Email invÃ¡lido');
      expect(() => validateEmail('test@')).toThrow('Email invÃ¡lido');
      expect(() => validateEmail('test@domain')).toThrow('Email invÃ¡lido');
    });

    it('should throw error for null or undefined email', () => {
      expect(() => validateEmail(null as unknown as string)).toThrow('Email invÃ¡lido');
      expect(() => validateEmail(undefined as unknown as string)).toThrow('Email invÃ¡lido');
    });
  });

  describe('validateUserId', () => {
    it('should pass validation for valid user id', () => {
      const validId = 'user-123';

      expect(() => validateUserId(validId)).not.toThrow();
    });

    it('should throw error for invalid user id', () => {
      const invalidIds: unknown[] = ['', null, undefined, 123];

      invalidIds.forEach(id => {
        expect(() => validateUserId(id as string)).toThrow('ID de usuario invÃ¡lido');
      });
    });
  });

  describe('generateQRCode', () => {
    it('should generate a QR code string', () => {
      const qrCode = generateQRCode();

      expect(typeof qrCode).toBe('string');
      expect(qrCode.length).toBeGreaterThan(0);
      expect(qrCode).toBe('ABC123DEF456');
    });
  });

  describe('hashPassword', () => {
    it('should hash password', async () => {
      const password = 'mypassword123';
      const hashed = await hashPassword(password);

      expect(hashed).toBe(`hashed_${password}`);
      expect(typeof hashed).toBe('string');
      expect(hashed.startsWith('hashed_')).toBe(true);
    });
  });

  describe('User Role Validation', () => {
    const validRoles = ['super_admin', 'admin_institucion', 'profesor', 'estudiante'];

    it('should accept all valid roles', () => {
      validRoles.forEach(role => {
        const data: Record<string, unknown> = {
          email: 'test@test.com',
          password: 'password123',
          nombres: 'Test',
          apellidos: 'User',
          rol: role,
        };

        if (role === 'estudiante') {
          data.identificacion = '123456789';
        }

        expect(() => validateUserData(data)).not.toThrow();
      });
    });

    it('should reject invalid roles', () => {
      const invalidRoles = ['admin', 'teacher', 'student', 'superuser'];

      invalidRoles.forEach(role => {
        const data: Record<string, unknown> = {
          email: 'test@test.com',
          password: 'password123',
          nombres: 'Test',
          apellidos: 'User',
          rol: role,
        };

        expect(() => validateUserData(data)).toThrow('Rol invÃ¡lido');
      });
      const dataWithEmptyRole: Record<string, unknown> = {
        email: 'test@test.com',
        password: 'password123',
        nombres: 'Test',
        apellidos: 'User',
        rol: '',
      };

      expect(() => validateUserData(dataWithEmptyRole)).toThrow('Rol invÃ¡lido');
    });
  });

  describe('Email Normalization', () => {
    it('should handle email case sensitivity', () => {
      const emails = ['Test@Example.COM', 'TEST@EXAMPLE.COM', 'test@example.com'];

      emails.forEach(email => {
        expect(() => validateEmail(email)).not.toThrow();
      });
    });
  });
});
/* Fin backend\tests\user.validation.test.ts */
