
/* Directorio: \lib */
â”œâ”€â”€ ðŸ“‚ config
â”‚   â”œâ”€â”€ app_config.dart [23]
â”‚   â””â”€â”€ app_constants.dart [62]
â”œâ”€â”€ main.dart [100]
â”œâ”€â”€ ðŸ“‚ managers
â”‚   â””â”€â”€ app_lifecycle_manager.dart [110]
â”œâ”€â”€ ðŸ“‚ models
â”‚   â”œâ”€â”€ clase_del_dia.dart [171]
â”‚   â”œâ”€â”€ grupo.dart [116]
â”‚   â”œâ”€â”€ horario.dart [79]
â”‚   â”œâ”€â”€ institution.dart [97]
â”‚   â”œâ”€â”€ materia.dart [37]
â”‚   â””â”€â”€ user.dart [290]
â”œâ”€â”€ ðŸ“‚ providers
â”‚   â”œâ”€â”€ auth_provider.dart [214]
â”‚   â”œâ”€â”€ grupo_provider.dart [314]
â”‚   â”œâ”€â”€ horario_provider.dart [346]
â”‚   â”œâ”€â”€ institution_provider.dart [229]
â”‚   â”œâ”€â”€ materia_provider.dart [246]
â”‚   â””â”€â”€ user_provider.dart [406]
â”œâ”€â”€ ðŸ“‚ screens
â”‚   â”œâ”€â”€ ðŸ“‚ academic
â”‚   â”‚   â”œâ”€â”€ gestion_academica_screen.dart [144]
â”‚   â”‚   â”œâ”€â”€ grupos_screen.dart [627]
â”‚   â”‚   â”œâ”€â”€ horarios_screen.dart [508]
â”‚   â”‚   â””â”€â”€ materias_screen.dart [566]
â”‚   â”œâ”€â”€ admin_dashboard.dart [227]
â”‚   â”œâ”€â”€ app_shell.dart [323]
â”‚   â”œâ”€â”€ clarity_admin_dashboard.dart [260]
â”‚   â”œâ”€â”€ home_screen.dart [339]
â”‚   â”œâ”€â”€ ðŸ“‚ institutions
â”‚   â”‚   â”œâ”€â”€ create_institution_admin_screen.dart [330]
â”‚   â”‚   â”œâ”€â”€ ðŸ“‚ form_steps
â”‚   â”‚   â”‚   â”œâ”€â”€ index.dart [5]
â”‚   â”‚   â”‚   â”œâ”€â”€ institution_basic_info_step.dart [73]
â”‚   â”‚   â”‚   â”œâ”€â”€ institution_config_step.dart [127]
â”‚   â”‚   â”‚   â””â”€â”€ institution_contact_step.dart [90]
â”‚   â”‚   â”œâ”€â”€ institutions_list_screen.dart [403]
â”‚   â”‚   â”œâ”€â”€ institution_admins_screen.dart [485]
â”‚   â”‚   â””â”€â”€ institution_form_screen.dart [278]
â”‚   â”œâ”€â”€ institution_selection_screen.dart [173]
â”‚   â”œâ”€â”€ login_screen.dart [386]
â”‚   â”œâ”€â”€ student_dashboard.dart [197]
â”‚   â”œâ”€â”€ super_admin_dashboard.dart [314]
â”‚   â”œâ”€â”€ teacher_dashboard.dart [603]
â”‚   â”œâ”€â”€ teacher_dashboard_with_scroll.dart [89]
â”‚   â”œâ”€â”€ ðŸ“‚ users
â”‚   â”‚   â”œâ”€â”€ create_professor_screen.dart [11]
â”‚   â”‚   â”œâ”€â”€ create_student_screen.dart [11]
â”‚   â”‚   â”œâ”€â”€ ðŸ“‚ form_steps
â”‚   â”‚   â”‚   â”œâ”€â”€ index.dart [5]
â”‚   â”‚   â”‚   â”œâ”€â”€ role_specific_details_step.dart [266]
â”‚   â”‚   â”‚   â”œâ”€â”€ user_account_step.dart [179]
â”‚   â”‚   â”‚   â””â”€â”€ user_personal_info_step.dart [261]
â”‚   â”‚   â”œâ”€â”€ users_list_screen.dart [588]
â”‚   â”‚   â”œâ”€â”€ user_detail_screen.dart [160]
â”‚   â”‚   â””â”€â”€ user_form_screen.dart [734]
â”‚   â””â”€â”€ welcome_screen.dart [91]
â”œâ”€â”€ ðŸ“‚ services
â”‚   â”œâ”€â”€ academic_service.dart [859]
â”‚   â”œâ”€â”€ auth_service.dart [181]
â”‚   â”œâ”€â”€ institution_service.dart [229]
â”‚   â”œâ”€â”€ profesor_service.dart [266]
â”‚   â””â”€â”€ user_service.dart [452]
â”œâ”€â”€ ðŸ“‚ theme
â”‚   â”œâ”€â”€ app_colors.dart [114]
â”‚   â”œâ”€â”€ app_spacing.dart [24]
â”‚   â”œâ”€â”€ app_text_styles.dart [203]
â”‚   â”œâ”€â”€ app_theme.dart [241]
â”‚   â”œâ”€â”€ index.dart [5]
â”‚   â””â”€â”€ theme_extensions.dart [42]
â”œâ”€â”€ ðŸ“‚ ui
â”‚   â””â”€â”€ ðŸ“‚ widgets
â”‚       â””â”€â”€ app_button.dart [196]
â”œâ”€â”€ ðŸ“‚ utils
â”‚   â”œâ”€â”€ app_router.dart [296]
â”‚   â”œâ”€â”€ app_routes.dart [45]
â”‚   â”œâ”€â”€ responsive_utils.dart [166]
â”‚   â”œâ”€â”€ role_enum.dart [53]
â”‚   â””â”€â”€ route_guards.dart [32]
â””â”€â”€ ðŸ“‚ widgets
    â”œâ”€â”€ ðŸ“‚ common
    â”‚   â”œâ”€â”€ empty_state_widget.dart [47]
    â”‚   â”œâ”€â”€ index.dart [4]
    â”‚   â”œâ”€â”€ management_scaffold.dart [218]
    â”‚   â””â”€â”€ shimmer_list_widget.dart [32]
    â”œâ”€â”€ ðŸ“‚ components
    â”‚   â”œâ”€â”€ clarity_components.dart [689]
    â”‚   â”œâ”€â”€ clarity_management_page.dart [154]
    â”‚   â”œâ”€â”€ command_palette.dart [282]
    â”‚   â””â”€â”€ index.dart [4]
    â”œâ”€â”€ dashboard_widgets.dart [287]
    â”œâ”€â”€ form_widgets.dart [317]
    â”œâ”€â”€ index.dart [11]
    â”œâ”€â”€ pagination_widget.dart [411]
    â”œâ”€â”€ role_guard.dart [39]
    â”œâ”€â”€ scroll_state_keeper.dart [31]
    â”œâ”€â”€ session_info_footer.dart [105]
    â””â”€â”€ ðŸ“‚ ui
        â”œâ”€â”€ app_button.dart [196]
        â”œâ”€â”€ app_components.dart [217]
        â”œâ”€â”€ error_logger.dart [198]
        â””â”€â”€ index.dart [4]


/* Directorio: \backend */
â”œâ”€â”€ ðŸ“‚ dist
â”‚   â”œâ”€â”€ ðŸ“‚ config
â”‚   â”‚   â”œâ”€â”€ app.js [13]
â”‚   â”‚   â”œâ”€â”€ database.js [40]
â”‚   â”‚   â””â”€â”€ jwt.js [60]
â”‚   â”œâ”€â”€ ðŸ“‚ controllers
â”‚   â”‚   â”œâ”€â”€ admin-institucion.controller.js [103]
â”‚   â”‚   â”œâ”€â”€ auth.controller.js [128]
â”‚   â”‚   â”œâ”€â”€ estudiante.controller.js [276]
â”‚   â”‚   â”œâ”€â”€ grupo.controller.js [199]
â”‚   â”‚   â”œâ”€â”€ horario.controller.js [206]
â”‚   â”‚   â”œâ”€â”€ institucion.controller.js [152]
â”‚   â”‚   â”œâ”€â”€ institution-admin.controller.js [257]
â”‚   â”‚   â”œâ”€â”€ materia.controller.js [195]
â”‚   â”‚   â”œâ”€â”€ profesor.controller.js [74]
â”‚   â”‚   â””â”€â”€ user.controller.js [253]
â”‚   â”œâ”€â”€ index.js [84]
â”‚   â”œâ”€â”€ ðŸ“‚ middleware
â”‚   â”‚   â”œâ”€â”€ auth.js [88]
â”‚   â”‚   â””â”€â”€ errorHandler.js [98]
â”‚   â”œâ”€â”€ ðŸ“‚ routes
â”‚   â”‚   â”œâ”€â”€ admin-institucion.routes.js [30]
â”‚   â”‚   â”œâ”€â”€ auth.routes.js [40]
â”‚   â”‚   â”œâ”€â”€ estudiante.routes.js [11]
â”‚   â”‚   â”œâ”€â”€ grupo.routes.js [326]
â”‚   â”‚   â”œâ”€â”€ horario.routes.js [479]
â”‚   â”‚   â”œâ”€â”€ index.js [52]
â”‚   â”‚   â”œâ”€â”€ institucion.routes.js [40]
â”‚   â”‚   â”œâ”€â”€ institution-admin.routes.js [28]
â”‚   â”‚   â”œâ”€â”€ materia.routes.js [255]
â”‚   â”‚   â”œâ”€â”€ profesor.routes.js [284]
â”‚   â”‚   â””â”€â”€ user.routes.js [46]
â”‚   â”œâ”€â”€ ðŸ“‚ scripts
â”‚   â”‚   â””â”€â”€ cleanup-tokens.js [33]
â”‚   â”œâ”€â”€ ðŸ“‚ services
â”‚   â”‚   â”œâ”€â”€ admin-institucion.service.js [247]
â”‚   â”‚   â”œâ”€â”€ auth.service.js [238]
â”‚   â”‚   â”œâ”€â”€ grupo.service.js [427]
â”‚   â”‚   â”œâ”€â”€ horario.service.js [742]
â”‚   â”‚   â”œâ”€â”€ institucion.service.js [308]
â”‚   â”‚   â”œâ”€â”€ materia.service.js [299]
â”‚   â”‚   â”œâ”€â”€ profesor.service.js [500]
â”‚   â”‚   â””â”€â”€ user.service.js [416]
â”‚   â”œâ”€â”€ ðŸ“‚ types
â”‚   â”‚   â””â”€â”€ index.js [44]
â”‚   â””â”€â”€ ðŸ“‚ utils
â”‚       â””â”€â”€ index.js [78]
â”œâ”€â”€ jest.unit.config.js [13]
â”œâ”€â”€ ðŸ“‚ prisma
â”‚   â”œâ”€â”€ seed.js [200]
â”‚   â”œâ”€â”€ seed.ts [200]
â”œâ”€â”€ setup-test-data.ts [525]
â”œâ”€â”€ show-student-example.ts [192]
â”œâ”€â”€ ðŸ“‚ src
â”‚   â”œâ”€â”€ ðŸ“‚ config
â”‚   â”‚   â”œâ”€â”€ app.ts [12]
â”‚   â”‚   â”œâ”€â”€ database.ts [43]
â”‚   â”‚   â””â”€â”€ jwt.ts [59]
â”‚   â”œâ”€â”€ ðŸ“‚ controllers
â”‚   â”‚   â”œâ”€â”€ admin-institucion.controller.ts [103]
â”‚   â”‚   â”œâ”€â”€ auth.controller.ts [139]
â”‚   â”‚   â”œâ”€â”€ estudiante.controller.ts [281]
â”‚   â”‚   â”œâ”€â”€ grupo.controller.ts [239]
â”‚   â”‚   â”œâ”€â”€ horario.controller.ts [281]
â”‚   â”‚   â”œâ”€â”€ institucion.controller.ts [184]
â”‚   â”‚   â”œâ”€â”€ institution-admin.controller.ts [297]
â”‚   â”‚   â”œâ”€â”€ materia.controller.ts [227]
â”‚   â”‚   â”œâ”€â”€ profesor.controller.ts [84]
â”‚   â”‚   â””â”€â”€ user.controller.ts [296]
â”‚   â”œâ”€â”€ index.ts [98]
â”‚   â”œâ”€â”€ ðŸ“‚ middleware
â”‚   â”‚   â”œâ”€â”€ auth.ts [103]
â”‚   â”‚   â””â”€â”€ errorHandler.ts [106]
â”‚   â”œâ”€â”€ ðŸ“‚ routes
â”‚   â”‚   â”œâ”€â”€ admin-institucion.routes.ts [32]
â”‚   â”‚   â”œâ”€â”€ auth.routes.ts [37]
â”‚   â”‚   â”œâ”€â”€ estudiante.routes.ts [175]
â”‚   â”‚   â”œâ”€â”€ grupo.routes.ts [323]
â”‚   â”‚   â”œâ”€â”€ horario.routes.ts [476]
â”‚   â”‚   â”œâ”€â”€ index.ts [53]
â”‚   â”‚   â”œâ”€â”€ institucion.routes.ts [43]
â”‚   â”‚   â”œâ”€â”€ institution-admin.routes.ts [20]
â”‚   â”‚   â”œâ”€â”€ materia.routes.ts [252]
â”‚   â”‚   â”œâ”€â”€ profesor.routes.ts [287]
â”‚   â”‚   â””â”€â”€ user.routes.ts [38]
â”‚   â”œâ”€â”€ ðŸ“‚ scripts
â”‚   â”‚   â””â”€â”€ cleanup-tokens.ts [32]
â”‚   â”œâ”€â”€ ðŸ“‚ services
â”‚   â”‚   â”œâ”€â”€ admin-institucion.service.ts [270]
â”‚   â”‚   â”œâ”€â”€ auth.service.ts [262]
â”‚   â”‚   â”œâ”€â”€ grupo.service.ts [471]
â”‚   â”‚   â”œâ”€â”€ horario.service.ts [826]
â”‚   â”‚   â”œâ”€â”€ institucion.service.ts [327]
â”‚   â”‚   â”œâ”€â”€ materia.service.ts [328]
â”‚   â”‚   â”œâ”€â”€ profesor.service.ts [548]
â”‚   â”‚   â””â”€â”€ user.service.ts [416]
â”‚   â”œâ”€â”€ ðŸ“‚ types
â”‚   â”‚   â””â”€â”€ index.ts [253]
â”‚   â””â”€â”€ ðŸ“‚ utils
â”‚       â””â”€â”€ index.ts [87]
â”œâ”€â”€ test-api-complete.ts [958]
â”œâ”€â”€ test-auth-simple.ts [61]
â”œâ”€â”€ test-server.ts [25]
â”œâ”€â”€ ðŸ“‚ tests
â”‚   â”œâ”€â”€ auth.integration.test.js [160]
â”‚   â”œâ”€â”€ auth.integration.test.ts [402]
â”‚   â”œâ”€â”€ auth.service.test.js [213]
â”‚   â”œâ”€â”€ auth.service.test.ts [514]
â”‚   â”œâ”€â”€ institucion.integration.test.ts [432]
â”‚   â”œâ”€â”€ setup.js [15]
â”‚   â”œâ”€â”€ setup.ts [16]
â”‚   â”œâ”€â”€ simple-validation.test.js [277]
â”‚   â”œâ”€â”€ test-database.ts [56]
â”‚   â”œâ”€â”€ user.controller.test.ts [411]
â”‚   â”œâ”€â”€ user.integration.test.ts [683]
â”‚   â”œâ”€â”€ user.logic.test.ts [230]
â”‚   â”œâ”€â”€ user.service.test.ts [463]
â”‚   â””â”€â”€ user.validation.test.ts [217]
â””â”€â”€ verify-schema.js [43]


Total de lÃ­neas resumidas: 39906
Total de archivos: 183
Promedio de lÃ­neas por archivo: 218
Archivo mÃ¡s grande: test-api-complete.ts (958 lÃ­neas)


/* Inicio lib\config\app_config.dart */
import 'package:flutter/foundation.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';

class AppConfig {
  static String? _baseUrl;
  static Future<void> initialize() async {
    try {
      await dotenv.load(fileName: ".env");
      final envUrl = dotenv.env['API_BASE_URL'];
      _baseUrl = envUrl != null && envUrl.isNotEmpty ? envUrl : 'http://localhost:3000';
    } catch (e) {
      _baseUrl = 'http://localhost:3000';
      debugPrint('Error cargando configuraciÃ³n: $e. Usando valor por defecto.');
    }
  }
  static String get baseUrl {
    if (_baseUrl == null) {
      throw StateError('AppConfig no ha sido inicializado. Llama a AppConfig.initialize() antes de usar baseUrl.');
    }
    return _baseUrl!;
  }
}

/* Fin lib\config\app_config.dart */

/* Inicio lib\config\app_constants.dart */

class AppConstants {
  AppConstants._();

  static final AppConstants instance = AppConstants._();
  static const int itemsPerPage = 5;
  static const int httpTimeoutSeconds = 10;
  static const int maxRetries = 3;
  final double mobileSmall = 480;
  final double mobileLarge = 768;
  final double tablet = 1024;
  final double desktop = 1440;
  final double maxWidthMobile = 480;
  final double maxWidthTablet = 768;
  final double maxWidthDesktop = 1024;
  final double maxWidthLargeDesktop = 1400;

  final double logoSize = 80;
  final double spinnerSize = 20;
  final double buttonBorderRadius = 8;
  final double cardBorderRadius = 8;
  final double logoBorderRadius = 20;
  final double errorLoggerWidthCollapsed = 60;
  final double errorLoggerHeightCollapsed = 60;
  final double errorLoggerWidthExpanded = 300;
  final double errorLoggerHeightExpanded = 200;

  final double defaultFontSize = 14;
  final double logoFontSize = 48;
  final double shadowBlurRadius = 8;
  final double shadowOffsetY = 2;
  final double errorLoggerShadowBlur = 8;
  final double errorLoggerShadowOffsetY = 4;
  final double borderWidthThin = 0.5;
  final double borderWidthNormal = 1;
  final double borderWidthThick = 1.5;

  final double shadowOpacity = 0.1
  final double surfaceTintOpacity = 0.1;
  double getMaxWidth(double screenWidth) {
    if (screenWidth <= mobileSmall) return maxWidthMobile;
    if (screenWidth <= mobileLarge) return maxWidthTablet;
    if (screenWidth <= tablet) return maxWidthDesktop;
    return maxWidthLargeDesktop;
  }
  ScreenType getScreenType(double width) {
    if (width <= mobileSmall) return ScreenType.mobileSmall;
    if (width <= mobileLarge) return ScreenType.mobileLarge;
    if (width <= tablet) return ScreenType.tablet;
    if (width <= desktop) return ScreenType.desktop;
    return ScreenType.largeDesktop;
  }
}

enum ScreenType {
  mobileSmall,    // <= 480px
  mobileLarge,    // 481-768px
  tablet,         // 769-1024px
  desktop,        // 1025-1440px
  largeDesktop,   // > 1440px
}

/* Fin lib\config\app_constants.dart */

/* Inicio lib\main.dart */
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'config/app_config.dart';
import 'providers/auth_provider.dart';
import 'providers/institution_provider.dart';
import 'providers/user_provider.dart';
import 'providers/horario_provider.dart';
import 'managers/app_lifecycle_manager.dart';
import 'theme/app_theme.dart';
import 'theme/app_colors.dart';
import 'utils/app_router.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await AppConfig.initialize();

  SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle(
    statusBarColor: AppColors.instance.transparent,
    statusBarIconBrightness: Brightness.light,
    systemNavigationBarColor: AppColors.instance.black,
    systemNavigationBarIconBrightness: Brightness.light,
  ));

  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> with WidgetsBindingObserver {

  late final AppLifecycleManager _lifecycleManager;
  late final AuthProvider _authProvider;
  late final InstitutionProvider _institutionProvider;
  late final HorarioProvider _horarioProvider;
  late AppRouter _appRouter;

  @override
  void initState() {
    super.initState();

    _lifecycleManager = AppLifecycleManager();
    _authProvider = AuthProvider();
    _institutionProvider = InstitutionProvider();
    _horarioProvider = HorarioProvider();

    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _appRouter.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider.value(value: _authProvider),
        ChangeNotifierProvider.value(value: _institutionProvider),
        ChangeNotifierProvider.value(value: _horarioProvider),
        ChangeNotifierProvider(create: (_) => UserProvider()),
        ChangeNotifierProvider.value(value: _lifecycleManager),
      ],
      child: Builder(
        builder: (context) {

          _appRouter = AppRouter(
            authProvider: _authProvider,
          );

          return MaterialApp.router(
            title: 'AsistApp',
            debugShowCheckedModeBanner: false,
            theme: AppTheme.defaultTheme,
            routerConfig: _appRouter.router,
            builder: (context, child) {
              return DefaultTextStyle(
                style: TextStyle(
                  decoration: TextDecoration.none,
                  color: AppColors.instance.white,
                  fontSize: 14.0,
                  fontWeight: FontWeight.normal,
                ),
                child: child!,
              );
            },
          );
        },
      ),
    );
  }
}
/* Fin lib\main.dart */

/* Inicio lib\managers\app_lifecycle_manager.dart */
import 'package:flutter/widgets.dart';
enum AppState {
  resumed,
  paused,
  hidden,
  detached,
}
class AppLifecycleManager extends ChangeNotifier {
  AppState _currentState = AppState.resumed;
  DateTime? _lastPausedTime;
  bool _isFirstResume = true;

  AppState get currentState => _currentState;
  bool get isInForeground => _currentState == AppState.resumed;
  bool get isInBackground => _currentState == AppState.paused || _currentState == AppState.hidden;

  AppLifecycleManager() {
    WidgetsBinding.instance.addObserver(_AppLifecycleObserver(this));
  }

  void _onLifecycleChanged(AppState state) {
    final previousState = _currentState;
    _currentState = state;

    switch (state) {
      case AppState.paused:
        _handleAppPaused();
        break;
      case AppState.resumed:
        _handleAppResumed(previousState);
        break;
      case AppState.hidden:
        _handleAppHidden();
        break;
      case AppState.detached:
        _handleAppDetached();
        break;
    }

    notifyListeners();
  }

  void _handleAppPaused() {
    _lastPausedTime = DateTime.now();
    debugPrint('AppLifecycleManager: App paused at $_lastPausedTime');
  }

  void _handleAppResumed(AppState previousState) {
    final now = DateTime.now();
    final timeInBackground = _lastPausedTime != null ? now.difference(_lastPausedTime!) : Duration.zero;

    debugPrint('AppLifecycleManager: App resumed after ${timeInBackground.inSeconds}s in background');
    if (_isFirstResume) {
      _isFirstResume = false;
      return;
    }
    if (timeInBackground.inSeconds > 30) {
      debugPrint('AppLifecycleManager: Long background time, triggering data refresh');
      _triggerDataRefresh();
    } else {
      debugPrint('AppLifecycleManager: Quick resume, using cached data');
    }
  }

  void _handleAppHidden() {
    debugPrint('AppLifecycleManager: App hidden');
  }

  void _handleAppDetached() {
    debugPrint('AppLifecycleManager: App detached');
  }
  void _triggerDataRefresh() {
    debugPrint('AppLifecycleManager: Triggering data refresh...');
  }
  void addLifecycleCallback(String key, VoidCallback callback) {
  }

  void removeLifecycleCallback(String key) {
  }
}
class _AppLifecycleObserver extends WidgetsBindingObserver {
  final AppLifecycleManager _manager;

  _AppLifecycleObserver(this._manager);

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    AppState mappedState;

    switch (state) {
      case AppLifecycleState.resumed:
        mappedState = AppState.resumed;
        break;
      case AppLifecycleState.paused:
        mappedState = AppState.paused;
        break;
      case AppLifecycleState.hidden:
        mappedState = AppState.hidden;
        break;
      case AppLifecycleState.detached:
        mappedState = AppState.detached;
        break;
      case AppLifecycleState.inactive:
        mappedState = AppState.paused;
        break;
    }

    _manager._onLifecycleChanged(mappedState);
  }
}
/* Fin lib\managers\app_lifecycle_manager.dart */

/* Inicio lib\models\clase_del_dia.dart */
class ClaseDelDia {
  final String id;
  final int diaSemana;
  final String horaInicio;
  final String horaFin;
  final GrupoSimple grupo;
  final MateriaSimple materia;
  final PeriodoAcademicoSimple periodoAcademico;
  final Institucion institucion;

  ClaseDelDia({
    required this.id,
    required this.diaSemana,
    required this.horaInicio,
    required this.horaFin,
    required this.grupo,
    required this.materia,
    required this.periodoAcademico,
    required this.institucion,
  });

  factory ClaseDelDia.fromJson(Map<String, dynamic> json) {
    return ClaseDelDia(
      id: json['id'],
      diaSemana: json['diaSemana'],
      horaInicio: json['horaInicio'],
      horaFin: json['horaFin'],
      grupo: GrupoSimple.fromJson(json['grupo']),
      materia: MateriaSimple.fromJson(json['materia']),
      periodoAcademico: PeriodoAcademicoSimple.fromJson(json['periodoAcademico']),
      institucion: Institucion.fromJson(json['institucion']),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'diaSemana': diaSemana,
      'horaInicio': horaInicio,
      'horaFin': horaFin,
      'grupo': grupo.toJson(),
      'materia': materia.toJson(),
      'periodoAcademico': periodoAcademico.toJson(),
      'institucion': institucion.toJson(),
    };
  }

  String get diaSemanaNombre {
    const dias = ['Lunes', 'Martes', 'MiÃ©rcoles', 'Jueves', 'Viernes', 'SÃ¡bado', 'Domingo'];
    return dias[diaSemana - 1];
  }

  String get horarioFormato => '$horaInicio - $horaFin';

  String get descripcion => '${materia.nombre} - ${grupo.nombreCompleto}';
}
class GrupoSimple {
  final String id;
  final String nombre;
  final String grado;
  final String? seccion;

  GrupoSimple({
    required this.id,
    required this.nombre,
    required this.grado,
    this.seccion,
  });

  factory GrupoSimple.fromJson(Map<String, dynamic> json) {
    return GrupoSimple(
      id: json['id'],
      nombre: json['nombre'],
      grado: json['grado'],
      seccion: json['seccion'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'nombre': nombre,
      'grado': grado,
      'seccion': seccion,
    };
  }

  String get nombreCompleto => seccion != null ? '$grado $seccion' : grado;
}

class MateriaSimple {
  final String id;
  final String nombre;
  final String? codigo;

  MateriaSimple({
    required this.id,
    required this.nombre,
    this.codigo,
  });

  factory MateriaSimple.fromJson(Map<String, dynamic> json) {
    return MateriaSimple(
      id: json['id'],
      nombre: json['nombre'],
      codigo: json['codigo'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'nombre': nombre,
      'codigo': codigo,
    };
  }

  String get nombreConCodigo => codigo != null ? '$codigo - $nombre' : nombre;
}

class PeriodoAcademicoSimple {
  final String id;
  final String nombre;
  final bool activo;

  PeriodoAcademicoSimple({
    required this.id,
    required this.nombre,
    required this.activo,
  });

  factory PeriodoAcademicoSimple.fromJson(Map<String, dynamic> json) {
    return PeriodoAcademicoSimple(
      id: json['id'],
      nombre: json['nombre'],
      activo: json['activo'] ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'nombre': nombre,
      'activo': activo,
    };
  }
}

class Institucion {
  final String id;
  final String nombre;

  Institucion({
    required this.id,
    required this.nombre,
  });

  factory Institucion.fromJson(Map<String, dynamic> json) {
    return Institucion(
      id: json['id'],
      nombre: json['nombre'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'nombre': nombre,
    };
  }
}
/* Fin lib\models\clase_del_dia.dart */

/* Inicio lib\models\grupo.dart */
class Grupo {
  final String id;
  final String nombre;
  final String grado;
  final String? seccion;
  final String periodoId;
  final String institucionId;
  final DateTime createdAt;
  final PeriodoAcademico periodoAcademico;
  final GrupoCount _count;

  Grupo({
    required this.id,
    required this.nombre,
    required this.grado,
    this.seccion,
    required this.periodoId,
    required this.institucionId,
    required this.createdAt,
    required this.periodoAcademico,
    required GrupoCount count,
  }) : _count = count;

  int get estudiantesGruposCount => _count.estudiantesGrupos;
  int get horariosCount => _count.horarios;

  factory Grupo.fromJson(Map<String, dynamic> json) {
    return Grupo(
      id: json['id'],
      nombre: json['nombre'],
      grado: json['grado'],
      seccion: json['seccion'],
      periodoId: json['periodoId'],
      institucionId: json['institucionId'],
      createdAt: DateTime.parse(json['createdAt']),
      periodoAcademico: PeriodoAcademico.fromJson(json['periodoAcademico']),
      count: GrupoCount.fromJson(json['_count']),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'nombre': nombre,
      'grado': grado,
      'seccion': seccion,
      'periodoId': periodoId,
      'institucionId': institucionId,
      'createdAt': createdAt.toIso8601String(),
      'periodoAcademico': periodoAcademico.toJson(),
      '_count': _count.toJson(),
    };
  }

  String get nombreCompleto => seccion != null ? '$grado $seccion' : grado;
}

class GrupoCount {
  final int estudiantesGrupos;
  final int horarios;

  GrupoCount({
    required this.estudiantesGrupos,
    required this.horarios,
  });

  factory GrupoCount.fromJson(Map<String, dynamic> json) {
    return GrupoCount(
      estudiantesGrupos: json['estudiantesGrupos'] ?? 0,
      horarios: json['horarios'] ?? 0,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'estudiantesGrupos': estudiantesGrupos,
      'horarios': horarios,
    };
  }
}

class PeriodoAcademico {
  final String id;
  final String nombre;
  final DateTime fechaInicio;
  final DateTime fechaFin;
  final bool activo;

  PeriodoAcademico({
    required this.id,
    required this.nombre,
    required this.fechaInicio,
    required this.fechaFin,
    required this.activo,
  });

  factory PeriodoAcademico.fromJson(Map<String, dynamic> json) {
    return PeriodoAcademico(
      id: json['id'],
      nombre: json['nombre'],
      fechaInicio: DateTime.parse(json['fechaInicio']),
      fechaFin: DateTime.parse(json['fechaFin']),
      activo: json['activo'] ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'nombre': nombre,
      'fechaInicio': fechaInicio.toIso8601String(),
      'fechaFin': fechaFin.toIso8601String(),
      'activo': activo,
    };
  }
}
/* Fin lib\models\grupo.dart */

/* Inicio lib\models\horario.dart */
import 'grupo.dart';
import 'materia.dart';

class Horario {
  final String id;
  final String periodoId;
  final String grupoId;
  final String materiaId;
  final String? profesorId;
  final int diaSemana;
  final String horaInicio;
  final String horaFin;
  final String institucionId;
  final DateTime createdAt;
  final Grupo grupo;
  final Materia materia;
  final PeriodoAcademico periodoAcademico;

  Horario({
    required this.id,
    required this.periodoId,
    required this.grupoId,
    required this.materiaId,
    this.profesorId,
    required this.diaSemana,
    required this.horaInicio,
    required this.horaFin,
    required this.institucionId,
    required this.createdAt,
    required this.grupo,
    required this.materia,
    required this.periodoAcademico,
  });

  factory Horario.fromJson(Map<String, dynamic> json) {
    return Horario(
      id: json['id'],
      periodoId: json['periodoId'],
      grupoId: json['grupoId'],
      materiaId: json['materiaId'],
      profesorId: json['profesorId'],
      diaSemana: json['diaSemana'],
      horaInicio: json['horaInicio'],
      horaFin: json['horaFin'],
      institucionId: json['institucionId'],
      createdAt: DateTime.parse(json['createdAt']),
      grupo: Grupo.fromJson(json['grupo']),
      materia: Materia.fromJson(json['materia']),
      periodoAcademico: PeriodoAcademico.fromJson(json['periodoAcademico']),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'periodoId': periodoId,
      'grupoId': grupoId,
      'materiaId': materiaId,
      'profesorId': profesorId,
      'diaSemana': diaSemana,
      'horaInicio': horaInicio,
      'horaFin': horaFin,
      'institucionId': institucionId,
      'createdAt': createdAt.toIso8601String(),
      'grupo': grupo.toJson(),
      'materia': materia.toJson(),
      'periodoAcademico': periodoAcademico.toJson(),
    };
  }

  String get diaSemanaNombre {
    const dias = ['Lunes', 'Martes', 'MiÃ©rcoles', 'Jueves', 'Viernes', 'SÃ¡bado', 'Domingo'];
    return dias[diaSemana - 1];
  }

  String get horarioFormato => '$horaInicio - $horaFin';

  String get descripcion => '${materia.nombre} - ${grupo.nombreCompleto}';
}
/* Fin lib\models\horario.dart */

/* Inicio lib\models\institution.dart */
class Institution {
  final String id;
  final String nombre;
  final String? direccion;
  final String? telefono;
  final String? email;
  final bool activa;
  final DateTime? createdAt;
  final DateTime? updatedAt;
  final String? role
  final Map<String, dynamic>? metadata;

  Institution({
    required this.id,
    required this.nombre,
    this.direccion,
    this.telefono,
    this.email,
    this.activa = true,
    this.createdAt,
    this.updatedAt,
    this.role,
    this.metadata,
  });

  factory Institution.fromJson(Map<String, dynamic> json) {
    return Institution(
      id: json['id'] as String,
      nombre: json['nombre'] as String? ?? json['name'] as String? ?? 'InstituciÃ³n sin nombre',
      direccion: json['direccion'] as String?,
      telefono: json['telefono'] as String?,
      email: json['email'] as String?,
      activa: json['activa'] as bool? ?? true,
      createdAt: json['createdAt'] != null ? DateTime.parse(json['createdAt']) : null,
      updatedAt: json['updatedAt'] != null ? DateTime.parse(json['updatedAt']) : null,
      role: json['rolEnInstitucion'] as String? ?? json['role'] as String?,
      metadata: json['metadata'] as Map<String, dynamic>?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'nombre': nombre,
      if (direccion != null) 'direccion': direccion,
      if (telefono != null) 'telefono': telefono,
      if (email != null) 'email': email,
      'activa': activa,
      if (createdAt != null) 'createdAt': createdAt!.toIso8601String(),
      if (updatedAt != null) 'updatedAt': updatedAt!.toIso8601String(),
      if (role != null) 'role': role,
      if (role != null) 'rolEnInstitucion': role,
      if (metadata != null) 'metadata': metadata,
    };
  }
  String get name => nombre;

  Institution copyWith({
    String? id,
    String? nombre,
    String? direccion,
    String? telefono,
    String? email,
    bool? activa,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? role,
    Map<String, dynamic>? metadata,
  }) {
    return Institution(
      id: id ?? this.id,
      nombre: nombre ?? this.nombre,
      direccion: direccion ?? this.direccion,
      telefono: telefono ?? this.telefono,
      email: email ?? this.email,
      activa: activa ?? this.activa,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      role: role ?? this.role,
      metadata: metadata ?? this.metadata,
    );
  }

  @override
  String toString() {
    return 'Institution(id: $id, nombre: $nombre, activa: $activa)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Institution && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;
}
/* Fin lib\models\institution.dart */

/* Inicio lib\models\materia.dart */
class Materia {
  final String id;
  final String nombre;
  final String? codigo;
  final String institucionId;
  final DateTime createdAt;

  Materia({
    required this.id,
    required this.nombre,
    this.codigo,
    required this.institucionId,
    required this.createdAt,
  });

  factory Materia.fromJson(Map<String, dynamic> json) {
    return Materia(
      id: json['id'],
      nombre: json['nombre'],
      codigo: json['codigo'],
      institucionId: json['institucionId'],
      createdAt: DateTime.parse(json['createdAt']),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'nombre': nombre,
      'codigo': codigo,
      'institucionId': institucionId,
      'createdAt': createdAt.toIso8601String(),
    };
  }

  String get nombreConCodigo => codigo != null ? '$codigo - $nombre' : nombre;
}
/* Fin lib\models\materia.dart */

/* Inicio lib\models\user.dart */
import '../config/app_constants.dart';

class User {
  final String id;
  final String email;
  final String nombres;
  final String apellidos;
  final String rol;
  final String? telefono;
  final bool activo;
  final List<UserInstitution> instituciones;
  final StudentDetails? estudiante;

  User({
    required this.id,
    required this.email,
    required this.nombres,
    required this.apellidos,
    required this.rol,
    this.telefono,
    required this.activo,
    required this.instituciones,
    this.estudiante,
  });

  String get nombreCompleto => '$nombres $apellidos';

  bool get esProfesor => rol == 'profesor';
  bool get esEstudiante => rol == 'estudiante';
  bool get esAdminInstitucion => rol == 'admin_institucion';
  bool get esSuperAdmin => rol == 'super_admin';

  factory User.fromJson(Map<String, dynamic> json) {
    return User(
      id: json['id'] as String? ?? '',
      email: json['email'] as String? ?? '',
      nombres: json['nombres'] as String? ?? '',
      apellidos: json['apellidos'] as String? ?? '',
      rol: json['rol'] as String? ?? 'profesor', // Default to profesor for institution-admin context
      telefono: json['telefono'] as String?,
      activo: json['activo'] as bool? ?? true,
      instituciones: (json['usuarioInstituciones'] as List<dynamic>?)
          ?.map((e) => UserInstitution.fromJson(e as Map<String, dynamic>))
          .toList() ?? [],
      estudiante: json['estudiante'] != null
          ? StudentDetails.fromJson(json['estudiante'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'email': email,
      'nombres': nombres,
      'apellidos': apellidos,
      'rol': rol,
      'telefono': telefono,
      'activo': activo,
      'usuarioInstituciones': instituciones.map((e) => e.toJson()).toList(),
      if (estudiante != null) 'estudiante': estudiante!.toJson(),
    };
  }

  User copyWith({
    String? id,
    String? email,
    String? nombres,
    String? apellidos,
    String? rol,
    String? telefono,
    bool? activo,
    List<UserInstitution>? instituciones,
    StudentDetails? estudiante,
  }) {
    return User(
      id: id ?? this.id,
      email: email ?? this.email,
      nombres: nombres ?? this.nombres,
      apellidos: apellidos ?? this.apellidos,
      rol: rol ?? this.rol,
      telefono: telefono ?? this.telefono,
      activo: activo ?? this.activo,
      instituciones: instituciones ?? this.instituciones,
      estudiante: estudiante ?? this.estudiante,
    );
  }
}

class UserInstitution {
  final String id;
  final String nombre;
  final String? rolEnInstitucion;
  final bool activo;

  UserInstitution({
    required this.id,
    required this.nombre,
    this.rolEnInstitucion,
    required this.activo,
  });

  factory UserInstitution.fromJson(Map<String, dynamic> json) {
    return UserInstitution(
      id: json['institucion']?['id'] as String? ?? '',
      nombre: json['institucion']?['nombre'] as String? ?? '',
      rolEnInstitucion: json['rolEnInstitucion'] as String?,
      activo: json['activo'] as bool? ?? true,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'institucion': {
        'id': id,
        'nombre': nombre,
      },
      'rolEnInstitucion': rolEnInstitucion,
      'activo': activo,
    };
  }
}

class StudentDetails {
  final String id;
  final String identificacion;
  final String codigoQr;
  final String? nombreResponsable;
  final String? telefonoResponsable;

  StudentDetails({
    required this.id,
    required this.identificacion,
    required this.codigoQr,
    this.nombreResponsable,
    this.telefonoResponsable,
  });

  factory StudentDetails.fromJson(Map<String, dynamic> json) {
    return StudentDetails(
      id: json['id'] as String? ?? '',
      identificacion: json['identificacion'] as String? ?? '',
      codigoQr: json['codigoQr'] as String? ?? '',
      nombreResponsable: json['nombreResponsable'] as String?,
      telefonoResponsable: json['telefonoResponsable'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'identificacion': identificacion,
      'codigoQr': codigoQr,
      'nombreResponsable': nombreResponsable,
      'telefonoResponsable': telefonoResponsable,
    };
  }
}
class CreateUserRequest {
  final String email;
  final String password;
  final String nombres;
  final String apellidos;
  final String rol;
  final String? telefono;
  final String? institucionId;
  final String? rolEnInstitucion;
  final String? identificacion;
  final String? nombreResponsable;
  final String? telefonoResponsable;
  final String? titulo;
  final String? especialidad;

  CreateUserRequest({
    required this.email,
    required this.password,
    required this.nombres,
    required this.apellidos,
    required this.rol,
    this.telefono,
    this.institucionId,
    this.rolEnInstitucion,
    this.identificacion,
    this.nombreResponsable,
    this.telefonoResponsable,
    this.titulo,
    this.especialidad,
  });

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = {
      'email': email,
      'password': password,
      'nombres': nombres,
      'apellidos': apellidos,
      'rol': rol,
      if (telefono != null) 'telefono': telefono,
      if (institucionId != null) 'institucionId': institucionId,
      if (rolEnInstitucion != null) 'rolEnInstitucion': rolEnInstitucion,
    };
    if (rol == 'estudiante') {
      if (identificacion != null) data['identificacion'] = identificacion;
      if (nombreResponsable != null) data['nombreResponsable'] = nombreResponsable;
      if (telefonoResponsable != null) data['telefonoResponsable'] = telefonoResponsable;
    }
    if (rol == 'profesor') {
      if (titulo != null) data['titulo'] = titulo;
      if (especialidad != null) data['especialidad'] = especialidad;
    }

    return data;
  }
}

class UpdateUserRequest {
  final String? email;
  final String? nombres;
  final String? apellidos;
  final String? telefono;
  final bool? activo;
  final String? identificacion;
  final String? nombreResponsable;
  final String? telefonoResponsable;

  UpdateUserRequest({
    this.email,
    this.nombres,
    this.apellidos,
    this.telefono,
    this.activo,
    this.identificacion,
    this.nombreResponsable,
    this.telefonoResponsable,
  });

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = {};

    if (email != null) data['email'] = email;
    if (nombres != null) data['nombres'] = nombres;
    if (apellidos != null) data['apellidos'] = apellidos;
    if (telefono != null) data['telefono'] = telefono;
    if (activo != null) data['activo'] = activo;
    if (identificacion != null) data['identificacion'] = identificacion;
    if (nombreResponsable != null) data['nombreResponsable'] = nombreResponsable;
    if (telefonoResponsable != null) data['telefonoResponsable'] = telefonoResponsable;

    return data;
  }
}

class PaginationInfo {
  final int page;
  final int limit;
  final int total;
  final int totalPages;
  final bool hasNext;
  final bool hasPrev;

  PaginationInfo({
    required this.page,
    required this.limit,
    required this.total,
    required this.totalPages,
    required this.hasNext,
    required this.hasPrev,
  });

  factory PaginationInfo.fromJson(Map<String, dynamic> json) {
    return PaginationInfo(
      page: json['page'] as int? ?? 1,
      limit: json['limit'] as int? ?? AppConstants.itemsPerPage,
      total: json['total'] as int? ?? 0,
      totalPages: json['totalPages'] as int? ?? 1,
      hasNext: json['hasNext'] as bool? ?? false,
      hasPrev: json['hasPrev'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'page': page,
      'limit': limit,
      'total': total,
      'totalPages': totalPages,
      'hasNext': hasNext,
      'hasPrev': hasPrev,
    };
  }
}
/* Fin lib\models\user.dart */

/* Inicio lib\providers\auth_provider.dart */
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../services/auth_service.dart';
import '../models/institution.dart';
import 'user_provider.dart';
import 'institution_provider.dart';

class AuthProvider with ChangeNotifier {
  final AuthService _authService = AuthService();

  String? _accessToken;
  String? _refreshToken;
  Map<String, dynamic>? _user;
  String? _selectedInstitutionId;
  List<Institution>? _institutions;

  String? get accessToken => _accessToken;
  String? get refreshToken => _refreshToken;
  Map<String, dynamic>? get user => _user;
  String? get selectedInstitutionId => _selectedInstitutionId;
  List<Institution>? get institutions => _institutions;

  bool get isAuthenticated => _accessToken != null && _user != null;

  Institution? get selectedInstitution {
    if (_selectedInstitutionId == null || _institutions == null) return null;
    try {
      return _institutions!.firstWhere(
        (institution) => institution.id == _selectedInstitutionId,
      );
    } catch (e) {
      return null;
    }
  }

  AuthProvider() {
    _loadTokensFromStorage();
  }

  Future<void> _loadTokensFromStorage() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      _accessToken = prefs.getString('accessToken');
      _refreshToken = prefs.getString('refreshToken');
      final userJson = prefs.getString('user');
      if (userJson != null) {
        _user = Map<String, dynamic>.from(jsonDecode(userJson));
      }
      _selectedInstitutionId = prefs.getString('selectedInstitutionId');
      notifyListeners();
    } catch (e) {
      debugPrint('Error loading from storage: $e');
    }
  }

  Future<void> _saveTokensToStorage() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      if (_accessToken != null) {
        await prefs.setString('accessToken', _accessToken!);
      } else {
        await prefs.remove('accessToken');
      }
      if (_refreshToken != null) {
        await prefs.setString('refreshToken', _refreshToken!);
      } else {
        await prefs.remove('refreshToken');
      }
      if (_user != null) {
        await prefs.setString('user', jsonEncode(_user));
      } else {
        await prefs.remove('user');
      }
      if (_selectedInstitutionId != null) {
        await prefs.setString('selectedInstitutionId', _selectedInstitutionId!);
      } else {
        await prefs.remove('selectedInstitutionId');
      }
    } catch (e) {
      debugPrint('Error saving to storage: $e');
    }
  }

  Future<void> _clearTokens() async {
    _accessToken = null;
    _refreshToken = null;
    _user = null;
    _selectedInstitutionId = null;
    await _saveTokensToStorage();
    notifyListeners();
  }

  void clearHeavyData() {
    _institutions = null;
    notifyListeners();
  }

  void clearTemporaryData() {
    _institutions = null;
    _selectedInstitutionId = null;
    notifyListeners();
  }

  Future<void> recoverFullState() async {
    if (_accessToken != null) {
      debugPrint('Recuperando estado completo del usuario');
      await loadUserInstitutions();

      if (_selectedInstitutionId != null && _institutions != null) {
        final institutionExists = _institutions!.any((i) => i.id == _selectedInstitutionId);
        if (!institutionExists) {
          debugPrint('InstituciÃ³n guardada ya no existe, limpiando');
          _selectedInstitutionId = null;
          await _saveTokensToStorage();
        }
      }

      notifyListeners();
    }
  }

  Future<void> loadUserInstitutions({bool notify = true}) async {
    if (_accessToken == null) return;

    try {
      final institutionMaps = await _authService.getUserInstitutions(_accessToken!);
      _institutions = institutionMaps?.map((map) => Institution.fromJson(map)).toList();
      if (notify) notifyListeners();
    } catch (e) {
      debugPrint('Error loading user institutions: $e');
    }
  }

  void selectInstitution(String institutionId) {
    _selectedInstitutionId = institutionId;
    _saveTokensToStorage();
    notifyListeners();
  }

  Future<bool> login(String email, String password) async {
    try {
      final result = await _authService.login(email, password);
      if (result != null) {
        _accessToken = result.accessToken;
        _refreshToken = result.refreshToken;
        _user = result.user;

        await loadUserInstitutions(notify: false);

        if (_institutions != null && _institutions!.length == 1) {
          _selectedInstitutionId = _institutions!.first.id;
          debugPrint('InstituciÃ³n seleccionada automÃ¡ticamente: $_selectedInstitutionId');
        } else if (_institutions != null && _institutions!.length > 1) {
          _selectedInstitutionId = null;
          debugPrint('MÃºltiples instituciones encontradas, esperando selecciÃ³n manual');
        }

        await _saveTokensToStorage();
        notifyListeners();
        return true;
      }
      return false;
    } catch (e) {
      debugPrint('Login error: $e');
      rethrow;
    }
  }

  Future<bool> refreshAccessToken() async {
    if (_refreshToken == null) return false;

    try {
      final result = await _authService.refreshToken(_refreshToken!);
      if (result != null) {
        _accessToken = result.accessToken;
        _refreshToken = result.refreshToken;
        await _saveTokensToStorage();
        notifyListeners();
        return true;
      }
      return false;
    } catch (e) {
      debugPrint('Refresh error: $e');
      return false;
    }
  }

  Future<void> logout() async {
    if (_refreshToken != null) {
      await _authService.logout(_refreshToken!);
    }
    await _clearTokens();
  }

  Future<void> logoutAndClearAllData(BuildContext context) async {
    if (_refreshToken != null) {
      await _authService.logout(_refreshToken!);
    }
    await _clearTokens();
    if (context.mounted) {
      try {
        final userProvider = Provider.of<UserProvider>(context, listen: false);
        userProvider.clearData();

        final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);
        institutionProvider.clearData();
      } catch (e) {
        debugPrint('Error clearing provider data: $e');
      }
    }
  }
}
/* Fin lib\providers\auth_provider.dart */

/* Inicio lib\providers\grupo_provider.dart */
import 'dart:async';
import 'package:flutter/foundation.dart';
import '../services/academic_service.dart' as academic_service;
import '../models/grupo.dart';
import '../models/user.dart'

enum GrupoState {
  initial,
  loading,
  loaded,
  error,
}

class GrupoProvider with ChangeNotifier {
  final academic_service.AcademicService _academicService = academic_service.AcademicService();

  GrupoState _state = GrupoState.initial;
  String? _errorMessage;
  List<Grupo> _grupos = [];
  Grupo? _selectedGrupo;
  String? _selectedPeriodoId;
  PaginationInfo? _paginationInfo;
  bool _isLoadingMore = false;
  bool _hasMoreData = true;
  GrupoState get state => _state;
  String? get errorMessage => _errorMessage;
  List<Grupo> get grupos => _grupos;
  Grupo? get selectedGrupo => _selectedGrupo;
  String? get selectedPeriodoId => _selectedPeriodoId;
  PaginationInfo? get paginationInfo => _paginationInfo;

  bool get isLoading => _state == GrupoState.loading;
  bool get hasError => _state == GrupoState.error;
  bool get isLoaded => _state == GrupoState.loaded;
  bool get isLoadingMore => _isLoadingMore;
  bool get hasMoreData => _hasMoreData;
  List<Grupo> get gruposActivos => _grupos.where((grupo) => grupo.periodoAcademico.activo).toList();
  List<Grupo> get gruposInactivos => _grupos.where((grupo) => !grupo.periodoAcademico.activo).toList();
  int get loadedGruposCount => _grupos.length;
  int get gruposActivosCount => gruposActivos.length;
  int get gruposInactivosCount => gruposInactivos.length;
  int get totalGruposFromPagination => _paginationInfo?.total ?? 0;

  void _setState(GrupoState newState, [String? error]) {
    _state = newState;
    _errorMessage = error;
    notifyListeners();
  }
  Future<void> loadGrupos(String accessToken, {int? page, int? limit, String? periodoId, String? search}) async {
    if (_state == GrupoState.loading) return;

    _setState(GrupoState.loading);
    resetPagination()

    try {
      debugPrint('GrupoProvider: Iniciando carga de grupos...');
      final response = await _academicService.getGrupos(
        accessToken,
        page: page ?? 1,
        limit: limit,
        periodoId: periodoId,
        search: search,
      );
      if (response != null) {
        debugPrint('GrupoProvider: Recibidos ${response.grupos.length} grupos');
        _grupos = response.grupos;
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
        _setState(GrupoState.loaded);
        debugPrint('GrupoProvider: Estado cambiado a loaded');
      } else {
        _setState(GrupoState.error, 'Error al cargar grupos');
      }
    } catch (e) {
      debugPrint('GrupoProvider: Error loading grupos: $e');
      _setState(GrupoState.error, e.toString());
    }
  }
  Future<void> loadGruposByPeriodo(String accessToken, String periodoId, {int? page, int limit = 10, String? search}) async {
    if (_state == GrupoState.loading) return;

    _setState(GrupoState.loading);
    _selectedPeriodoId = periodoId;
    resetPagination()

    try {
      debugPrint('GrupoProvider: Iniciando carga de grupos por periodo $periodoId...');
      final response = await _academicService.getGrupos(accessToken, page: page ?? 1, limit: limit, periodoId: periodoId, search: search);
      if (response != null) {
        debugPrint('GrupoProvider: Recibidos ${response.grupos.length} grupos del periodo $periodoId');
        _grupos = response.grupos;
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
        _setState(GrupoState.loaded);
      } else {
        _setState(GrupoState.error, 'Error al cargar grupos del periodo');
      }
    } catch (e) {
      debugPrint('GrupoProvider: Error loading grupos by periodo: $e');
      _setState(GrupoState.error, e.toString());
    }
  }
  Future<void> loadGrupoById(String accessToken, String grupoId) async {
    _setState(GrupoState.loading);

    try {
      final grupo = await _academicService.getGrupoById(accessToken, grupoId);
      if (grupo != null) {
        _selectedGrupo = grupo;
        _setState(GrupoState.loaded);
      } else {
        _setState(GrupoState.error, 'Grupo no encontrado');
      }
    } catch (e) {
      debugPrint('Error loading grupo: $e');
      _setState(GrupoState.error, e.toString());
    }
  }
  Future<bool> createGrupo(String accessToken, academic_service.CreateGrupoRequest grupoData) async {
    _setState(GrupoState.loading);

    try {
      final newGrupo = await _academicService.createGrupo(accessToken, grupoData);
      if (newGrupo != null) {
        _grupos.insert(0, newGrupo);
        _setState(GrupoState.loaded);
        return true;
      } else {
        _setState(GrupoState.error, 'Error al crear grupo');
        return false;
      }
    } catch (e) {
      debugPrint('Error creating grupo: $e');
      _setState(GrupoState.error, e.toString());
      return false;
    }
  }
  Future<bool> updateGrupo(String accessToken, String grupoId, academic_service.UpdateGrupoRequest grupoData) async {
    _setState(GrupoState.loading);

    try {
      final updatedGrupo = await _academicService.updateGrupo(accessToken, grupoId, grupoData);
      if (updatedGrupo != null) {
        final index = _grupos.indexWhere((grupo) => grupo.id == grupoId);
        if (index != -1) {
          _grupos[index] = updatedGrupo;
        }
        if (_selectedGrupo?.id == grupoId) {
          _selectedGrupo = updatedGrupo;
        }

        _setState(GrupoState.loaded);
        return true;
      } else {
        _setState(GrupoState.error, 'Error al actualizar grupo');
        return false;
      }
    } catch (e) {
      debugPrint('Error updating grupo: $e');
      _setState(GrupoState.error, e.toString());
      return false;
    }
  }
  Future<bool> deleteGrupo(String accessToken, String grupoId) async {
    try {
      final success = await _academicService.deleteGrupo(accessToken, grupoId);

      if (!success) {
        _errorMessage = 'Error al eliminar el grupo desde el servicio.';
      }
      return success;
    } catch (e) {
      debugPrint('Error deleting grupo: $e');
      _errorMessage = e.toString();
      return false;
    }
  }
  void selectGrupo(Grupo grupo) {
    _selectedGrupo = grupo;
    notifyListeners();
  }
  void clearSelectedGrupo() {
    _selectedGrupo = null;
    notifyListeners();
  }
  void clearData() {
    _grupos = [];
    _selectedGrupo = null;
    _selectedPeriodoId = null;
    _paginationInfo = null;
    _setState(GrupoState.initial);
  }
  Future<void> refreshData(String accessToken) async {
    if (_selectedPeriodoId != null) {
      await loadGruposByPeriodo(accessToken, _selectedPeriodoId!);
    } else {
      await loadGrupos(accessToken);
    }
  }
  List<Grupo> searchGrupos(String query) {
    if (query.isEmpty) return _grupos;

    final lowercaseQuery = query.toLowerCase();
    return _grupos.where((grupo) {
      return grupo.nombre.toLowerCase().contains(lowercaseQuery) ||
             grupo.grado.toLowerCase().contains(lowercaseQuery) ||
             (grupo.seccion?.toLowerCase().contains(lowercaseQuery) ?? false);
    }).toList();
  }
  List<Grupo> filterGruposByGrado(String grado) {
    if (grado.isEmpty) return _grupos;
    return _grupos.where((grupo) => grupo.grado == grado).toList();
  }
  List<Grupo> filterGruposByPeriodoStatus({bool? activo}) {
    if (activo == null) return _grupos;
    return _grupos.where((grupo) => grupo.periodoAcademico.activo == activo).toList();
  }
  Future<void> loadNextPage(String accessToken) async {
    if (_paginationInfo == null || !_paginationInfo!.hasNext || _state == GrupoState.loading) return;

    final nextPage = _paginationInfo!.page + 1;
    if (_selectedPeriodoId != null) {
      await loadGruposByPeriodo(accessToken, _selectedPeriodoId!, page: nextPage, limit: _paginationInfo!.limit);
    } else {
      await loadGrupos(accessToken, page: nextPage, limit: _paginationInfo!.limit);
    }
  }
  Future<void> loadPreviousPage(String accessToken) async {
    if (_paginationInfo == null || !_paginationInfo!.hasPrev || _state == GrupoState.loading) return;

    final prevPage = _paginationInfo!.page - 1;
    if (_selectedPeriodoId != null) {
      await loadGruposByPeriodo(accessToken, _selectedPeriodoId!, page: prevPage, limit: _paginationInfo!.limit);
    } else {
      await loadGrupos(accessToken, page: prevPage, limit: _paginationInfo!.limit);
    }
  }
  Future<void> loadPage(String accessToken, int page) async {
    if (_state == GrupoState.loading) return;

    if (_selectedPeriodoId != null) {
      await loadGruposByPeriodo(accessToken, _selectedPeriodoId!, page: page, limit: _paginationInfo?.limit ?? 10);
    } else {
      await loadGrupos(accessToken, page: page, limit: _paginationInfo?.limit ?? 10);
    }
  }
  Map<String, int> getGruposStatistics() {
    return {
      'total': _paginationInfo?.total ?? 0,
      'activos': gruposActivosCount,
      'inactivos': gruposInactivosCount,
    };
  }
  Future<void> loadMoreGrupos(String accessToken, {String? periodoId, String? search}) async {
    if (_isLoadingMore || !_hasMoreData || _paginationInfo == null) return;

    _isLoadingMore = true;
    notifyListeners();

    try {
      final nextPage = _paginationInfo!.page + 1;

      academic_service.PaginatedGruposResponse? response;
      if (_selectedPeriodoId != null) {
        response = await _academicService.getGrupos(
          accessToken,
          page: nextPage,
          limit: _paginationInfo!.limit,
          periodoId: _selectedPeriodoId,
        );
      } else {
        response = await _academicService.getGrupos(
          accessToken,
          page: nextPage,
          limit: _paginationInfo!.limit,
          periodoId: periodoId,
          search: search,
        );
      }

      if (response != null) {
        _grupos.addAll(response.grupos)
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
        debugPrint('GrupoProvider: Cargados ${response.grupos.length} grupos mÃ¡s. Total ahora: ${_grupos.length}');
      } else {
        _hasMoreData = false;
      }
    } catch (e) {
      debugPrint('GrupoProvider: Error loading more grupos: $e');
    } finally {
      _isLoadingMore = false;
      notifyListeners();
    }
  }
  Future<List<Grupo>?> searchGruposRemote(String accessToken, {String? search, int limit = 10}) async {
    try {
      final response = await _academicService.getGrupos(
        accessToken,
        page: 1,
        limit: limit,
        search: search,
      );
      return response?.grupos;
    } catch (e) {
      debugPrint('Error searchGruposRemote: $e');
      return null;
    }
  }
  void resetPagination() {
    _hasMoreData = true;
    _isLoadingMore = false;
  }
}
/* Fin lib\providers\grupo_provider.dart */

/* Inicio lib\providers\horario_provider.dart */
import 'dart:async';
import 'package:flutter/foundation.dart';
import '../services/academic_service.dart' as academic_service;
import '../models/horario.dart';
import '../models/clase_del_dia.dart';
import '../models/user.dart'

enum HorarioState {
  initial,
  loading,
  loaded,
  error,
}

class HorarioProvider with ChangeNotifier {
  final academic_service.AcademicService _academicService = academic_service.AcademicService();

  HorarioState _state = HorarioState.initial;
  String? _errorMessage;
  List<Horario> _horarios = [];
  List<ClaseDelDia> _clasesDelDia = [];
  List<ClaseDelDia> _horarioSemanal = [];
  Horario? _selectedHorario;
  String? _selectedGrupoId;
  String? _selectedPeriodoId;
  PaginationInfo? _paginationInfo;
  bool _isLoadingMore = false;
  bool _hasMoreData = true;
  HorarioState get state => _state;
  String? get errorMessage => _errorMessage;
  List<Horario> get horarios => _horarios;
  List<ClaseDelDia> get clasesDelDia => _clasesDelDia;
  List<ClaseDelDia> get horarioSemanal => _horarioSemanal;
  Horario? get selectedHorario => _selectedHorario;
  String? get selectedGrupoId => _selectedGrupoId;
  String? get selectedPeriodoId => _selectedPeriodoId;
  PaginationInfo? get paginationInfo => _paginationInfo;

  bool get isLoading => _state == HorarioState.loading;
  bool get hasError => _state == HorarioState.error;
  bool get isLoaded => _state == HorarioState.loaded;
  bool get isLoadingMore => _isLoadingMore;
  bool get hasMoreData => _hasMoreData;
  List<Horario> get horariosActivos => _horarios.where((horario) => horario.periodoAcademico.activo).toList();
  int get loadedHorariosCount => _horarios.length;
  int get clasesDelDiaCount => _clasesDelDia.length;
  int get horarioSemanalCount => _horarioSemanal.length;
  int get totalHorariosFromPagination => _paginationInfo?.total ?? 0;

  void _setState(HorarioState newState, [String? error]) {
    _state = newState;
    _errorMessage = error;
    notifyListeners();
  }
  Future<void> loadHorarios(String accessToken, {int? page, int? limit, String? grupoId, String? periodoId}) async {
    if (_state == HorarioState.loading) return;

    _setState(HorarioState.loading);
    resetPagination()

    try {
      debugPrint('HorarioProvider: Iniciando carga de horarios...');
      final response = await _academicService.getHorarios(
        accessToken,
        page: page ?? 1,
        limit: limit,
        grupoId: grupoId,
        periodoId: periodoId,
      );
      if (response != null) {
        debugPrint('HorarioProvider: Recibidos ${response.horarios.length} horarios');
        _horarios = response.horarios;
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
        _setState(HorarioState.loaded);
        debugPrint('HorarioProvider: Estado cambiado a loaded');
      } else {
        _setState(HorarioState.error, 'Error al cargar horarios');
      }
    } catch (e) {
      debugPrint('HorarioProvider: Error loading horarios: $e');
      _setState(HorarioState.error, e.toString());
    }
  }
  Future<void> loadHorariosByGrupo(String accessToken, String grupoId) async {
    if (_state == HorarioState.loading) return;

    _setState(HorarioState.loading);
    _selectedGrupoId = grupoId;

    try {
      debugPrint('HorarioProvider: Iniciando carga de horarios por grupo $grupoId...');
      final horarios = await _academicService.getHorariosPorGrupo(accessToken, grupoId);
      if (horarios != null) {
        debugPrint('HorarioProvider: Recibidos ${horarios.length} horarios del grupo $grupoId');
        _horarios = horarios;
        _hasMoreData = false
        _setState(HorarioState.loaded);
      } else {
        _setState(HorarioState.error, 'Error al cargar horarios del grupo');
      }
    } catch (e) {
      debugPrint('HorarioProvider: Error loading horarios by grupo: $e');
      _setState(HorarioState.error, e.toString());
    }
  }
  Future<void> loadHorarioById(String accessToken, String horarioId) async {
    _setState(HorarioState.loading);

    try {
      final horario = await _academicService.getHorarioById(accessToken, horarioId);
      if (horario != null) {
        _selectedHorario = horario;
        _setState(HorarioState.loaded);
      } else {
        _setState(HorarioState.error, 'Horario no encontrado');
      }
    } catch (e) {
      debugPrint('Error loading horario: $e');
      _setState(HorarioState.error, e.toString());
    }
  }
  Future<bool> createHorario(String accessToken, academic_service.CreateHorarioRequest horarioData) async {
    _setState(HorarioState.loading);

    try {
      final newHorario = await _academicService.createHorario(accessToken, horarioData);
      if (newHorario != null) {
        _horarios.insert(0, newHorario);
        _setState(HorarioState.loaded);
        return true;
      } else {
        _setState(HorarioState.error, 'Error al crear horario');
        return false;
      }
    } catch (e) {
      debugPrint('Error creating horario: $e');
      _setState(HorarioState.error, e.toString());
      return false;
    }
  }
  Future<bool> updateHorario(String accessToken, String horarioId, academic_service.UpdateHorarioRequest horarioData) async {
    _setState(HorarioState.loading);

    try {
      final updatedHorario = await _academicService.updateHorario(accessToken, horarioId, horarioData);
      if (updatedHorario != null) {
        final index = _horarios.indexWhere((horario) => horario.id == horarioId);
        if (index != -1) {
          _horarios[index] = updatedHorario;
        }
        if (_selectedHorario?.id == horarioId) {
          _selectedHorario = updatedHorario;
        }

        _setState(HorarioState.loaded);
        return true;
      } else {
        _setState(HorarioState.error, 'Error al actualizar horario');
        return false;
      }
    } catch (e) {
      debugPrint('Error updating horario: $e');
      _setState(HorarioState.error, e.toString());
      return false;
    }
  }
  Future<bool> deleteHorario(String accessToken, String horarioId) async {
    try {
      final success = await _academicService.deleteHorario(accessToken, horarioId);

      if (!success) {
        _errorMessage = 'Error al eliminar el horario desde el servicio.';
      }
      return success;
    } catch (e) {
      debugPrint('Error deleting horario: $e');
      _errorMessage = e.toString();
      return false;
    }
  }
  Future<void> cargarClasesDelDia(String accessToken) async {
    _setState(HorarioState.loading);

    try {
      debugPrint('HorarioProvider: Cargando clases del dÃ­a para el profesor...');
      final clases = await _academicService.getMisClasesDelDia(accessToken);
      if (clases != null) {
        debugPrint('HorarioProvider: Recibidas ${clases.length} clases del dÃ­a');
        _clasesDelDia = clases;
        _setState(HorarioState.loaded);
      } else {
        _setState(HorarioState.error, 'Error al cargar clases del dÃ­a');
      }
    } catch (e) {
      debugPrint('HorarioProvider: Error loading clases del dia: $e');
      _setState(HorarioState.error, e.toString());
    }
  }
  Future<void> cargarClasesPorDia(String accessToken, int diaSemana) async {
    _setState(HorarioState.loading);

    try {
      debugPrint('HorarioProvider: Cargando clases del dÃ­a $diaSemana para el profesor...');
      final clases = await _academicService.getMisClasesPorDia(accessToken, diaSemana);
      if (clases != null) {
        debugPrint('HorarioProvider: Recibidas ${clases.length} clases del dÃ­a $diaSemana');
        _clasesDelDia = clases;
        _setState(HorarioState.loaded);
      } else {
        _setState(HorarioState.error, 'Error al cargar clases del dÃ­a especÃ­fico');
      }
    } catch (e) {
      debugPrint('HorarioProvider: Error loading clases por dia: $e');
      _setState(HorarioState.error, e.toString());
    }
  }
  Future<void> cargarHorarioSemanal(String accessToken) async {
    _setState(HorarioState.loading);

    try {
      debugPrint('HorarioProvider: Cargando horario semanal para el profesor...');
      final horario = await _academicService.getMiHorarioSemanal(accessToken);
      if (horario != null) {
        debugPrint('HorarioProvider: Recibido horario semanal con ${horario.length} clases');
        _horarioSemanal = horario;
        _setState(HorarioState.loaded);
      } else {
        _setState(HorarioState.error, 'Error al cargar horario semanal');
      }
    } catch (e) {
      debugPrint('HorarioProvider: Error loading horario semanal: $e');
      _setState(HorarioState.error, e.toString());
    }
  }
  void selectHorario(Horario horario) {
    _selectedHorario = horario;
    notifyListeners();
  }
  void clearSelectedHorario() {
    _selectedHorario = null;
    notifyListeners();
  }
  void clearData() {
    _horarios = [];
    _clasesDelDia = [];
    _horarioSemanal = [];
    _selectedHorario = null;
    _selectedGrupoId = null;
    _selectedPeriodoId = null;
    _paginationInfo = null;
    _setState(HorarioState.initial);
  }
  Future<void> refreshData(String accessToken) async {
    if (_selectedGrupoId != null) {
      await loadHorariosByGrupo(accessToken, _selectedGrupoId!);
    } else {
      await loadHorarios(accessToken);
    }
  }
  List<Horario> searchHorarios(String query) {
    if (query.isEmpty) return _horarios;

    final lowercaseQuery = query.toLowerCase();
    return _horarios.where((horario) {
      return horario.materia.nombre.toLowerCase().contains(lowercaseQuery) ||
             horario.grupo.nombre.toLowerCase().contains(lowercaseQuery) ||
             horario.descripcion.toLowerCase().contains(lowercaseQuery);
    }).toList();
  }
  List<Horario> filterHorariosByDia(int diaSemana) {
    return _horarios.where((horario) => horario.diaSemana == diaSemana).toList();
  }
  List<ClaseDelDia> getClasesDelDiaOrdenadas() {
    return _clasesDelDia..sort((a, b) => a.horaInicio.compareTo(b.horaInicio));
  }
  List<ClaseDelDia> getHorarioPorDia(int diaSemana) {
    return _horarioSemanal.where((clase) => clase.diaSemana == diaSemana).toList()
      ..sort((a, b) => a.horaInicio.compareTo(b.horaInicio));
  }
  Future<void> loadNextPage(String accessToken) async {
    if (_paginationInfo == null || !_paginationInfo!.hasNext || _state == HorarioState.loading) return;

    final nextPage = _paginationInfo!.page + 1;
    if (_selectedGrupoId != null) {
      await loadHorariosByGrupo(accessToken, _selectedGrupoId!);
    } else {
      await loadHorarios(accessToken, page: nextPage, limit: _paginationInfo!.limit);
    }
  }
  Future<void> loadPreviousPage(String accessToken) async {
    if (_paginationInfo == null || !_paginationInfo!.hasPrev || _state == HorarioState.loading) return;

    final prevPage = _paginationInfo!.page - 1;
    await loadHorarios(accessToken, page: prevPage, limit: _paginationInfo!.limit);
  }
  Future<void> loadPage(String accessToken, int page) async {
    if (_state == HorarioState.loading) return;

    await loadHorarios(accessToken, page: page, limit: _paginationInfo?.limit ?? 10);
  }
  Map<String, int> getHorariosStatistics() {
    return {
      'total': _paginationInfo?.total ?? 0,
      'activos': horariosActivos.length,
      'clases_hoy': _clasesDelDia.length,
      'horario_semanal': _horarioSemanal.length,
    };
  }
  Future<void> loadMoreHorarios(String accessToken, {String? grupoId, String? periodoId}) async {
    if (_isLoadingMore || !_hasMoreData || _paginationInfo == null) return;

    _isLoadingMore = true;
    notifyListeners();

    try {
      final nextPage = _paginationInfo!.page + 1;

      final response = await _academicService.getHorarios(
        accessToken,
        page: nextPage,
        limit: _paginationInfo!.limit,
        grupoId: grupoId,
        periodoId: periodoId,
      );

      if (response != null) {
        _horarios.addAll(response.horarios)
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
        debugPrint('HorarioProvider: Cargados ${response.horarios.length} horarios mÃ¡s. Total ahora: ${_horarios.length}');
      } else {
        _hasMoreData = false;
      }
    } catch (e) {
      debugPrint('HorarioProvider: Error loading more horarios: $e');
    } finally {
      _isLoadingMore = false;
      notifyListeners();
    }
  }
  void resetPagination() {
    _hasMoreData = true;
    _isLoadingMore = false;
  }
}
/* Fin lib\providers\horario_provider.dart */

/* Inicio lib\providers\institution_provider.dart */
import 'dart:async';
import 'package:flutter/foundation.dart';
import '../services/institution_service.dart';
import '../models/institution.dart';
import '../models/user.dart';

enum InstitutionState {
  initial,
  loading,
  loaded,
  error,
}

class InstitutionProvider with ChangeNotifier {
  final InstitutionService _institutionService = InstitutionService();

  InstitutionState _state = InstitutionState.initial;
  String? _errorMessage;
  List<Institution> _institutions = [];
  Institution? _selectedInstitution;
  PaginationInfo? _paginationInfo;
  bool _isLoadingMore = false;
  bool _hasMoreData = true;
  InstitutionState get state => _state;
  String? get errorMessage => _errorMessage;
  List<Institution> get institutions => _institutions;
  Institution? get selectedInstitution => _selectedInstitution;
  PaginationInfo? get paginationInfo => _paginationInfo;

  bool get isLoading => _state == InstitutionState.loading;
  bool get hasError => _state == InstitutionState.error;
  bool get isLoaded => _state == InstitutionState.loaded;
  bool get isLoadingMore => _isLoadingMore;
  bool get hasMoreData => _hasMoreData;
  List<Institution> get activeInstitutions =>
      _institutions.where((inst) => inst.activa).toList();

  List<Institution> get inactiveInstitutions =>
      _institutions.where((inst) => !inst.activa).toList();

  int get totalInstitutions => _institutions.length;
  int get activeInstitutionsCount => activeInstitutions.length;
  int get inactiveInstitutionsCount => inactiveInstitutions.length;

  void _setState(InstitutionState newState, [String? error]) {
    _state = newState;
    _errorMessage = error;
    notifyListeners();
  }
  void resetPagination() {
    _hasMoreData = true;
    _isLoadingMore = false;
  }
  Future<void> loadInstitutions(String accessToken, {int? page, int? limit, bool? activa, String? search}) async {
    if (_state == InstitutionState.loading) return;

    _setState(InstitutionState.loading);
    resetPagination()

    try {
      debugPrint('InstitutionProvider: Iniciando carga de instituciones...');
      final response = await _institutionService.getAllInstitutions(accessToken, page: page ?? 1, limit: limit, activa: activa, search: search);
      if (response != null) {
        debugPrint('InstitutionProvider: Recibidas ${response.institutions.length} instituciones');
        _institutions = response.institutions;
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
        _setState(InstitutionState.loaded);
        debugPrint('InstitutionProvider: Estado cambiado a loaded');
      } else {
        _setState(InstitutionState.error, 'Error al cargar instituciones');
      }
    } catch (e) {
      debugPrint('InstitutionProvider: Error loading institutions: $e');
      _setState(InstitutionState.error, e.toString());
    }
  }
  Future<void> loadInstitutionById(String accessToken, String id) async {
    _setState(InstitutionState.loading);

    try {
      final institution = await _institutionService.getInstitutionById(accessToken, id);
      _selectedInstitution = institution;
      _setState(InstitutionState.loaded);
    } catch (e) {
      debugPrint('Error loading institution: $e');
      _setState(InstitutionState.error, e.toString());
    }
  }
  Future<bool> createInstitution(
    String accessToken,
    Map<String, dynamic> institutionData,
  ) async {
    _setState(InstitutionState.loading);

    try {
      final newInstitution = await _institutionService.createInstitution(
        accessToken,
        nombre: institutionData['nombre'],
        direccion: institutionData['direccion'],
        telefono: institutionData['telefono'],
        email: institutionData['email'],
      );
      if (newInstitution != null) {
        _institutions.insert(0, newInstitution);
      }
      _setState(InstitutionState.loaded);
      return true;
    } catch (e) {
      debugPrint('Error creating institution: $e');
      _setState(InstitutionState.error, e.toString());
      return false;
    }
  }
  Future<bool> updateInstitution(
    String accessToken,
    String id, {
    String? nombre,
    String? direccion,
    String? telefono,
    String? email,
    bool? activa,
  }) async {
    _setState(InstitutionState.loading);

    try {
      final updatedInstitution = await _institutionService.updateInstitution(
        accessToken,
        id,
        nombre: nombre,
        direccion: direccion,
        telefono: telefono,
        email: email,
        activa: activa,
      );
      final index = _institutions.indexWhere((inst) => inst.id == id);
      if (index != -1 && updatedInstitution != null) {
        _institutions[index] = updatedInstitution;
      }
      if (_selectedInstitution?.id == id && updatedInstitution != null) {
        _selectedInstitution = updatedInstitution;
      }

      _setState(InstitutionState.loaded);
      return true;
    } catch (e) {
      debugPrint('Error updating institution: $e');
      _setState(InstitutionState.error, e.toString());
      return false;
    }
  }
  Future<bool> deleteInstitution(String accessToken, String id) async {
    _setState(InstitutionState.loading);

    try {
      await _institutionService.deleteInstitution(accessToken, id);
      _institutions.removeWhere((inst) => inst.id == id);
      if (_selectedInstitution?.id == id) {
        _selectedInstitution = null;
      }

      _setState(InstitutionState.loaded);
      return true;
    } catch (e) {
      debugPrint('Error deleting institution: $e');
      _setState(InstitutionState.error, e.toString());
      return false;
    }
  }
  void selectInstitution(Institution institution) {
    _selectedInstitution = institution;
    notifyListeners();
  }
  void clearSelectedInstitution() {
    _selectedInstitution = null;
    notifyListeners();
  }
  void clearData() {
    _institutions = [];
    _selectedInstitution = null;
    _setState(InstitutionState.initial);
  }
  Future<void> refreshData(String accessToken) async {
    await loadInstitutions(accessToken);
  }
  List<Institution> searchInstitutions(String query) {
    if (query.isEmpty) return _institutions;

    final lowercaseQuery = query.toLowerCase();
    return _institutions.where((inst) {
      return inst.nombre.toLowerCase().contains(lowercaseQuery) ||
             (inst.email?.toLowerCase().contains(lowercaseQuery) ?? false);
    }).toList();
  }
  Future<void> loadMoreInstitutions(String accessToken, {bool? activa, String? search}) async {
    if (_isLoadingMore || !_hasMoreData || _paginationInfo == null) return;

    _isLoadingMore = true;
    notifyListeners();

    try {
      final nextPage = _paginationInfo!.page + 1;
      debugPrint('InstitutionProvider: Cargando mÃ¡s instituciones, pÃ¡gina $nextPage...');

      final response = await _institutionService.getAllInstitutions(
        accessToken,
        page: nextPage,
        limit: _paginationInfo!.limit,
        activa: activa,
        search: search
      );

      if (response != null && response.institutions.isNotEmpty) {
        debugPrint('InstitutionProvider: Recibidas ${response.institutions.length} instituciones adicionales');
        _institutions.addAll(response.institutions);
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
      } else {
        _hasMoreData = false;
      }
    } catch (e) {
      debugPrint('InstitutionProvider: Error loading more institutions: $e');
      _hasMoreData = false;
    } finally {
      _isLoadingMore = false;
      notifyListeners();
    }
  }
}
/* Fin lib\providers\institution_provider.dart */

/* Inicio lib\providers\materia_provider.dart */
import 'dart:async';
import 'package:flutter/foundation.dart';
import '../services/academic_service.dart' as academic_service;
import '../models/materia.dart';
import '../models/user.dart'

enum MateriaState {
  initial,
  loading,
  loaded,
  error,
}

class MateriaProvider with ChangeNotifier {
  final academic_service.AcademicService _academicService = academic_service.AcademicService();

  MateriaState _state = MateriaState.initial;
  String? _errorMessage;
  List<Materia> _materias = [];
  Materia? _selectedMateria;
  PaginationInfo? _paginationInfo;
  bool _isLoadingMore = false;
  bool _hasMoreData = true;
  MateriaState get state => _state;
  String? get errorMessage => _errorMessage;
  List<Materia> get materias => _materias;
  Materia? get selectedMateria => _selectedMateria;
  PaginationInfo? get paginationInfo => _paginationInfo;

  bool get isLoading => _state == MateriaState.loading;
  bool get hasError => _state == MateriaState.error;
  bool get isLoaded => _state == MateriaState.loaded;
  bool get isLoadingMore => _isLoadingMore;
  bool get hasMoreData => _hasMoreData;
  int get loadedMateriasCount => _materias.length;
  int get totalMateriasFromPagination => _paginationInfo?.total ?? 0;

  void _setState(MateriaState newState, [String? error]) {
    _state = newState;
    _errorMessage = error;
    notifyListeners();
  }
  Future<void> loadMaterias(String accessToken, {int? page, int? limit, String? search}) async {
    if (_state == MateriaState.loading) return;

    _setState(MateriaState.loading);
    resetPagination()

    try {
      debugPrint('MateriaProvider: Iniciando carga de materias...');
      final response = await _academicService.getMaterias(
        accessToken,
        page: page ?? 1,
        limit: limit,
        search: search,
      );
      if (response != null) {
        debugPrint('MateriaProvider: Recibidas ${response.materias.length} materias');
        _materias = response.materias;
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
        _setState(MateriaState.loaded);
        debugPrint('MateriaProvider: Estado cambiado a loaded');
      } else {
        _setState(MateriaState.error, 'Error al cargar materias');
      }
    } catch (e) {
      debugPrint('MateriaProvider: Error loading materias: $e');
      _setState(MateriaState.error, e.toString());
    }
  }
  Future<void> loadMateriaById(String accessToken, String materiaId) async {
    _setState(MateriaState.loading);

    try {
      final materia = await _academicService.getMateriaById(accessToken, materiaId);
      if (materia != null) {
        _selectedMateria = materia;
        _setState(MateriaState.loaded);
      } else {
        _setState(MateriaState.error, 'Materia no encontrada');
      }
    } catch (e) {
      debugPrint('Error loading materia: $e');
      _setState(MateriaState.error, e.toString());
    }
  }
  Future<bool> createMateria(String accessToken, academic_service.CreateMateriaRequest materiaData) async {
    _setState(MateriaState.loading);

    try {
      final newMateria = await _academicService.createMateria(accessToken, materiaData);
      if (newMateria != null) {
        _materias.insert(0, newMateria);
        _setState(MateriaState.loaded);
        return true;
      } else {
        _setState(MateriaState.error, 'Error al crear materia');
        return false;
      }
    } catch (e) {
      debugPrint('Error creating materia: $e');
      _setState(MateriaState.error, e.toString());
      return false;
    }
  }
  Future<bool> updateMateria(String accessToken, String materiaId, academic_service.UpdateMateriaRequest materiaData) async {
    _setState(MateriaState.loading);

    try {
      final updatedMateria = await _academicService.updateMateria(accessToken, materiaId, materiaData);
      if (updatedMateria != null) {
        final index = _materias.indexWhere((materia) => materia.id == materiaId);
        if (index != -1) {
          _materias[index] = updatedMateria;
        }
        if (_selectedMateria?.id == materiaId) {
          _selectedMateria = updatedMateria;
        }

        _setState(MateriaState.loaded);
        return true;
      } else {
        _setState(MateriaState.error, 'Error al actualizar materia');
        return false;
      }
    } catch (e) {
      debugPrint('Error updating materia: $e');
      _setState(MateriaState.error, e.toString());
      return false;
    }
  }
  Future<bool> deleteMateria(String accessToken, String materiaId) async {
    try {
      final success = await _academicService.deleteMateria(accessToken, materiaId);

      if (!success) {
        _errorMessage = 'Error al eliminar la materia desde el servicio.';
      }
      return success;
    } catch (e) {
      debugPrint('Error deleting materia: $e');
      _errorMessage = e.toString();
      return false;
    }
  }
  void selectMateria(Materia materia) {
    _selectedMateria = materia;
    notifyListeners();
  }
  void clearSelectedMateria() {
    _selectedMateria = null;
    notifyListeners();
  }
  void clearData() {
    _materias = [];
    _selectedMateria = null;
    _paginationInfo = null;
    _setState(MateriaState.initial);
  }
  Future<void> refreshData(String accessToken) async {
    await loadMaterias(accessToken);
  }
  List<Materia> searchMaterias(String query) {
    if (query.isEmpty) return _materias;

    final lowercaseQuery = query.toLowerCase();
    return _materias.where((materia) {
      return materia.nombre.toLowerCase().contains(lowercaseQuery) ||
             (materia.codigo?.toLowerCase().contains(lowercaseQuery) ?? false);
    }).toList();
  }
  Future<void> loadNextPage(String accessToken) async {
    if (_paginationInfo == null || !_paginationInfo!.hasNext || _state == MateriaState.loading) return;

    final nextPage = _paginationInfo!.page + 1;
    await loadMaterias(accessToken, page: nextPage, limit: _paginationInfo!.limit);
  }
  Future<void> loadPreviousPage(String accessToken) async {
    if (_paginationInfo == null || !_paginationInfo!.hasPrev || _state == MateriaState.loading) return;

    final prevPage = _paginationInfo!.page - 1;
    await loadMaterias(accessToken, page: prevPage, limit: _paginationInfo!.limit);
  }
  Future<void> loadPage(String accessToken, int page) async {
    if (_state == MateriaState.loading) return;

    await loadMaterias(accessToken, page: page, limit: _paginationInfo?.limit ?? 10);
  }
  Map<String, int> getMateriasStatistics() {
    return {
      'total': _paginationInfo?.total ?? 0,
      'con_codigo': _materias.where((m) => m.codigo != null).length,
      'sin_codigo': _materias.where((m) => m.codigo == null).length,
    };
  }
  Future<void> loadMoreMaterias(String accessToken, {String? search}) async {
    if (_isLoadingMore || !_hasMoreData || _paginationInfo == null) return;

    _isLoadingMore = true;
    notifyListeners();

    try {
      final nextPage = _paginationInfo!.page + 1;

      final response = await _academicService.getMaterias(
        accessToken,
        page: nextPage,
        limit: _paginationInfo!.limit,
        search: search,
      );

      if (response != null) {
        _materias.addAll(response.materias)
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
        debugPrint('MateriaProvider: Cargadas ${response.materias.length} materias mÃ¡s. Total ahora: ${_materias.length}');
      } else {
        _hasMoreData = false;
      }
    } catch (e) {
      debugPrint('MateriaProvider: Error loading more materias: $e');
    } finally {
      _isLoadingMore = false;
      notifyListeners();
    }
  }
  Future<List<Materia>?> searchMateriasRemote(String accessToken, {String? search, int limit = 10}) async {
    try {
      final response = await _academicService.getMaterias(
        accessToken,
        page: 1,
        limit: limit,
        search: search,
      );
      return response?.materias;
    } catch (e) {
      debugPrint('Error searchMateriasRemote: $e');
      return null;
    }
  }
  void resetPagination() {
    _hasMoreData = true;
    _isLoadingMore = false;
  }
}
/* Fin lib\providers\materia_provider.dart */

/* Inicio lib\providers\user_provider.dart */
import 'dart:async';
import 'package:flutter/foundation.dart';
import '../services/user_service.dart' as user_service;
import '../models/user.dart';

enum UserState {
  initial,
  loading,
  loaded,
  error,
}

class UserProvider with ChangeNotifier {
  final user_service.UserService _userService = user_service.UserService();

  UserState _state = UserState.initial;
  String? _errorMessage;
  List<User> _users = [];
  User? _selectedUser;
  String? _selectedInstitutionId;
  PaginationInfo? _paginationInfo;
  bool _isLoadingMore = false;
  bool _hasMoreData = true;
  UserState get state => _state;
  String? get errorMessage => _errorMessage;
  List<User> get users => _users;
  User? get selectedUser => _selectedUser;
  String? get selectedInstitutionId => _selectedInstitutionId;
  PaginationInfo? get paginationInfo => _paginationInfo;

  bool get isLoading => _state == UserState.loading;
  bool get hasError => _state == UserState.error;
  bool get isLoaded => _state == UserState.loaded;
  bool get isLoadingMore => _isLoadingMore;
  bool get hasMoreData => _hasMoreData;
  List<User> get activeUsers => _users.where((user) => user.activo).toList();
  List<User> get inactiveUsers => _users.where((user) => !user.activo).toList();

  List<User> get professors => _users.where((user) => user.esProfesor).toList();
  List<User> get students => _users.where((user) => user.esEstudiante).toList();
  List<User> get adminInstitutions => _users.where((user) => user.esAdminInstitucion).toList();
  int get loadedUsersCount => _users.length;
  int get activeUsersCount => activeUsers.length;
  int get inactiveUsersCount => inactiveUsers.length;

  int get professorsCount => professors.length;
  int get studentsCount => students.length;
  int get adminInstitutionsCount => adminInstitutions.length;
  int get totalUsersFromPagination => _paginationInfo?.total ?? 0;

  void _setState(UserState newState, [String? error]) {
    _state = newState;
    _errorMessage = error;
    notifyListeners();
  }
  Future<void> loadUsers(String accessToken, {int? page, int? limit, bool? activo, String? search, List<String>? roles}) async {
    if (_state == UserState.loading) return;

    _setState(UserState.loading);
    resetPagination()

    try {
      debugPrint('UserProvider: Iniciando carga de usuarios...');
      final response = await _userService.getAllUsers(
        accessToken,
        page: page ?? 1,
        limit: limit,
        activo: activo,
        search: search,
        roles: roles,
      );
      if (response != null) {
        debugPrint('UserProvider: Recibidos ${response.users.length} usuarios');
        _users = response.users;
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
        _setState(UserState.loaded);
        debugPrint('UserProvider: Estado cambiado a loaded');
      } else {
        _setState(UserState.error, 'Error al cargar usuarios');
      }
    } catch (e) {
      debugPrint('UserProvider: Error loading users: $e');
      _setState(UserState.error, e.toString());
    }
  }
  Future<void> loadUsersByInstitution(String accessToken, String institutionId, {int? page, int limit = 5, String? role, bool? activo, String? search}) async {
    if (_state == UserState.loading) return;

    _setState(UserState.loading);
    _selectedInstitutionId = institutionId;
    resetPagination()

    try {
      debugPrint('UserProvider: Iniciando carga de usuarios por instituciÃ³n $institutionId...');
      final response = await _userService.getUsersByInstitution(accessToken, institutionId, page: page ?? 1, limit: limit, role: role, activo: activo, search: search);
      if (response != null) {
        debugPrint('UserProvider: Recibidos ${response.users.length} usuarios de instituciÃ³n $institutionId');
        _users = response.users;
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
        _setState(UserState.loaded);
      } else {
        _setState(UserState.error, 'Error al cargar usuarios de la instituciÃ³n');
      }
    } catch (e) {
      debugPrint('UserProvider: Error loading users by institution: $e');
      _setState(UserState.error, e.toString());
    }
  }
  Future<void> loadAdminsByInstitution(String accessToken, String institutionId) async {
    if (_state == UserState.loading) return;

    _setState(UserState.loading);
    _selectedInstitutionId = institutionId;

    try {
      debugPrint('UserProvider: Cargando admins de la instituciÃ³n $institutionId...');
      final admins = await _userService.getAdminsByInstitution(accessToken, institutionId);
      if (admins != null) {
        _users = admins;
        _hasMoreData = false;
        _setState(UserState.loaded);
      } else {
        _setState(UserState.error, 'Error al cargar administradores de la instituciÃ³n');
      }
    } catch (e) {
      debugPrint('UserProvider: Error loading admins by institution: $e');
      _setState(UserState.error, e.toString());
    }
  }
  Future<bool> assignAdminToInstitution(String accessToken, String institutionId, String userId) async {
    try {
      final updated = await _userService.assignAdminToInstitution(accessToken, institutionId, userId);
      if (updated != null) {
        await loadAdminsByInstitution(accessToken, institutionId);
        return true;
      }
      return false;
    } catch (e) {
      debugPrint('Error assignAdminToInstitution: $e');
      return false;
    }
  }
  Future<bool> removeAdminFromInstitution(String accessToken, String institutionId, String userId) async {
    try {
      final result = await _userService.removeAdminFromInstitution(accessToken, institutionId, userId);
      if (result != null) {
        await loadAdminsByInstitution(accessToken, institutionId);
        return true;
      }
      return false;
    } catch (e) {
      debugPrint('Error removeAdminFromInstitution: $e');
      return false;
    }
  }
  Future<void> loadUsersByRole(String accessToken, String role, {int? page, int? limit}) async {
    if (_state == UserState.loading) return;

    _setState(UserState.loading);
    resetPagination()

    try {
      debugPrint('UserProvider: Iniciando carga de usuarios por rol $role...');
      final response = await _userService.getUsersByRole(accessToken, role, page: page ?? 1, limit: limit);
      if (response != null) {
        debugPrint('UserProvider: Recibidos ${response.users.length} usuarios con rol $role');
        _users = response.users;
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
        _setState(UserState.loaded);
      } else {
        _setState(UserState.error, 'Error al cargar usuarios por rol');
      }
    } catch (e) {
      debugPrint('UserProvider: Error loading users by role: $e');
      _setState(UserState.error, e.toString());
    }
  }
  Future<void> loadUserById(String accessToken, String userId) async {
    _setState(UserState.loading);

    try {
      final user = await _userService.getUserById(accessToken, userId);
      if (user != null) {
        _selectedUser = user;
        _setState(UserState.loaded);
      } else {
        _setState(UserState.error, 'Usuario no encontrado');
      }
    } catch (e) {
      debugPrint('Error loading user: $e');
      _setState(UserState.error, e.toString());
    }
  }
  Future<bool> createUser(String accessToken, CreateUserRequest userData) async {
    _setState(UserState.loading);

    try {
      final newUser = await _userService.createUser(accessToken, userData);
      if (newUser != null) {
        _users.insert(0, newUser);
        _setState(UserState.loaded);
        return true;
      } else {
        _setState(UserState.error, 'Error al crear usuario');
        return false;
      }
    } catch (e) {
      debugPrint('Error creating user: $e');
      _setState(UserState.error, e.toString());
      return false;
    }
  }
  Future<bool> updateUser(String accessToken, String userId, UpdateUserRequest userData) async {
    _setState(UserState.loading);

    try {
      final updatedUser = await _userService.updateUser(accessToken, userId, userData);
      if (updatedUser != null) {
        final index = _users.indexWhere((user) => user.id == userId);
        if (index != -1) {
          _users[index] = updatedUser;
        }
        if (_selectedUser?.id == userId) {
          _selectedUser = updatedUser;
        }

        _setState(UserState.loaded);
        return true;
      } else {
        _setState(UserState.error, 'Error al actualizar usuario');
        return false;
      }
    } catch (e) {
      debugPrint('Error updating user: $e');
      _setState(UserState.error, e.toString());
      return false;
    }
  }
  Future<bool> deleteUser(String accessToken, String userId) async {
    try {
      final success = await _userService.deleteUser(accessToken, userId);

      if (!success) {
        _errorMessage = 'Error al eliminar el usuario desde el servicio.';
      }
      return success;
    } catch (e) {
      debugPrint('Error deleting user: $e');
      _errorMessage = e.toString();
      return false;
    }
  }
  Future<bool> changeUserPassword(String accessToken, String userId, String newPassword) async {
    try {
      final result = await _userService.changePassword(accessToken, userId, newPassword);
      return result == true;
    } catch (e) {
      debugPrint('Error changeUserPassword: $e');
      _errorMessage = e.toString();
      return false;
    }
  }
  void selectUser(User user) {
    _selectedUser = user;
    notifyListeners();
  }
  void clearSelectedUser() {
    _selectedUser = null;
    notifyListeners();
  }
  void clearData() {
    _users = [];
    _selectedUser = null;
    _selectedInstitutionId = null;
    _paginationInfo = null;
    _setState(UserState.initial);
  }
  Future<void> refreshData(String accessToken) async {
    if (_selectedInstitutionId != null) {
      await loadUsersByInstitution(accessToken, _selectedInstitutionId!);
    } else {
      await loadUsers(accessToken);
    }
  }
  List<User> searchUsers(String query) {
    if (query.isEmpty) return _users;

    final lowercaseQuery = query.toLowerCase();
    return _users.where((user) {
      return user.nombreCompleto.toLowerCase().contains(lowercaseQuery) ||
             user.email.toLowerCase().contains(lowercaseQuery) ||
             (user.telefono?.contains(lowercaseQuery) ?? false);
    }).toList();
  }
  List<User> filterUsersByRole(String role) {
    if (role.isEmpty) return _users;
    return _users.where((user) => user.rol == role).toList();
  }
  List<User> filterUsersByStatus({bool? active}) {
    if (active == null) return _users;
    return _users.where((user) => user.activo == active).toList();
  }
  Future<void> loadNextPage(String accessToken) async {
    if (_paginationInfo == null || !_paginationInfo!.hasNext || _state == UserState.loading) return;

    final nextPage = _paginationInfo!.page + 1;
    if (_selectedInstitutionId != null) {
      await loadUsersByInstitution(accessToken, _selectedInstitutionId!, page: nextPage, limit: _paginationInfo!.limit);
    } else {
      await loadUsers(accessToken, page: nextPage, limit: _paginationInfo!.limit);
    }
  }
  Future<void> loadPreviousPage(String accessToken) async {
    if (_paginationInfo == null || !_paginationInfo!.hasPrev || _state == UserState.loading) return;

    final prevPage = _paginationInfo!.page - 1;
    if (_selectedInstitutionId != null) {
      await loadUsersByInstitution(accessToken, _selectedInstitutionId!, page: prevPage, limit: _paginationInfo!.limit);
    } else {
      await loadUsers(accessToken, page: prevPage, limit: _paginationInfo!.limit);
    }
  }
  Future<void> loadPage(String accessToken, int page) async {
    if (_state == UserState.loading) return;

    if (_selectedInstitutionId != null) {
      await loadUsersByInstitution(accessToken, _selectedInstitutionId!, page: page, limit: _paginationInfo?.limit ?? 5);
    } else {
      await loadUsers(accessToken, page: page, limit: _paginationInfo?.limit ?? 5);
    }
  }
  Map<String, int> getUserStatistics() {
    return {
      'total': _paginationInfo?.total ?? 0,
      'activos': activeUsersCount,
      'inactivos': inactiveUsersCount,
      'profesores': professorsCount,
      'estudiantes': studentsCount,
      'admins_institucion': adminInstitutionsCount,
    };
  }
  Future<void> loadMoreUsers(String accessToken, {bool? activo, String? search, List<String>? roles}) async {
    if (_isLoadingMore || !_hasMoreData || _paginationInfo == null) return;

    _isLoadingMore = true;
    notifyListeners();

    try {
      final nextPage = _paginationInfo!.page + 1;

      user_service.PaginatedUserResponse? response;
      if (_selectedInstitutionId != null) {
        response = await _userService.getUsersByInstitution(
          accessToken,
          _selectedInstitutionId!,
          page: nextPage,
          limit: _paginationInfo!.limit,
        );
      } else {
        response = await _userService.getAllUsers(
          accessToken,
          page: nextPage,
          limit: _paginationInfo!.limit,
          activo: activo,
          search: search,
          roles: roles,
        );
      }

      if (response != null) {
        _users.addAll(response.users)
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
        debugPrint('UserProvider: Cargados ${response.users.length} usuarios mÃ¡s. Total ahora: ${_users.length}');
      } else {
        _hasMoreData = false;
      }
    } catch (e) {
      debugPrint('UserProvider: Error loading more users: $e');
    } finally {
      _isLoadingMore = false;
      notifyListeners();
    }
  }
  Future<List<User>?> searchUsersRemote(String accessToken, {String? search, int limit = 10}) async {
    try {
      final response = await _userService.getAllUsers(
        accessToken,
        page: 1,
        limit: limit,
        search: search,
      );
      return response?.users;
    } catch (e) {
      debugPrint('Error searchUsersRemote: $e');
      return null;
    }
  }
  void resetPagination() {
    _hasMoreData = true;
    _isLoadingMore = false;
  }
}
/* Fin lib\providers\user_provider.dart */

/* Inicio lib\screens\academic\gestion_academica_screen.dart */
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import '../../theme/app_colors.dart';
import '../../theme/app_text_styles.dart';
import '../../theme/app_spacing.dart';
import '../../widgets/components/index.dart';

class GestionAcademicaScreen extends StatelessWidget {
  const GestionAcademicaScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final textStyles = AppTextStyles.instance;
    final spacing = AppSpacing.instance;

    return Scaffold(
      backgroundColor: colors.background,
      appBar: AppBar(
        backgroundColor: colors.primary,
        foregroundColor: colors.white,
        elevation: 0,
        title: Text(
          'GestiÃ³n AcadÃ©mica',
          style: textStyles.headlineMedium.copyWith(color: colors.white),
        ),
      ),
      body: SingleChildScrollView(
        padding: EdgeInsets.all(spacing.screenPadding),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Administrar Estructura AcadÃ©mica',
              style: textStyles.displayMedium,
            ),
            SizedBox(height: spacing.sm),
            Text(
              'Gestiona grupos, materias y horarios de tu instituciÃ³n',
              style: textStyles.bodyLarge.copyWith(color: colors.textSecondary),
            ),
            SizedBox(height: spacing.xl),
            Container(
              decoration: BoxDecoration(
                color: colors.surface,
                borderRadius: BorderRadius.circular(spacing.borderRadius),
                border: Border.all(color: colors.borderLight),
              ),
              child: Column(
                children: [
                  _buildMenuOption(
                    context,
                    icon: Icons.group,
                    title: 'Gestionar Grupos',
                    subtitle: 'Crear y administrar grupos acadÃ©micos',
                    color: colors.info,
                    onTap: () => context.push('/academic/grupos'),
                  ),
                  Divider(color: colors.borderLight),
                  _buildMenuOption(
                    context,
                    icon: Icons.book,
                    title: 'Gestionar Materias',
                    subtitle: 'Administrar catÃ¡logo de materias',
                    color: colors.warning,
                    onTap: () => context.push('/academic/materias'),
                  ),
                  Divider(color: colors.borderLight),
                  _buildMenuOption(
                    context,
                    icon: Icons.calendar_view_week,
                    title: 'Gestionar Horarios',
                    subtitle: 'Asignar clases y gestionar horarios',
                    color: colors.success,
                    onTap: () => context.push('/academic/horarios'),
                  ),
                ],
              ),
            ),

            SizedBox(height: spacing.xxl),
            ClarityCard(
              leading: Icon(Icons.info_outline, color: colors.info),
              title: Text(
                'InformaciÃ³n Importante',
                style: textStyles.headlineSmall,
              ),
              subtitle: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'â€¢ Los grupos deben estar asociados a un periodo acadÃ©mico activo',
                    style: textStyles.bodyMedium,
                  ),
                  SizedBox(height: spacing.xs),
                  Text(
                    'â€¢ Las materias pueden ser reutilizadas en diferentes horarios',
                    style: textStyles.bodyMedium,
                  ),
                  SizedBox(height: spacing.xs),
                  Text(
                    'â€¢ Los horarios incluyen validaciÃ³n automÃ¡tica de conflictos',
                    style: textStyles.bodyMedium,
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildMenuOption(
    BuildContext context, {
    required IconData icon,
    required String title,
    required String subtitle,
    required Color color,
    required VoidCallback onTap,
  }) {
    final colors = AppColors.instance;
    final textStyles = AppTextStyles.instance;
    final spacing = AppSpacing.instance;

    return ListTile(
      leading: CircleAvatar(
        backgroundColor: color.withValues(alpha: 0.1),
        child: Icon(icon, color: color),
      ),
      title: Text(title, style: textStyles.headlineSmall),
      subtitle: Text(
        subtitle,
        style: textStyles.bodyMedium.copyWith(color: colors.textMuted),
      ),
      trailing: Icon(Icons.arrow_forward_ios, color: colors.textDisabled),
      onTap: onTap,
      contentPadding: EdgeInsets.symmetric(
        horizontal: spacing.lg,
        vertical: spacing.md,
      ),
    );
  }
}
/* Fin lib\screens\academic\gestion_academica_screen.dart */

/* Inicio lib\screens\academic\grupos_screen.dart */
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../models/grupo.dart';
import '../../providers/auth_provider.dart';
import '../../providers/grupo_provider.dart';
import '../../services/academic_service.dart' as academic_service;
import '../../theme/theme_extensions.dart';
import '../../widgets/components/index.dart';

class GruposScreen extends StatefulWidget {
  const GruposScreen({super.key});

  @override
  State<GruposScreen> createState() => _GruposScreenState();
}

class _GruposScreenState extends State<GruposScreen> {
  final TextEditingController _searchController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  Timer? _searchDebounceTimer;
  String _searchQuery = '';
  final String _selectedPeriodoId = '';
  bool _isSearching = false;

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);

    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadGrupos();
    });
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _searchController.dispose();
    _searchDebounceTimer?.cancel();
    super.dispose();
  }

  void _onScroll() {
    if (_isSearching) return;

    final grupoProvider = Provider.of<GrupoProvider>(context, listen: false);

    if (_scrollController.position.pixels >= _scrollController.position.maxScrollExtent * 0.9) {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      _loadMoreGrupos(grupoProvider, authProvider.accessToken);
    }
  }

  Future<void> _loadGrupos() async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final grupoProvider = Provider.of<GrupoProvider>(context, listen: false);

    if (authProvider.accessToken == null) {
      debugPrint('Error: No hay token de acceso para cargar grupos.');
      return;
    }

    await grupoProvider.loadGrupos(
      authProvider.accessToken!,
      page: 1,
      limit: 10,
      periodoId: _selectedPeriodoId.isEmpty ? null : _selectedPeriodoId,
      search: _searchQuery.isEmpty ? null : _searchQuery,
    );
  }

  Future<void> _loadMoreGrupos(GrupoProvider provider, String? accessToken) async {
    if (accessToken == null || provider.isLoadingMore || !provider.hasMoreData) return;

    await provider.loadMoreGrupos(
      accessToken,
      periodoId: _selectedPeriodoId.isEmpty ? null : _selectedPeriodoId,
      search: _searchQuery.isEmpty ? null : _searchQuery,
    );
  }

  void _onSearchChanged(String query) {
    _searchDebounceTimer?.cancel();

    setState(() {
      _isSearching = query.isNotEmpty;
    });

    _searchDebounceTimer = Timer(const Duration(milliseconds: 500), () {
      setState(() {
        _searchQuery = query.trim();
      });
      _loadGrupos();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Consumer2<AuthProvider, GrupoProvider>(
      builder: (context, authProvider, grupoProvider, child) {
        return ClarityManagementPage(
          title: 'GestiÃ³n de Grupos',
          isLoading: grupoProvider.isLoading,
          hasError: grupoProvider.hasError,
          errorMessage: grupoProvider.errorMessage,
          itemCount: grupoProvider.grupos.length,
          itemBuilder: (context, index) {
            final grupo = grupoProvider.grupos[index];
            return _buildGrupoCard(grupo, grupoProvider, context);
          },
          filterWidgets: _buildFilterWidgets(context),
          statisticWidgets: _buildStatisticWidgets(context, grupoProvider),
          onRefresh: _loadGrupos,
          scrollController: _scrollController,
          hasMoreData: grupoProvider.hasMoreData,
          isLoadingMore: grupoProvider.isLoadingMore,
          emptyStateWidget: ClarityEmptyState(
            icon: _isSearching ? Icons.search_off : Icons.group,
            title: _isSearching
              ? 'No se encontraron resultados'
              : 'AÃºn no has creado ningÃºn grupo',
            subtitle: _isSearching
              ? 'Intenta con otros tÃ©rminos de bÃºsqueda'
              : 'Comienza creando tu primer grupo acadÃ©mico',
          ),
          floatingActionButton: FloatingActionButton(
            onPressed: () => _showCreateGrupoDialog(context),
            tooltip: 'Crear Grupo',
            child: const Icon(Icons.add),
          ),
        );
      },
    );
  }

  List<Widget> _buildFilterWidgets(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return [
      TextField(
        controller: _searchController,
        style: textStyles.bodyLarge,
        decoration: InputDecoration(
          hintText: 'Buscar por nombre, grado o secciÃ³n...',
          hintStyle: textStyles.bodyMedium.withColor(colors.textMuted),
          prefixIcon: Icon(Icons.search, color: colors.textSecondary),
          suffixIcon: _isSearching
              ? IconButton(
                  icon: Icon(Icons.clear, color: colors.textSecondary),
                  onPressed: () {
                    _searchController.clear();
                    _onSearchChanged('');
                  },
                )
              : null,
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.border),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.borderLight),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.primary, width: 2),
          ),
          filled: true,
          fillColor: colors.surface,
          contentPadding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
        ),
        onChanged: _onSearchChanged,
      ),
      SizedBox(height: spacing.sm),
      Text(
        'PrÃ³ximamente: Filtro por periodo acadÃ©mico',
        style: textStyles.bodySmall.copyWith(color: colors.textMuted),
      ),
    ];
  }

  List<Widget> _buildStatisticWidgets(BuildContext context, GrupoProvider provider) {
    final stats = provider.getGruposStatistics();
    final colors = context.colors;

    return [
      ClarityCompactStat(
        title: 'Total',
        value: stats['total'].toString(),
        icon: Icons.group,
        color: colors.primary,
      ),
      ClarityCompactStat(
        title: 'Activos',
        value: stats['activos'].toString(),
        icon: Icons.check_circle,
        color: colors.success,
      ),
      ClarityCompactStat(
        title: 'Estudiantes',
        value: '0', // TODO: Calcular total de estudiantes
        icon: Icons.people,
        color: colors.info,
      ),
    ];
  }

  Widget _buildGrupoCard(Grupo grupo, GrupoProvider provider, BuildContext context) {
    final colors = context.colors;
    final textStyles = context.textStyles;

    final List<ClarityContextMenuAction> contextActions = [
      ClarityContextMenuAction(
        label: 'Editar',
        icon: Icons.edit,
        color: colors.primary,
        onPressed: () => _showEditGrupoDialog(context, grupo),
      ),
      ClarityContextMenuAction(
        label: 'Eliminar',
        icon: Icons.delete,
        color: colors.error,
        onPressed: () => _showDeleteConfirmationDialog(grupo, provider),
      ),
    ];

    return ClarityListItem(
      leading: CircleAvatar(
        backgroundColor: colors.info,
        child: Text(
          grupo.grado,
          style: textStyles.labelMedium.copyWith(color: colors.white),
        ),
      ),
      title: grupo.nombre,
      subtitle: 'Grado: ${grupo.grado}${grupo.seccion != null ? ' - SecciÃ³n: ${grupo.seccion}' : ''}',
      badgeText: grupo.periodoAcademico.activo ? 'Activo' : 'Inactivo',
      badgeColor: grupo.periodoAcademico.activo ? colors.success : colors.error,
      contextActions: contextActions,
      onTap: () => _navigateToGrupoDetail(grupo),
    );
  }

  void _showCreateGrupoDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => const CreateGrupoDialog(),
    ).then((result) {
      if (result == true) {
        _loadGrupos()
      }
    });
  }

  void _showEditGrupoDialog(BuildContext context, Grupo grupo) {
    showDialog(
      context: context,
      builder: (context) => EditGrupoDialog(grupo: grupo),
    ).then((result) {
      if (result == true) {
        _loadGrupos()
      }
    });
  }

  void _showDeleteConfirmationDialog(Grupo grupo, GrupoProvider provider) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Eliminar Grupo', style: Theme.of(context).textTheme.headlineSmall),
        content: Text(
          'Â¿EstÃ¡s seguro de que quieres eliminar "${grupo.nombre}"?\n\n'
          'Esta acciÃ³n no se puede deshacer.',
          style: Theme.of(context).textTheme.bodyMedium,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: Text('Cancelar', style: Theme.of(context).textTheme.labelLarge),
          ),
          TextButton(
            onPressed: () async {
              Navigator.of(context).pop();
              await _deleteGrupo(grupo, provider);
            },
            style: TextButton.styleFrom(foregroundColor: Theme.of(context).colorScheme.error),
            child: Text('Eliminar', style: Theme.of(context).textTheme.labelLarge?.copyWith(color: Theme.of(context).colorScheme.error)),
          ),
        ],
      ),
    );
  }

  Future<void> _deleteGrupo(Grupo grupo, GrupoProvider provider) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    final success = await provider.deleteGrupo(
      authProvider.accessToken!,
      grupo.id,
    );

    if (!mounted) return;

    if (success) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            'Grupo eliminado correctamente',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onPrimary),
          ),
          backgroundColor: Theme.of(context).colorScheme.primary,
        ),
      );
      await _loadGrupos();
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            provider.errorMessage ?? 'Error al eliminar grupo',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onError),
          ),
          backgroundColor: Theme.of(context).colorScheme.error,
        ),
      );
    }
  }

  void _navigateToGrupoDetail(Grupo grupo) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('Detalle de grupo: ${grupo.nombre}')),
    );
  }
}
class CreateGrupoDialog extends StatefulWidget {
  const CreateGrupoDialog({super.key});

  @override
  State<CreateGrupoDialog> createState() => _CreateGrupoDialogState();
}

class _CreateGrupoDialogState extends State<CreateGrupoDialog> {
  final _formKey = GlobalKey<FormState>();
  final _nombreController = TextEditingController();
  final _gradoController = TextEditingController();
  final _seccionController = TextEditingController();

  bool _isLoading = false;

  @override
  void dispose() {
    _nombreController.dispose();
    _gradoController.dispose();
    _seccionController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return AlertDialog(
      title: Text('Crear Grupo', style: textStyles.headlineMedium),
      content: Form(
        key: _formKey,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextFormField(
              controller: _nombreController,
              decoration: InputDecoration(
                labelText: 'Nombre del Grupo',
                hintText: 'Ej: Grupo A, 1ro BÃ¡sico A',
              ),
              validator: (value) {
                if (value == null || value.isEmpty) {
                  return 'El nombre es requerido';
                }
                return null;
              },
            ),
            SizedBox(height: spacing.md),
            TextFormField(
              controller: _gradoController,
              decoration: InputDecoration(
                labelText: 'Grado',
                hintText: 'Ej: 1ro, 2do, 3ro',
              ),
              validator: (value) {
                if (value == null || value.isEmpty) {
                  return 'El grado es requerido';
                }
                return null;
              },
            ),
            SizedBox(height: spacing.md),
            TextFormField(
              controller: _seccionController,
              decoration: InputDecoration(
                labelText: 'SecciÃ³n (opcional)',
                hintText: 'Ej: A, B, C',
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isLoading ? null : () => Navigator.of(context).pop(),
          child: Text('Cancelar'),
        ),
        ElevatedButton(
          onPressed: _isLoading ? null : _createGrupo,
          child: _isLoading
              ? SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(strokeWidth: 2),
                )
              : Text('Crear'),
        ),
      ],
    );
  }

  Future<void> _createGrupo() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final grupoProvider = Provider.of<GrupoProvider>(context, listen: false);
      const periodoId = '550e8400-e29b-41d4-a716-446655440000'

      final success = await grupoProvider.createGrupo(
        authProvider.accessToken!,
        academic_service.CreateGrupoRequest(
          nombre: _nombreController.text.trim(),
          grado: _gradoController.text.trim(),
          seccion: _seccionController.text.trim().isEmpty ? null : _seccionController.text.trim(),
          periodoId: periodoId,
        ),
      );

      if (success && mounted) {
        Navigator.of(context).pop(true);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Grupo creado correctamente')),
        );
      } else if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(grupoProvider.errorMessage ?? 'Error al crear grupo'),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: $e'),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }
}
class EditGrupoDialog extends StatefulWidget {
  final Grupo grupo;

  const EditGrupoDialog({super.key, required this.grupo});

  @override
  State<EditGrupoDialog> createState() => _EditGrupoDialogState();
}

class _EditGrupoDialogState extends State<EditGrupoDialog> {
  final _formKey = GlobalKey<FormState>();
  late final TextEditingController _nombreController;
  late final TextEditingController _gradoController;
  late final TextEditingController _seccionController;

  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _nombreController = TextEditingController(text: widget.grupo.nombre);
    _gradoController = TextEditingController(text: widget.grupo.grado);
    _seccionController = TextEditingController(text: widget.grupo.seccion ?? '');
  }

  @override
  void dispose() {
    _nombreController.dispose();
    _gradoController.dispose();
    _seccionController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return AlertDialog(
      title: Text('Editar Grupo', style: textStyles.headlineMedium),
      content: Form(
        key: _formKey,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextFormField(
              controller: _nombreController,
              decoration: InputDecoration(
                labelText: 'Nombre del Grupo',
                hintText: 'Ej: Grupo A, 1ro BÃ¡sico A',
              ),
              validator: (value) {
                if (value == null || value.isEmpty) {
                  return 'El nombre es requerido';
                }
                return null;
              },
            ),
            SizedBox(height: spacing.md),
            TextFormField(
              controller: _gradoController,
              decoration: InputDecoration(
                labelText: 'Grado',
                hintText: 'Ej: 1ro, 2do, 3ro',
              ),
              validator: (value) {
                if (value == null || value.isEmpty) {
                  return 'El grado es requerido';
                }
                return null;
              },
            ),
            SizedBox(height: spacing.md),
            TextFormField(
              controller: _seccionController,
              decoration: InputDecoration(
                labelText: 'SecciÃ³n (opcional)',
                hintText: 'Ej: A, B, C',
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isLoading ? null : () => Navigator.of(context).pop(),
          child: Text('Cancelar'),
        ),
        ElevatedButton(
          onPressed: _isLoading ? null : _updateGrupo,
          child: _isLoading
              ? SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(strokeWidth: 2),
                )
              : Text('Actualizar'),
        ),
      ],
    );
  }

  Future<void> _updateGrupo() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final grupoProvider = Provider.of<GrupoProvider>(context, listen: false);

      final success = await grupoProvider.updateGrupo(
        authProvider.accessToken!,
        widget.grupo.id,
        academic_service.UpdateGrupoRequest(
          nombre: _nombreController.text.trim(),
          grado: _gradoController.text.trim(),
          seccion: _seccionController.text.trim().isEmpty ? null : _seccionController.text.trim(),
        ),
      );

      if (success && mounted) {
        Navigator.of(context).pop(true);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Grupo actualizado correctamente')),
        );
      } else if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(grupoProvider.errorMessage ?? 'Error al actualizar grupo'),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: $e'),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }
}
/* Fin lib\screens\academic\grupos_screen.dart */

/* Inicio lib\screens\academic\horarios_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../providers/auth_provider.dart';
import '../../providers/grupo_provider.dart';
import '../../providers/materia_provider.dart';
import '../../providers/horario_provider.dart';
import '../../providers/user_provider.dart';
import '../../services/academic_service.dart' as academic_service;
import '../../theme/theme_extensions.dart';
import '../../models/grupo.dart';
import '../../models/materia.dart';
import '../../models/user.dart';

class HorariosScreen extends StatefulWidget {
  const HorariosScreen({super.key});

  @override
  State<HorariosScreen> createState() => _HorariosScreenState();
}

class _HorariosScreenState extends State<HorariosScreen> {
  Grupo? _selectedGrupo;
  final List<String> _horas = [
    '07:00', '08:00', '09:00', '10:00', '11:00', '12:00',
    '13:00', '14:00', '15:00', '16:00', '17:00', '18:00'
  ];
  final List<String> _diasSemana = ['Lunes', 'Martes', 'MiÃ©rcoles', 'Jueves', 'Viernes'];
  final List<int> _diasSemanaValues = [1, 2, 3, 4, 5]

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadInitialData();
    });
  }

  Future<void> _loadInitialData() async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final grupoProvider = Provider.of<GrupoProvider>(context, listen: false);
    final materiaProvider = Provider.of<MateriaProvider>(context, listen: false);
    final userProvider = Provider.of<UserProvider>(context, listen: false);

    final token = authProvider.accessToken;
    final institutionId = authProvider.selectedInstitutionId;

    if (token != null && institutionId != null) {
      try {
        await grupoProvider.loadGrupos(token);
        await materiaProvider.loadMaterias(token);
        await userProvider.loadUsersByInstitution(token, institutionId);
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Error cargando datos: $e'),
              backgroundColor: context.colors.error,
            ),
          );
        }
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return Scaffold(
      backgroundColor: colors.background,
      appBar: AppBar(
        backgroundColor: colors.primary,
        foregroundColor: colors.white,
        elevation: 0,
        title: Text(
          'GestiÃ³n de Horarios',
          style: textStyles.headlineMedium.copyWith(color: colors.white),
        ),
      ),
      body: SingleChildScrollView(
        padding: EdgeInsets.all(spacing.screenPadding),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Seleccionar Grupo',
              style: textStyles.headlineSmall,
            ),
            SizedBox(height: spacing.md),
            Consumer<GrupoProvider>(
              builder: (context, grupoProvider, child) {
                if (grupoProvider.isLoading) {
                  return const CircularProgressIndicator();
                }

                return DropdownButtonFormField<Grupo>(
                  value: _selectedGrupo,
                  decoration: InputDecoration(
                    labelText: 'Grupo',
                    hintText: 'Selecciona un grupo',
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(spacing.borderRadius),
                    ),
                  ),
                  items: grupoProvider.grupos.map((grupo) {
                    return DropdownMenuItem<Grupo>(
                      value: grupo,
                      child: Text('${grupo.nombre} - ${grupo.grado}'),
                    );
                  }).toList(),
                  onChanged: (grupo) {
                    setState(() => _selectedGrupo = grupo);
                    if (grupo != null) {
                      _loadHorariosForGrupo(grupo.id);
                    }
                  },
                );
              },
            ),

            SizedBox(height: spacing.xl),
            if (_selectedGrupo != null) ...[
              Text(
                'Horario Semanal - ${_selectedGrupo!.nombre}',
                style: textStyles.headlineSmall,
              ),
              SizedBox(height: spacing.md),
              _buildWeeklyCalendar(),
            ] else ...[
              Center(
                child: Padding(
                  padding: EdgeInsets.all(spacing.xl),
                  child: Column(
                    children: [
                      Icon(
                        Icons.calendar_today_outlined,
                        size: 64,
                        color: colors.textSecondary,
                      ),
                      SizedBox(height: spacing.md),
                      Text(
                        'Selecciona un grupo para ver su horario',
                        style: textStyles.bodyLarge.copyWith(
                          color: colors.textSecondary,
                        ),
                        textAlign: TextAlign.center,
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildWeeklyCalendar() {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return Container(
      decoration: BoxDecoration(
        color: colors.surface,
        borderRadius: BorderRadius.circular(spacing.borderRadius),
        border: Border.all(color: colors.borderLight),
      ),
      child: Column(
        children: [
          Row(
            children: [
              SizedBox(width: 80),
              ..._diasSemana.map((dia) => Expanded(
                child: Container(
                  padding: EdgeInsets.symmetric(vertical: spacing.md),
                  decoration: BoxDecoration(
                    border: Border(
                      left: BorderSide(color: colors.borderLight),
                    ),
                  ),
                  child: Text(
                    dia,
                    style: textStyles.bodyMedium.copyWith(
                      fontWeight: FontWeight.w600,
                      color: colors.primary,
                    ),
                    textAlign: TextAlign.center,
                  ),
                ),
              )),
            ],
          ),
          Divider(height: 0),
          ..._horas.map((hora) => _buildHourRow(hora)),
        ],
      ),
    );
  }

  Widget _buildHourRow(String hora) {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return Row(
      children: [
        Container(
          width: 80,
          padding: EdgeInsets.symmetric(vertical: spacing.sm, horizontal: spacing.xs),
          decoration: BoxDecoration(
            border: Border(
              top: BorderSide(color: colors.borderLight),
            ),
          ),
          child: Text(
            hora,
            style: textStyles.bodySmall.copyWith(
              color: colors.textSecondary,
              fontWeight: FontWeight.w500,
            ),
            textAlign: TextAlign.center,
          ),
        ),
        ...List.generate(_diasSemana.length, (index) {
          final diaSemana = _diasSemanaValues[index];
          return Expanded(
            child: _buildScheduleCell(hora, diaSemana),
          );
        }),
      ],
    );
  }

  Widget _buildScheduleCell(String hora, int diaSemana) {
    final colors = context.colors;

    return InkWell(
      onTap: () => _showCreateClassDialog(hora, diaSemana),
      child: Container(
        height: 60,
        decoration: BoxDecoration(
          border: Border(
            left: BorderSide(color: colors.borderLight),
            top: BorderSide(color: colors.borderLight),
          ),
        ),
        child: Container(
          color: colors.background.withValues(alpha: 0.5),
          child: Center(
            child: Icon(
              Icons.add,
              color: colors.textDisabled,
              size: 20,
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _loadHorariosForGrupo(String grupoId) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final horarioProvider = Provider.of<HorarioProvider>(context, listen: false);

    final token = authProvider.accessToken;
    if (token != null) {
      try {
        await horarioProvider.loadHorariosByGrupo(token, grupoId);
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Error cargando horarios: $e'),
              backgroundColor: context.colors.error,
            ),
          );
        }
      }
    }
  }

  Future<void> _showCreateClassDialog(String hora, int diaSemana) async {
    if (_selectedGrupo == null) return;

    final result = await showDialog<bool>(
      context: context,
      builder: (context) => CreateClassDialog(
        grupo: _selectedGrupo!,
        horaInicio: hora,
        diaSemana: diaSemana,
      ),
    );

    if (result == true && _selectedGrupo != null) {
      _loadHorariosForGrupo(_selectedGrupo!.id);
    }
  }
}
class CreateClassDialog extends StatefulWidget {
  final Grupo grupo;
  final String horaInicio;
  final int diaSemana;

  const CreateClassDialog({
    super.key,
    required this.grupo,
    required this.horaInicio,
    required this.diaSemana,
  });

  @override
  State<CreateClassDialog> createState() => _CreateClassDialogState();
}

class _CreateClassDialogState extends State<CreateClassDialog> {
  final _formKey = GlobalKey<FormState>();
  Materia? _selectedMateria;
  User? _selectedProfesor;
  bool _isLoading = false;

  @override
  Widget build(BuildContext context) {
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return AlertDialog(
      title: Text('Crear Clase', style: textStyles.headlineMedium),
      content: Form(
        key: _formKey,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              padding: EdgeInsets.all(spacing.md),
              decoration: BoxDecoration(
                color: context.colors.surface,
                borderRadius: BorderRadius.circular(spacing.borderRadius),
                border: Border.all(color: context.colors.borderLight),
              ),
              child: Column(
                children: [
                  Text(
                    'Horario: ${widget.horaInicio} - ${_getHoraFin(widget.horaInicio)}',
                    style: textStyles.bodyMedium.copyWith(fontWeight: FontWeight.w600),
                  ),
                  Text(
                    'DÃ­a: ${_getDiaNombre(widget.diaSemana)}',
                    style: textStyles.bodyMedium,
                  ),
                  Text(
                    'Grupo: ${widget.grupo.nombre}',
                    style: textStyles.bodyMedium,
                  ),
                ],
              ),
            ),

            SizedBox(height: spacing.lg),
            Consumer<MateriaProvider>(
              builder: (context, materiaProvider, child) {
                return DropdownButtonFormField<Materia>(
                  value: _selectedMateria,
                  decoration: InputDecoration(
                    labelText: 'Materia',
                    hintText: 'Selecciona una materia',
                  ),
                  items: materiaProvider.materias.map((materia) {
                    return DropdownMenuItem<Materia>(
                      value: materia,
                      child: Text(materia.nombre),
                    );
                  }).toList(),
                  validator: (value) {
                    if (value == null) {
                      return 'La materia es requerida';
                    }
                    return null;
                  },
                  onChanged: (materia) {
                    setState(() => _selectedMateria = materia);
                  },
                );
              },
            ),

            SizedBox(height: spacing.md),
            Consumer<UserProvider>(
              builder: (context, userProvider, child) {
                return DropdownButtonFormField<User>(
                  value: _selectedProfesor,
                  decoration: InputDecoration(
                    labelText: 'Profesor (opcional)',
                    hintText: 'Selecciona un profesor',
                  ),
                  items: userProvider.professors.map((profesor) {
                    return DropdownMenuItem<User>(
                      value: profesor,
                      child: Text('${profesor.nombres} ${profesor.apellidos}'),
                    );
                  }).toList(),
                  onChanged: (profesor) {
                    setState(() => _selectedProfesor = profesor);
                  },
                );
              },
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isLoading ? null : () => Navigator.of(context).pop(false),
          child: Text('Cancelar'),
        ),
        ElevatedButton(
          onPressed: _isLoading ? null : _createClass,
          child: _isLoading
              ? SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(strokeWidth: 2),
                )
              : Text('Crear Clase'),
        ),
      ],
    );
  }

  Future<void> _createClass() async {
    if (!_formKey.currentState!.validate()) return;
    if (_selectedMateria == null) return;

    setState(() => _isLoading = true);

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final horarioProvider = Provider.of<HorarioProvider>(context, listen: false);

      final token = authProvider.accessToken;
      if (token == null) return;
      const periodoId = '550e8400-e29b-41d4-a716-446655440000'

      final success = await horarioProvider.createHorario(
        token,
        academic_service.CreateHorarioRequest(
          periodoId: periodoId,
          grupoId: widget.grupo.id,
          materiaId: _selectedMateria!.id,
          profesorId: _selectedProfesor?.id,
          diaSemana: widget.diaSemana,
          horaInicio: widget.horaInicio,
          horaFin: _getHoraFin(widget.horaInicio),
        ),
      );

      if (success && mounted) {
        Navigator.of(context).pop(true);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Clase creada correctamente')),
        );
      } else if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(horarioProvider.errorMessage ?? 'Error al crear clase'),
            backgroundColor: context.colors.error,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: $e'),
            backgroundColor: context.colors.error,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  String _getHoraFin(String horaInicio) {
    final parts = horaInicio.split(':');
    final hour = int.parse(parts[0]);
    final nextHour = hour + 1;
    return '${nextHour.toString().padLeft(2, '0')}:00';
  }

  String _getDiaNombre(int diaSemana) {
    const dias = {
      1: 'Lunes',
      2: 'Martes',
      3: 'MiÃ©rcoles',
      4: 'Jueves',
      5: 'Viernes',
      6: 'SÃ¡bado',
      7: 'Domingo',
    };
    return dias[diaSemana] ?? 'Desconocido';
  }
}
/* Fin lib\screens\academic\horarios_screen.dart */

/* Inicio lib\screens\academic\materias_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../../widgets/components/clarity_management_page.dart';
import '../../widgets/components/clarity_components.dart';
import '../../theme/theme_extensions.dart';
import '../../services/academic_service.dart' as academic_service;
import '../../providers/materia_provider.dart';
import '../../providers/auth_provider.dart';
import '../../models/materia.dart';

class MateriasScreen extends StatefulWidget {
  const MateriasScreen({super.key});

  @override
  State<MateriasScreen> createState() => _MateriasScreenState();
}

class _MateriasScreenState extends State<MateriasScreen> {
  final TextEditingController _searchController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  bool _isSearching = false;

  @override
  void initState() {
    super.initState();
    _searchController.addListener(_onSearchChanged);
    _scrollController.addListener(_onScroll);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadMaterias();
    });
  }

  @override
  void dispose() {
    _searchController.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  void _onSearchChanged() {
    final query = _searchController.text.trim();
    setState(() => _isSearching = query.isNotEmpty);

    if (query.isNotEmpty) {
      _loadMaterias(search: query);
    } else {
      _loadMaterias();
    }
  }

  void _onScroll() {
    if (_scrollController.position.pixels == _scrollController.position.maxScrollExtent) {
      _loadMoreMaterias();
    }
  }

  Future<void> _loadMaterias({String? search}) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final materiaProvider = Provider.of<MateriaProvider>(context, listen: false);

    if (authProvider.accessToken != null) {
      await materiaProvider.loadMaterias(authProvider.accessToken!, search: search);
    }
  }

  Future<void> _loadMoreMaterias() async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final materiaProvider = Provider.of<MateriaProvider>(context, listen: false);

    if (authProvider.accessToken != null) {
      final search = _isSearching ? _searchController.text.trim() : null;
      await materiaProvider.loadMoreMaterias(authProvider.accessToken!, search: search);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Consumer2<AuthProvider, MateriaProvider>(
      builder: (context, authProvider, materiaProvider, child) {
        return ClarityManagementPage(
          title: 'GestiÃ³n de Materias',
          isLoading: materiaProvider.isLoading,
          hasError: materiaProvider.hasError,
          errorMessage: materiaProvider.errorMessage,
          itemCount: materiaProvider.materias.length,
          itemBuilder: (context, index) {
            final materia = materiaProvider.materias[index];
            return _buildMateriaCard(materia, materiaProvider, context);
          },
          filterWidgets: _buildFilterWidgets(context),
          statisticWidgets: _buildStatisticWidgets(context, materiaProvider),
          onRefresh: _loadMaterias,
          scrollController: _scrollController,
          hasMoreData: materiaProvider.hasMoreData,
          isLoadingMore: materiaProvider.isLoadingMore,
          emptyStateWidget: ClarityEmptyState(
            icon: _isSearching ? Icons.search_off : Icons.subject,
            title: _isSearching
              ? 'No se encontraron resultados'
              : 'AÃºn no has creado ninguna materia',
            subtitle: _isSearching
              ? 'Intenta con otros tÃ©rminos de bÃºsqueda'
              : 'Comienza creando tu primera materia acadÃ©mica',
          ),
          floatingActionButton: FloatingActionButton(
            onPressed: () => _showCreateMateriaDialog(context),
            tooltip: 'Crear Materia',
            child: const Icon(Icons.add),
          ),
        );
      },
    );
  }

  List<Widget> _buildFilterWidgets(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return [
      TextField(
        controller: _searchController,
        style: textStyles.bodyLarge,
        decoration: InputDecoration(
          hintText: 'Buscar por nombre o cÃ³digo...',
          hintStyle: textStyles.bodyMedium.withColor(colors.textMuted),
          prefixIcon: Icon(Icons.search, color: colors.textSecondary),
          suffixIcon: _isSearching
              ? IconButton(
                  icon: Icon(Icons.clear, color: colors.textSecondary),
                  onPressed: () {
                    _searchController.clear();
                    _onSearchChanged();
                  },
                )
              : null,
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.border),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.borderLight),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.primary, width: 2),
          ),
          filled: true,
          fillColor: colors.surface,
          contentPadding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
        ),
        onChanged: (value) => _onSearchChanged(),
      ),
      SizedBox(height: spacing.sm),
      Text(
        'PrÃ³ximamente: MÃ¡s filtros disponibles',
        style: textStyles.bodySmall.copyWith(color: colors.textMuted),
      ),
    ];
  }

  List<Widget> _buildStatisticWidgets(BuildContext context, MateriaProvider provider) {
    final stats = provider.getMateriasStatistics();
    final colors = context.colors;

    return [
      ClarityCompactStat(
        title: 'Total',
        value: stats['total'].toString(),
        icon: Icons.subject,
        color: colors.primary,
      ),
      ClarityCompactStat(
        title: 'Con CÃ³digo',
        value: stats['con_codigo'].toString(),
        icon: Icons.tag,
        color: colors.success,
      ),
      ClarityCompactStat(
        title: 'Sin CÃ³digo',
        value: stats['sin_codigo'].toString(),
        icon: Icons.label_off,
        color: colors.warning,
      ),
    ];
  }

  Widget _buildMateriaCard(Materia materia, MateriaProvider provider, BuildContext context) {
    final colors = context.colors;

    final List<ClarityContextMenuAction> contextActions = [
      ClarityContextMenuAction(
        label: 'Editar',
        icon: Icons.edit,
        color: colors.primary,
        onPressed: () => _showEditMateriaDialog(context, materia),
      ),
      ClarityContextMenuAction(
        label: 'Eliminar',
        icon: Icons.delete,
        color: colors.error,
        onPressed: () => _showDeleteConfirmationDialog(materia, provider),
      ),
    ];

    return ClarityListItem(
      leading: CircleAvatar(
        backgroundColor: colors.primary,
        child: Icon(
          Icons.subject,
          color: colors.white,
        ),
      ),
      title: materia.nombre,
      subtitle: materia.codigo != null ? 'CÃ³digo: ${materia.codigo}' : 'Sin cÃ³digo asignado',
      contextActions: contextActions,
      onTap: () => _navigateToMateriaDetail(materia),
    );
  }

  void _showCreateMateriaDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => const CreateMateriaDialog(),
    ).then((result) {
      if (result == true) {
        _loadMaterias()
      }
    });
  }

  void _showEditMateriaDialog(BuildContext context, Materia materia) {
    showDialog(
      context: context,
      builder: (context) => EditMateriaDialog(materia: materia),
    ).then((result) {
      if (result == true) {
        _loadMaterias()
      }
    });
  }

  void _showDeleteConfirmationDialog(Materia materia, MateriaProvider provider) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Eliminar Materia', style: Theme.of(context).textTheme.headlineSmall),
        content: Text(
          'Â¿EstÃ¡s seguro de que quieres eliminar "${materia.nombre}"?\n\n'
          'Esta acciÃ³n no se puede deshacer.',
          style: Theme.of(context).textTheme.bodyMedium,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: Text('Cancelar', style: Theme.of(context).textTheme.labelLarge),
          ),
          TextButton(
            onPressed: () async {
              Navigator.of(context).pop();
              await _deleteMateria(materia, provider);
            },
            style: TextButton.styleFrom(foregroundColor: Theme.of(context).colorScheme.error),
            child: Text('Eliminar', style: Theme.of(context).textTheme.labelLarge?.copyWith(color: Theme.of(context).colorScheme.error)),
          ),
        ],
      ),
    );
  }

  Future<void> _deleteMateria(Materia materia, MateriaProvider provider) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    final success = await provider.deleteMateria(
      authProvider.accessToken!,
      materia.id,
    );

    if (!mounted) return;

    if (success) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            'Materia eliminada correctamente',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onPrimary),
          ),
          backgroundColor: Theme.of(context).colorScheme.primary,
        ),
      );
      await _loadMaterias();
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            provider.errorMessage ?? 'Error al eliminar materia',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onError),
          ),
          backgroundColor: Theme.of(context).colorScheme.error,
        ),
      );
    }
  }

  void _navigateToMateriaDetail(Materia materia) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('Detalle de materia: ${materia.nombre}')),
    );
  }
}
class CreateMateriaDialog extends StatefulWidget {
  const CreateMateriaDialog({super.key});

  @override
  State<CreateMateriaDialog> createState() => _CreateMateriaDialogState();
}

class _CreateMateriaDialogState extends State<CreateMateriaDialog> {
  final _formKey = GlobalKey<FormState>();
  final _nombreController = TextEditingController();
  final _codigoController = TextEditingController();

  bool _isLoading = false;

  @override
  void dispose() {
    _nombreController.dispose();
    _codigoController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return AlertDialog(
      title: Text('Crear Materia', style: textStyles.headlineMedium),
      content: Form(
        key: _formKey,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextFormField(
              controller: _nombreController,
              decoration: InputDecoration(
                labelText: 'Nombre de la Materia',
                hintText: 'Ej: MatemÃ¡ticas, Lenguaje, Ciencias',
              ),
              validator: (value) {
                if (value == null || value.isEmpty) {
                  return 'El nombre es requerido';
                }
                return null;
              },
            ),
            SizedBox(height: spacing.md),
            TextFormField(
              controller: _codigoController,
              decoration: InputDecoration(
                labelText: 'CÃ³digo (opcional)',
                hintText: 'Ej: MAT101, LEN201',
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isLoading ? null : () => Navigator.of(context).pop(),
          child: Text('Cancelar'),
        ),
        ElevatedButton(
          onPressed: _isLoading ? null : _createMateria,
          child: _isLoading
              ? SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(strokeWidth: 2),
                )
              : Text('Crear'),
        ),
      ],
    );
  }

  Future<void> _createMateria() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final materiaProvider = Provider.of<MateriaProvider>(context, listen: false);

      final success = await materiaProvider.createMateria(
        authProvider.accessToken!,
        academic_service.CreateMateriaRequest(
          nombre: _nombreController.text.trim(),
          codigo: _codigoController.text.trim().isEmpty ? null : _codigoController.text.trim(),
        ),
      );

      if (success && mounted) {
        Navigator.of(context).pop(true);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Materia creada correctamente')),
        );
      } else if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(materiaProvider.errorMessage ?? 'Error al crear materia'),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: $e'),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }
}
class EditMateriaDialog extends StatefulWidget {
  final Materia materia;

  const EditMateriaDialog({super.key, required this.materia});

  @override
  State<EditMateriaDialog> createState() => _EditMateriaDialogState();
}

class _EditMateriaDialogState extends State<EditMateriaDialog> {
  final _formKey = GlobalKey<FormState>();
  late final TextEditingController _nombreController;
  late final TextEditingController _codigoController;

  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _nombreController = TextEditingController(text: widget.materia.nombre);
    _codigoController = TextEditingController(text: widget.materia.codigo ?? '');
  }

  @override
  void dispose() {
    _nombreController.dispose();
    _codigoController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return AlertDialog(
      title: Text('Editar Materia', style: textStyles.headlineMedium),
      content: Form(
        key: _formKey,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextFormField(
              controller: _nombreController,
              decoration: InputDecoration(
                labelText: 'Nombre de la Materia',
                hintText: 'Ej: MatemÃ¡ticas, Lenguaje, Ciencias',
              ),
              validator: (value) {
                if (value == null || value.isEmpty) {
                  return 'El nombre es requerido';
                }
                return null;
              },
            ),
            SizedBox(height: spacing.md),
            TextFormField(
              controller: _codigoController,
              decoration: InputDecoration(
                labelText: 'CÃ³digo (opcional)',
                hintText: 'Ej: MAT101, LEN201',
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isLoading ? null : () => Navigator.of(context).pop(),
          child: Text('Cancelar'),
        ),
        ElevatedButton(
          onPressed: _isLoading ? null : _updateMateria,
          child: _isLoading
              ? SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(strokeWidth: 2),
                )
              : Text('Actualizar'),
        ),
      ],
    );
  }

  Future<void> _updateMateria() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final materiaProvider = Provider.of<MateriaProvider>(context, listen: false);

      final success = await materiaProvider.updateMateria(
        authProvider.accessToken!,
        widget.materia.id,
        academic_service.UpdateMateriaRequest(
          nombre: _nombreController.text.trim(),
          codigo: _codigoController.text.trim().isEmpty ? null : _codigoController.text.trim(),
        ),
      );

      if (success && mounted) {
        Navigator.of(context).pop(true);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Materia actualizada correctamente')),
        );
      } else if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(materiaProvider.errorMessage ?? 'Error al actualizar materia'),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: $e'),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }
}
/* Fin lib\screens\academic\materias_screen.dart */

/* Inicio lib\screens\admin_dashboard.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../providers/user_provider.dart';
import '../theme/theme_extensions.dart';
import '../widgets/components/index.dart';

class AdminDashboard extends StatefulWidget {
  const AdminDashboard({super.key});

  @override
  @override
  State<AdminDashboard> createState() => _AdminDashboardState();
}

class _AdminDashboardState extends State<AdminDashboard> {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      try {
        final authProvider = Provider.of<AuthProvider>(context, listen: false);
        final userProvider = Provider.of<UserProvider>(context, listen: false);

        final selectedInstitutionId = authProvider.selectedInstitutionId;
        final token = authProvider.accessToken;
        if (selectedInstitutionId != null && token != null) {
          await userProvider.loadUsersByInstitution(token, selectedInstitutionId);
        }
      } catch (e) {
        debugPrint('AdminDashboard init load error: $e');
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final userProvider = Provider.of<UserProvider>(context);
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    final user = authProvider.user;
    final userName = user?['nombres'] ?? 'Usuario';
    final stats = userProvider.getUserStatistics();

    return Scaffold(
      backgroundColor: colors.background,
      body: SingleChildScrollView(
        padding: EdgeInsets.all(spacing.lg),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Â¡Hola, $userName!', style: textStyles.displayMedium),
            SizedBox(height: spacing.sm),
            Text(
              'Bienvenido al panel de administraciÃ³n.',
              style: textStyles.bodyLarge.copyWith(color: colors.textSecondary),
            ),
            SizedBox(height: spacing.xl),
            _buildCompactStatsBar(context, stats, userProvider),

            SizedBox(height: spacing.xl),
            Text('Acciones Principales', style: textStyles.headlineSmall),
            SizedBox(height: spacing.md),
            Container(
              decoration: BoxDecoration(
                color: colors.surface,
                borderRadius: BorderRadius.circular(spacing.borderRadius),
                border: Border.all(color: colors.borderLight),
              ),
              child: Column(
                children: [
                  _buildMenuActionItem(
                    context,
                    icon: Icons.people_outline_rounded,
                    label: 'Usuarios',
                    value: stats['total']?.toString() ?? '0',
                    color: colors.primary,
                    onTap: () => context.go('/users'),
                    isFirst: true,
                  ),
                  Divider(height: 0, indent: spacing.lg, endIndent: spacing.lg),
                  _buildMenuActionItem(
                    context,
                    icon: Icons.school_outlined,
                    label: 'GestiÃ³n AcadÃ©mica',
                    value: 'Grupos & Materias',
                    color: const Color(0xFF10B981),
                    onTap: () => context.go('/academic'),
                  ),
                  Divider(height: 0, indent: spacing.lg, endIndent: spacing.lg),
                  _buildMenuActionItem(
                    context,
                    icon: Icons.calendar_today_outlined,
                    label: 'Horarios',
                    value: 'GestiÃ³n',
                    color: const Color(0xFF06B6D4),
                    onTap: () {},
                  ),
                  Divider(height: 0, indent: spacing.lg, endIndent: spacing.lg),
                  _buildMenuActionItem(
                    context,
                    icon: Icons.settings_outlined,
                    label: 'Ajustes',
                    value: 'Config',
                    color: const Color(0xFF8B5CF6),
                    onTap: () {},
                    isLast: true,
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildCompactStatsBar(BuildContext context, Map<String, int> stats, UserProvider userProvider) {
    final colors = context.colors;
    final spacing = context.spacing;

    return Container(
      padding: EdgeInsets.symmetric(horizontal: spacing.sm, vertical: spacing.md),
      decoration: BoxDecoration(
        color: colors.surface,
        borderRadius: BorderRadius.circular(spacing.borderRadius),
        border: Border.all(color: colors.borderLight),
      ),
      child: SingleChildScrollView
        scrollDirection: Axis.horizontal,
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceAround,
          children: [
            ClarityCompactStat(
              value: stats['total']?.toString() ?? '0',
              title: 'Usuarios',
              icon: Icons.people,
              color: colors.primary,
            ),
            SizedBox(width: spacing.lg),
            ClarityCompactStat(
              value: stats['profesores']?.toString() ?? userProvider.professorsCount.toString(),
              title: 'Profesores',
              icon: Icons.school,
              color: colors.info,
            ),
            SizedBox(width: spacing.lg),
            ClarityCompactStat(
              value: stats['estudiantes']?.toString() ?? userProvider.studentsCount.toString(),
              title: 'Estudiantes',
              icon: Icons.person,
              color: colors.warning,
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildMenuActionItem(
    BuildContext context, {
    required IconData icon,
    required String label,
    required String value,
    required Color color,
    required VoidCallback onTap,
    bool isFirst = false,
    bool isLast = false,
  }) {
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: EdgeInsets.symmetric(
            horizontal: spacing.lg,
            vertical: spacing.sm,
          ),
          child: Row(
            children: [
              Container(
                padding: EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: color.withValues(alpha: 0.12),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Icon(icon, color: color, size: 20),
              ),
              SizedBox(width: spacing.md),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      label,
                      style: textStyles.bodyMedium.copyWith(
                        fontWeight: FontWeight.w600,
                        color: context.colors.textPrimary,
                      ),
                    ),
                    Text(
                      value,
                      style: textStyles.bodySmall.copyWith(
                        color: color,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ],
                ),
              ),
              Icon(
                Icons.arrow_forward_ios_rounded,
                size: 16,
                color: context.colors.textSecondary,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
/* Fin lib\screens\admin_dashboard.dart */

/* Inicio lib\screens\app_shell.dart */
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:go_router/go_router.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart'
import '../theme/app_colors.dart';
import '../utils/responsive_utils.dart';
import '../widgets/components/command_palette.dart';

class AppShell extends StatefulWidget {
  final StatefulNavigationShell navigationShell;

  const AppShell({
    super.key,
    required this.navigationShell,
  });

  @override
  State<AppShell> createState() => _AppShellState();
}

class _AppShellState extends State<AppShell> {
  late FocusNode _focusNode;
  final GlobalKey<ScaffoldState> _scaffoldKey = GlobalKey<ScaffoldState>();

  @override
  void initState() {
    super.initState();
    _focusNode = FocusNode();
    _focusNode.addListener(_handleKeyboardShortcuts);
  }

  @override
  void dispose() {
    _focusNode.removeListener(_handleKeyboardShortcuts);
    _focusNode.dispose();
    super.dispose();
  }

  void _handleKeyboardShortcuts() {
  }

  void _showCommandPalette() {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final userRole = authProvider.user?['rol'] as String?;
    final items = _buildCommandPaletteItems(userRole);

    showDialog(
      context: context,
      builder: (context) => CommandPalette(
        items: items,
        onDismiss: () {
          FocusScope.of(context).requestFocus(_focusNode);
        },
      ),
    );
  }

  List<CommandPaletteItem> _buildCommandPaletteItems(String? userRole) {
    final items = <CommandPaletteItem>[
      CommandPaletteItem(
        title: 'Ir a Dashboard',
        description: 'Abre el dashboard principal',
        icon: Icons.dashboard_rounded,
        shortcut: 'âŒ˜D',
        onExecute: () {
          context.go('/');
        },
      ),
    ];
    if (userRole == 'super_admin') {
      items.addAll([
        CommandPaletteItem(
          title: 'Ir a Instituciones',
          description: 'Gestiona todas las instituciones',
          icon: Icons.business_rounded,
          shortcut: 'âŒ˜I',
          onExecute: () {
            context.go('/instituciones');
          },
        ),
        CommandPaletteItem(
          title: 'Ir a Usuarios',
          description: 'Gestiona todos los usuarios',
          icon: Icons.people_alt_rounded,
          shortcut: 'âŒ˜U',
          onExecute: () {
            context.go('/usuarios');
          },
        ),
      ]);
    }

    if (userRole == 'super_admin' || userRole == 'admin_institucion') {
      items.addAll([
        CommandPaletteItem(
          title: 'Crear Nueva InstituciÃ³n',
          description: 'Agrega una instituciÃ³n nueva',
          icon: Icons.add_business_rounded,
          onExecute: () {
          },
        ),
      ]);
    }
    items.addAll([
      CommandPaletteItem(
        title: 'Cerrar SesiÃ³n',
        description: 'Cierra tu sesiÃ³n actual',
        icon: Icons.logout_rounded,
        color: AppColors.instance.error, // Rojo error con mejor contraste
        onExecute: () {
          Provider.of<AuthProvider>(context, listen: false).logout();
          context.go('/login');
        },
      ),
      CommandPaletteItem(
        title: 'Preferencias',
        description: 'Accede a la configuraciÃ³n',
        icon: Icons.settings_rounded,
        onExecute: () {
        },
      ),
      CommandPaletteItem(
        title: 'Ayuda',
        description: 'Ver documentaciÃ³n y ayuda',
        icon: Icons.help_rounded,
        onExecute: () {
        },
      ),
    ]);

    return items;
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final userRole = authProvider.user?['rol'] as String?;

    final allBranches = [
      (label: 'Dashboard', icon: Icons.dashboard_rounded, branchIndex: 0, roles: ['super_admin', 'admin_institucion', 'profesor', 'estudiante']),
      (label: 'Instituciones', icon: Icons.business_rounded, branchIndex: 1, roles: ['super_admin']),
      (label: 'Usuarios', icon: Icons.people_alt_rounded, branchIndex: 2, roles: ['super_admin', 'admin_institucion']),
    ];

    final accessibleBranches = allBranches.where((branch) => branch.roles.contains(userRole)).toList();
    int selectedIndex = 0
    if (accessibleBranches.isNotEmpty) {
      final currentBranchIndex = widget.navigationShell.currentIndex;
      final foundIndex = accessibleBranches.indexWhere((b) => b.branchIndex == currentBranchIndex);
      if (foundIndex != -1) {
        selectedIndex = foundIndex;
      }
    }
  final institutionName = authProvider.selectedInstitution?.name;
    return Focus(
      focusNode: _focusNode,
      onKeyEvent: (node, event) {
        if (HardwareKeyboard.instance.isLogicalKeyPressed(LogicalKeyboardKey.keyK) &&
            (HardwareKeyboard.instance.isControlPressed || HardwareKeyboard.instance.isMetaPressed)) {
          _showCommandPalette();
          return KeyEventResult.handled;
        }
        return KeyEventResult.ignored;
      },
      child: LayoutBuilder(
        builder: (context, constraints) {
          final responsive = ResponsiveUtils.getResponsiveValues(constraints);
          if (accessibleBranches.isEmpty) {
            return Scaffold(
              key: _scaffoldKey,
              appBar: AppBar(
                backgroundColor: context.colors.surface,
                elevation: 0,
                foregroundColor: context.colors.textPrimary,
                title: Text(institutionName != null ? 'Dashboard â€” $institutionName' : 'Dashboard'),
                actions: [
                  IconButton(
                    icon: Icon(Icons.logout, color: context.colors.error),
                    tooltip: 'Cerrar sesiÃ³n',
                    onPressed: () async {
                      await authProvider.logoutAndClearAllData(context);
                      if (context.mounted) context.go('/login');
                    },
                  ),
                ],
              ),
              body: widget.navigationShell,
            );
          }
          if (!responsive['isMobile']) {
            return Scaffold(
              key: _scaffoldKey,
              appBar: AppBar(
                backgroundColor: context.colors.surface,
                elevation: 0,
                foregroundColor: context.colors.textPrimary,
        title: Text(institutionName != null
          ? '${accessibleBranches[selectedIndex].label} â€” $institutionName'
          : accessibleBranches[selectedIndex].label),
                actions: [
                  IconButton(
                    icon: Icon(Icons.logout, color: context.colors.error),
                    tooltip: 'Cerrar sesiÃ³n',
                    onPressed: () async {
                      await authProvider.logoutAndClearAllData(context);
                      if (context.mounted) context.go('/login');
                    },
                  ),
                ],
              ),
              body: Row(
                children: [
                  if (accessibleBranches.isNotEmpty)
                    NavigationRail(
                      selectedIndex: selectedIndex,
                      onDestinationSelected: (index) {
                        final branchIndexToGo = accessibleBranches[index].branchIndex;
                        widget.navigationShell.goBranch(branchIndexToGo, initialLocation: index == widget.navigationShell.currentIndex);
                      },
                      labelType: NavigationRailLabelType.all,
                      destinations: [
                        for (final branch in accessibleBranches)
                          NavigationRailDestination(
                            icon: Icon(branch.icon),
                            label: Text(branch.label),
                          ),
                      ],
                    ),
                  const VerticalDivider(thickness: 1, width: 1),
                  Expanded(child: widget.navigationShell),
                ],
              ),
            );
          } else {
            return Scaffold(
              key: _scaffoldKey,
              appBar: AppBar(
                backgroundColor: context.colors.primary,
                elevation: 0,
                foregroundColor: Theme.of(context).colorScheme.onPrimary,
                title: Text(institutionName != null
                  ? '${accessibleBranches[selectedIndex].label} â€” $institutionName'
                  : accessibleBranches[selectedIndex].label),
                leading: IconButton(
                  icon: const Icon(Icons.menu),
                  tooltip: 'MenÃº',
                  color: Theme.of(context).colorScheme.onPrimary,
                  onPressed: () {
                    _scaffoldKey.currentState?.openDrawer();
                  },
                ),
              ),
              drawer: Drawer(
                backgroundColor: context.colors.surface,
                child: Column(
                  children: [
                    Container(
                      height: 120,
                      color: context.colors.primary,
                      padding: const EdgeInsets.all(16),
                      alignment: Alignment.bottomLeft,
                      child: Text(
                        'MenÃº',
                        style: context.textStyles.headlineSmall.copyWith(
                          color: Theme.of(context).colorScheme.onPrimary,
                        ),
                      ),
                    ),
                    const SizedBox(height: 16),
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 16),
                      child: ElevatedButton.icon(
                        onPressed: () {
                          Navigator.of(context).pop();
                          authProvider.logoutAndClearAllData(context).then((_) {
                            if (context.mounted) context.go('/login');
                          });
                        },
                        icon: Icon(Icons.logout, color: context.colors.white),
                        label: const Text('Cerrar SesiÃ³n'),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: context.colors.error,
                          foregroundColor: context.colors.white,
                          minimumSize: const Size(double.infinity, 48),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
              body: widget.navigationShell,
              bottomNavigationBar: accessibleBranches.length > 1 ? BottomNavigationBar(
                currentIndex: selectedIndex,
                onTap: (index) {
                  final branchIndexToGo = accessibleBranches[index].branchIndex;
                  widget.navigationShell.goBranch(branchIndexToGo, initialLocation: index == widget.navigationShell.currentIndex);
                },
                type: BottomNavigationBarType.fixed, // Muestra siempre los labels
                backgroundColor: context.colors.surface,
                selectedItemColor: context.colors.primary,
                unselectedItemColor: context.colors.textMuted,
                selectedLabelStyle: context.textStyles.labelSmall.bold,
                unselectedLabelStyle: context.textStyles.labelSmall,
                items: [
                  for (final branch in accessibleBranches)
                    BottomNavigationBarItem(
                      icon: Icon(branch.icon),
                      label: branch.label,
                    ),
                  ],
              ) : null, // No mostrar la barra si solo hay una opciÃ³n
            );
          }
        },
      ),
    );
  }
}
/* Fin lib\screens\app_shell.dart */

/* Inicio lib\screens\clarity_admin_dashboard.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../providers/user_provider.dart';
import '../theme/app_colors.dart';
import '../theme/app_text_styles.dart';
import '../theme/app_spacing.dart';
import '../widgets/components/index.dart';
class ClarityAdminDashboard extends StatelessWidget {
  const ClarityAdminDashboard({super.key});

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final userProvider = Provider.of<UserProvider>(context);
    final colors = AppColors.instance;
    final textStyles = AppTextStyles.instance;
    final spacing = AppSpacing.instance;

    final user = authProvider.user;
    final userName = user?['nombres'] ?? 'Usuario';

    return Scaffold(
      backgroundColor: colors.background,
      appBar: AppBar(
        backgroundColor: colors.primary,
        foregroundColor: colors.white,
        elevation: 0,
        title: Text(
          'Panel de AdministraciÃ³n',
          style: textStyles.headlineMedium.copyWith(color: colors.white),
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.logout),
            tooltip: 'Cerrar sesiÃ³n',
            onPressed: () async {
              await authProvider.logoutAndClearAllData(context);
            },
          ),
        ],
      ),
      body: LayoutBuilder(
        builder: (context, constraints) {

          return SingleChildScrollView(
            padding: EdgeInsets.all(spacing.screenPadding),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [

                Text(
                  'Â¡Hola, $userName!',
                  style: textStyles.displayMedium,
                ),
                SizedBox(height: spacing.sm),
                Text(
                  'AquÃ­ tienes un resumen de tu instituciÃ³n',
                  style: textStyles.bodyLarge.copyWith(color: colors.textSecondary),
                ),
                SizedBox(height: spacing.xl),

                Text(
                  'MÃ©tricas Clave',
                  style: textStyles.headlineSmall,
                ),
                SizedBox(height: spacing.md),
                LayoutBuilder(
                  builder: (context, constraints) {
                    final crossAxisCount = constraints.maxWidth > 600 ? 4 : 2;
                    final childAspectRatio = constraints.maxWidth > 600 ? 1.5 : 1.2;

                    return GridView.count(
                      crossAxisCount: crossAxisCount,
                      childAspectRatio: childAspectRatio,
                      crossAxisSpacing: spacing.md,
                      mainAxisSpacing: spacing.md,
                      shrinkWrap: true,
                      physics: const NeverScrollableScrollPhysics(),
                      children: [
                        ClarityKPICard(
                          value: userProvider.totalUsersFromPagination.toString(),
                          label: 'Total Usuarios',
                          icon: Icons.people,
                          iconColor: colors.featureUsers,
                        ),
                        ClarityKPICard(
                          value: userProvider.activeUsersCount.toString(),
                          label: 'Usuarios Activos',
                          icon: Icons.check_circle,
                          iconColor: colors.success,
                        ),
                        ClarityKPICard(
                          value: userProvider.professorsCount.toString(),
                          label: 'Profesores',
                          icon: Icons.school,
                          iconColor: colors.featureClasses,
                        ),
                        ClarityKPICard(
                          value: userProvider.studentsCount.toString(),
                          label: 'Estudiantes',
                          icon: Icons.person,
                          iconColor: colors.featureStudents,
                        ),
                      ],
                    );
                  },
                ),

                SizedBox(height: spacing.xxl),

                Text(
                  'Accesos Directos',
                  style: textStyles.headlineSmall,
                ),
                SizedBox(height: spacing.md),
                Container(
                  decoration: BoxDecoration(
                    color: colors.surface,
                    borderRadius: BorderRadius.circular(spacing.borderRadius),
                    border: Border.all(color: colors.borderLight),
                  ),
                  child: Column(
                    children: [
                      ListTile(
                        leading: Icon(Icons.people, color: colors.featureUsers),
                        title: Text('Gestionar Usuarios', style: textStyles.bodyLarge),
                        subtitle: Text('Crear, editar y administrar', style: textStyles.bodySmall.copyWith(color: colors.textMuted)),
                        onTap: () {},
                      ),
                      Divider(color: colors.borderLight),
                      ListTile(
                        leading: Icon(Icons.business, color: colors.featureInstitutions),
                        title: Text('Instituciones', style: textStyles.bodyLarge),
                        subtitle: Text('Administrar instituciones', style: textStyles.bodySmall.copyWith(color: colors.textMuted)),
                        onTap: () {},
                      ),
                      Divider(color: colors.borderLight),
                      ListTile(
                        leading: Icon(Icons.bar_chart, color: colors.featureReports),
                        title: Text('Reportes', style: textStyles.bodyLarge),
                        subtitle: Text('EstadÃ­sticas y anÃ¡lisis', style: textStyles.bodySmall.copyWith(color: colors.textMuted)),
                        onTap: () {},
                      ),
                      Divider(color: colors.borderLight),
                      ListTile(
                        leading: Icon(Icons.school, color: colors.featureClasses),
                        title: Text('GestiÃ³n AcadÃ©mica', style: textStyles.bodyLarge),
                        subtitle: Text('Grupos, materias y horarios', style: textStyles.bodySmall.copyWith(color: colors.textMuted)),
                        onTap: () {
                          context.push('/academic');
                        },
                      ),
                      Divider(color: colors.borderLight),
                      ListTile(
                        leading: Icon(Icons.settings, color: colors.featureSettings),
                        title: Text('ConfiguraciÃ³n', style: textStyles.bodyLarge),
                        subtitle: Text('Ajustes del sistema', style: textStyles.bodySmall.copyWith(color: colors.textMuted)),
                        onTap: () {},
                      ),
                      Divider(color: colors.borderLight),
                      ListTile(
                        leading: Icon(Icons.notifications, color: colors.featureNotifications),
                        title: Text('Notificaciones', style: textStyles.bodyLarge),
                        subtitle: Text('Centro de mensajes', style: textStyles.bodySmall.copyWith(color: colors.textMuted)),
                        onTap: () {},
                      ),
                    ],
                  ),
                ),

                SizedBox(height: spacing.xxl),

                Text(
                  'Actividad Reciente',
                  style: textStyles.headlineSmall,
                ),
                SizedBox(height: spacing.md),
                Column(
                  children: [
                    _buildActivityItem(
                      context,
                      icon: Icons.person_add,
                      title: 'Nuevo usuario registrado',
                      subtitle: 'MarÃ­a GonzÃ¡lez se uniÃ³ como estudiante',
                      time: 'Hace 2 horas',
                      color: colors.success,
                    ),
                    SizedBox(height: spacing.sm),
                    _buildActivityItem(
                      context,
                      icon: Icons.edit,
                      title: 'Perfil actualizado',
                      subtitle: 'Juan PÃ©rez modificÃ³ su informaciÃ³n',
                      time: 'Hace 4 horas',
                      color: colors.info,
                    ),
                    SizedBox(height: spacing.sm),
                    _buildActivityItem(
                      context,
                      icon: Icons.warning,
                      title: 'Usuario inactivo',
                      subtitle: 'Ana LÃ³pez no ha iniciado sesiÃ³n en 30 dÃ­as',
                      time: 'Hace 1 dÃ­a',
                      color: colors.warning,
                    ),
                  ],
                ),

                SizedBox(height: spacing.xxl),
              ],
            ),
          );
        },
      ),
    );
  }

  Widget _buildActivityItem(
    BuildContext context, {
    required IconData icon,
    required String title,
    required String subtitle,
    required String time,
    required Color color,
  }) {
    final colors = AppColors.instance;
    final textStyles = AppTextStyles.instance;
    final spacing = AppSpacing.instance;

    return ClarityCard(
      leading: CircleAvatar(
        backgroundColor: color.withValues(alpha: 0.1),
        child: Icon(icon, color: color, size: spacing.md),
      ),
      title: Text(
        title,
        style: textStyles.bodyMedium.copyWith(
          color: colors.textPrimary,
          fontWeight: FontWeight.w500,
        ),
      ),
      subtitle: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            subtitle,
            style: textStyles.bodySmall.copyWith(color: colors.textMuted),
          ),
          SizedBox(height: spacing.xs),
          Text(
            time,
            style: textStyles.caption.copyWith(color: colors.textDisabled),
          ),
        ],
      ),
    );
  }
}
/* Fin lib\screens\clarity_admin_dashboard.dart */

/* Inicio lib\screens\home_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../utils/responsive_utils.dart';

class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  Widget _buildUserInfo(AuthProvider authProvider, TextStyle headlineMedium, Color primary, bool isSmallScreen) {
    final user = authProvider.user;
    final userName = user?['nombres'] ?? user?['email'] ?? 'Usuario';

    return Column(
      children: [
        Text(
          userName,
          style: headlineMedium.copyWith(
            color: primary,
            fontSize: isSmallScreen ? 18 : 24,
          ),
          textAlign: TextAlign.center,
        ),
        const SizedBox(height: 8),
        Text(
          'Rol: ${user?['rol'] ?? 'Sin rol'}',
          style: TextStyle(
            color: primary.withValues(alpha: 0.7),
            fontSize: isSmallScreen ? 14 : 16,
          ),
          textAlign: TextAlign.center,
        ),
      ],
    );
  }

  Widget _buildInstitutionInfo(AuthProvider authProvider, TextStyle bodyLarge, Color textMuted, bool isSmallScreen) {
    final selectedInstitution = authProvider.selectedInstitution;

    if (selectedInstitution == null) {
      return Builder(
        builder: (context) {
          final colors = context.colors;
          return Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: colors.warningBackground,
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: colors.warningBorder),
            ),
            child: Column(
              children: [
                Icon(
                  Icons.business,
                  color: colors.warning,
                  size: isSmallScreen ? 24 : 32,
                ),
                const SizedBox(height: 8),
                Text(
                  'No hay instituciÃ³n seleccionada',
                  style: bodyLarge.copyWith(
                    color: colors.warning,
                    fontWeight: FontWeight.w500,
                  ),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 4),
                Text(
                  'Como super administrador, puedes gestionar todas las instituciones del sistema.',
                  style: TextStyle(
                    color: textMuted,
                    fontSize: isSmallScreen ? 12 : 14,
                  ),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          );
        },
      );
    }

    return Column(
      children: [
        Text(
          'InstituciÃ³n: ${selectedInstitution.name}',
          style: bodyLarge.copyWith(
            fontWeight: FontWeight.bold,
            fontSize: isSmallScreen ? 16 : 18,
          ),
          textAlign: TextAlign.center,
        ),
        const SizedBox(height: 4),
        Text(
          'Rol en instituciÃ³n: ${selectedInstitution.role ?? 'Sin rol'}',
          style: TextStyle(
            color: textMuted,
            fontSize: isSmallScreen ? 14 : 16,
          ),
          textAlign: TextAlign.center,
        ),
      ],
    );
  }

  Widget _buildDashboardOptions(bool isSmallScreen, Color textPrimary, Color textSecondary) {
    return Builder(
      builder: (context) {
        final colors = context.colors;
        return Column(
          children: [
            const SizedBox(height: 32),
            Wrap(
              spacing: 12,
              runSpacing: 12,
              alignment: WrapAlignment.center,
              children: [
                _buildFeatureCard(
                  icon: Icons.people,
                  title: 'GestiÃ³n de Usuarios',
                  description: 'Administrar usuarios del sistema',
                  isSmallScreen: isSmallScreen,
                  textPrimary: textPrimary,
                  textSecondary: textSecondary,
                ),
                _buildFeatureCard(
                  icon: Icons.business,
                  title: 'Instituciones',
                  description: 'Gestionar instituciones educativas',
                  isSmallScreen: isSmallScreen,
                  textPrimary: textPrimary,
                  textSecondary: textSecondary,
                ),
                _buildFeatureCard(
                  icon: Icons.assignment,
                  title: 'Asistencia',
                  description: 'Registro y control de asistencia',
                  isSmallScreen: isSmallScreen,
                  textPrimary: textPrimary,
                  textSecondary: textSecondary,
                ),
                _buildFeatureCard(
                  icon: Icons.bar_chart,
                  title: 'Reportes',
                  description: 'EstadÃ­sticas y reportes',
                  isSmallScreen: isSmallScreen,
                  textPrimary: textPrimary,
                  textSecondary: textSecondary,
                ),
              ],
            ),
            const SizedBox(height: 24),
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: colors.infoBackground,
                borderRadius: BorderRadius.circular(12),
                border: Border.all(color: colors.infoBorder),
              ),
              child: Column(
                children: [
                  Icon(
                    Icons.info_outline,
                    color: colors.info,
                    size: isSmallScreen ? 24 : 32,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Sistema en Desarrollo',
                    style: TextStyle(
                      color: colors.info,
                      fontWeight: FontWeight.bold,
                      fontSize: isSmallScreen ? 16 : 18,
                    ),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 4),
                  Text(
                    'Las funcionalidades estarÃ¡n disponibles prÃ³ximamente.',
                    style: TextStyle(
                      color: textSecondary,
                      fontSize: isSmallScreen ? 12 : 14,
                    ),
                    textAlign: TextAlign.center,
                  ),
                ],
              ),
            ),
          ],
        );
      },
    );
  }

  Widget _buildFeatureCard({
    required IconData icon,
    required String title,
    required String description,
    required bool isSmallScreen,
    required Color textPrimary,
    required Color textSecondary,
  }) {
    return Builder(
      builder: (context) {
        final colors = context.colors;
        return Container(
          width: isSmallScreen ? 160 : 180,
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: colors.surface,
            borderRadius: BorderRadius.circular(12),
            boxShadow: [
              BoxShadow(
                color: colors.shadow,
                spreadRadius: 1,
                blurRadius: 4,
                offset: const Offset(0, 2),
              ),
            ],
            border: Border.all(color: colors.borderLight),
          ),
          child: Column(
            children: [
              Icon(
                icon,
                size: isSmallScreen ? 32 : 40,
                color: colors.secondary,
              ),
              const SizedBox(height: 8),
              Text(
                title,
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                  fontSize: isSmallScreen ? 14 : 16,
                  color: textPrimary,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 4),
              Text(
                description,
                style: TextStyle(
                  color: textSecondary,
                  fontSize: isSmallScreen ? 10 : 12,
                ),
                textAlign: TextAlign.center,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildSignOutButton(BuildContext context, AuthProvider authProvider) {
    return ElevatedButton(
      onPressed: () async {
        await authProvider.logoutAndClearAllData(context);
      },
      child: const Text('Cerrar SesiÃ³n'),
    );
  }

  AppBar _buildAppBar(Color primaryColor) {
    return AppBar(
      title: const Text('AsistApp'),
      backgroundColor: primaryColor,
      actions: _buildAppBarActions(),
    );
  }

  List<Widget> _buildAppBarActions() {
    return [
      IconButton(
        icon: const Icon(Icons.logout),
        onPressed: () async {
        },
      ),
    ];
  }

  Widget _buildBody(BuildContext context, AuthProvider authProvider, dynamic textStyles, dynamic colors, Map<String, dynamic> responsive) {
    return SafeArea(
      child: SingleChildScrollView(
        child: ConstrainedBox(
          constraints: BoxConstraints(maxWidth: responsive['maxWidth']),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Padding(
                padding: EdgeInsets.symmetric(
                  horizontal: responsive['horizontalPadding'],
                  vertical: responsive['verticalPadding'],
                ),
                child: Column(
                  children: [
                    _buildUserInfo(authProvider, textStyles.headlineMedium, colors.primary, responsive['isSmallScreen']),
                    SizedBox(height: responsive['elementSpacing']),

                    _buildInstitutionInfo(authProvider, textStyles.bodyLarge, colors.textMuted, responsive['isSmallScreen']),
                    SizedBox(height: responsive['elementSpacing']),

                    _buildDashboardOptions(responsive['isSmallScreen'], colors.textPrimary, colors.textSecondary),

                    SizedBox(height: responsive['elementSpacing'] * 2),

                    _buildSignOutButton(context, authProvider),

                    SizedBox(height: responsive['verticalPadding']),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final colors = context.colors;
    final textStyles = context.textStyles;

    return Scaffold(
      backgroundColor: colors.background,
      appBar: _buildAppBar(colors.primary),
      body: LayoutBuilder(
        builder: (context, constraints) {
          final responsive = ResponsiveUtils.getResponsiveValues(constraints);
          return _buildBody(context, authProvider, textStyles, colors, responsive);
        },
      ),
    );
  }
}
/* Fin lib\screens\home_screen.dart */

/* Inicio lib\screens\institutions\create_institution_admin_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../models/institution.dart';
import '../../models/user.dart';
import '../../providers/auth_provider.dart';
import '../../providers/user_provider.dart';
import '../../theme/theme_extensions.dart';
import '../../widgets/form_widgets.dart';
import '../../widgets/components/clarity_components.dart';

class CreateInstitutionAdminScreen extends StatefulWidget {
  final Institution institution;

  const CreateInstitutionAdminScreen({
    super.key,
    required this.institution,
  });

  @override
  State<CreateInstitutionAdminScreen> createState() => _CreateInstitutionAdminScreenState();
}

class _CreateInstitutionAdminScreenState extends State<CreateInstitutionAdminScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nombresController = TextEditingController();
  final _apellidosController = TextEditingController();
  final _emailController = TextEditingController();
  final _telefonoController = TextEditingController();

  bool _isLoading = false;
  bool _activo = true;

  @override
  void dispose() {
    _nombresController.dispose();
    _apellidosController.dispose();
    _emailController.dispose();
    _telefonoController.dispose();
    super.dispose();
  }

  Future<void> _saveAdmin() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final userProvider = Provider.of<UserProvider>(context, listen: false);

      final createRequest = CreateUserRequest(
        email: _emailController.text.trim(),
        password: 'TempPass123!', // ContraseÃ±a temporal que debe ser cambiada por el usuario
        nombres: _nombresController.text.trim(),
        apellidos: _apellidosController.text.trim(),
        telefono: _telefonoController.text.trim().isNotEmpty ? _telefonoController.text.trim() : null,
        rol: 'admin_institucion',
        institucionId: widget.institution.id,
        rolEnInstitucion: 'admin', // Rol especÃ­fico dentro de la instituciÃ³n
      );

      final success = await userProvider.createUser(
        authProvider.accessToken!,
        createRequest,
      );

      if (success && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              'Administrador de instituciÃ³n creado exitosamente',
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onPrimary,
              ),
            ),
            backgroundColor: Theme.of(context).colorScheme.primary,
          ),
        );
        context.go('/institutions');
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              'Error al crear administrador: ${e.toString()}',
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onError,
              ),
            ),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Scaffold(
      appBar: AppBar(
        title: Text('Crear Administrador - ${widget.institution.nombre}'),
        backgroundColor: colors.primary,
        foregroundColor: colors.getTextColorForBackground(colors.primary),
      ),
      body: SingleChildScrollView(
        padding: EdgeInsets.all(spacing.lg),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              SizedBox(height: spacing.lg),

              Text(
                'InformaciÃ³n Personal',
                style: textStyles.headlineMedium.bold,
              ),
              SizedBox(height: spacing.lg),
              LayoutBuilder(
                builder: (context, constraints) {
                  final isWide = constraints.maxWidth > 600;
                  return isWide
                    ? Row(
                        children: [
                          Expanded(
                            child: CustomTextFormField(
                              controller: _nombresController,
                              labelText: 'Nombres',
                              hintText: 'Ingrese los nombres',
                              validator: (value) {
                                if (value == null || value.trim().isEmpty) {
                                  return 'Los nombres son requeridos';
                                }
                                if (value.trim().length < 2) {
                                  return 'Los nombres deben tener al menos 2 caracteres';
                                }
                                return null;
                              },
                            ),
                          ),
                          SizedBox(width: spacing.md),
                          Expanded(
                            child: CustomTextFormField(
                              controller: _apellidosController,
                              labelText: 'Apellidos',
                              hintText: 'Ingrese los apellidos',
                              validator: (value) {
                                if (value == null || value.trim().isEmpty) {
                                  return 'Los apellidos son requeridos';
                                }
                                if (value.trim().length < 2) {
                                  return 'Los apellidos deben tener al menos 2 caracteres';
                                }
                                return null;
                              },
                            ),
                          ),
                        ],
                      )
                    : Column(
                        children: [
                          CustomTextFormField(
                            controller: _nombresController,
                            labelText: 'Nombres',
                            hintText: 'Ingrese los nombres',
                            validator: (value) {
                              if (value == null || value.trim().isEmpty) {
                                return 'Los nombres son requeridos';
                              }
                              if (value.trim().length < 2) {
                                return 'Los nombres deben tener al menos 2 caracteres';
                              }
                              return null;
                            },
                          ),
                          SizedBox(height: spacing.md),
                          CustomTextFormField(
                            controller: _apellidosController,
                            labelText: 'Apellidos',
                            hintText: 'Ingrese los apellidos',
                            validator: (value) {
                              if (value == null || value.trim().isEmpty) {
                                return 'Los apellidos son requeridos';
                              }
                              if (value.trim().length < 2) {
                                return 'Los apellidos deben tener al menos 2 caracteres';
                              }
                              return null;
                            },
                          ),
                        ],
                      );
                },
              ),
              SizedBox(height: spacing.md),
              CustomTextFormField(
                controller: _emailController,
                labelText: 'Email',
                hintText: 'admin@ejemplo.com',
                keyboardType: TextInputType.emailAddress,
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'El email es requerido';
                  }
                  final emailRegex = RegExp(r'^[^@\s]+@[^@\s]+\.[^@\s]+$');
                  if (!emailRegex.hasMatch(value.trim())) {
                    return 'Ingrese un email vÃ¡lido';
                  }
                  return null;
                },
              ),
              SizedBox(height: spacing.md),
              CustomTextFormField(
                controller: _telefonoController,
                labelText: 'TelÃ©fono',
                hintText: '+57 300 123 4567',
                keyboardType: TextInputType.phone,
                validator: (value) {
                  if (value != null && value.trim().isNotEmpty) {
                    final phoneRegex = RegExp(r'^\+?[0-9\s\-\(\)]+$');
                    if (!phoneRegex.hasMatch(value.trim())) {
                      return 'Ingrese un telÃ©fono vÃ¡lido';
                    }
                  }
                  return null;
                },
              ),
              SizedBox(height: spacing.lg),
              ClarityCard(
                title: Text(
                  'InstituciÃ³n Asignada',
                  style: textStyles.titleMedium.bold,
                ),
                leading: Icon(
                  Icons.business,
                  color: colors.primary,
                ),
                subtitle: Text(
                  widget.institution.nombre,
                  style: textStyles.bodyLarge,
                ),
              ),
              SizedBox(height: spacing.lg),
              ClarityCard(
                title: Text(
                  'Estado del Usuario',
                  style: textStyles.bodyLarge.semiBold,
                ),
                trailing: Switch(
                  value: _activo,
                  onChanged: (value) {
                    setState(() => _activo = value);
                  },
                  activeColor: colors.primary,
                ),
                leading: Icon(
                  _activo ? Icons.check_circle : Icons.cancel,
                  color: _activo ? colors.success : colors.error,
                ),
                subtitle: Text(
                  _activo ? 'Usuario activo en el sistema' : 'Usuario inactivo',
                  style: textStyles.bodyMedium.withColor(
                    _activo ? colors.success : colors.error,
                  ),
                ),
              ),
              SizedBox(height: spacing.xl),
              Row(
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed: _isLoading ? null : () => context.pop(),
                      style: OutlinedButton.styleFrom(
                        padding: EdgeInsets.symmetric(vertical: spacing.md),
                        side: BorderSide(color: colors.primary),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(spacing.borderRadius),
                        ),
                      ),
                      child: Text(
                        'Cancelar',
                        style: textStyles.button.withColor(colors.primary),
                      ),
                    ),
                  ),
                  SizedBox(width: spacing.md),
                  Expanded(
                    child: ElevatedButton(
                      onPressed: _isLoading ? null : _saveAdmin,
                      style: ElevatedButton.styleFrom(
                        padding: EdgeInsets.symmetric(vertical: spacing.md),
                        backgroundColor: colors.primary,
                        foregroundColor: Theme.of(context).colorScheme.onPrimary,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(spacing.borderRadius),
                        ),
                      ),
                      child: _isLoading
                        ? SizedBox(
                            height: 20,
                            width: 20,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              valueColor: AlwaysStoppedAnimation<Color>(
                                Theme.of(context).colorScheme.onPrimary,
                              ),
                            ),
                          )
                        : Text('Crear Administrador', style: textStyles.button),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}
/* Fin lib\screens\institutions\create_institution_admin_screen.dart */

/* Inicio lib\screens\institutions\form_steps\index.dart */

export 'institution_basic_info_step.dart';
export 'institution_contact_step.dart';
export 'institution_config_step.dart';

/* Fin lib\screens\institutions\form_steps\index.dart */

/* Inicio lib\screens\institutions\form_steps\institution_basic_info_step.dart */
import 'package:flutter/material.dart';
import '../../../theme/theme_extensions.dart';
import '../../../widgets/form_widgets.dart';
class InstitutionBasicInfoStep extends StatelessWidget {
  final TextEditingController nombreController;
  final TextEditingController emailController;

  const InstitutionBasicInfoStep({
    super.key,
    required this.nombreController,
    required this.emailController,
  });

  @override
  Widget build(BuildContext context) {
    final spacing = context.spacing;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'InformaciÃ³n BÃ¡sica',
          style: context.textStyles.headlineSmall,
        ),
        SizedBox(height: spacing.md),
        Text(
          'Ingrese los datos fundamentales de la instituciÃ³n',
          style: context.textStyles.bodyMedium.copyWith(
            color: context.colors.textSecondary,
          ),
        ),
        SizedBox(height: spacing.lg),

        CustomTextFormField(
          key: const Key('nombreInstitucionField'),
          controller: nombreController,
          labelText: 'Nombre de la InstituciÃ³n',
          hintText: 'Ingrese el nombre completo',
          prefixIcon: const Icon(Icons.business),
          validator: (value) {
            if (value == null || value.trim().isEmpty) {
              return 'El nombre es obligatorio';
            }
            if (value.trim().length < 3) {
              return 'El nombre debe tener al menos 3 caracteres';
            }
            return null;
          },
        ),
        SizedBox(height: spacing.md),

        CustomTextFormField(
          key: const Key('emailInstitucionField'),
          controller: emailController,
          labelText: 'Email Institucional',
          hintText: 'contacto@institucion.com',
          prefixIcon: const Icon(Icons.email),
          keyboardType: TextInputType.emailAddress,
          validator: (value) {
            if (value != null && value.trim().isNotEmpty) {
              final emailRegex = RegExp(r'^[^@\s]+@[^@\s]+\.[^@\s]+$');
              if (!emailRegex.hasMatch(value.trim())) {
                return 'Ingrese un email vÃ¡lido';
              }
            }
            return null;
          },
        ),
      ],
    );
  }
}

/* Fin lib\screens\institutions\form_steps\institution_basic_info_step.dart */

/* Inicio lib\screens\institutions\form_steps\institution_config_step.dart */
import 'package:flutter/material.dart';
import '../../../theme/theme_extensions.dart';
import '../../../widgets/components/clarity_components.dart';
class InstitutionConfigStep extends StatelessWidget {
  final bool activa;
  final ValueChanged<bool> onActivaChanged;
  final bool isEditMode;

  const InstitutionConfigStep({
    super.key,
    required this.activa,
    required this.onActivaChanged,
    this.isEditMode = false,
  });

  @override
  Widget build(BuildContext context) {
    final spacing = context.spacing;
    final colors = context.colors;
    final textStyles = context.textStyles;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'ConfiguraciÃ³n',
          style: textStyles.headlineSmall,
        ),
        SizedBox(height: spacing.md),
        Text(
          'Establezca el estado operativo de la instituciÃ³n',
          style: textStyles.bodyMedium.copyWith(
            color: colors.textSecondary,
          ),
        ),
        SizedBox(height: spacing.lg),

        ClarityCard(
          leading: Icon(
            activa ? Icons.check_circle : Icons.cancel,
            color: activa ? colors.success : colors.error,
            size: 48,
          ),
          title: Text(
            'Estado de la InstituciÃ³n',
            style: textStyles.bodyLarge.semiBold,
          ),
          subtitle: Text(
            activa ? 'InstituciÃ³n operativa' : 'InstituciÃ³n inactiva',
            style: textStyles.bodyMedium.withColor(
              activa ? colors.success : colors.error,
            ),
          ),
          trailing: Switch(
            value: activa,
            onChanged: onActivaChanged,
            activeColor: colors.success,
          ),
        ),

        SizedBox(height: spacing.lg),

        Container(
          padding: EdgeInsets.all(spacing.md),
          decoration: BoxDecoration(
            color: colors.warning.withValues(alpha: 0.1),
            borderRadius: BorderRadius.circular(8),
            border: Border.all(color: colors.warning.withValues(alpha: 0.3)),
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Icon(Icons.warning_amber_rounded, color: colors.warning, size: 20),
                  SizedBox(width: spacing.sm),
                  Expanded(
                    child: Text(
                      'Importante',
                      style: textStyles.bodyMedium.semiBold.withColor(colors.warning),
                    ),
                  ),
                ],
              ),
              SizedBox(height: spacing.sm),
              Text(
                activa
                    ? 'Los usuarios podrÃ¡n acceder y usar los servicios de esta instituciÃ³n.'
                    : 'Si desactiva la instituciÃ³n, los usuarios no podrÃ¡n iniciar sesiÃ³n ni acceder a sus datos.',
                style: textStyles.bodySmall.copyWith(
                  color: colors.textSecondary,
                ),
              ),
            ],
          ),
        ),

        if (!isEditMode) ...[
          SizedBox(height: spacing.lg),
          Container(
            padding: EdgeInsets.all(spacing.md),
            decoration: BoxDecoration(
              color: colors.info.withValues(alpha: 0.1),
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: colors.info.withValues(alpha: 0.3)),
            ),
            child: Row(
              children: [
                Icon(Icons.lightbulb_outline, color: colors.info, size: 20),
                SizedBox(width: spacing.sm),
                Expanded(
                  child: Text(
                    'DespuÃ©s de crear la instituciÃ³n, podrÃ¡ asignarle administradores y usuarios.',
                    style: textStyles.bodySmall.copyWith(
                      color: colors.info,
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ],
    );
  }
}

/* Fin lib\screens\institutions\form_steps\institution_config_step.dart */

/* Inicio lib\screens\institutions\form_steps\institution_contact_step.dart */
import 'package:flutter/material.dart';
import '../../../theme/theme_extensions.dart';
import '../../../widgets/form_widgets.dart';
class InstitutionContactStep extends StatelessWidget {
  final TextEditingController direccionController;
  final TextEditingController telefonoController;

  const InstitutionContactStep({
    super.key,
    required this.direccionController,
    required this.telefonoController,
  });

  @override
  Widget build(BuildContext context) {
    final spacing = context.spacing;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Contacto y UbicaciÃ³n',
          style: context.textStyles.headlineSmall,
        ),
        SizedBox(height: spacing.md),
        Text(
          'InformaciÃ³n para contactar y localizar la instituciÃ³n',
          style: context.textStyles.bodyMedium.copyWith(
            color: context.colors.textSecondary,
          ),
        ),
        SizedBox(height: spacing.lg),

        CustomTextFormField(
          controller: direccionController,
          labelText: 'DirecciÃ³n',
          hintText: 'DirecciÃ³n completa de la instituciÃ³n',
          prefixIcon: const Icon(Icons.location_on),
          maxLines: 3,
          validator: (value) {
            return null;
          },
        ),
        SizedBox(height: spacing.md),

        CustomTextFormField(
          controller: telefonoController,
          labelText: 'TelÃ©fono',
          hintText: '+57 300 123 4567',
          prefixIcon: const Icon(Icons.phone),
          keyboardType: TextInputType.phone,
          validator: (value) {
            if (value != null && value.trim().isNotEmpty) {
              final phoneRegex = RegExp(r'^\+?[0-9\s\-\(\)]+$');
              if (!phoneRegex.hasMatch(value.trim())) {
                return 'Ingrese un telÃ©fono vÃ¡lido';
              }
            }
            return null;
          },
        ),

        SizedBox(height: spacing.md),
        Container(
          padding: EdgeInsets.all(spacing.md),
          decoration: BoxDecoration(
            color: context.colors.info.withValues(alpha: 0.1),
            borderRadius: BorderRadius.circular(8),
            border: Border.all(color: context.colors.info.withValues(alpha: 0.3)),
          ),
          child: Row(
            children: [
              Icon(Icons.info_outline, color: context.colors.info, size: 20),
              SizedBox(width: spacing.sm),
              Expanded(
                child: Text(
                  'Estos datos serÃ¡n visibles para los usuarios de la instituciÃ³n.',
                  style: context.textStyles.bodySmall.copyWith(
                    color: context.colors.info,
                  ),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }
}

/* Fin lib\screens\institutions\form_steps\institution_contact_step.dart */

/* Inicio lib\screens\institutions\institutions_list_screen.dart */
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../models/institution.dart';
import '../../providers/auth_provider.dart';
import '../../providers/institution_provider.dart';
import '../../theme/theme_extensions.dart';
import '../../widgets/components/index.dart';

class InstitutionsListScreen extends StatefulWidget {
  const InstitutionsListScreen({super.key});

  @override
  State<InstitutionsListScreen> createState() => _InstitutionsListScreenState();
}

class _InstitutionsListScreenState extends State<InstitutionsListScreen> {
  final TextEditingController _searchController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  Timer? _searchDebounceTimer;

  String _searchQuery = '';
  bool? _statusFilter

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);

    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadInstitutions();
    });
  }

  @override
  void dispose() {
    _searchDebounceTimer?.cancel();
    _scrollController.dispose();
    _searchController.dispose();
    super.dispose();
  }

  void _onScroll() {
    if (_scrollController.position.pixels == _scrollController.position.maxScrollExtent) {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);

      if (authProvider.accessToken != null && institutionProvider.hasMoreData && !institutionProvider.isLoadingMore) {
        institutionProvider.loadMoreInstitutions(
          authProvider.accessToken!,
          search: _searchQuery.isNotEmpty ? _searchQuery : null,
          activa: _statusFilter,
        );
      }
    }
  }

  Future<void> _loadInstitutions() async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);

    if (authProvider.accessToken != null) {
      debugPrint('Cargando instituciones con token: ${authProvider.accessToken!.substring(0, 20)}...');
      await institutionProvider.loadInstitutions(
        authProvider.accessToken!,
        search: _searchQuery.isNotEmpty ? _searchQuery : null,
        activa: _statusFilter,
      );
      debugPrint('Instituciones cargadas: ${institutionProvider.institutions.length}');
      debugPrint('Estado del provider: ${institutionProvider.state}');
      if (institutionProvider.hasError) {
        debugPrint('Error del provider: ${institutionProvider.errorMessage}');
      }
    } else {
      debugPrint('No hay token de acceso disponible');
    }
  }

  void _onSearchChanged(String query) {
    _searchDebounceTimer?.cancel();
    _searchDebounceTimer = Timer(const Duration(milliseconds: 500), () {
      setState(() {
        _searchQuery = query;
      });
      _loadInstitutions();
    });
  }

  void _onStatusFilterChanged(bool? status) {
    setState(() {
      _statusFilter = status;
    });
    _loadInstitutions();
  }

  @override
  Widget build(BuildContext context) {
    return Consumer2<AuthProvider, InstitutionProvider>(
      builder: (context, authProvider, institutionProvider, child) {
        final userRole = authProvider.user?['rol'] as String?;
        final canCreateInstitutions = userRole == 'super_admin';

        return ClarityManagementPage(
          title: 'GestiÃ³n de Instituciones',
          isLoading: institutionProvider.isLoading,
          hasError: institutionProvider.hasError,
          errorMessage: institutionProvider.errorMessage,
          itemCount: institutionProvider.institutions.length,
          itemBuilder: (context, index) {
            final institution = institutionProvider.institutions[index];
            return _buildInstitutionCard(institution, institutionProvider, context);
          },
          filterWidgets: _buildFilterWidgets(context),
          statisticWidgets: _buildStatisticWidgets(context, institutionProvider),
          onRefresh: _loadInstitutions,
          scrollController: _scrollController,
          hasMoreData: institutionProvider.hasMoreData,
          isLoadingMore: institutionProvider.isLoadingMore,
          emptyStateWidget: ClarityEmptyState(
            icon: _searchQuery.isNotEmpty ? Icons.search_off : Icons.business,
            title: _searchQuery.isNotEmpty
                ? 'No se encontraron instituciones'
                : 'No hay instituciones',
            subtitle: _searchQuery.isNotEmpty
                ? 'Intenta con otros tÃ©rminos de bÃºsqueda'
                : 'Comienza creando tu primera instituciÃ³n',
          ),
          floatingActionButton: canCreateInstitutions
              ? FloatingActionButton(
                  onPressed: () => _navigateToForm(context),
                  backgroundColor: context.colors.primary,
                  child: Icon(
                    Icons.add,
                    color: context.colors.getTextColorForBackground(context.colors.primary),
                  ),
                )
              : null,
        );
      },
    );
  }

  List<Widget> _buildFilterWidgets(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return [
      TextField(
        key: const Key('searchInstitutionField'),
        controller: _searchController,
        style: textStyles.bodyLarge,
        decoration: InputDecoration(
          hintText: 'Buscar por nombre, cÃ³digo o email...',
          hintStyle: textStyles.bodyMedium.withColor(colors.textMuted),
          prefixIcon: Icon(Icons.search, color: colors.textSecondary),
          suffixIcon: _searchQuery.isNotEmpty
              ? IconButton(
                  icon: Icon(Icons.clear, color: colors.textSecondary),
                  onPressed: () {
                    _searchController.clear();
                    _onSearchChanged('');
                  },
                )
              : null,
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.border),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.borderLight),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.primary, width: 2),
          ),
          filled: true,
          fillColor: colors.surface,
          contentPadding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
        ),
        onChanged: _onSearchChanged,
      ),
      SizedBox(height: spacing.sm),
      Wrap(
        spacing: spacing.md,
        runSpacing: spacing.sm,
        crossAxisAlignment: WrapCrossAlignment.center,
        children: [
          Text('Mostrar:', style: textStyles.labelMedium),
          FilterChip(
            label: const Text('Todas'),
            selected: _statusFilter == null,
            onSelected: (selected) {
              if (selected) _onStatusFilterChanged(null);
            },
          ),
          FilterChip(
            label: const Text('Activas'),
            selected: _statusFilter == true,
            onSelected: (selected) {
              if (selected) _onStatusFilterChanged(true);
            },
          ),
          FilterChip(
            label: const Text('Inactivas'),
            selected: _statusFilter == false,
            onSelected: (selected) {
              if (selected) _onStatusFilterChanged(false);
            },
          ),
        ],
      ),
    ];
  }

  List<Widget> _buildStatisticWidgets(BuildContext context, InstitutionProvider provider) {
    final colors = context.colors;
    return [
      ClarityCompactStat(
        title: 'Total',
        value: provider.totalInstitutions.toString(),
        icon: Icons.business,
        color: colors.primary,
      ),
      ClarityCompactStat(
        title: 'Activas',
        value: provider.activeInstitutionsCount.toString(),
        icon: Icons.check_circle,
        color: colors.success,
      ),
      ClarityCompactStat(
        title: 'Inactivas',
        value: provider.inactiveInstitutionsCount.toString(),
        icon: Icons.cancel,
        color: colors.error,
      ),
    ];
  }

  Widget _buildInstitutionCard(Institution institution, InstitutionProvider provider, BuildContext context) {
    final colors = context.colors;

    return Consumer<AuthProvider>(
      builder: (context, authProvider, child) {
        final userRole = authProvider.user?['rol'] as String?;
        final isSuperAdmin = userRole == 'super_admin';

        final List<ClarityContextMenuAction> contextActions = [
          if (isSuperAdmin) ...[
            ClarityContextMenuAction(
              label: 'Crear Admin',
              icon: Icons.admin_panel_settings,
              color: colors.primary,
              onPressed: () => _navigateToCreateInstitutionAdmin(institution),
            ),
            ClarityContextMenuAction(
              label: 'Gestionar Admins',
              icon: Icons.group,
              color: colors.info,
              onPressed: () => context.push('/institutions/${institution.id}/admins'),
            ),
          ],
          ClarityContextMenuAction(
            label: 'Editar',
            icon: Icons.edit,
            color: colors.primary,
            onPressed: () => _navigateToForm(context, institution: institution),
          ),
          ClarityContextMenuAction(
            label: institution.activa ? 'Desactivar' : 'Activar',
            icon: institution.activa ? Icons.toggle_off : Icons.toggle_on,
            color: institution.activa ? colors.warning : colors.success,
            onPressed: () => _handleMenuAction('toggle_status', institution, provider),
          ),
          ClarityContextMenuAction(
            label: 'Eliminar',
            icon: Icons.delete,
            color: colors.error,
            onPressed: () => _handleMenuAction('delete', institution, provider),
          ),
        ];

        return ClarityListItem(
          leading: Icon(
            Icons.business,
            color: colors.primary,
            size: 32,
          ),
          title: institution.nombre,
          subtitle: institution.email ?? institution.telefono ?? 'Sin contacto',
          badgeText: institution.activa ? 'Activa' : 'Inactiva',
          badgeColor: institution.activa ? colors.success : colors.error,
          contextActions: contextActions,
          onTap: () => _navigateToForm(context, institution: institution),
        );
      },
    );
  }

  void _handleMenuAction(String action, Institution institution, InstitutionProvider provider) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    switch (action) {
      case 'create_admin':
        _navigateToCreateInstitutionAdmin(institution);
        break;

      case 'edit':
        _navigateToForm(context, institution: institution);
        break;

      case 'toggle_status':
        final newStatus = !institution.activa;
        final success = await provider.updateInstitution(
          authProvider.accessToken!,
          institution.id,
          activa: newStatus,
        );

        if (success && mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                'InstituciÃ³n ${newStatus ? 'activada' : 'desactivada'} correctamente',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onPrimary),
              ),
              backgroundColor: Theme.of(context).colorScheme.primary,
            ),
          );
        }
        break;

      case 'delete':
        _showDeleteConfirmationDialog(institution, provider);
        break;
      case 'manage_admins':

        context.push('/institutions/${institution.id}/admins');
        break;
    }
  }

  void _showDeleteConfirmationDialog(Institution institution, InstitutionProvider provider) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Eliminar InstituciÃ³n', style: Theme.of(context).textTheme.headlineSmall),
        content: Text(
          'Â¿EstÃ¡s seguro de que quieres eliminar "${institution.nombre}"?\n\n'
          'Esta acciÃ³n no se puede deshacer.',
          style: Theme.of(context).textTheme.bodyMedium,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: Text('Cancelar', style: Theme.of(context).textTheme.labelLarge),
          ),
          TextButton(
            onPressed: () async {
              Navigator.of(context).pop();
              await _deleteInstitution(institution, provider);
            },
            style: TextButton.styleFrom(foregroundColor: Theme.of(context).colorScheme.error),
            child: Text('Eliminar', style: Theme.of(context).textTheme.labelLarge?.copyWith(color: Theme.of(context).colorScheme.error)),
          ),
        ],
      ),
    );
  }

  Future<void> _deleteInstitution(Institution institution, InstitutionProvider provider) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    final success = await provider.deleteInstitution(
      authProvider.accessToken!,
      institution.id,
    );

    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            'InstituciÃ³n eliminada correctamente',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onPrimary),
          ),
          backgroundColor: Theme.of(context).colorScheme.primary,
        ),
      );
    }
  }

  void _navigateToForm(BuildContext context, {Institution? institution}) {

    context.push('/institutions/form', extra: institution);
  }

  void _navigateToCreateInstitutionAdmin(Institution institution) {

    context.push('/institutions/create-admin', extra: institution);
  }
}
/* Fin lib\screens\institutions\institutions_list_screen.dart */

/* Inicio lib\screens\institutions\institution_admins_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../providers/user_provider.dart';
import '../../providers/auth_provider.dart';
import '../../providers/institution_provider.dart';
import '../../widgets/components/clarity_components.dart';
import '../../theme/theme_extensions.dart';
import '../../models/user.dart';
import 'create_institution_admin_screen.dart';

class InstitutionAdminsScreen extends StatefulWidget {
  final String institutionId;

  const InstitutionAdminsScreen({super.key, required this.institutionId});

  @override
  State<InstitutionAdminsScreen> createState() => _InstitutionAdminsScreenState();
}

class _InstitutionAdminsScreenState extends State<InstitutionAdminsScreen> {
  final ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadAdmins();
    });
  }

  Future<void> _loadAdmins() async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final userProvider = Provider.of<UserProvider>(context, listen: false);
    if (authProvider.accessToken != null) {
      await userProvider.loadAdminsByInstitution(authProvider.accessToken!, widget.institutionId);
    }
  }

  Future<void> _removeAdmin(User user) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final userProvider = Provider.of<UserProvider>(context, listen: false);

    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Remover Administrador'),
        content: Text('Â¿Deseas remover el rol de administrador a ${user.nombreCompleto}?'),
        actions: [
          TextButton(onPressed: () => Navigator.of(context).pop(false), child: const Text('Cancelar')),
          TextButton(onPressed: () => Navigator.of(context).pop(true), child: const Text('Remover')),
        ],
      ),
    );

    if (confirmed != true) return;

    if (authProvider.accessToken != null) {
      final success = await userProvider.removeAdminFromInstitution(authProvider.accessToken!, widget.institutionId, user.id);
      if (success && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Administrador removido correctamente')));
        await _loadAdmins();
      }
    }
  }

  void _openAddAdminSheet() {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (context) {
        final colors = context.colors;
        return Padding(
          padding: EdgeInsets.only(bottom: MediaQuery.of(context).viewInsets.bottom),
          child: Wrap(
            children: [
              ListTile(
                leading: Icon(Icons.person_add, color: colors.primary),
                title: const Text('Crear Nuevo Administrador'),
                onTap: () {
                  Navigator.of(context).pop();
                  final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);
                  final institution = institutionProvider.institutions.firstWhere((i) => i.id == widget.institutionId);
                  Navigator.push(
                    context,
                    MaterialPageRoute(builder: (_) => CreateInstitutionAdminScreen(institution: institution)),
                  ).then((_) => _loadAdmins());
                },
              ),
              ListTile(
                leading: Icon(Icons.person_search, color: colors.primary),
                title: const Text('Asignar Usuario Existente'),
                onTap: () {
                  Navigator.of(context).pop();
                  _showAssignExistingUserDialog();
                },
              ),
            ],
          ),
        );
      },
    );
  }

  void _showAssignExistingUserDialog() {
    showDialog(
      context: context,
      builder: (context) => AssignExistingUserDialog(institutionId: widget.institutionId, onAssigned: () async {
        await _loadAdmins();
      }),
    );
  }

  @override
  Widget build(BuildContext context) {
    final userProvider = Provider.of<UserProvider>(context);

    return Scaffold(
      backgroundColor: context.colors.background,
      appBar: AppBar(
        backgroundColor: context.colors.surface,
        elevation: 0,
        title: Text(
          'Administradores de InstituciÃ³n',
          style: context.textStyles.headlineMedium,
        ),
        centerTitle: false,
      ),
      body: RefreshIndicator(
        onRefresh: _loadAdmins,
        child: CustomScrollView(
          controller: _scrollController,
          slivers: [
            if (userProvider.isLoading && userProvider.users.isEmpty)
              const SliverFillRemaining(
                child: Center(child: CircularProgressIndicator()),
              )
            else if (userProvider.hasError)
              SliverFillRemaining(
                child: ClarityEmptyState(
                  icon: Icons.error_outline,
                  title: 'Error al cargar administradores',
                  subtitle: userProvider.errorMessage ?? 'Error desconocido',
                  action: ElevatedButton.icon(
                    onPressed: _loadAdmins,
                    icon: const Icon(Icons.refresh),
                    label: const Text('Reintentar'),
                  ),
                ),
              )
            else if (userProvider.users.isEmpty)
              SliverFillRemaining(
                child: ClarityEmptyState(
                  icon: Icons.group_off,
                  title: 'No hay administradores',
                  subtitle: 'Agrega administradores a esta instituciÃ³n',
                ),
              )
            else
              SliverPadding(
                padding: EdgeInsets.all(context.spacing.screenPadding),
                sliver: SliverList(
                  delegate: SliverChildBuilderDelegate(
                    (context, index) {
                      if (index >= userProvider.users.length) {
                        if (userProvider.hasMoreData && !userProvider.isLoadingMore) {
                          WidgetsBinding.instance.addPostFrameCallback((_) {
                            final authProvider = Provider.of<AuthProvider>(context, listen: false);
                            if (authProvider.accessToken != null && userProvider.hasMoreData && !userProvider.isLoadingMore) {
                              userProvider.loadUsersByInstitution(authProvider.accessToken!, widget.institutionId);
                            }
                          });
                        }
                        return userProvider.isLoadingMore
                          ? const Center(
                              child: Padding(
                                padding: EdgeInsets.all(16.0),
                                child: CircularProgressIndicator(),
                              ),
                            )
                          : const SizedBox.shrink();
                      }

                      final user = userProvider.users[index];
                      return Padding(
                        padding: EdgeInsets.only(bottom: context.spacing.md),
                        child: _buildAdminCard(user, context),
                      );
                    },
                    childCount: userProvider.users.length + (userProvider.hasMoreData ? 1 : 0),
                  ),
                ),
              ),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _openAddAdminSheet,
        backgroundColor: context.colors.primary,
        child: Icon(
          Icons.add,
          color: context.colors.getTextColorForBackground(context.colors.primary),
        ),
      ),
    );
  }

  Widget _buildAdminCard(User user, BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return ClarityCard(
      title: Row(
        children: [
          CircleAvatar(
            backgroundColor: colors.primary.withValues(alpha: 0.1),
            child: Text(
              user.nombres.isNotEmpty ? user.nombres[0].toUpperCase() : '?',
              style: textStyles.bodyMedium.withColor(colors.primary),
            ),
          ),
          SizedBox(width: spacing.sm),
          Expanded(
            child: Text(
              user.nombreCompleto,
              style: textStyles.titleMedium.bold,
            ),
          ),
        ],
      ),
      subtitle: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.email, size: 16, color: colors.textSecondary),
              SizedBox(width: spacing.xs),
              Expanded(
                child: Text(
                  user.email,
                  style: textStyles.bodySmall,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ],
          ),
          if (user.telefono != null) ...[
            SizedBox(height: spacing.xs),
            Row(
              children: [
                Icon(Icons.phone, size: 16, color: colors.textSecondary),
                SizedBox(width: spacing.xs),
                Expanded(
                  child: Text(
                    user.telefono!,
                    style: textStyles.bodySmall,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ],
            ),
          ],
        ],
      ),
      trailing: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          ClarityActionButton(
            icon: Icons.key,
            tooltip: 'Cambiar contraseÃ±a',
            color: colors.primary,
            onPressed: () => _showChangePasswordDialog(context, user),
          ),
          SizedBox(width: spacing.sm),
          ClarityActionButton(
            icon: Icons.remove_circle,
            tooltip: 'Remover administrador',
            color: colors.error,
            onPressed: () => _removeAdmin(user),
          ),
        ],
      ),
    );
  }

  void _showChangePasswordDialog(BuildContext context, User user) {
    showDialog<void>(
      context: context,
      barrierDismissible: false,
      builder: (context) => _ChangePasswordDialog(user: user, onSaved: () async {
        await _loadAdmins();
      }),
    );
  }

}

class _ChangePasswordDialog extends StatefulWidget {
  final User user;
  final VoidCallback? onSaved;

  const _ChangePasswordDialog({required this.user, this.onSaved});

  @override
  State<_ChangePasswordDialog> createState() => _ChangePasswordDialogState();
}

class _ChangePasswordDialogState extends State<_ChangePasswordDialog> {
  final _formKey = GlobalKey<FormState>();
  final TextEditingController _newPasswordController = TextEditingController();
  final TextEditingController _confirmPasswordController = TextEditingController();
  bool _isSaving = false;

  @override
  void dispose() {
    _newPasswordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  Future<void> _save() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isSaving = true);

    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final userProvider = Provider.of<UserProvider>(context, listen: false);

    try {
      if (authProvider.accessToken == null) throw Exception('No hay sesiÃ³n activa');

      final success = await userProvider.changeUserPassword(
        authProvider.accessToken!,
        widget.user.id,
        _newPasswordController.text.trim(),
      );

      if (success && mounted) {
        Navigator.of(context).pop();
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('ContraseÃ±a de ${widget.user.nombreCompleto} cambiada correctamente')));
        widget.onSaved?.call();
      } else {
        if (mounted) {
          setState(() => _isSaving = false);
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Error al cambiar la contraseÃ±a')));
        }
      }
    } catch (e) {
      if (mounted) {
        setState(() => _isSaving = false);
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error: ${e.toString()}')));
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final spacing = context.spacing;

    return AlertDialog(
      title: Text('Cambiar contraseÃ±a - ${widget.user.nombreCompleto}'),
      content: Form(
        key: _formKey,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextFormField(
              controller: _newPasswordController,
              obscureText: true,
              decoration: const InputDecoration(labelText: 'Nueva contraseÃ±a'),
              validator: (value) {
                if (value == null || value.trim().isEmpty) return 'La contraseÃ±a es requerida';
                if (value.trim().length < 8) return 'La contraseÃ±a debe tener al menos 8 caracteres';
                return null;
              },
            ),
            SizedBox(height: spacing.md),
            TextFormField(
              controller: _confirmPasswordController,
              obscureText: true,
              decoration: const InputDecoration(labelText: 'Confirmar contraseÃ±a'),
              validator: (value) {
                if (value == null || value.trim().isEmpty) return 'La confirmaciÃ³n es requerida';
                if (value.trim() != _newPasswordController.text.trim()) return 'Las contraseÃ±as no coinciden';
                return null;
              },
            ),
          ],
        ),
      ),
      actions: [
        TextButton(onPressed: _isSaving ? null : () => Navigator.of(context).pop(), child: const Text('Cancelar')),
        ElevatedButton(
          onPressed: _isSaving ? null : _save,
          child: _isSaving ? const SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2,)) : const Text('Guardar'),
        ),
      ],
    );
  }
}

class AssignExistingUserDialog extends StatefulWidget {
  final String institutionId;
  final VoidCallback? onAssigned;

  const AssignExistingUserDialog({super.key, required this.institutionId, this.onAssigned});

  @override
  State<AssignExistingUserDialog> createState() => _AssignExistingUserDialogState();
}

class _AssignExistingUserDialogState extends State<AssignExistingUserDialog> {
  final _searchController = TextEditingController();
  List<User> _results = [];
  bool _isSearching = false;

  Future<void> _search(String query) async {
    setState(() => _isSearching = true);
    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final userProvider = Provider.of<UserProvider>(context, listen: false);
      final users = await userProvider.searchUsersRemote(authProvider.accessToken!, search: query, limit: 10);
      final response = users;
      if (response != null) {
        final candidates = response.where((u) => u.instituciones.every((inst) => !inst.activo || inst.rolEnInstitucion != 'admin')).toList();
        setState(() => _results = candidates);
      }
    } catch (e) {
      debugPrint('Error buscando usuarios: $e');
    } finally {
      setState(() => _isSearching = false);
    }
  }

  Future<void> _assign(User user) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final userProvider = Provider.of<UserProvider>(context, listen: false);
    if (authProvider.accessToken != null) {
      final success = await userProvider.assignAdminToInstitution(authProvider.accessToken!, widget.institutionId, user.id);
      if (success && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Administrador asignado correctamente')));
        widget.onAssigned?.call();
        Navigator.of(context).pop();
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Asignar Usuario Existente'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          TextField(
            controller: _searchController,
            decoration: const InputDecoration(hintText: 'Buscar por nombre o email'),
            onSubmitted: _search,
          ),
          const SizedBox(height: 12),
          if (_isSearching) const CircularProgressIndicator(),
          if (!_isSearching && _results.isNotEmpty)
            SizedBox(
              height: 200,
              child: ListView.builder(
                itemCount: _results.length,
                itemBuilder: (context, index) {
                  final user = _results[index];
                  return ListTile(
                    title: Text(user.nombreCompleto),
                    subtitle: Text(user.email),
                    trailing: TextButton(onPressed: () => _assign(user), child: const Text('Asignar')),
                  );
                },
              ),
            ),
        ],
      ),
      actions: [
        TextButton(onPressed: () => Navigator.of(context).pop(), child: const Text('Cerrar')),
      ],
    );
  }
}

/* Fin lib\screens\institutions\institution_admins_screen.dart */

/* Inicio lib\screens\institutions\institution_form_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../models/institution.dart';
import '../../providers/auth_provider.dart';
import '../../providers/institution_provider.dart';
import '../../theme/theme_extensions.dart';
import 'form_steps/index.dart';

class InstitutionFormScreen extends StatefulWidget {
  final Institution? institution;

  const InstitutionFormScreen({super.key, this.institution});

  @override
  State<InstitutionFormScreen> createState() => _InstitutionFormScreenState();
}

class _InstitutionFormScreenState extends State<InstitutionFormScreen> {
  final _formKey = GlobalKey<FormState>();
  int _currentStep = 0;
  final _nombreController = TextEditingController();
  final _direccionController = TextEditingController();
  final _telefonoController = TextEditingController();
  final _emailController = TextEditingController();

  bool _activa = true;
  bool _isLoading = false;

  bool get isEditing => widget.institution != null;

  @override
  void initState() {
    super.initState();
    if (widget.institution != null) {
      _loadInstitutionData();
    }
  }

  @override
  void dispose() {
    _nombreController.dispose();
    _direccionController.dispose();
    _telefonoController.dispose();
    _emailController.dispose();
    super.dispose();
  }

  void _loadInstitutionData() {
    final institution = widget.institution!;
    _nombreController.text = institution.nombre;
    _direccionController.text = institution.direccion ?? '';
    _telefonoController.text = institution.telefono ?? '';
    _emailController.text = institution.email ?? '';
    _activa = institution.activa;
  }

  Future<void> _saveInstitution() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);

      final institutionData = {
        'nombre': _nombreController.text.trim(),
        'direccion': _direccionController.text.trim(),
        'telefono': _telefonoController.text.trim(),
        'email': _emailController.text.trim(),
        'activa': _activa,
      };

      bool success;
      if (widget.institution == null) {
        success = await institutionProvider.createInstitution(
          authProvider.accessToken!,
          institutionData,
        );
      } else {
        success = await institutionProvider.updateInstitution(
          authProvider.accessToken!,
          widget.institution!.id,
          nombre: institutionData['nombre'] as String?,
          direccion: institutionData['direccion'] as String?,
          telefono: institutionData['telefono'] as String?,
          email: institutionData['email'] as String?,
          activa: institutionData['activa'] as bool?,
        );
      }

      if (success && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              widget.institution == null
                  ? 'InstituciÃ³n creada correctamente'
                  : 'InstituciÃ³n actualizada correctamente',
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onPrimary),
            ),
            backgroundColor: Theme.of(context).colorScheme.primary,
          ),
        );
        context.pop();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              'Error: ${e.toString()}',
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onError),
            ),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final spacing = context.spacing;
    final colors = context.colors;
    final textStyles = context.textStyles;
    final title = isEditing ? 'Editar InstituciÃ³n' : 'Nueva InstituciÃ³n';

    return Scaffold(
      backgroundColor: colors.background,
      appBar: AppBar(
        title: Text(title),
        backgroundColor: colors.primary,
        foregroundColor: colors.white,
      ),
      body: Form(
        key: _formKey,
        child: Stepper(
          currentStep: _currentStep,
          onStepContinue: _onStepContinue,
          onStepCancel: _onStepCancel,
          onStepTapped: (step) => setState(() => _currentStep = step),
          controlsBuilder: (context, details) {
            final isLastStep = details.currentStep == 2

            return Padding(
              padding: EdgeInsets.only(top: spacing.lg),
              child: Row(
                children: [
                  if (details.currentStep > 0) ...[
                    Expanded(
                      child: OutlinedButton(
                        onPressed: _isLoading ? null : details.onStepCancel,
                        style: OutlinedButton.styleFrom(
                          padding: EdgeInsets.symmetric(vertical: spacing.md),
                          side: BorderSide(color: colors.primary),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(spacing.borderRadius),
                          ),
                        ),
                        child: Text(
                          'Anterior',
                          style: textStyles.button.withColor(colors.primary),
                        ),
                      ),
                    ),
                    SizedBox(width: spacing.md),
                  ],
                  Expanded(
                    child: ElevatedButton(
                      key: const Key('formSaveButton'),
                      onPressed: _isLoading ? null : details.onStepContinue,
                      style: ElevatedButton.styleFrom(
                        padding: EdgeInsets.symmetric(vertical: spacing.md),
                        backgroundColor: colors.primary,
                        foregroundColor: colors.white,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(spacing.borderRadius),
                        ),
                      ),
                      child: _isLoading
                          ? const SizedBox(
                              height: 20,
                              width: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                              ),
                            )
                          : Text(
                              isLastStep ? (isEditing ? 'Actualizar' : 'Crear') : 'Siguiente',
                              style: textStyles.button.withColor(colors.white),
                            ),
                    ),
                  ),
                  if (details.currentStep == 0) ...[
                    SizedBox(width: spacing.md),
                    Expanded(
                      child: OutlinedButton(
                        onPressed: _isLoading ? null : () => context.pop(),
                        style: OutlinedButton.styleFrom(
                          padding: EdgeInsets.symmetric(vertical: spacing.md),
                          side: BorderSide(color: colors.error),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(spacing.borderRadius),
                          ),
                        ),
                        child: Text(
                          'Cancelar',
                          style: textStyles.button.withColor(colors.error),
                        ),
                      ),
                    ),
                  ],
                ],
              ),
            );
          },
          steps: [
            Step(
              title: const Text('InformaciÃ³n'),
              subtitle: const Text('Datos bÃ¡sicos'),
              content: InstitutionBasicInfoStep(
                nombreController: _nombreController,
                emailController: _emailController,
              ),
              isActive: _currentStep >= 0,
              state: _currentStep > 0 ? StepState.complete : StepState.indexed,
            ),
            Step(
              title: const Text('Contacto'),
              subtitle: const Text('UbicaciÃ³n y telÃ©fono'),
              content: InstitutionContactStep(
                direccionController: _direccionController,
                telefonoController: _telefonoController,
              ),
              isActive: _currentStep >= 1,
              state: _currentStep > 1 ? StepState.complete : (_currentStep == 1 ? StepState.indexed : StepState.disabled),
            ),
            Step(
              title: const Text('ConfiguraciÃ³n'),
              subtitle: const Text('Estado'),
              content: InstitutionConfigStep(
                activa: _activa,
                onActivaChanged: (value) => setState(() => _activa = value),
                isEditMode: isEditing,
              ),
              isActive: _currentStep >= 2,
              state: _currentStep == 2 ? StepState.indexed : StepState.disabled,
            ),
          ],
        ),
      ),
    );
  }

  void _onStepContinue() {
    if (!_formKey.currentState!.validate()) {
      return;
    }

    if (_currentStep < 2) {
      setState(() => _currentStep++);
    } else {
      _saveInstitution();
    }
  }

  void _onStepCancel() {
    if (_currentStep > 0) {
      setState(() => _currentStep--);
    }
  }
}
/* Fin lib\screens\institutions\institution_form_screen.dart */

/* Inicio lib\screens\institution_selection_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../utils/responsive_utils.dart';
import '../models/institution.dart';

class InstitutionSelectionScreen extends StatefulWidget {
  const InstitutionSelectionScreen({super.key});

  @override
  State<InstitutionSelectionScreen> createState() => _InstitutionSelectionScreenState();
}

class _InstitutionSelectionScreenState extends State<InstitutionSelectionScreen> {
  String? _selectedInstitutionId;
  bool _isLoading = false;

  Map<String, dynamic> _getResponsiveValues(BoxConstraints constraints) {
    return ResponsiveUtils.getResponsiveValues(constraints);
  }

  Widget _buildMainTitle(Map<String, dynamic> responsive) {
    final titleFontSize = responsive['titleFontSize'] as double;

    return Builder(
      builder: (context) {
        final colors = context.colors;
        return Text(
          'Seleccionar InstituciÃ³n',
          style: TextStyle(
            fontSize: titleFontSize,
            fontWeight: FontWeight.bold,
            color: colors.textPrimary,
          ),
          textAlign: TextAlign.center,
        );
      },
    );
  }

  Widget _buildSubtitle(Map<String, dynamic> responsive, Color textMuted) {
    final subtitleFontSize = responsive['subtitleFontSize'] as double;

    return Text(
      'Elija la instituciÃ³n con la que desea trabajar',
      style: TextStyle(
        color: textMuted,
        fontSize: subtitleFontSize,
      ),
      textAlign: TextAlign.center,
    );
  }

  Widget _buildInstitutionList(List<Institution> institutions, Map<String, dynamic> responsive) {
    final bodyFontSize = responsive['bodyFontSize'] as double;

    return ListView.builder(
      shrinkWrap: true,
      itemCount: institutions.length,
      itemBuilder: (context, index) {
        final institution = institutions[index];
        final isSelected = _selectedInstitutionId == institution.id;

        return Card(
          margin: const EdgeInsets.symmetric(vertical: 8),
          color: isSelected ? Theme.of(context).colorScheme.primaryContainer : Theme.of(context).colorScheme.surface,
          child: ListTile(
            leading: Radio<String>(
              value: institution.id,
              groupValue: _selectedInstitutionId,
              onChanged: (value) {
                setState(() {
                  _selectedInstitutionId = value;
                });
              },
            ),
            title: Text(
              institution.name,
              style: TextStyle(
                fontSize: bodyFontSize,
                color: isSelected ? Theme.of(context).colorScheme.onPrimaryContainer : Theme.of(context).colorScheme.onSurface,
              ),
            ),
            subtitle: institution.role != null
                ? Text('Rol: ${institution.role}', style: TextStyle(fontSize: bodyFontSize * 0.9))
                : null,
            onTap: () {
              setState(() {
                _selectedInstitutionId = institution.id;
              });
            },
          ),
        );
      },
    );
  }

  Widget _buildContinueButton(Map<String, dynamic> responsive) {
    final buttonWidth = responsive['buttonWidth'] as double;

    return SizedBox(
      width: buttonWidth,
      child: ElevatedButton(
        onPressed: _isLoading || _selectedInstitutionId == null ? null : _continue,
        child: Text(_isLoading ? 'Continuando...' : 'Continuar'),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final authProvider = Provider.of<AuthProvider>(context);
    final institutions = authProvider.institutions;

    if (institutions == null || institutions.isEmpty) {
      return const Scaffold(
        body: Center(
          child: Text('No hay instituciones disponibles'),
        ),
      );
    }

    return Scaffold(
      backgroundColor: colors.background,
      body: SafeArea(
        child: ResponsiveUtils.buildResponsiveContainer(
          context: context,
          child: SingleChildScrollView(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                LayoutBuilder(
                  builder: (context, constraints) {
                    final responsive = _getResponsiveValues(constraints);
                    final elementSpacing = responsive['elementSpacing'] as double;

                    return Column(
                      children: [
                        _buildMainTitle(responsive),
                        SizedBox(height: elementSpacing),

                        _buildSubtitle(responsive, colors.textMuted),
                        SizedBox(height: elementSpacing * 1.5),

                        _buildInstitutionList(institutions, responsive),
                        SizedBox(height: elementSpacing * 2),

                        _buildContinueButton(responsive),
                      ],
                    );
                  },
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _continue() async {
    if (_selectedInstitutionId == null) return;

    setState(() {
      _isLoading = true;
    });
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    authProvider.selectInstitution(_selectedInstitutionId!);
  }
}
/* Fin lib\screens\institution_selection_screen.dart */

/* Inicio lib\screens\login_screen.dart */
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../utils/responsive_utils.dart';

class LoginScreen extends StatefulWidget {
  const LoginScreen({super.key});

  @override
  State<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {

  final _emailController = TextEditingController(text: 'superadmin@asistapp.com');
  final _passwordController = TextEditingController(text: 'Admin123!');
  bool _isLoading = false;
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Widget _buildMainTitle(Map<String, dynamic> responsive) {
    final titleFontSize = responsive['titleFontSize'] as double;

    return Builder(
      builder: (context) {
        final colors = context.colors;
        return Text(
          'AsistApp',
          key: const Key('appTitle'),
          style: TextStyle(
            fontSize: titleFontSize,
            fontWeight: FontWeight.bold,
            color: colors.textPrimary,
          ),
          textAlign: TextAlign.center,
        );
      },
    );
  }

  Widget _buildSubtitle(Map<String, dynamic> responsive, Color textMuted) {
    final subtitleFontSize = responsive['subtitleFontSize'] as double;

    return Text(
      'Sistema de Registro de Asistencia Escolar',
      style: TextStyle(
        color: textMuted,
        fontSize: subtitleFontSize,
      ),
      textAlign: TextAlign.center,
    );
  }

  Widget _buildEmailField() {
    return TextFormField(
      key: const Key('emailField'),
      controller: _emailController,
      decoration: const InputDecoration(
        labelText: 'Correo electrÃ³nico',
      ),
      keyboardType: TextInputType.emailAddress,
    );
  }

  Widget _buildPasswordField() {
    return TextFormField(
      key: const Key('passwordField'),
      controller: _passwordController,
      decoration: const InputDecoration(
        labelText: 'ContraseÃ±a',
      ),
      obscureText: true,
    );
  }

  Widget _buildLoginButton(Map<String, dynamic> responsive) {
    final buttonWidth = responsive['buttonWidth'] as double;

    return SizedBox(
      width: buttonWidth,
      child: ElevatedButton(
        key: const Key('loginButton'),
        onPressed: _isLoading ? null : _login,
        child: Text(_isLoading ? 'Iniciando sesiÃ³n...' : 'Iniciar SesiÃ³n'),
      ),
    );
  }

  Widget _buildTestUsersSection(Map<String, dynamic> responsive) {
    final bodyFontSize = responsive['bodyFontSize'] as double;

    return Builder(
      builder: (context) {
        final colors = context.colors;
        return Column(
          children: [
            const SizedBox(height: 32),
            Text(
              'Usuarios de Prueba (Desarrollo)',
              style: TextStyle(
                fontSize: bodyFontSize,
                fontWeight: FontWeight.bold,
                color: colors.textSecondary,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 16),

            _buildUserCategory(
              'ðŸ‘‘ Super Administradores',
              [
                _buildTestUserButton('Super Admin', 'superadmin@asistapp.com', 'Admin123!', 'super_admin', 'GestiÃ³n de instituciones y admins.', responsive),
              ],
              responsive,
            ),

            _buildUserCategory(
              'ðŸ‘¨â€ðŸ’¼ Administradores de InstituciÃ³n',
              [
                _buildTestUserButton('Admin San JosÃ©', 'admin@sanjose.edu', 'SanJose123!', 'admin_institucion', 'Probar gestiÃ³n acadÃ©mica (grupos, materias, horarios).', responsive),
                _buildTestUserButton('Admin Santander', 'admin@santander.edu', 'Santander123!', 'admin_institucion', 'Probar en instituciÃ³n con menos datos.', responsive),
                _buildTestUserButton('Admin Multi-Sede', 'multiadmin@asistapp.com', 'Multi123!', 'admin_institucion', 'Probar pantalla de selecciÃ³n de instituciÃ³n.', responsive),
              ],
              responsive,
            ),

            _buildUserCategory(
              'ðŸ‘¨â€ðŸ« Profesores',
              [
                _buildTestUserButton('Juan PÃ©rez', 'juan.perez@sanjose.edu', 'Prof123!', 'profesor', 'San JosÃ© - Tiene clases hoy para probar el dashboard.', responsive),
                _buildTestUserButton('Laura GÃ³mez', 'laura.gomez@sanjose.edu', 'Prof123!', 'profesor', 'San JosÃ© - Tiene clases en diferentes grupos.', responsive),
                _buildTestUserButton('Profe Sin Clases', 'vacio.profe@sanjose.edu', 'Prof123!', 'profesor', 'San JosÃ© - Probar dashboard sin clases asignadas.', responsive),
                _buildTestUserButton('Carlos DÃ­az', 'carlos.diaz@santander.edu', 'Prof123!', 'profesor', 'Santander - Probar dashboard en otra instituciÃ³n.', responsive),
              ],
              responsive,
            ),

            _buildUserCategory(
              'ðŸ‘¨â€ðŸŽ“ Estudiantes',
              [
                _buildTestUserButton('Santiago Mendoza', 'santiago.mendoza@sanjose.edu', 'Est123!', 'estudiante', 'San JosÃ© - Asignado al Grupo 10-A.', responsive),
                _buildTestUserButton('Mateo Castro', 'mateo.castro@sanjose.edu', 'Est123!', 'estudiante', 'San JosÃ© - Asignado al Grupo 11-B.', responsive),
                _buildTestUserButton('SofÃ­a NÃºÃ±ez', 'sofia.nunez@santander.edu', 'Est123!', 'estudiante', 'Santander - Asignada al Grupo 6-1.', responsive),
              ],
              responsive,
            ),
          ],
        );
      },
    );
  }

  Widget _buildUserCategory(String title, List<Widget> buttons, Map<String, dynamic> responsive) {
    return Builder(
      builder: (context) {
        final colors = context.colors;
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
              child: Text(
                title,
                style: TextStyle(
                  fontSize: responsive['bodyFontSize'] as double,
                  fontWeight: FontWeight.bold,
                  color: colors.textPrimary,
                ),
              ),
            ),
            Wrap(
              spacing: 8,
              runSpacing: 8,
              alignment: WrapAlignment.start,
              children: buttons,
            ),
            const SizedBox(height: 8),
          ],
        );
      },
    );
  }

  Widget _buildTestUserButton(
    String name,
    String email,
    String password,
    String role,
    String institutions,
    Map<String, dynamic> responsive,
  ) {
    final isSmallScreen = responsive['isSmallScreen'] as bool;
    final buttonWidth = isSmallScreen ? 140.0 : 160.0;

    return Builder(
      builder: (context) {
        final colors = context.colors;
        final textStyles = context.textStyles;

        return SizedBox(
          width: buttonWidth,
          child: OutlinedButton(
            onPressed: () {
              setState(() {
                _emailController.text = email;
                _passwordController.text = password;
                _errorMessage = null;
              });
            },
            style: OutlinedButton.styleFrom(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 12),
              side: BorderSide(color: colors.primary.withValues(alpha: 0.5)),
            ),
            child: Column(
              children: [
                Text(
                  name,
                  style: textStyles.labelMedium.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 2),
                Text(
                  role,
                  style: textStyles.bodySmall,
                  textAlign: TextAlign.center,
                ),
                Text(
                  institutions,
                  style: textStyles.bodySmall.copyWith(
                    fontStyle: FontStyle.italic,
                    color: colors.textMuted,
                  ),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildErrorMessage() {
    if (_errorMessage == null) return const SizedBox.shrink();

    return Builder(
      builder: (context) {
        final textStyles = context.textStyles;
        final colors = context.colors;
        return Text(
          _errorMessage!,
          style: textStyles.bodyMedium.copyWith(color: colors.error),  // Usar estilo del tema
          textAlign: TextAlign.center,
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;

    return Scaffold(
      backgroundColor: colors.background,
      body: SafeArea(
        child: LayoutBuilder(
          builder: (context, constraints) {
            final responsive = ResponsiveUtils.getResponsiveValues(constraints);

            return SingleChildScrollView(
              child: ConstrainedBox(
                constraints: BoxConstraints(maxWidth: responsive['maxWidth']),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    Padding(
                      padding: EdgeInsets.symmetric(
                        horizontal: responsive['horizontalPadding'],
                        vertical: responsive['verticalPadding'],
                      ),
                      child: Column(
                        children: [
                          _buildMainTitle(responsive),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildSubtitle(responsive, colors.textMuted),
                          SizedBox(height: responsive['elementSpacing'] * 1.5),

                          _buildEmailField(),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildPasswordField(),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildErrorMessage(),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildLoginButton(responsive),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildTestUsersSection(responsive),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            );
          },
        ),
      ),
    );
  }

  Future<void> _login() async {
    if (_emailController.text.isEmpty ||
        _passwordController.text.isEmpty) {
      setState(() {
        _errorMessage = 'Por favor complete todos los campos';
      });
      return;
    }

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final success = await authProvider.login(
        _emailController.text.trim(),
        _passwordController.text,
      );

      if (success) {
        debugPrint('Login exitoso, AuthWrapper manejarÃ¡ la navegaciÃ³n');
      } else {
        setState(() {
          _errorMessage = 'Credenciales incorrectas';
        });
      }
    } catch (e) {
      String raw = e.toString();
      const exceptionPrefix = 'Exception: ';
      if (raw.startsWith(exceptionPrefix)) {
        raw = raw.substring(exceptionPrefix.length);
      }

      String messageToShow = raw;
      try {
        final parsed = jsonDecode(raw);
        if (parsed is Map<String, dynamic>) {
          messageToShow = parsed['message'] ?? parsed['error'] ?? (parsed['data'] is Map ? (parsed['data']['message'] ?? parsed['data']['error']) : null) ?? raw;
        }
      } catch (_) {
      }

      setState(() {
        _errorMessage = messageToShow;
      });
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }
}
/* Fin lib\screens\login_screen.dart */

/* Inicio lib\screens\student_dashboard.dart */
import 'package:flutter/material.dart';
import 'package:provider/Provider.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../widgets/components/index.dart';
Widget _buildMenuActionItem(
  BuildContext context, {
  required IconData icon,
  required String label,
  required String value,
  required Color color,
  required VoidCallback onTap,
  bool isFirst = false,
  bool isLast = false,
}) {
  final textStyles = context.textStyles;
  final spacing = context.spacing;
  final colors = context.colors;

  return Material(
    color: Colors.transparent,
    child: InkWell(
      onTap: onTap,
      child: Padding(
        padding: EdgeInsets.symmetric(
          horizontal: spacing.lg,
          vertical: spacing.sm,
        ),
        child: Row(
          children: [
              Container(
                padding: EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: color.withValues(alpha: 0.12),
                  borderRadius: BorderRadius.circular(8),
                ),
              child: Icon(icon, color: color, size: 20),
            ),
            SizedBox(width: spacing.md),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    label,
                    style: textStyles.bodyMedium.copyWith(
                      fontWeight: FontWeight.w600,
                      color: colors.textPrimary,
                    ),
                  ),
                  Text(
                    value,
                    style: textStyles.bodySmall.copyWith(
                      color: color,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ],
              ),
            ),
            Icon(
              Icons.arrow_forward_ios_rounded,
              size: 16,
              color: colors.textSecondary,
            ),
          ],
        ),
      ),
    ),
  );
}

class StudentDashboard extends StatelessWidget {
  const StudentDashboard({super.key});

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    final user = authProvider.user;
    final userName = user?['nombres'] ?? 'Usuario';

    return SingleChildScrollView(
      padding: EdgeInsets.all(spacing.lg),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
            Text('Â¡Hola, $userName!', style: textStyles.displayMedium),
            SizedBox(height: spacing.sm),
            Text(
              'Bienvenido al panel estudiantil.',
              style: textStyles.bodyLarge.copyWith(color: colors.textSecondary),
            ),
            SizedBox(height: spacing.xl),
            _buildCompactStatsBar(context),

            SizedBox(height: spacing.xl),
            Text('Acciones Principales', style: textStyles.headlineSmall),
            SizedBox(height: spacing.md),
            Container(
              decoration: BoxDecoration(
                color: colors.surface,
                borderRadius: BorderRadius.circular(spacing.borderRadius),
                border: Border.all(color: colors.borderLight),
              ),
              child: Column(
                children: [
                  _buildMenuActionItem(
                    context,
                    icon: Icons.qr_code_2_rounded,
                    label: 'Mi CÃ³digo QR',
                    value: 'Para registrar asistencia',
                    color: colors.primary,
                    onTap: () => context.go('/student/qr'),
                    isFirst: true,
                  ),
                  Divider(height: 0, indent: spacing.lg, endIndent: spacing.lg),
                  _buildMenuActionItem(
                    context,
                    icon: Icons.calendar_today_outlined,
                    label: 'Mi Horario',
                    value: 'Ver mis clases',
                    color: const Color(0xFF06B6D4),
                    onTap: () => context.go('/student/schedule'),
                  ),
                  Divider(height: 0, indent: spacing.lg, endIndent: spacing.lg),
                  _buildMenuActionItem(
                    context,
                    icon: Icons.check_circle_outline_rounded,
                    label: 'Mi Asistencia',
                    value: 'Historial y estadÃ­sticas',
                    color: colors.success,
                    onTap: () => context.go('/student/attendance'),
                  ),
                  Divider(height: 0, indent: spacing.lg, endIndent: spacing.lg),
                  _buildMenuActionItem(
                    context,
                    icon: Icons.notifications_outlined,
                    label: 'Notificaciones',
                    value: 'Ver mensajes',
                    color: colors.warning,
                    onTap: () => context.go('/student/notifications'),
                    isLast: true,
                  ),
                ],
              ),
            ),
          ],
        ),
      );
  }
  Widget _buildCompactStatsBar(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;

    return Container(
      padding: EdgeInsets.symmetric(horizontal: spacing.sm, vertical: spacing.md),
      decoration: BoxDecoration(
        color: colors.surface,
        borderRadius: BorderRadius.circular(spacing.borderRadius),
        border: Border.all(color: colors.borderLight),
      ),
      child: SingleChildScrollView
        scrollDirection: Axis.horizontal,
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceAround,
          children: [
            ClarityCompactStat(
              value: '85%', // Placeholder - se puede conectar a datos reales
              title: 'Asistencia',
              icon: Icons.check_circle,
              color: colors.success,
            ),
            SizedBox(width: spacing.lg),
            ClarityCompactStat(
              value: '4.2', // Placeholder - se puede conectar a datos reales
              title: 'Promedio',
              icon: Icons.grade,
              color: colors.primary,
            ),
            SizedBox(width: spacing.lg),
            ClarityCompactStat(
              value: '12', // Placeholder - se puede conectar a datos reales
              title: 'Materias',
              icon: Icons.book,
              color: colors.info,
            ),
          ],
        ),
      ),
    );
  }
}
/* Fin lib\screens\student_dashboard.dart */

/* Inicio lib\screens\super_admin_dashboard.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../providers/institution_provider.dart';
import '../providers/user_provider.dart';
import '../theme/theme_extensions.dart';
import '../widgets/components/index.dart';

class SuperAdminDashboard extends StatefulWidget {
  const SuperAdminDashboard({super.key});

  @override
  State<SuperAdminDashboard> createState() => _SuperAdminDashboardState();
}

class _SuperAdminDashboardState extends State<SuperAdminDashboard> {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      try {
        final authProvider = Provider.of<AuthProvider>(context, listen: false);
        final userProvider = Provider.of<UserProvider>(context, listen: false);
        final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);

        final token = authProvider.accessToken;
        if (token != null) {
          await userProvider.loadUsers(token);
          await institutionProvider.loadInstitutions(token);
        }
      } catch (e) {
        debugPrint('SuperAdminDashboard init load error: $e');
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final institutionProvider = Provider.of<InstitutionProvider>(context);
    final userProvider = Provider.of<UserProvider>(context, listen: false);

    final user = authProvider.user;
    final userName = user?['nombres'] ?? 'Usuario';

    return LayoutBuilder(
      builder: (context, constraints) {
          final isDesktop = constraints.maxWidth > 1024;
          final isTablet = constraints.maxWidth > 600;
          final columnCount = isDesktop ? 4 : (isTablet ? 3 : 2);
          return isDesktop
              ? _buildDesktopLayout(
                  context,
                  userName,
                  institutionProvider,
                  userProvider,
                  columnCount,
                )
              : _buildMobileLayout(
                  context,
                  userName,
                  institutionProvider,
                  userProvider,
                  columnCount,
                );
        },
    );
  }
  Widget _buildDesktopLayout(
    BuildContext context,
    String userName,
    InstitutionProvider institutionProvider,
    UserProvider userProvider,
    int columnCount,
  ) {
    final spacing = context.spacing;

    return SingleChildScrollView(
      child: Padding(
        padding: EdgeInsets.all(spacing.screenPadding),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Expanded(
              flex: 70,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  _buildGreeting(context, userName),
                  SizedBox(height: spacing.xl),
                  _buildKPIRow(context, institutionProvider, userProvider),
                  SizedBox(height: spacing.xl),
                  _buildActionsGrid(context, columnCount),
                ],
              ),
            ),
            SizedBox(width: spacing.lg),
          ],
        ),
      ),
    );
  }
  Widget _buildMobileLayout(
    BuildContext context,
    String userName,
    InstitutionProvider institutionProvider,
    UserProvider userProvider,
    int columnCount,
  ) {
    final spacing = context.spacing;

    return SingleChildScrollView(
      padding: EdgeInsets.all(spacing.screenPadding),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildGreeting(context, userName),
          SizedBox(height: spacing.xl),
          _buildKPIRow(context, institutionProvider, userProvider),
          SizedBox(height: spacing.xl),
          _buildActionsGrid(context, columnCount),
        ],
      ),
    );
  }
  Widget _buildGreeting(BuildContext context, String userName) {
    final textStyles = context.textStyles;
    final colors = context.colors;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Â¡Hola, $userName!',
          style: textStyles.headlineMedium.copyWith(
            fontWeight: FontWeight.w700,
          ),
        ),
        SizedBox(height: context.spacing.sm),
        Text(
          'Bienvenido al panel de administraciÃ³n del sistema.',
          style: textStyles.bodyLarge.copyWith(color: colors.textSecondary),
        ),
      ],
    );
  }
  Widget _buildKPIRow(
    BuildContext context,
    InstitutionProvider institutionProvider,
    UserProvider userProvider,
  ) {
    final spacing = context.spacing;

    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      child: Row(
        children: [
          ClarityCompactStat(
            value: (institutionProvider.paginationInfo?.total ?? 0).toString(),
            title: 'Instituciones',
            icon: Icons.business,
            color: context.colors.primary,
          ),
          SizedBox(width: spacing.lg),
          ClarityCompactStat(
            value: userProvider.totalUsersFromPagination.toString(),
            title: 'Usuarios',
            icon: Icons.people,
            color: context.colors.info,
          ),
          SizedBox(width: spacing.lg),
          ClarityCompactStat(
            value: '3',
            title: 'Reportes',
            icon: Icons.analytics,
            color: context.colors.warning,
          ),
        ],
      ),
    );
  }
  Widget _buildActionsGrid(BuildContext context, int columnCount) {
    final spacing = context.spacing;

    final colors = context.colors;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Acciones Principales',
          style: context.textStyles.headlineSmall,
        ),
        SizedBox(height: spacing.md),
        Container(
          decoration: BoxDecoration(
            color: colors.surface,
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            border: Border.all(color: colors.borderLight),
          ),
          child: Column(
            children: [
              _buildMenuActionItem(
                context,
                icon: Icons.business_rounded,
                label: 'Instituciones',
                value: 'GestiÃ³n Total',
                color: colors.primary,
                onTap: () => context.go('/institutions'),
                isFirst: true,
              ),
              Divider(height: 0, indent: spacing.lg, endIndent: spacing.lg),
              _buildMenuActionItem(
                context,
                icon: Icons.people_alt_rounded,
                label: 'Usuarios',
                value: 'Admins y Super Admins',
                color: colors.info,
                onTap: () => context.go('/users'),
              ),
              Divider(height: 0, indent: spacing.lg, endIndent: spacing.lg),
              _buildMenuActionItem(
                context,
                icon: Icons.bar_chart_rounded,
                label: 'Reportes',
                value: 'AnÃ¡lisis Global',
                color: const Color(0xFF7C3AED),
                onTap: () {},
              ),
              Divider(height: 0, indent: spacing.lg, endIndent: spacing.lg),
              _buildMenuActionItem(
                context,
                icon: Icons.settings_outlined,
                label: 'Ajustes',
                value: 'Sistema',
                color: const Color(0xFF8B5CF6),
                onTap: () {},
                isLast: true,
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildMenuActionItem(
    BuildContext context, {
    required IconData icon,
    required String label,
    required String value,
    required Color color,
    required VoidCallback onTap,
    bool isFirst = false,
    bool isLast = false,
  }) {
    final textStyles = context.textStyles;
    final spacing = context.spacing;
    final colors = context.colors;

    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: EdgeInsets.symmetric(
            horizontal: spacing.lg,
            vertical: spacing.sm,
          ),
          child: Row(
            children: [
              Container(
                padding: EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: color.withValues(alpha: 0.12),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Icon(icon, color: color, size: 20),
              ),
              SizedBox(width: spacing.md),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      label,
                      style: textStyles.bodyMedium.copyWith(
                        fontWeight: FontWeight.w600,
                        color: colors.textPrimary,
                      ),
                    ),
                    Text(
                      value,
                      style: textStyles.bodySmall.copyWith(
                        color: color,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ],
                ),
              ),
              Icon(
                Icons.arrow_forward_ios_rounded,
                size: 16,
                color: colors.textSecondary,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
/* Fin lib\screens\super_admin_dashboard.dart */

/* Inicio lib\screens\teacher_dashboard.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../providers/horario_provider.dart';
import '../theme/theme_extensions.dart';
import '../widgets/components/index.dart';
import '../models/clase_del_dia.dart';

class TeacherDashboard extends StatefulWidget {
  const TeacherDashboard({super.key});

  @override
  State<TeacherDashboard> createState() => _TeacherDashboardState();
}

class _TeacherDashboardState extends State<TeacherDashboard> with TickerProviderStateMixin {
  late AnimationController _fadeController;
  late Animation<double> _fadeAnimation;

  @override
  void initState() {
    super.initState();
    _fadeController = AnimationController(
      duration: const Duration(milliseconds: 800),
      vsync: this,
    );
    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _fadeController, curve: Curves.easeOut),
    );

    WidgetsBinding.instance.addPostFrameCallback((_) async {
      try {
        final authProvider = Provider.of<AuthProvider>(context, listen: false);
        final horarioProvider = Provider.of<HorarioProvider>(context, listen: false);

        final token = authProvider.accessToken;
        if (token != null) {
          await horarioProvider.cargarClasesDelDia(token);
          _fadeController.forward();
        }
      } catch (e) {
        debugPrint('TeacherDashboard init load error: $e');
      }
    });
  }

  @override
  void dispose() {
    _fadeController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final horarioProvider = Provider.of<HorarioProvider>(context);
    final colors = context.colors;
    final spacing = context.spacing;

    final user = authProvider.user;
    final userName = user?['nombres'] ?? 'Profesor';

    return Scaffold(
      backgroundColor: colors.background,
      body: RefreshIndicator(
        onRefresh: () async {
          final token = authProvider.accessToken;
          if (token != null) {
            await horarioProvider.cargarClasesDelDia(token);
          }
        },
        child: SingleChildScrollView(
          physics: const AlwaysScrollableScrollPhysics(),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildHeader(context, userName),

              SizedBox(height: spacing.xl),
              _buildStatsSection(context, horarioProvider),

              SizedBox(height: spacing.xl),
              _buildClasesSection(context, horarioProvider),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildHeader(BuildContext context, String userName) {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return Container(
      padding: EdgeInsets.all(spacing.xl),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: [
            colors.primary,
            colors.primary.withValues(alpha: 0.8),
            colors.secondary.withValues(alpha: 0.6),
          ],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.only(
          bottomLeft: Radius.circular(spacing.xl),
          bottomRight: Radius.circular(spacing.xl),
        ),
      ),
      child: SafeArea(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Container(
                  padding: EdgeInsets.all(spacing.md),
                  decoration: BoxDecoration(
                    color: colors.white.withValues(alpha: 0.2),
                    borderRadius: BorderRadius.circular(spacing.borderRadiusLarge),
                  ),
                  child: Icon(
                    Icons.school,
                    color: colors.white,
                    size: 32,
                  ),
                ),
                SizedBox(width: spacing.lg),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'Â¡Hola, $userName!',
                        style: textStyles.displayMedium.copyWith(
                          color: colors.white,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      SizedBox(height: spacing.xs),
                      Text(
                        'Bienvenido a tu panel docente',
                        style: textStyles.bodyLarge.copyWith(
                          color: colors.white.withValues(alpha: 0.9),
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
            SizedBox(height: spacing.lg),
            Container(
              padding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
              decoration: BoxDecoration(
                color: colors.white.withValues(alpha: 0.15),
                borderRadius: BorderRadius.circular(spacing.borderRadius),
              ),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Icon(
                    Icons.calendar_today,
                    color: colors.white,
                    size: 18,
                  ),
                  SizedBox(width: spacing.sm),
                  Text(
                    _getCurrentDate(),
                    style: textStyles.bodyMedium.copyWith(
                      color: colors.white,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildStatsSection(BuildContext context, HorarioProvider horarioProvider) {
    final colors = context.colors;
    final spacing = context.spacing;

    return Padding(
      padding: EdgeInsets.symmetric(horizontal: spacing.lg),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Resumen del DÃ­a',
            style: context.textStyles.headlineMedium.copyWith(
              fontWeight: FontWeight.bold,
              color: colors.textPrimary,
            ),
          ),
          SizedBox(height: spacing.md),
          Row(
            children: [
              Expanded(
                child: ClarityKPICard(
                  value: horarioProvider.clasesDelDiaCount.toString(),
                  label: 'Clases Hoy',
                  icon: Icons.class_,
                  iconColor: colors.primary,
                  backgroundColor: colors.primary.withValues(alpha: 0.05),
                ),
              ),
              SizedBox(width: spacing.md),
              Expanded(
                child: ClarityKPICard(
                  value: _calculateTotalStudents(horarioProvider).toString(),
                  label: 'Estudiantes',
                  icon: Icons.people,
                  iconColor: colors.info,
                  backgroundColor: colors.info.withValues(alpha: 0.05),
                ),
              ),
              SizedBox(width: spacing.md),
              Expanded(
                child: ClarityKPICard(
                  value: '95%', // TODO: Calcular asistencia real
                  label: 'Asistencia Promedio',
                  icon: Icons.check_circle,
                  iconColor: colors.success,
                  backgroundColor: colors.success.withValues(alpha: 0.05),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildClasesSection(BuildContext context, HorarioProvider horarioProvider) {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return Padding(
      padding: EdgeInsets.symmetric(horizontal: spacing.lg),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                'Mis Clases de Hoy',
                style: textStyles.headlineMedium.copyWith(
                  fontWeight: FontWeight.bold,
                  color: colors.textPrimary,
                ),
              ),
              IconButton(
                onPressed: () async {
                  final authProvider = Provider.of<AuthProvider>(context, listen: false);
                  final token = authProvider.accessToken;
                  if (token != null) {
                    await horarioProvider.cargarClasesDelDia(token);
                  }
                },
                icon: Icon(Icons.refresh, color: colors.primary),
                tooltip: 'Actualizar',
              ),
            ],
          ),
          SizedBox(height: spacing.md),

          if (horarioProvider.isLoading)
            const Center(child: CircularProgressIndicator())
          else if (horarioProvider.clasesDelDia.isEmpty)
            _buildEmptyState(context)
          else
            FadeTransition(
              opacity: _fadeAnimation,
              child: _buildClasesList(context, horarioProvider.getClasesDelDiaOrdenadas()),
            ),
        ],
      ),
    );
  }

  Widget _buildEmptyState(BuildContext context) {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return Container(
      padding: EdgeInsets.all(spacing.xl),
      decoration: BoxDecoration(
        color: colors.surface,
        borderRadius: BorderRadius.circular(spacing.borderRadiusLarge),
        border: Border.all(color: colors.borderLight),
      ),
      child: Column(
        children: [
          Container(
            padding: EdgeInsets.all(spacing.lg),
            decoration: BoxDecoration(
              color: colors.primary.withValues(alpha: 0.1),
              shape: BoxShape.circle,
            ),
            child: Icon(
              Icons.event_available,
              size: 48,
              color: colors.primary,
            ),
          ),
          SizedBox(height: spacing.lg),
          Text(
            'Â¡DÃ­a Libre!',
            style: textStyles.headlineMedium.copyWith(
              color: colors.textPrimary,
              fontWeight: FontWeight.bold,
            ),
            textAlign: TextAlign.center,
          ),
          SizedBox(height: spacing.sm),
          Text(
            'No tienes clases programadas para hoy.\nÂ¡Disfruta tu tiempo libre!',
            style: textStyles.bodyLarge.copyWith(
              color: colors.textSecondary,
            ),
            textAlign: TextAlign.center,
          ),
          SizedBox(height: spacing.lg),
          OutlinedButton.icon(
            onPressed: () {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Horario semanal prÃ³ximamente')),
              );
            },
            icon: const Icon(Icons.calendar_view_week),
            label: const Text('Ver Horario Semanal'),
            style: OutlinedButton.styleFrom(
              padding: EdgeInsets.symmetric(horizontal: spacing.lg, vertical: spacing.md),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildClasesList(BuildContext context, List<ClaseDelDia> clases) {
    return ListView.builder(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      itemCount: clases.length,
      itemBuilder: (context, index) {
        final clase = clases[index];
        return Padding(
          padding: EdgeInsets.only(bottom: context.spacing.md),
          child: ClaseCardPro(clase: clase, index: index),
        );
      },
    );
  }

  String _getCurrentDate() {
    final now = DateTime.now();
    final dias = ['Domingo', 'Lunes', 'Martes', 'MiÃ©rcoles', 'Jueves', 'Viernes', 'SÃ¡bado'];
    final meses = ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio',
                   'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'];

    return '${dias[now.weekday % 7]} ${now.day} de ${meses[now.month - 1]}';
  }

  int _calculateTotalStudents(HorarioProvider horarioProvider) {
    return horarioProvider.clasesDelDiaCount * 25;
  }
}
class ClaseCardPro extends StatefulWidget {
  final ClaseDelDia clase;
  final int index;

  const ClaseCardPro({
    super.key,
    required this.clase,
    required this.index,
  });

  @override
  State<ClaseCardPro> createState() => _ClaseCardProState();
}

class _ClaseCardProState extends State<ClaseCardPro> with TickerProviderStateMixin {
  late AnimationController _scaleController;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _scaleController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 0.8, end: 1.0).animate(
      CurvedAnimation(parent: _scaleController, curve: Curves.elasticOut),
    );
    Future.delayed(Duration(milliseconds: widget.index * 100), () {
      if (mounted) _scaleController.forward();
    });
  }

  @override
  void dispose() {
    _scaleController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return ScaleTransition(
      scale: _scaleAnimation,
      child: Container(
        decoration: BoxDecoration(
          gradient: LinearGradient(
            colors: [
              colors.surface,
              colors.surface.withValues(alpha: 0.8),
            ],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
          borderRadius: BorderRadius.circular(spacing.borderRadiusLarge),
          border: Border.all(color: colors.borderLight, width: 1),
          boxShadow: [
            BoxShadow(
              color: colors.shadow.withValues(alpha: 0.1),
              blurRadius: 8,
              offset: const Offset(0, 4),
            ),
          ],
        ),
        child: Material(
          color: Colors.transparent,
          child: InkWell(
            onTap: () {
            },
            borderRadius: BorderRadius.circular(spacing.borderRadiusLarge),
            child: Padding(
              padding: EdgeInsets.all(spacing.lg),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Container(
                        padding: EdgeInsets.all(spacing.sm),
                        decoration: BoxDecoration(
                          color: colors.primary.withValues(alpha: 0.1),
                          borderRadius: BorderRadius.circular(spacing.borderRadius),
                        ),
                        child: Icon(
                          Icons.book,
                          color: colors.primary,
                          size: 24,
                        ),
                      ),
                      SizedBox(width: spacing.md),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              widget.clase.materia.nombre,
                              style: textStyles.headlineSmall.copyWith(
                                fontWeight: FontWeight.bold,
                                color: colors.primary,
                              ),
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                            SizedBox(height: spacing.xs),
                            Text(
                              widget.clase.grupo.nombreCompleto,
                              style: textStyles.bodyMedium.copyWith(
                                color: colors.textSecondary,
                              ),
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ],
                        ),
                      ),
                      Container(
                        padding: EdgeInsets.symmetric(horizontal: spacing.sm, vertical: spacing.xs),
                        decoration: BoxDecoration(
                          color: colors.success.withValues(alpha: 0.1),
                          borderRadius: BorderRadius.circular(spacing.borderRadius),
                        ),
                        child: Text(
                          'Activa',
                          style: textStyles.labelSmall.copyWith(
                            color: colors.success,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      ),
                    ],
                  ),

                  SizedBox(height: spacing.lg),
                  Container(
                    padding: EdgeInsets.all(spacing.md),
                    decoration: BoxDecoration(
                      color: colors.background,
                      borderRadius: BorderRadius.circular(spacing.borderRadius),
                      border: Border.all(color: colors.borderLight),
                    ),
                    child: Row(
                      children: [
                        Icon(
                          Icons.access_time,
                          color: colors.primary,
                          size: 20,
                        ),
                        SizedBox(width: spacing.sm),
                        Text(
                          widget.clase.horarioFormato,
                          style: textStyles.bodyLarge.copyWith(
                            fontWeight: FontWeight.w600,
                            color: colors.textPrimary,
                          ),
                        ),
                        const Spacer(),
                        Icon(
                          Icons.location_on,
                          color: colors.textMuted,
                          size: 18,
                        ),
                        SizedBox(width: spacing.xs),
                        Text(
                          'Aula 101', // TODO: Agregar informaciÃ³n real de aula
                          style: textStyles.bodyMedium.copyWith(
                            color: colors.textMuted,
                          ),
                        ),
                      ],
                    ),
                  ),

                  SizedBox(height: spacing.lg),
                  Row(
                    children: [
                      Expanded(
                        child: ElevatedButton.icon(
                          onPressed: () {
                            ScaffoldMessenger.of(context).showSnackBar(
                              SnackBar(
                                content: Text('Tomando asistencia de ${widget.clase.materia.nombre}...'),
                                backgroundColor: colors.success,
                              ),
                            );
                          },
                          icon: const Icon(Icons.qr_code_scanner),
                          label: const Text('Tomar Asistencia'),
                          style: ElevatedButton.styleFrom(
                            backgroundColor: colors.primary,
                            foregroundColor: colors.white,
                            padding: EdgeInsets.symmetric(vertical: spacing.md),
                            shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(spacing.borderRadius),
                            ),
                          ),
                        ),
                      ),
                      SizedBox(width: spacing.md),
                      IconButton(
                        onPressed: () {
                          ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(content: Text('Opciones prÃ³ximamente')),
                          );
                        },
                        icon: Icon(Icons.more_vert, color: colors.textMuted),
                        style: IconButton.styleFrom(
                          backgroundColor: colors.surface,
                          side: BorderSide(color: colors.borderLight),
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}
/* Fin lib\screens\teacher_dashboard.dart */

/* Inicio lib\screens\teacher_dashboard_with_scroll.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../widgets/scroll_state_keeper.dart';
import '../utils/app_routes.dart';
import '../utils/responsive_utils.dart';
class TeacherDashboardWithScroll extends StatelessWidget {
  const TeacherDashboardWithScroll({super.key});

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final colors = context.colors;
    final textStyles = context.textStyles;

    return Scaffold(
      backgroundColor: colors.background,
      appBar: AppBar(
        title: const Text('Profesor - AsistApp'),
        backgroundColor: colors.primary,
        actions: [
          IconButton(
            icon: const Icon(Icons.logout),
            onPressed: () async {
              await authProvider.logoutAndClearAllData(context);
            },
          ),
        ],
      ),
      body: SafeArea(
        child: ScrollStateKeeper(
          routeKey: AppRoutes.teacherDashboard,
          keepScrollPosition: true,
          builder: (context, scrollController) {
            return LayoutBuilder(
              builder: (context, constraints) {
                final responsive = ResponsiveUtils.getResponsiveValues(constraints);

                return SingleChildScrollView(
                  controller: scrollController, // â† El scroll se guarda automÃ¡ticamente
                  child: ConstrainedBox(
                    constraints: BoxConstraints(
                      maxWidth: responsive['maxWidth'],
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.center,
                      children: [
                        Padding(
                          padding: EdgeInsets.symmetric(
                            horizontal: responsive['horizontalPadding'],
                            vertical: responsive['verticalPadding'],
                          ),
                          child: Column(
                            children: [
                              Text(
                                'Panel del Profesor',
                                style: textStyles.displayLarge.copyWith(
                                  fontSize: responsive['isSmallScreen'] ? 28 : 42,
                                ),
                                textAlign: TextAlign.center,
                              ),
                              const SizedBox(height: 16),

                              ...List.generate(20, (index) => Card(
                                margin: const EdgeInsets.symmetric(vertical: 8),
                                child: ListTile(
                                  leading: CircleAvatar(child: Text('${index + 1}')),
                                  title: Text('Clase ${index + 1}'),
                                  subtitle: Text('Grupo ${index % 5 + 1}'),
                                  trailing: const Icon(Icons.arrow_forward_ios),
                                ),
                              )),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ),
                );
              },
            );
          },
        ),
      ),
    );
  }
}

/* Fin lib\screens\teacher_dashboard_with_scroll.dart */

/* Inicio lib\screens\users\create_professor_screen.dart */
import 'package:flutter/material.dart';
import 'user_form_screen.dart';

class CreateProfessorScreen extends StatelessWidget {
  const CreateProfessorScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return UserFormScreen(userRole: 'profesor');
  }
}
/* Fin lib\screens\users\create_professor_screen.dart */

/* Inicio lib\screens\users\create_student_screen.dart */
import 'package:flutter/material.dart';
import 'user_form_screen.dart';

class CreateStudentScreen extends StatelessWidget {
  const CreateStudentScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return UserFormScreen(userRole: 'estudiante');
  }
}
/* Fin lib\screens\users\create_student_screen.dart */

/* Inicio lib\screens\users\form_steps\index.dart */

export 'user_account_step.dart';
export 'user_personal_info_step.dart';
export 'role_specific_details_step.dart';

/* Fin lib\screens\users\form_steps\index.dart */

/* Inicio lib\screens\users\form_steps\role_specific_details_step.dart */
import 'package:flutter/material.dart';
import '../../../theme/theme_extensions.dart';
import '../../../widgets/form_widgets.dart';
import '../../../widgets/components/clarity_components.dart';
class RoleSpecificDetailsStep extends StatelessWidget {
  final String userRole;
  final TextEditingController? tituloController;
  final TextEditingController? especialidadController;
  final TextEditingController? nombreResponsableController;
  final TextEditingController? telefonoResponsableController;

  final GlobalKey<FormFieldState<String>>? tituloFieldKey;
  final GlobalKey<FormFieldState<String>>? especialidadFieldKey;
  final GlobalKey<FormFieldState<String>>? nombreResponsableFieldKey;
  final GlobalKey<FormFieldState<String>>? telefonoResponsableFieldKey;

  const RoleSpecificDetailsStep({
    super.key,
    required this.userRole,
    this.tituloController,
    this.especialidadController,
    this.nombreResponsableController,
    this.telefonoResponsableController,
    this.tituloFocusNode,
    this.especialidadFocusNode,
    this.nombreResponsableFocusNode,
    this.telefonoResponsableFocusNode,
    this.tituloFieldKey,
    this.especialidadFieldKey,
    this.nombreResponsableFieldKey,
    this.telefonoResponsableFieldKey,
  });

  final FocusNode? tituloFocusNode;
  final FocusNode? especialidadFocusNode;
  final FocusNode? nombreResponsableFocusNode;
  final FocusNode? telefonoResponsableFocusNode;

  @override
  Widget build(BuildContext context) {
    final spacing = context.spacing;

    if (userRole == 'profesor') {
      return _buildProfesorDetails(context, spacing);
    } else if (userRole == 'estudiante') {
      return _buildEstudianteDetails(context, spacing);
    } else {
      return _buildNoAdditionalDetails(context);
    }
  }

  Widget _buildProfesorDetails(BuildContext context, dynamic spacing) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'InformaciÃ³n AcadÃ©mica',
          style: context.textStyles.headlineSmall,
        ),
        SizedBox(height: spacing.md),
        Text(
          'Complete los datos acadÃ©micos del profesor',
          style: context.textStyles.bodyMedium.copyWith(
            color: context.colors.textSecondary,
          ),
        ),
        SizedBox(height: spacing.lg),

        ClaritySection(
          title: 'Credenciales AcadÃ©micas',
          child: Column(
            children: [
              LayoutBuilder(
                builder: (context, constraints) {
                  final isWide = constraints.maxWidth > 600;
                  return isWide
                      ? Row(
                          children: [
                            Expanded(
                              child: CustomTextFormField(
                  fieldKey: tituloFieldKey,
                  focusNode: tituloFocusNode,
                                controller: tituloController!,
                                labelText: 'TÃ­tulo AcadÃ©mico',
                                hintText: 'Licenciado en..., MagÃ­ster en...',
                                validator: (value) {
                                  if (value == null || value.trim().isEmpty) {
                                    return 'El tÃ­tulo acadÃ©mico es requerido';
                                  }
                                  if (value.trim().length < 3) {
                                    return 'El tÃ­tulo debe tener al menos 3 caracteres';
                                  }
                                  return null;
                                },
                              ),
                            ),
                            SizedBox(width: spacing.md),
                            Expanded(
                              child: CustomTextFormField(
                  fieldKey: especialidadFieldKey,
                  focusNode: especialidadFocusNode,
                                controller: especialidadController!,
                                labelText: 'Especialidad',
                                hintText: 'MatemÃ¡ticas, FÃ­sica, etc.',
                                validator: (value) {
                                  if (value == null || value.trim().isEmpty) {
                                    return 'La especialidad es requerida';
                                  }
                                  if (value.trim().length < 3) {
                                    return 'La especialidad debe tener al menos 3 caracteres';
                                  }
                                  return null;
                                },
                              ),
                            ),
                          ],
                        )
                      : Column(
                          children: [
                            CustomTextFormField(
                              fieldKey: tituloFieldKey,
                              controller: tituloController!,
                              labelText: 'TÃ­tulo AcadÃ©mico',
                              hintText: 'Licenciado en..., MagÃ­ster en...',
                              validator: (value) {
                                if (value == null || value.trim().isEmpty) {
                                  return 'El tÃ­tulo acadÃ©mico es requerido';
                                }
                                if (value.trim().length < 3) {
                                  return 'El tÃ­tulo debe tener al menos 3 caracteres';
                                }
                                return null;
                              },
                            ),
                            SizedBox(height: spacing.md),
                            CustomTextFormField(
                              fieldKey: especialidadFieldKey,
                              controller: especialidadController!,
                              labelText: 'Especialidad',
                              hintText: 'MatemÃ¡ticas, FÃ­sica, etc.',
                              validator: (value) {
                                if (value == null || value.trim().isEmpty) {
                                  return 'La especialidad es requerida';
                                }
                                if (value.trim().length < 3) {
                                  return 'La especialidad debe tener al menos 3 caracteres';
                                }
                                return null;
                              },
                            ),
                          ],
                        );
                },
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildEstudianteDetails(BuildContext context, dynamic spacing) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'InformaciÃ³n del Responsable',
          style: context.textStyles.headlineSmall,
        ),
        SizedBox(height: spacing.md),
        Text(
          'Datos del padre, madre o tutor del estudiante (opcional)',
          style: context.textStyles.bodyMedium.copyWith(
            color: context.colors.textSecondary,
          ),
        ),
        SizedBox(height: spacing.lg),

        ClaritySection(
          title: 'Contacto de Emergencia',
          child: Column(
            children: [
              CustomTextFormField(
                fieldKey: nombreResponsableFieldKey,
                focusNode: nombreResponsableFocusNode,
                controller: nombreResponsableController!,
                labelText: 'Nombre del Responsable',
                hintText: 'Padre, madre o tutor',
                validator: (value) {
                  return null;
                },
              ),
              SizedBox(height: spacing.md),
              CustomTextFormField(
                fieldKey: telefonoResponsableFieldKey,
                focusNode: telefonoResponsableFocusNode,
                controller: telefonoResponsableController!,
                labelText: 'TelÃ©fono del Responsable',
                hintText: '+57 300 123 4567',
                keyboardType: TextInputType.phone,
                validator: (value) {
                  if (value != null && value.trim().isNotEmpty) {
                    final phoneRegex = RegExp(r'^\+?[0-9\s\-\(\)]+$');
                    if (!phoneRegex.hasMatch(value.trim())) {
                      return 'Ingrese un telÃ©fono vÃ¡lido';
                    }
                  }
                  return null;
                },
              ),
            ],
          ),
        ),

        SizedBox(height: spacing.md),
        Container(
          padding: EdgeInsets.all(spacing.md),
          decoration: BoxDecoration(
            color: context.colors.info.withValues(alpha: 0.1),
            borderRadius: BorderRadius.circular(8),
            border: Border.all(color: context.colors.info.withValues(alpha: 0.3)),
          ),
          child: Row(
            children: [
              Icon(Icons.info_outline, color: context.colors.info, size: 20),
              SizedBox(width: spacing.sm),
              Expanded(
                child: Text(
                  'Esta informaciÃ³n serÃ¡ utilizada para contacto en caso de emergencia.',
                  style: context.textStyles.bodySmall.copyWith(
                    color: context.colors.info,
                  ),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildNoAdditionalDetails(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Resumen',
          style: context.textStyles.headlineSmall,
        ),
        SizedBox(height: context.spacing.md),
        ClarityCard(
          leading: Icon(
            Icons.check_circle,
            color: context.colors.success,
            size: 48,
          ),
          title: const Text('InformaciÃ³n Completa'),
          subtitle: const Text(
            'Este tipo de usuario no requiere informaciÃ³n adicional. Puede proceder a guardar.',
          ),
        ),
      ],
    );
  }
}

/* Fin lib\screens\users\form_steps\role_specific_details_step.dart */

/* Inicio lib\screens\users\form_steps\user_account_step.dart */
import 'package:flutter/material.dart';
import '../../../theme/theme_extensions.dart';
import '../../../widgets/form_widgets.dart';
import '../../../providers/institution_provider.dart';
import '../../../providers/auth_provider.dart';
import 'package:provider/provider.dart';
class UserAccountStep extends StatefulWidget {
  final TextEditingController emailController;
  final String userRole;
  final String? selectedInstitutionId;
  final ValueChanged<String?> onInstitutionChanged;
  final bool isEditMode;
  final FocusNode? emailFocusNode;
  final FocusNode? institutionFocusNode;
  final GlobalKey<FormFieldState<String>>? emailFieldKey;
  final GlobalKey<FormFieldState<String>>? institutionFieldKey;

  const UserAccountStep({
    super.key,
    required this.emailController,
    required this.userRole,
    required this.selectedInstitutionId,
    required this.onInstitutionChanged,
    this.isEditMode = false,
    this.emailFocusNode,
    this.institutionFocusNode,
    this.emailFieldKey,
    this.institutionFieldKey,
  });

  @override
  State<UserAccountStep> createState() => _UserAccountStepState();
}

class _UserAccountStepState extends State<UserAccountStep> {
  bool _isReloading = false;

  @override
  Widget build(BuildContext context) {
    final spacing = context.spacing;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'InformaciÃ³n de la Cuenta',
          style: context.textStyles.headlineSmall,
        ),
        SizedBox(height: spacing.md),
        Text(
          'Configure las credenciales de acceso del usuario',
          style: context.textStyles.bodyMedium.copyWith(
            color: context.colors.textSecondary,
          ),
        ),
        SizedBox(height: spacing.lg),
        CustomTextFormField(
          key: const Key('emailUsuarioField'),
          fieldKey: widget.emailFieldKey,
          focusNode: widget.emailFocusNode,
          controller: widget.emailController,
          labelText: 'Email',
          hintText: '${widget.userRole}@ejemplo.com',
          keyboardType: TextInputType.emailAddress,
          enabled: !widget.isEditMode, // No editable en modo ediciÃ³n
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'El email es requerido';
              }
              final emailRegex = RegExp(r'^[^@\s]+@[^@\s]+\.[^@\s]+$');
              if (!emailRegex.hasMatch(value.trim())) {
                return 'Ingrese un email vÃ¡lido';
              }
              return null;
            },
        ),
        SizedBox(height: spacing.md),
        if (widget.userRole == 'admin_institucion') ...[
          Consumer2<AuthProvider, InstitutionProvider>(
            builder: (context, authProvider, institutionProvider, child) {
              if (institutionProvider.institutions.isEmpty) {
                return Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'No se encontraron instituciones.',
                      style: context.textStyles.bodyMedium.copyWith(color: context.colors.textSecondary),
                    ),
                    SizedBox(height: spacing.sm),
                    Row(
                      children: [
                        ElevatedButton(
                          onPressed: _isReloading
                              ? null
                              : () async {
                                  final token = authProvider.accessToken;
                                  if (token != null) {
                                    setState(() => _isReloading = true);
                                    try {
                                      await institutionProvider.loadInstitutions(token, page: 1, limit: 100);
                                    } finally {
                                      if (mounted) setState(() => _isReloading = false);
                                    }
                                  } else {
                                    ScaffoldMessenger.of(context).showSnackBar(
                                      SnackBar(content: Text('No hay sesiÃ³n activa para recargar instituciones')),
                                    );
                                  }
                                },
                          child: _isReloading
                              ? const SizedBox(width: 16, height: 16, child: CircularProgressIndicator(strokeWidth: 2))
                              : const Text('Recargar instituciones'),
                        ),
                        SizedBox(width: spacing.md),
                        TextButton(
                          onPressed: () {},
                          child: Text('Contactar soporte', style: context.textStyles.bodySmall.withColor(context.colors.info)),
                        ),
                      ],
                    ),
                  ],
                );
              }

              return CustomDropdownFormField<String>(
                key: const Key('institucionDropdown'),
                fieldKey: widget.institutionFieldKey,
                focusNode: widget.institutionFocusNode,
                value: widget.selectedInstitutionId,
                labelText: 'InstituciÃ³n',
                hintText: 'Seleccione una instituciÃ³n',
                items: institutionProvider.institutions.map((institution) {
                  return DropdownMenuItem<String>(
                    value: institution.id,
                    child: Text(institution.nombre),
                  );
                }).toList(),
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Debe seleccionar una instituciÃ³n';
                  }
                  return null;
                },
                onChanged: widget.onInstitutionChanged,
              );
            },
          ),
          SizedBox(height: spacing.md),
        ],

        if (!widget.isEditMode) ...[
          Container(
            padding: EdgeInsets.all(spacing.md),
            decoration: BoxDecoration(
              color: context.colors.info.withValues(alpha: 0.1),
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: context.colors.info.withValues(alpha: 0.3)),
            ),
            child: Row(
              children: [
                Icon(Icons.info_outline, color: context.colors.info, size: 20),
                SizedBox(width: spacing.sm),
                Expanded(
                  child: Text(
                    'Se generarÃ¡ una contraseÃ±a temporal. El usuario deberÃ¡ cambiarla en su primer acceso.',
                    style: context.textStyles.bodySmall.copyWith(
                      color: context.colors.info,
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ],
    );
  }
}

/* Fin lib\screens\users\form_steps\user_account_step.dart */

/* Inicio lib\screens\users\form_steps\user_personal_info_step.dart */
import 'package:flutter/material.dart';
import '../../../theme/theme_extensions.dart';
import '../../../widgets/form_widgets.dart';
class UserPersonalInfoStep extends StatelessWidget {
  final TextEditingController nombresController;
  final TextEditingController apellidosController;
  final TextEditingController telefonoController;
  final TextEditingController identificacionController;
  final String userRole;
  final bool activo;
  final ValueChanged<bool> onActivoChanged;
  final FocusNode? nombresFocusNode;
  final FocusNode? apellidosFocusNode;
  final FocusNode? telefonoFocusNode;
  final FocusNode? identificacionFocusNode;
  final GlobalKey<FormFieldState<String>>? nombresFieldKey;
  final GlobalKey<FormFieldState<String>>? apellidosFieldKey;
  final GlobalKey<FormFieldState<String>>? telefonoFieldKey;
  final GlobalKey<FormFieldState<String>>? identificacionFieldKey;

  const UserPersonalInfoStep({
    super.key,
    required this.nombresController,
    required this.apellidosController,
    required this.telefonoController,
    required this.identificacionController,
    required this.userRole,
    required this.activo,
    required this.onActivoChanged,
    this.nombresFocusNode,
    this.apellidosFocusNode,
    this.telefonoFocusNode,
    this.identificacionFocusNode,
    this.nombresFieldKey,
    this.apellidosFieldKey,
    this.telefonoFieldKey,
    this.identificacionFieldKey,
  });

  @override
  Widget build(BuildContext context) {
    final spacing = context.spacing;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'InformaciÃ³n Personal',
          style: context.textStyles.headlineSmall,
        ),
        SizedBox(height: spacing.md),
        Text(
          'Ingrese los datos personales del usuario',
          style: context.textStyles.bodyMedium.copyWith(
            color: context.colors.textSecondary,
          ),
        ),
        SizedBox(height: spacing.lg),
        LayoutBuilder(
          builder: (context, constraints) {
            final isWide = constraints.maxWidth > 600;
            return isWide
                ? Row(
                    children: [
                      Expanded(
                        child: CustomTextFormField(
                          key: const Key('user_form_nombres'),
                          fieldKey: nombresFieldKey,
                          focusNode: nombresFocusNode,
                          controller: nombresController,
                          labelText: 'Nombres',
                          hintText: 'Ingrese los nombres',
                          validator: (value) {
                            if (value == null || value.trim().isEmpty) {
                              return 'Los nombres son requeridos';
                            }
                            if (value.trim().length < 2) {
                              return 'Los nombres deben tener al menos 2 caracteres';
                            }
                            return null;
                          },
                        ),
                      ),
                      SizedBox(width: spacing.md),
                      Expanded(
                        child: CustomTextFormField(
                          key: const Key('user_form_apellidos'),
                          fieldKey: apellidosFieldKey,
                          focusNode: apellidosFocusNode,
                          controller: apellidosController,
                          labelText: 'Apellidos',
                          hintText: 'Ingrese los apellidos',
                          validator: (value) {
                            if (value == null || value.trim().isEmpty) {
                              return 'Los apellidos son requeridos';
                            }
                            if (value.trim().length < 2) {
                              return 'Los apellidos deben tener al menos 2 caracteres';
                            }
                            return null;
                          },
                        ),
                      ),
                    ],
                  )
                : Column(
                    children: [
                      CustomTextFormField(
                        key: const Key('nombresUsuarioField'),
                        fieldKey: nombresFieldKey,
                        focusNode: nombresFocusNode,
                        controller: nombresController,
                        labelText: 'Nombres',
                        hintText: 'Ingrese los nombres',
                        validator: (value) {
                          if (value == null || value.trim().isEmpty) {
                            return 'Los nombres son requeridos';
                          }
                          if (value.trim().length < 2) {
                            return 'Los nombres deben tener al menos 2 caracteres';
                          }
                          return null;
                        },
                      ),
                      SizedBox(height: spacing.md),
                      CustomTextFormField(
                        key: const Key('apellidosUsuarioField'),
                        fieldKey: apellidosFieldKey,
                        focusNode: apellidosFocusNode,
                        controller: apellidosController,
                        labelText: 'Apellidos',
                        hintText: 'Ingrese los apellidos',
                        validator: (value) {
                          if (value == null || value.trim().isEmpty) {
                            return 'Los apellidos son requeridos';
                          }
                          if (value.trim().length < 2) {
                            return 'Los apellidos deben tener al menos 2 caracteres';
                          }
                          return null;
                        },
                      ),
                    ],
                  );
          },
        ),
        SizedBox(height: spacing.md),
        LayoutBuilder(
          builder: (context, constraints) {
            final isWide = constraints.maxWidth > 600;
            return isWide
                ? Row(
                    children: [
                      Expanded(
                        child: CustomTextFormField(
                          key: const Key('user_form_telefono'),
                          fieldKey: telefonoFieldKey,
                          controller: telefonoController,
                          labelText: 'TelÃ©fono',
                          hintText: '+57 300 123 4567',
                          keyboardType: TextInputType.phone,
                          validator: (value) {
                            if (value != null && value.trim().isNotEmpty) {
                              final phoneRegex = RegExp(r'^\+?[0-9\s\-\(\)]+$');
                              if (!phoneRegex.hasMatch(value.trim())) {
                                return 'Ingrese un telÃ©fono vÃ¡lido';
                              }
                            }
                            return null;
                          },
                        ),
                      ),
                      SizedBox(width: spacing.md),
                      Expanded(
                        child: CustomTextFormField(
                          key: const Key('user_form_identificacion'),
                          fieldKey: identificacionFieldKey,
                          controller: identificacionController,
                          labelText: 'IdentificaciÃ³n',
                          hintText: 'CÃ©dula o documento',
                          validator: (value) {
                            if (userRole == 'admin_institucion' || userRole == 'super_admin') {
                              return null;
                            }

                            if (value == null || value.trim().isEmpty) {
                              return 'La identificaciÃ³n es requerida';
                            }
                            if (value.trim().length < 5) {
                              return 'La identificaciÃ³n debe tener al menos 5 caracteres';
                            }
                            return null;
                          },
                        ),
                      ),
                    ],
                  )
                : Column(
                    children: [
                      CustomTextFormField(
                        key: const Key('user_form_telefono'),
                        fieldKey: telefonoFieldKey,
                        focusNode: telefonoFocusNode,
                        controller: telefonoController,
                        labelText: 'TelÃ©fono',
                        hintText: '+57 300 123 4567',
                        keyboardType: TextInputType.phone,
                        validator: (value) {
                          if (value != null && value.trim().isNotEmpty) {
                            final phoneRegex = RegExp(r'^\+?[0-9\s\-\(\)]+$');
                            if (!phoneRegex.hasMatch(value.trim())) {
                              return 'Ingrese un telÃ©fono vÃ¡lido';
                            }
                          }
                          return null;
                        },
                      ),
                      SizedBox(height: spacing.md),
                      CustomTextFormField(
                        key: const Key('user_form_identificacion'),
                        fieldKey: identificacionFieldKey,
                        focusNode: identificacionFocusNode,
                        controller: identificacionController,
                        labelText: 'IdentificaciÃ³n',
                        hintText: 'CÃ©dula o documento',
                        validator: (value) {
                          if (userRole == 'admin_institucion' || userRole == 'super_admin') {
                            return null;
                          }

                          if (value == null || value.trim().isEmpty) {
                            return 'La identificaciÃ³n es requerida';
                          }
                          if (value.trim().length < 5) {
                            return 'La identificaciÃ³n debe tener al menos 5 caracteres';
                          }
                          return null;
                        },
                      ),
                    ],
                  );
          },
        ),
        SizedBox(height: spacing.lg),
        SwitchListTile(
          title: const Text('Usuario Activo'),
          subtitle: Text(
            activo ? 'El usuario puede iniciar sesiÃ³n' : 'El usuario estÃ¡ deshabilitado',
            style: context.textStyles.bodySmall.copyWith(
              color: context.colors.textSecondary,
            ),
          ),
          value: activo,
          onChanged: onActivoChanged,
          activeColor: context.colors.success,
        ),
      ],
    );
  }
}

/* Fin lib\screens\users\form_steps\user_personal_info_step.dart */

/* Inicio lib\screens\users\users_list_screen.dart */
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import 'package:flutter_speed_dial/flutter_speed_dial.dart';
import '../../models/user.dart';
import '../../providers/auth_provider.dart';
import '../../providers/user_provider.dart';
import '../../theme/theme_extensions.dart';
import '../../widgets/components/index.dart';

class UsersListScreen extends StatefulWidget {
  const UsersListScreen({super.key});

  @override
  State<UsersListScreen> createState() => _UsersListScreenState();
}

class _UsersListScreenState extends State<UsersListScreen> {
  final TextEditingController _searchController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  Timer? _searchDebounceTimer;
  String _searchQuery = '';
  String _selectedRoleFilter = '';
  bool? _statusFilter = true
  bool _isSearching = false;

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final userRole = authProvider.user?['rol'] as String?;
      if (userRole == 'admin_institucion') {
        setState(() {
          _selectedRoleFilter = ''
        });
      }
      _loadUsers();
    });
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _searchController.dispose();
    _searchDebounceTimer?.cancel();
    super.dispose();
  }

  void _onScroll() {
    if (_isSearching) return

    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final userProvider = Provider.of<UserProvider>(context, listen: false);

    if (_scrollController.position.pixels >= _scrollController.position.maxScrollExtent * 0.9) {
      final userRole = authProvider.user?['rol'] as String?;
      _loadMoreUsers(userProvider, authProvider.accessToken, userRole);
    }
  }

  Future<void> _loadUsers() async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final userProvider = Provider.of<UserProvider>(context, listen: false);
    final userRole = authProvider.user?['rol'] as String?;

    if (authProvider.accessToken == null) {
      debugPrint('Error: No hay token de acceso para cargar usuarios.');
      return;
    }
    if (userRole == 'super_admin') {
      debugPrint('Cargando usuarios (admin_institucion y super_admin) como super_admin...');
      final roles = (_selectedRoleFilter.isEmpty)
          ? ['super_admin', 'admin_institucion']
          : [_selectedRoleFilter];

      await userProvider.loadUsers(
        authProvider.accessToken!,
        page: 1,
        limit: 15,
        search: _searchQuery.isEmpty ? null : _searchQuery,
        activo: _statusFilter,
        roles: roles,
      );
    } else if (userRole == 'admin_institucion') {
      if (authProvider.selectedInstitutionId != null) {
        debugPrint('Cargando usuarios para la instituciÃ³n: ${authProvider.selectedInstitutionId}');
        await userProvider.loadUsersByInstitution(
          authProvider.accessToken!,
          authProvider.selectedInstitutionId!,
          page: 1,
          limit: 5,
          role: _selectedRoleFilter.isEmpty ? null : _selectedRoleFilter,
          activo: _statusFilter,
          search: _searchQuery.isEmpty ? null : _searchQuery,
        );
      } else {
        debugPrint('Admin de instituciÃ³n sin instituciÃ³n seleccionada. No se cargarÃ¡n usuarios.');
        userProvider.clearData()
      }
    }
  }

  Future<void> _loadMoreUsers(UserProvider provider, String? accessToken, String? userRole) async {
    if (accessToken == null || provider.isLoadingMore || !provider.hasMoreData) return;
    if (userRole == 'super_admin') {
      final roles = (_selectedRoleFilter.isEmpty)
          ? ['super_admin', 'admin_institucion']
          : [_selectedRoleFilter];

      await provider.loadMoreUsers(
        accessToken,
        activo: _statusFilter,
        search: _searchQuery.isEmpty ? null : _searchQuery,
        roles: roles,
      );
    } else {
      await provider.loadMoreUsers(accessToken);
    }
  }

  void _onSearchChanged(String query) {
    _searchDebounceTimer?.cancel();

    setState(() {
      _isSearching = query.isNotEmpty;
    });
    _searchDebounceTimer = Timer(const Duration(milliseconds: 500), () {
      setState(() {
        _searchQuery = query.trim();
      });
      _loadUsers();
    });
  }

  @override
  @override
  Widget build(BuildContext context) {
    return Consumer2<AuthProvider, UserProvider>(
      builder: (context, authProvider, userProvider, child) {
        final userRole = authProvider.user?['rol'] as String?;
        final title = userRole == 'admin_institucion'
          ? 'GestiÃ³n de Profesores'
          : 'GestiÃ³n de Usuarios';
        final canCreateUsers = userRole == 'admin_institucion' || userRole == 'super_admin';

        return ClarityManagementPage(
          title: title,
          isLoading: userProvider.isLoading,
          hasError: userProvider.hasError,
          errorMessage: userProvider.errorMessage,
          itemCount: userProvider.users.length,
          itemBuilder: (context, index) {
            final user = userProvider.users[index];
            return _buildUserCard(user, userProvider, context);
          },
          filterWidgets: _buildFilterWidgets(context, authProvider),
          statisticWidgets: _buildStatisticWidgets(context, userProvider),
          onRefresh: _loadUsers,
          scrollController: _scrollController,
          hasMoreData: userProvider.hasMoreData,
          isLoadingMore: userProvider.isLoadingMore,
          emptyStateWidget: ClarityEmptyState(
            icon: _isSearching ? Icons.search_off : Icons.people,
            title: _isSearching
              ? 'No se encontraron resultados'
              : 'AÃºn no has creado ningÃºn usuario',
            subtitle: _isSearching
              ? 'Intenta con otros tÃ©rminos de bÃºsqueda'
              : 'Comienza creando tu primer usuario',
          ),
          floatingActionButton: canCreateUsers
              ? _buildSpeedDial(context, userRole!)
              : null,
        );
      },
    );
  }

  Widget _buildSpeedDial(BuildContext context, String userRole) {
    final colors = context.colors;

    if (userRole == 'super_admin') {
      return SpeedDial(
        icon: Icons.add,
        activeIcon: Icons.close,
        backgroundColor: colors.primary,
        foregroundColor: colors.getTextColorForBackground(colors.primary),
        children: [
          SpeedDialChild(
            child: Icon(Icons.admin_panel_settings,
              color: colors.getTextColorForBackground(colors.primary)),
            backgroundColor: colors.primary,
            label: 'Crear Admin InstituciÃ³n',
            onTap: _navigateToCreateAdminInstitution,
          ),
          SpeedDialChild(
            child: Icon(Icons.shield,
              color: colors.getTextColorForBackground(colors.primary)),
            backgroundColor: colors.primary,
            label: 'Crear Super Admin',
            onTap: _navigateToCreateSuperAdmin,
          ),
        ],
      );
    } else {
      return SpeedDial(
        icon: Icons.add,
        activeIcon: Icons.close,
        backgroundColor: colors.primary,
        foregroundColor: colors.getTextColorForBackground(colors.primary),
        children: [
          SpeedDialChild(
            key: const Key('createUser_professor'),
            child: Icon(Icons.school,
              color: colors.getTextColorForBackground(colors.primary)),
            backgroundColor: colors.primary,
            label: 'Crear Profesor',
            onTap: _navigateToCreateProfessor,
          ),
          SpeedDialChild(
            key: const Key('createUser_student'),
            child: Icon(Icons.person,
              color: colors.getTextColorForBackground(colors.primary)),
            backgroundColor: colors.primary,
            label: 'Crear Estudiante',
            onTap: _navigateToCreateStudent,
          ),
        ],
      );
    }
  }

  List<Widget> _buildFilterWidgets(BuildContext context, AuthProvider authProvider) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return [
      TextField(
        controller: _searchController,
        style: textStyles.bodyLarge,
        decoration: InputDecoration(
          hintText: 'Buscar por nombre, email o telÃ©fono...',
          hintStyle: textStyles.bodyMedium.withColor(colors.textMuted),
          prefixIcon: Icon(Icons.search, color: colors.textSecondary),
          suffixIcon: _isSearching
              ? IconButton(
                  icon: Icon(Icons.clear, color: colors.textSecondary),
                  onPressed: () {
                    _searchController.clear();
                    _onSearchChanged('');
                  },
                )
              : null,
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.border),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.borderLight),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.primary, width: 2),
          ),
          filled: true,
          fillColor: colors.surface,
          contentPadding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
        ),
        onChanged: _onSearchChanged,
      ),
      SizedBox(height: spacing.sm),
      Wrap(
        spacing: spacing.md,
        runSpacing: spacing.sm,
        crossAxisAlignment: WrapCrossAlignment.center,
        children: [
          Text('Mostrar:', style: textStyles.labelMedium),
          FilterChip(
            label: const Text('Activos'),
            selected: _statusFilter == true && !_isSearching,
            onSelected: !_isSearching ? (selected) {
              setState(() => _statusFilter = selected ? true : null);
              _loadUsers();
            } : null,
          ),
          FilterChip(
            label: const Text('Inactivos'),
            selected: _statusFilter == false && !_isSearching,
            onSelected: !_isSearching ? (selected) {
              setState(() => _statusFilter = selected ? false : null);
              _loadUsers();
            } : null,
          ),
          FilterChip(
            label: const Text('Todos'),
            selected: _statusFilter == null && !_isSearching,
            onSelected: !_isSearching ? (selected) {
              setState(() => _statusFilter = selected ? null : true);
              _loadUsers();
            } : null,
          ),
        ],
      ),
      SizedBox(height: spacing.sm),
      Row(
        children: [
          Expanded(
            child: Consumer<AuthProvider>(
              builder: (context, authProvider, child) {
                final userRole = authProvider.user?['rol'] as String?;
                final isAdminInstitucion = userRole == 'admin_institucion';
                final isSuperAdmin = userRole == 'super_admin';

                return DropdownButtonFormField<String>(
                  value: _selectedRoleFilter.isEmpty ? null : _selectedRoleFilter,
                  hint: Text('Filtrar por rol', style: textStyles.bodyMedium),
                  items: isSuperAdmin ? [
                    DropdownMenuItem(value: '', child: Text('Todos los roles', style: textStyles.bodyMedium)),
                    DropdownMenuItem(value: 'admin_institucion', child: Text('Admins InstituciÃ³n', style: textStyles.bodyMedium)),
                    DropdownMenuItem(value: 'super_admin', child: Text('Super Admins', style: textStyles.bodyMedium)),
                  ] : isAdminInstitucion ? [
                    DropdownMenuItem(value: '', child: Text('Todos los usuarios', style: textStyles.bodyMedium)),
                    DropdownMenuItem(value: 'profesor', child: Text('Solo Profesores', style: textStyles.bodyMedium)),
                    DropdownMenuItem(value: 'estudiante', child: Text('Solo Estudiantes', style: textStyles.bodyMedium)),
                  ] : [
                    DropdownMenuItem(value: '', child: Text('Todos los roles', style: textStyles.bodyMedium)),
                    DropdownMenuItem(value: 'profesor', child: Text('Profesores', style: textStyles.bodyMedium)),
                    DropdownMenuItem(value: 'estudiante', child: Text('Estudiantes', style: textStyles.bodyMedium)),
                    DropdownMenuItem(value: 'admin_institucion', child: Text('Admins InstituciÃ³n', style: textStyles.bodyMedium)),
                  ],
                  onChanged: (value) {
                    setState(() => _selectedRoleFilter = value ?? '');
                    _loadUsers();
                  },
                  decoration: InputDecoration(
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(spacing.borderRadius),
                    ),
                    contentPadding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
                  ),
                );
              },
            ),
          ),
        ],
      ),
    ];
  }

  List<Widget> _buildStatisticWidgets(BuildContext context, UserProvider provider) {
    final stats = provider.getUserStatistics();
    final colors = context.colors;

    return [
      ClarityCompactStat(
        title: 'Total',
        value: stats['total'].toString(),
        icon: Icons.people,
        color: colors.primary,
      ),
      ClarityCompactStat(
        title: 'Activos',
        value: stats['activos'].toString(),
        icon: Icons.check_circle,
        color: colors.success,
      ),
      ClarityCompactStat(
        title: 'Profesores',
        value: stats['profesores'].toString(),
        icon: Icons.school,
        color: colors.info,
      ),
      ClarityCompactStat(
        title: 'Estudiantes',
        value: stats['estudiantes'].toString(),
        icon: Icons.person,
        color: colors.warning,
      ),
    ];
  }

  Widget _buildUserCard(User user, UserProvider provider, BuildContext context) {
    final colors = context.colors;
    final textStyles = context.textStyles;

    return Consumer<AuthProvider>(
      builder: (context, authProvider, child) {
        final userRole = authProvider.user?['rol'] as String?;
        final canEditUsers = userRole == 'admin_institucion' || userRole == 'super_admin';
        final List<ClarityContextMenuAction> contextActions = canEditUsers
            ? [
                ClarityContextMenuAction(
                  label: 'Editar',
                  icon: Icons.edit,
                  color: colors.primary,
                  onPressed: () => _navigateToUserEdit(user),
                ),
                ClarityContextMenuAction(
                  label: user.activo ? 'Desactivar' : 'Activar',
                  icon: user.activo ? Icons.toggle_off : Icons.toggle_on,
                  color: user.activo ? colors.warning : colors.success,
                  onPressed: () => _handleMenuAction('toggle_status', user, provider),
                ),
                ClarityContextMenuAction(
                  label: 'Eliminar',
                  icon: Icons.delete,
                  color: colors.error,
                  onPressed: () => _handleMenuAction('delete', user, provider),
                ),
              ]
            : [];

        return ClarityListItem(
          leading: CircleAvatar(
            backgroundColor: _getRoleColor(user.rol, context),
            child: Text(
              user.nombreCompleto.substring(0, 1).toUpperCase(),
              style: textStyles.labelMedium.copyWith(color: colors.white),
            ),
          ),
          title: user.nombreCompleto,
          subtitle: user.email,
          badgeText: user.activo ? 'Activo' : 'Inactivo',
          badgeColor: user.activo ? colors.success : colors.error,
          contextActions: contextActions.isNotEmpty ? contextActions : null,
          onTap: () => _navigateToUserDetail(user),
        );
      },
    );
  }

  Color _getRoleColor(String role, BuildContext context) {
    final colors = context.colors;
    switch (role) {
      case 'profesor':
        return colors.info;
      case 'estudiante':
        return colors.warning;
      case 'admin_institucion':
        return colors.primary;
      case 'super_admin':
        return colors.error;
      default:
        return colors.primary;
    }
  }

  void _handleMenuAction(String action, User user, UserProvider provider) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    switch (action) {
      case 'edit':
        _navigateToUserEdit(user);
        break;

      case 'toggle_status':
        final newStatus = !user.activo;
        final success = await provider.updateUser(
          authProvider.accessToken!,
          user.id,
          UpdateUserRequest(
            activo: newStatus,
            nombres: user.nombres, // Incluir valores actuales para evitar null
            apellidos: user.apellidos,
            email: user.email,
            telefono: user.telefono,
          ),
        );

        if (success && mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                'Usuario ${newStatus ? 'activado' : 'desactivado'} correctamente',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onPrimary),
              ),
              backgroundColor: Theme.of(context).colorScheme.primary,
            ),
          );
          await _loadUsers();
        } else if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                provider.errorMessage ?? 'Error al cambiar estado del usuario',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onError),
              ),
              backgroundColor: Theme.of(context).colorScheme.error,
            ),
          );
        }
        break;

      case 'delete':
        _showDeleteConfirmationDialog(user, provider);
        break;
    }
  }

  void _showDeleteConfirmationDialog(User user, UserProvider provider) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Eliminar Usuario', style: Theme.of(context).textTheme.headlineSmall),
        content: Text(
          'Â¿EstÃ¡s seguro de que quieres eliminar "${user.nombreCompleto}"?\n\n'
          'Esta acciÃ³n no se puede deshacer.',
          style: Theme.of(context).textTheme.bodyMedium,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: Text('Cancelar', style: Theme.of(context).textTheme.labelLarge),
          ),
          TextButton(
            onPressed: () async {
              Navigator.of(context).pop();
              await _deleteUser(user, provider);
            },
            style: TextButton.styleFrom(foregroundColor: Theme.of(context).colorScheme.error),
            child: Text('Eliminar', style: Theme.of(context).textTheme.labelLarge?.copyWith(color: Theme.of(context).colorScheme.error)),
          ),
        ],
      ),
    );
  }

  Future<void> _deleteUser(User user, UserProvider provider) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    final success = await provider.deleteUser(
      authProvider.accessToken!,
      user.id,
    );

    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            'Usuario eliminado correctamente',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onPrimary),
          ),
          backgroundColor: Theme.of(context).colorScheme.primary,
        ),
      );
      await _loadUsers();
    } else if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            provider.errorMessage ?? 'Error al eliminar usuario',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onError),
          ),
          backgroundColor: Theme.of(context).colorScheme.error,
        ),
      );
    }
  }

  void _navigateToCreateProfessor() {
    context.push('/users/professor/create');
  }

  void _navigateToCreateStudent() {
    context.push('/users/student/create');
  }

  void _navigateToCreateAdminInstitution() {
    context.push('/users/admin_institucion/create');
  }

  void _navigateToCreateSuperAdmin() {
    context.push('/users/super_admin/create');
  }

  void _navigateToUserEdit(User user) {
    context.push('/users/${user.rol}/create?edit=true&userId=${user.id}');
  }

  void _navigateToUserDetail(User user) {
    context.push('/users/detail/${user.id}', extra: user);
  }
}
/* Fin lib\screens\users\users_list_screen.dart */

/* Inicio lib\screens\users\user_detail_screen.dart */
import 'package:flutter/material.dart';
import '../../models/user.dart';
import '../../theme/theme_extensions.dart';

class UserDetailScreen extends StatelessWidget {
  final User user;

  const UserDetailScreen({
    super.key,
    required this.user,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Scaffold(
      appBar: AppBar(
        title: Text(
          user.nombreCompleto,
          style: textStyles.titleLarge,
        ),
        backgroundColor: colors.primary,
        foregroundColor: Theme.of(context).colorScheme.onPrimary,
        elevation: 0,
      ),
      body: SingleChildScrollView(
        padding: EdgeInsets.all(spacing.lg),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildInfoSection(
              context,
              'InformaciÃ³n BÃ¡sica',
              [
                _buildInfoItem('Nombres', user.nombres),
                _buildInfoItem('Apellidos', user.apellidos),
                _buildInfoItem('Email', user.email),
                _buildInfoItem('TelÃ©fono', user.telefono ?? 'No especificado'),
                _buildInfoItem('Rol', _getRoleDisplayName(user.rol)),
                _buildInfoItem('Estado', user.activo ? 'Activo' : 'Inactivo',
                    valueColor: user.activo ? colors.success : colors.error),
              ],
            ),

            SizedBox(height: spacing.lg),
            if (user.esEstudiante && user.estudiante != null) ...[
              _buildInfoSection(
                context,
                'InformaciÃ³n del Estudiante',
                [
                  _buildInfoItem('IdentificaciÃ³n', user.estudiante!.identificacion),
                  _buildInfoItem('CÃ³digo QR', user.estudiante!.codigoQr),
                  if (user.estudiante!.nombreResponsable != null)
                    _buildInfoItem('Nombre del Responsable', user.estudiante!.nombreResponsable!),
                  if (user.estudiante!.telefonoResponsable != null)
                    _buildInfoItem('TelÃ©fono del Responsable', user.estudiante!.telefonoResponsable!),
                ],
              ),
              SizedBox(height: spacing.lg),
            ],
            if (user.instituciones.isNotEmpty) ...[
              _buildInfoSection(
                context,
                'Instituciones',
                user.instituciones.map((inst) => _buildInfoItem(
                  inst.nombre,
                  inst.rolEnInstitucion ?? 'Sin rol especÃ­fico',
                )).toList(),
              ),
              SizedBox(height: spacing.lg),
            ],
            _buildInfoSection(
              context,
              'InformaciÃ³n del Sistema',
              [
                _buildInfoItem('ID de Usuario', user.id),
                _buildInfoItem('Fecha de CreaciÃ³n', 'No disponible'), // TODO: Agregar campo de fecha si existe
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoSection(BuildContext context, String title, List<Widget> items) {
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(spacing.borderRadius),
      ),
      child: Padding(
        padding: EdgeInsets.all(spacing.lg),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              title,
              style: textStyles.titleMedium.bold,
            ),
            SizedBox(height: spacing.md),
            ...items,
          ],
        ),
      ),
    );
  }

  Widget _buildInfoItem(String label, String value, {Color? valueColor}) {
    return Padding(
      padding: EdgeInsets.symmetric(vertical: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Expanded(
            flex: 2,
            child: Text(
              '$label:',
              style: TextStyle(
                fontWeight: FontWeight.w600,
                color: Colors.grey[700],
              ),
            ),
          ),
          Expanded(
            flex: 3,
            child: Text(
              value,
              style: TextStyle(
                color: valueColor,
                fontWeight: valueColor != null ? FontWeight.w500 : FontWeight.normal,
              ),
            ),
          ),
        ],
      ),
    );
  }

  String _getRoleDisplayName(String role) {
    switch (role) {
      case 'super_admin':
        return 'Super Administrador';
      case 'admin_institucion':
        return 'Administrador de InstituciÃ³n';
      case 'profesor':
        return 'Profesor';
      case 'estudiante':
        return 'Estudiante';
      default:
        return role;
    }
  }
}
/* Fin lib\screens\users\user_detail_screen.dart */

/* Inicio lib\screens\users\user_form_screen.dart */
import 'dart:math';
import 'package:flutter/services.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../models/user.dart';
import '../../providers/auth_provider.dart';
import '../../providers/user_provider.dart';
import '../../providers/institution_provider.dart';
import '../../theme/theme_extensions.dart';
import 'form_steps/index.dart';

class UserFormScreen extends StatefulWidget {
  final String userRole

  const UserFormScreen({
    super.key,
    required this.userRole,
  });

  @override
  State<UserFormScreen> createState() => _UserFormScreenState();
}

class _UserFormScreenState extends State<UserFormScreen> {
  final _formKey = GlobalKey<FormState>();
  int _currentStep = 0;
  AutovalidateMode _autoValidateMode = AutovalidateMode.disabled;
  final FocusNode _emailFocus = FocusNode();
  final FocusNode _institutionFocus = FocusNode();

  final FocusNode _nombresFocus = FocusNode();
  final FocusNode _apellidosFocus = FocusNode();
  final FocusNode _telefonoFocus = FocusNode();
  final FocusNode _identificacionFocus = FocusNode();

  final FocusNode _tituloFocus = FocusNode();
  final FocusNode _especialidadFocus = FocusNode();
  final FocusNode _nombreResponsableFocus = FocusNode();
  final FocusNode _telefonoResponsableFocus = FocusNode();
  final GlobalKey<FormFieldState<String>> _emailFieldKey = GlobalKey<FormFieldState<String>>();
  final GlobalKey<FormFieldState<String>> _institutionFieldKey = GlobalKey<FormFieldState<String>>();
  final GlobalKey<FormFieldState<String>> _nombresFieldKey = GlobalKey<FormFieldState<String>>();
  final GlobalKey<FormFieldState<String>> _apellidosFieldKey = GlobalKey<FormFieldState<String>>();
  final GlobalKey<FormFieldState<String>> _telefonoFieldKey = GlobalKey<FormFieldState<String>>();
  final GlobalKey<FormFieldState<String>> _identificacionFieldKey = GlobalKey<FormFieldState<String>>();
  final GlobalKey<FormFieldState<String>> _tituloFieldKey = GlobalKey<FormFieldState<String>>();
  final GlobalKey<FormFieldState<String>> _especialidadFieldKey = GlobalKey<FormFieldState<String>>();
  final GlobalKey<FormFieldState<String>> _nombreResponsableFieldKey = GlobalKey<FormFieldState<String>>();
  final GlobalKey<FormFieldState<String>> _telefonoResponsableFieldKey = GlobalKey<FormFieldState<String>>();
  final _nombresController = TextEditingController();
  final _apellidosController = TextEditingController();
  final _emailController = TextEditingController();
  final _telefonoController = TextEditingController();
  final _identificacionController = TextEditingController();
  final _tituloController = TextEditingController();
  final _especialidadController = TextEditingController();
  final _nombreResponsableController = TextEditingController();
  final _telefonoResponsableController = TextEditingController();

  bool _isLoading = false;
  bool _isInitialLoading = false;
  bool _activo = true;
  User? _user
  String? _selectedInstitutionId

  @override
  void initState() {
    super.initState();
    final total = _getTotalSteps();
    _stepKeys = List.generate(total, (_) => GlobalKey<FormState>());
  }

  late List<GlobalKey<FormState>> _stepKeys;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _loadUserIfEditing();
    _loadInstitutionsIfNeeded();
  }

  Future<void> _loadUserIfEditing() async {
    if (_user != null || _isInitialLoading) return;

    final uri = GoRouterState.of(context).uri;
    final queryParams = uri.queryParameters;

    final isEdit = queryParams['edit'] == 'true';
    final userId = queryParams['userId'];

    if (isEdit && userId != null) {
      final navigator = GoRouter.of(context);
      final messenger = ScaffoldMessenger.of(context);
      final theme = Theme.of(context);

      setState(() => _isInitialLoading = true);

      try {
        final authProvider = Provider.of<AuthProvider>(context, listen: false);
        final userProvider = Provider.of<UserProvider>(context, listen: false);

        await userProvider.loadUserById(
          authProvider.accessToken!,
          userId,
        );

        final user = userProvider.selectedUser;
        if (user != null && mounted) {
          setState(() => _user = user);
          _fillFormWithUserData();
        }
      } catch (e) {
        if (!mounted) return;
        messenger.showSnackBar(
          SnackBar(
            content: Text(
              'Error al cargar usuario: ${e.toString()}',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onError,
              ),
            ),
            backgroundColor: theme.colorScheme.error,
          ),
        );
        navigator.go('/users');
      } finally {
        if (mounted) {
          setState(() => _isInitialLoading = false);
        }
      }
    }
  }

  Future<void> _loadInstitutionsIfNeeded() async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final userRole = authProvider.user?['rol'] as String?;
    if (userRole == 'super_admin' && widget.userRole == 'admin_institucion') {
      final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);
      if (institutionProvider.institutions.isEmpty) {
        await institutionProvider.loadInstitutions(
          authProvider.accessToken!,
          page: 1,
          limit: 100, // Cargar todas para el dropdown
        );
      }
    }
  }

  void _fillFormWithUserData() {
    final user = _user!;
    _nombresController.text = user.nombres;
    _apellidosController.text = user.apellidos;
    _emailController.text = user.email;
    _telefonoController.text = user.telefono ?? '';
    _activo = user.activo;
    if (user.instituciones.isNotEmpty) {
      _selectedInstitutionId = user.instituciones.first.id;
    }

    if (user.estudiante != null) {
      _identificacionController.text = user.estudiante!.identificacion;
      _nombreResponsableController.text = user.estudiante!.nombreResponsable ?? '';
      _telefonoResponsableController.text = user.estudiante!.telefonoResponsable ?? '';
    }
  }

  @override
  void dispose() {
    _emailFocus.dispose();
    _institutionFocus.dispose();
    _nombresFocus.dispose();
    _apellidosFocus.dispose();
    _telefonoFocus.dispose();
    _identificacionFocus.dispose();
    _tituloFocus.dispose();
    _especialidadFocus.dispose();
    _nombreResponsableFocus.dispose();
    _telefonoResponsableFocus.dispose();
    _nombresController.dispose();
    _apellidosController.dispose();
    _emailController.dispose();
    _telefonoController.dispose();
    _identificacionController.dispose();
    _tituloController.dispose();
    _especialidadController.dispose();
    _nombreResponsableController.dispose();
    _telefonoResponsableController.dispose();
    super.dispose();
  }

  Future<void> _saveUser() async {
    final navigator = GoRouter.of(context);
    final messenger = ScaffoldMessenger.of(context);
    final theme = Theme.of(context);
    for (var i = 0; i < _stepKeys.length; i++) {
      final valid = _stepKeys[i].currentState?.validate() ?? true;
      if (!valid) {
        setState(() => _autoValidateMode = AutovalidateMode.always);
        messenger.showSnackBar(
          SnackBar(
            content: Text(
              'Corrige los campos marcados antes de guardar',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onPrimary,
              ),
            ),
            backgroundColor: theme.colorScheme.primary,
          ),
        );
        setState(() => _currentStep = i);
        _focusFirstInvalidField(i, context);
        return;
      }
    }
    if (widget.userRole == 'admin_institucion' && _selectedInstitutionId == null) {
      messenger.showSnackBar(
        SnackBar(
          content: Text(
            'Debe seleccionar una instituciÃ³n',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: theme.colorScheme.onError,
            ),
          ),
          backgroundColor: theme.colorScheme.error,
        ),
      );
      return;
    }

    setState(() => _isLoading = true);

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final userProvider = Provider.of<UserProvider>(context, listen: false);

      if (_user != null) {
        final updateRequest = UpdateUserRequest(
          email: _emailController.text.trim(),
          nombres: _nombresController.text.trim(),
          apellidos: _apellidosController.text.trim(),
          telefono: _telefonoController.text.trim().isNotEmpty ? _telefonoController.text.trim() : null,
          identificacion: widget.userRole == 'estudiante' ? _identificacionController.text.trim() : null,
          nombreResponsable: widget.userRole == 'estudiante' ? _nombreResponsableController.text.trim().isNotEmpty ? _nombreResponsableController.text.trim() : null : null,
          telefonoResponsable: widget.userRole == 'estudiante' ? _telefonoResponsableController.text.trim().isNotEmpty ? _telefonoResponsableController.text.trim() : null : null,
          activo: _activo,
        );

        final success = await userProvider.updateUser(
          authProvider.accessToken!,
          _user!.id,
          updateRequest,
        );

        if (success) {
          if (!mounted) return;
          messenger.showSnackBar(
            SnackBar(
              content: Text(
                '${_getRoleDisplayName(widget.userRole)} actualizado exitosamente',
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.onPrimary,
                ),
              ),
              backgroundColor: theme.colorScheme.primary,
            ),
          );
          navigator.go('/users');
        }
      } else {
        final String tempPassword = _generateRandomPassword();

        final createRequest = CreateUserRequest(
          email: _emailController.text.trim(),
          password: tempPassword,
          nombres: _nombresController.text.trim(),
          apellidos: _apellidosController.text.trim(),
          telefono: _telefonoController.text.trim().isNotEmpty ? _telefonoController.text.trim() : null,
          identificacion: widget.userRole == 'estudiante' ? _identificacionController.text.trim() : null,
          rol: widget.userRole,
          titulo: widget.userRole == 'profesor' ? _tituloController.text.trim() : null,
          especialidad: widget.userRole == 'profesor' ? _especialidadController.text.trim() : null,
          nombreResponsable: widget.userRole == 'estudiante' ? _nombreResponsableController.text.trim().isNotEmpty ? _nombreResponsableController.text.trim() : null : null,
          telefonoResponsable: widget.userRole == 'estudiante' ? _telefonoResponsableController.text.trim().isNotEmpty ? _telefonoResponsableController.text.trim() : null : null,
          institucionId: widget.userRole == 'admin_institucion' ? _selectedInstitutionId : authProvider.selectedInstitutionId,
          rolEnInstitucion: widget.userRole == 'admin_institucion' ? 'admin' : null,
        );

        final success = await userProvider.createUser(
          authProvider.accessToken!,
          createRequest,
        );

        if (success) {
          messenger.showSnackBar(
            SnackBar(
              content: Text(
                '${_getRoleDisplayName(widget.userRole)} creado exitosamente',
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.onPrimary,
                ),
              ),
              backgroundColor: theme.colorScheme.primary,
            ),
          );
          await showDialog<void>(
            context: context,
            barrierDismissible: false,
            builder: (context) {
              return AlertDialog(
                title: Text('ContraseÃ±a temporal'),
                content: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text('Se ha creado el usuario. Esta es la contraseÃ±a temporal (se mostrarÃ¡ sÃ³lo ahora):'),
                    SizedBox(height: 12),
                    SelectableText(tempPassword, style: Theme.of(context).textTheme.headlineSmall),
                    SizedBox(height: 12),
                    Text(
                      'AsegÃºrate de copiarla y entregarla al usuario. No se podrÃ¡ volver a visualizar.',
                      style: Theme.of(context).textTheme.bodySmall,
                    ),
                  ],
                ),
                actions: [
                  TextButton(
                    onPressed: () async {
                      final navigator = Navigator.of(context);
                      await Clipboard.setData(ClipboardData(text: tempPassword));
                      try {
                        navigator.pop();
                      } catch (_) {
                      }
                    },
                    child: const Text('Copiar y Cerrar'),
                  ),
                ],
              );
            },
          );
          if (!mounted) return;
          navigator.go('/users');
        }
      }
    } catch (e) {
      if (!mounted) return;
      messenger.showSnackBar(
        SnackBar(
          content: Text(
            'Error al ${_user != null ? 'actualizar' : 'crear'} ${_getRoleDisplayName(widget.userRole)}: ${e.toString()}',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: theme.colorScheme.onError,
            ),
          ),
          backgroundColor: theme.colorScheme.error,
        ),
      );
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  String _getRoleDisplayName(String role) {
    switch (role) {
      case 'profesor':
        return 'Profesor';
      case 'estudiante':
        return 'Estudiante';
      case 'admin_institucion':
        return 'Administrador de InstituciÃ³n';
      case 'super_admin':
        return 'Super Administrador';
      default:
        return 'Usuario';
    }
  }

  void _focusFirstInvalidField(int step, BuildContext context) {
  final emailRegex = RegExp(r'^[^@\s]+@[^@\s]+\.[^@\s]+$');
    final phoneRegex = RegExp(r'^\+?[0-9\s\-\(\)]+$');

    if (step == 0) {
      final email = _emailController.text.trim();
      if (email.isEmpty || !emailRegex.hasMatch(email)) {
        FocusScope.of(context).requestFocus(_emailFocus);
        WidgetsBinding.instance.addPostFrameCallback((_) {
          final ctx = _emailFieldKey.currentContext;
          if (ctx != null) Scrollable.ensureVisible(ctx, duration: const Duration(milliseconds: 300));
        });
        return;
      }

      if (widget.userRole == 'admin_institucion' && _selectedInstitutionId == null) {
        FocusScope.of(context).requestFocus(_institutionFocus);
        WidgetsBinding.instance.addPostFrameCallback((_) {
          final ctx = _institutionFieldKey.currentContext;
          if (ctx != null) Scrollable.ensureVisible(ctx, duration: const Duration(milliseconds: 300));
        });
        return;
      }
    } else if (step == 1) {
      final nombres = _nombresController.text.trim();
      final apellidos = _apellidosController.text.trim();
      final telefono = _telefonoController.text.trim();
      final identificacion = _identificacionController.text.trim();

      if (nombres.isEmpty || nombres.length < 2) {
        FocusScope.of(context).requestFocus(_nombresFocus);
        WidgetsBinding.instance.addPostFrameCallback((_) {
          final ctx = _nombresFieldKey.currentContext;
          if (ctx != null) Scrollable.ensureVisible(ctx, duration: const Duration(milliseconds: 300));
        });
        return;
      }
      if (apellidos.isEmpty || apellidos.length < 2) {
        FocusScope.of(context).requestFocus(_apellidosFocus);
        WidgetsBinding.instance.addPostFrameCallback((_) {
          final ctx = _apellidosFieldKey.currentContext;
          if (ctx != null) Scrollable.ensureVisible(ctx, duration: const Duration(milliseconds: 300));
        });
        return;
      }
      if (telefono.isNotEmpty && !phoneRegex.hasMatch(telefono)) {
        FocusScope.of(context).requestFocus(_telefonoFocus);
        WidgetsBinding.instance.addPostFrameCallback((_) {
          final ctx = _telefonoFieldKey.currentContext;
          if (ctx != null) Scrollable.ensureVisible(ctx, duration: const Duration(milliseconds: 300));
        });
        return;
      }
      if (!(widget.userRole == 'admin_institucion' || widget.userRole == 'super_admin')) {
        if (identificacion.isEmpty || identificacion.length < 5) {
          FocusScope.of(context).requestFocus(_identificacionFocus);
          WidgetsBinding.instance.addPostFrameCallback((_) {
            final ctx = _identificacionFieldKey.currentContext;
            if (ctx != null) Scrollable.ensureVisible(ctx, duration: const Duration(milliseconds: 300));
          });
          return;
        }
      }
    } else if (step == 2) {
      if (widget.userRole == 'profesor') {
        final titulo = _tituloController.text.trim();
        final especialidad = _especialidadController.text.trim();
        if (titulo.isEmpty || titulo.length < 3) {
          FocusScope.of(context).requestFocus(_tituloFocus);
          WidgetsBinding.instance.addPostFrameCallback((_) {
            final ctx = _tituloFieldKey.currentContext;
            if (ctx != null) Scrollable.ensureVisible(ctx, duration: const Duration(milliseconds: 300));
          });
          return;
        }
        if (especialidad.isEmpty || especialidad.length < 3) {
          FocusScope.of(context).requestFocus(_especialidadFocus);
          WidgetsBinding.instance.addPostFrameCallback((_) {
            final ctx = _especialidadFieldKey.currentContext;
            if (ctx != null) Scrollable.ensureVisible(ctx, duration: const Duration(milliseconds: 300));
          });
          return;
        }
      } else if (widget.userRole == 'estudiante') {
        final telefonoResp = _telefonoResponsableController.text.trim();
        if (telefonoResp.isNotEmpty && !phoneRegex.hasMatch(telefonoResp)) {
          FocusScope.of(context).requestFocus(_telefonoResponsableFocus);
          WidgetsBinding.instance.addPostFrameCallback((_) {
            final ctx = _telefonoResponsableFieldKey.currentContext;
            if (ctx != null) Scrollable.ensureVisible(ctx, duration: const Duration(milliseconds: 300));
          });
          return;
        }
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;
    final title = _user != null ? 'Editar Usuario' : 'Crear ${_getRoleDisplayName(widget.userRole)}';

    if (_isInitialLoading) {
      return Scaffold(
        backgroundColor: colors.background,
        appBar: AppBar(
          title: Text(title),
          backgroundColor: colors.primary,
          foregroundColor: colors.white,
        ),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: const [
              CircularProgressIndicator(),
              SizedBox(height: 16),
              Text('Cargando usuario...'),
            ],
          ),
        ),
      );
    }
    final int totalSteps = _getTotalSteps();

    return Scaffold(
      backgroundColor: colors.background,
      appBar: AppBar(
        title: Text(title),
        backgroundColor: colors.primary,
        foregroundColor: colors.white,
      ),
      body: Form(
        key: _formKey,
        autovalidateMode: _autoValidateMode,
        child: Stepper(
          currentStep: _currentStep,
          onStepContinue: _onStepContinue,
          onStepCancel: _onStepCancel,
          onStepTapped: (step) => setState(() => _currentStep = step),
          controlsBuilder: (context, details) {
            final isLastStep = details.currentStep == totalSteps - 1;

            return Padding(
              padding: EdgeInsets.only(top: spacing.lg),
              child: Row(
                children: [
                  if (details.currentStep > 0) ...[
                    Expanded(
                      child: OutlinedButton(
                        onPressed: _isLoading ? null : details.onStepCancel,
                        style: OutlinedButton.styleFrom(
                          padding: EdgeInsets.symmetric(vertical: spacing.md),
                          side: BorderSide(color: colors.primary),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(spacing.borderRadius),
                          ),
                        ),
                        child: Text(
                          'Anterior',
                          style: textStyles.button.withColor(colors.primary),
                        ),
                      ),
                    ),
                    SizedBox(width: spacing.md),
                  ],
                  Expanded(
                    child: ElevatedButton(
                      key: const Key('formSaveButton'),
                      onPressed: _isLoading ? null : details.onStepContinue,
                      style: ElevatedButton.styleFrom(
                        padding: EdgeInsets.symmetric(vertical: spacing.md),
                        backgroundColor: colors.primary,
                        foregroundColor: colors.white,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(spacing.borderRadius),
                        ),
                      ),
                      child: _isLoading
                          ? const SizedBox(
                              height: 20,
                              width: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                              ),
                            )
                          : Text(
                              isLastStep ? (_user != null ? 'Actualizar' : 'Crear') : 'Siguiente',
                              style: textStyles.button.withColor(colors.white),
                            ),
                    ),
                  ),
                  if (details.currentStep == 0) ...[
                    SizedBox(width: spacing.md),
                    Expanded(
                      child: OutlinedButton(
                        onPressed: _isLoading ? null : () => context.pop(),
                        style: OutlinedButton.styleFrom(
                          padding: EdgeInsets.symmetric(vertical: spacing.md),
                          side: BorderSide(color: colors.error),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(spacing.borderRadius),
                          ),
                        ),
                        child: Text(
                          'Cancelar',
                          style: textStyles.button.withColor(colors.error),
                        ),
                      ),
                    ),
                  ],
                ],
              ),
            );
          },
          steps: _buildSteps(),
        ),
      ),
    );
  }

  int _getTotalSteps() {
    if (widget.userRole == 'profesor' || widget.userRole == 'estudiante') {
      return 3;
    }
    return 2
  }

  List<Step> _buildSteps() {
  final steps = <Step>[
      Step(
        title: const Text('Cuenta'),
        subtitle: const Text('Email y acceso'),
        content: Form(
          key: _stepKeys[0],
          child: UserAccountStep(
            emailController: _emailController,
            userRole: widget.userRole,
            selectedInstitutionId: _selectedInstitutionId,
            onInstitutionChanged: (value) => setState(() => _selectedInstitutionId = value),
            emailFocusNode: _emailFocus,
            institutionFocusNode: _institutionFocus,
            isEditMode: _user != null,
            emailFieldKey: _emailFieldKey,
            institutionFieldKey: _institutionFieldKey,
          ),
        ),
        isActive: _currentStep >= 0,
        state: _currentStep > 0 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Info Personal'),
        subtitle: const Text('Datos bÃ¡sicos'),
        content: Form(
          key: _stepKeys[1],
          child: UserPersonalInfoStep(
            nombresController: _nombresController,
            apellidosController: _apellidosController,
            telefonoController: _telefonoController,
            identificacionController: _identificacionController,
            userRole: widget.userRole,
            activo: _activo,
            onActivoChanged: (value) => setState(() => _activo = value),
            nombresFocusNode: _nombresFocus,
            apellidosFocusNode: _apellidosFocus,
            telefonoFocusNode: _telefonoFocus,
            identificacionFocusNode: _identificacionFocus,
             nombresFieldKey: _nombresFieldKey,
             apellidosFieldKey: _apellidosFieldKey,
             telefonoFieldKey: _telefonoFieldKey,
             identificacionFieldKey: _identificacionFieldKey,
          ),
        ),
        isActive: _currentStep >= 1,
        state: _currentStep > 1 ? StepState.complete : (_currentStep == 1 ? StepState.indexed : StepState.disabled),
      ),
    ];
    if (widget.userRole == 'profesor' || widget.userRole == 'estudiante') {
      steps.add(
        Step(
          title: const Text('Detalles'),
          subtitle: Text(widget.userRole == 'profesor' ? 'Info acadÃ©mica' : 'Responsable'),
          content: Form(
            key: _stepKeys[2],
            child: RoleSpecificDetailsStep(
              userRole: widget.userRole,
              tituloController: widget.userRole == 'profesor' ? _tituloController : null,
              especialidadController: widget.userRole == 'profesor' ? _especialidadController : null,
              nombreResponsableController: widget.userRole == 'estudiante' ? _nombreResponsableController : null,
              telefonoResponsableController: widget.userRole == 'estudiante' ? _telefonoResponsableController : null,
              tituloFocusNode: _tituloFocus,
              especialidadFocusNode: _especialidadFocus,
              nombreResponsableFocusNode: _nombreResponsableFocus,
              telefonoResponsableFocusNode: _telefonoResponsableFocus,
              tituloFieldKey: _tituloFieldKey,
              especialidadFieldKey: _especialidadFieldKey,
              nombreResponsableFieldKey: _nombreResponsableFieldKey,
              telefonoResponsableFieldKey: _telefonoResponsableFieldKey,
            ),
          ),
          isActive: _currentStep >= 2,
          state: _currentStep == 2 ? StepState.indexed : StepState.disabled,
        ),
      );
    }

    return steps;
  }

  void _onStepContinue() {
    final totalSteps = _getTotalSteps();
    final currentStepValid = _stepKeys[_currentStep].currentState?.validate() ?? true;
    if (!currentStepValid) {
      setState(() => _autoValidateMode = AutovalidateMode.always);

      final messenger = ScaffoldMessenger.of(context);
      final theme = Theme.of(context);
      messenger.showSnackBar(
        SnackBar(
          content: Text(
            'Corrige los campos marcados antes de continuar',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: theme.colorScheme.onPrimary,
            ),
          ),
          backgroundColor: theme.colorScheme.primary,
        ),
      );
  _focusFirstInvalidField(_currentStep, context);

      return;
    }

    if (_currentStep < totalSteps - 1) {
      setState(() => _currentStep++);
    } else {
      _saveUser();
    }
  }

  void _onStepCancel() {
    if (_currentStep > 0) {
      setState(() => _currentStep--);
    }
  }

  String _generateRandomPassword({int length = 12}) {
    const String chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#%^&*()';
    final Random random = Random.secure();
    return List.generate(length, (_) => chars[random.nextInt(chars.length)]).join();
  }
}
/* Fin lib\screens\users\user_form_screen.dart */

/* Inicio lib\screens\welcome_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../utils/responsive_utils.dart';

class WelcomeScreen extends StatelessWidget {
  const WelcomeScreen({super.key});

  Widget _buildUserName(AuthProvider authProvider, TextStyle headlineMedium, Color primary, bool isSmallScreen) {
    final user = authProvider.user;
    final userName = user?['name'] ?? user?['email'] ?? 'Usuario';

    return Text(
      userName,
      style: headlineMedium.copyWith(
        color: primary,
        fontSize: isSmallScreen ? 18 : 24,
      ),
      textAlign: TextAlign.center,
    );
  }

  Widget _buildSignOutButton(BuildContext context, AuthProvider authProvider) {
    return ElevatedButton(
      onPressed: () async {
        await authProvider.logoutAndClearAllData(context);
      },
      child: const Text('Cerrar SesiÃ³n'),
    );
  }

  Widget _buildBody(AuthProvider authProvider, dynamic textStyles, Color primaryColor, Map<String, dynamic> responsive) {
    return SafeArea(
      child: LayoutBuilder(
        builder: (context, constraints) {
          return Center(
            child: SingleChildScrollView(
              child: ConstrainedBox(
                constraints: BoxConstraints(maxWidth: responsive['maxWidth']),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    Padding(
                      padding: EdgeInsets.symmetric(
                        horizontal: responsive['horizontalPadding'],
                        vertical: responsive['verticalPadding'],
                      ),
                      child: Column(
                        children: [
                          _buildUserName(authProvider, textStyles.headlineMedium, primaryColor, responsive['isSmallScreen']),
                          SizedBox(height: responsive['elementSpacing']),

                          const Text(
                            'Has iniciado sesiÃ³n correctamente',
                            textAlign: TextAlign.center,
                          ),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildSignOutButton(context, authProvider),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
          );
        },
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final colors = context.colors;
    final textStyles = context.textStyles;

    return Scaffold(
      backgroundColor: colors.background,
      body: LayoutBuilder(
        builder: (context, constraints) {
          final responsive = ResponsiveUtils.getResponsiveValues(constraints);
          return _buildBody(authProvider, textStyles, colors.primary, responsive);
        },
      ),
    );
  }
}
/* Fin lib\screens\welcome_screen.dart */

/* Inicio lib\services\academic_service.dart */
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';
import '../config/app_config.dart';
import '../models/grupo.dart';
import '../models/materia.dart';
import '../models/horario.dart';
import '../models/clase_del_dia.dart';
import '../models/user.dart'

class PaginatedGruposResponse {
  final List<Grupo> grupos;
  final PaginationInfo pagination;

  PaginatedGruposResponse({
    required this.grupos,
    required this.pagination,
  });
}

class PaginatedMateriasResponse {
  final List<Materia> materias;
  final PaginationInfo pagination;

  PaginatedMateriasResponse({
    required this.materias,
    required this.pagination,
  });
}

class PaginatedHorariosResponse {
  final List<Horario> horarios;
  final PaginationInfo pagination;

  PaginatedHorariosResponse({
    required this.horarios,
    required this.pagination,
  });
}

class AcademicService {
  Future<PaginatedGruposResponse?> getGrupos(String accessToken, {int? page, int? limit, String? periodoId, String? search}) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      if (limit != null) queryParams['limit'] = limit.toString();
      if (periodoId != null && periodoId.isNotEmpty) queryParams['periodoId'] = periodoId;
      if (search != null && search.isNotEmpty) queryParams['search'] = search;

      final uri = Uri.parse('$baseUrlValue/grupos').replace(queryParameters: queryParams);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /grupos - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final grupos = (responseData['data'] as List)
              .map((grupoJson) => Grupo.fromJson(grupoJson))
              .toList();
          final pagination = PaginationInfo.fromJson(responseData['pagination']);
          return PaginatedGruposResponse(grupos: grupos, pagination: pagination);
        }
      } else {
        debugPrint('Error getting grupos: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting grupos: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Grupo?> getGrupoById(String accessToken, String grupoId) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/grupos/$grupoId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /grupos/$grupoId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Grupo.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error getting grupo: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting grupo: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Grupo?> createGrupo(String accessToken, CreateGrupoRequest grupoData) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/grupos'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(grupoData.toJson()),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('POST /grupos - Status: ${response.statusCode}');

      if (response.statusCode == 201) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Grupo.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error creating grupo: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error creating grupo: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Grupo?> updateGrupo(String accessToken, String grupoId, UpdateGrupoRequest grupoData) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.put(
        Uri.parse('$baseUrlValue/grupos/$grupoId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(grupoData.toJson()),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PUT /grupos/$grupoId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Grupo.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error updating grupo: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error updating grupo: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<bool> deleteGrupo(String accessToken, String grupoId) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.delete(
        Uri.parse('$baseUrlValue/grupos/$grupoId'),
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('DELETE /grupos/$grupoId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      } else {
        debugPrint('Error deleting grupo: ${response.statusCode} - ${response.body}');
        return false;
      }
    } catch (e, stackTrace) {
      debugPrint('Error deleting grupo: $e');
      debugPrint('StackTrace: $stackTrace');
      return false;
    }
  }
  Future<PaginatedMateriasResponse?> getMaterias(String accessToken, {int? page, int? limit, String? search}) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      if (limit != null) queryParams['limit'] = limit.toString();
      if (search != null && search.isNotEmpty) queryParams['search'] = search;

      final uri = Uri.parse('$baseUrlValue/materias').replace(queryParameters: queryParams);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /materias - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final materias = (responseData['data'] as List)
              .map((materiaJson) => Materia.fromJson(materiaJson))
              .toList();
          final pagination = PaginationInfo.fromJson(responseData['pagination']);
          return PaginatedMateriasResponse(materias: materias, pagination: pagination);
        }
      } else {
        debugPrint('Error getting materias: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting materias: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Materia?> getMateriaById(String accessToken, String materiaId) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/materias/$materiaId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /materias/$materiaId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Materia.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error getting materia: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting materia: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Materia?> createMateria(String accessToken, CreateMateriaRequest materiaData) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/materias'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(materiaData.toJson()),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('POST /materias - Status: ${response.statusCode}');

      if (response.statusCode == 201) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Materia.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error creating materia: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error creating materia: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Materia?> updateMateria(String accessToken, String materiaId, UpdateMateriaRequest materiaData) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.put(
        Uri.parse('$baseUrlValue/materias/$materiaId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(materiaData.toJson()),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PUT /materias/$materiaId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Materia.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error updating materia: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error updating materia: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<bool> deleteMateria(String accessToken, String materiaId) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.delete(
        Uri.parse('$baseUrlValue/materias/$materiaId'),
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('DELETE /materias/$materiaId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      } else {
        debugPrint('Error deleting materia: ${response.statusCode} - ${response.body}');
        return false;
      }
    } catch (e, stackTrace) {
      debugPrint('Error deleting materia: $e');
      debugPrint('StackTrace: $stackTrace');
      return false;
    }
  }
  Future<PaginatedHorariosResponse?> getHorarios(String accessToken, {int? page, int? limit, String? grupoId, String? periodoId}) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      if (limit != null) queryParams['limit'] = limit.toString();
      if (grupoId != null && grupoId.isNotEmpty) queryParams['grupoId'] = grupoId;
      if (periodoId != null && periodoId.isNotEmpty) queryParams['periodoId'] = periodoId;

      final uri = Uri.parse('$baseUrlValue/horarios').replace(queryParameters: queryParams);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /horarios - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final horarios = (responseData['data'] as List)
              .map((horarioJson) => Horario.fromJson(horarioJson))
              .toList();
          final pagination = PaginationInfo.fromJson(responseData['pagination']);
          return PaginatedHorariosResponse(horarios: horarios, pagination: pagination);
        }
      } else {
        debugPrint('Error getting horarios: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting horarios: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<List<Horario>?> getHorariosPorGrupo(String accessToken, String grupoId) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final uri = Uri.parse('$baseUrlValue/horarios').replace(queryParameters: {'grupoId': grupoId});

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /horarios?grupoId=$grupoId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return (responseData['data'] as List)
              .map((horarioJson) => Horario.fromJson(horarioJson))
              .toList();
        }
      } else {
        debugPrint('Error getting horarios por grupo: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting horarios por grupo: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Horario?> getHorarioById(String accessToken, String horarioId) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/horarios/$horarioId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /horarios/$horarioId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Horario.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error getting horario: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting horario: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Horario?> createHorario(String accessToken, CreateHorarioRequest horarioData) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/horarios'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(horarioData.toJson()),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('POST /horarios - Status: ${response.statusCode}');

      if (response.statusCode == 201) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Horario.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error creating horario: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error creating horario: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Horario?> updateHorario(String accessToken, String horarioId, UpdateHorarioRequest horarioData) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.put(
        Uri.parse('$baseUrlValue/horarios/$horarioId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(horarioData.toJson()),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PUT /horarios/$horarioId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Horario.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error updating horario: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error updating horario: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<bool> deleteHorario(String accessToken, String horarioId) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.delete(
        Uri.parse('$baseUrlValue/horarios/$horarioId'),
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('DELETE /horarios/$horarioId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      } else {
        debugPrint('Error deleting horario: ${response.statusCode} - ${response.body}');
        return false;
      }
    } catch (e, stackTrace) {
      debugPrint('Error deleting horario: $e');
      debugPrint('StackTrace: $stackTrace');
      return false;
    }
  }
  Future<List<ClaseDelDia>?> getMisClasesDelDia(String accessToken) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/profesores/dashboard/clases-hoy'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /profesores/dashboard/clases-hoy - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return (responseData['data'] as List)
              .map((claseJson) => ClaseDelDia.fromJson(claseJson))
              .toList();
        }
      } else {
        debugPrint('Error getting clases del dia: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting clases del dia: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<List<ClaseDelDia>?> getMisClasesPorDia(String accessToken, int diaSemana) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/profesores/dashboard/clases/$diaSemana'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /profesores/dashboard/clases/$diaSemana - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return (responseData['data'] as List)
              .map((claseJson) => ClaseDelDia.fromJson(claseJson))
              .toList();
        }
      } else {
        debugPrint('Error getting clases por dia: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting clases por dia: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<List<ClaseDelDia>?> getMiHorarioSemanal(String accessToken) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/profesores/dashboard/horario-semanal'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /profesores/dashboard/horario-semanal - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return (responseData['data'] as List)
              .map((claseJson) => ClaseDelDia.fromJson(claseJson))
              .toList();
        }
      } else {
        debugPrint('Error getting horario semanal: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting horario semanal: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
}

class CreateGrupoRequest {
  final String nombre;
  final String grado;
  final String? seccion;
  final String periodoId;

  CreateGrupoRequest({
    required this.nombre,
    required this.grado,
    this.seccion,
    required this.periodoId,
  });

  Map<String, dynamic> toJson() {
    return {
      'nombre': nombre,
      'grado': grado,
      'seccion': seccion,
      'periodoId': periodoId,
    };
  }
}

class UpdateGrupoRequest {
  final String nombre;
  final String grado;
  final String? seccion;

  UpdateGrupoRequest({
    required this.nombre,
    required this.grado,
    this.seccion,
  });

  Map<String, dynamic> toJson() {
    return {
      'nombre': nombre,
      'grado': grado,
      'seccion': seccion,
    };
  }
}

class CreateMateriaRequest {
  final String nombre;
  final String? codigo;

  CreateMateriaRequest({
    required this.nombre,
    this.codigo,
  });

  Map<String, dynamic> toJson() {
    return {
      'nombre': nombre,
      'codigo': codigo,
    };
  }
}

class UpdateMateriaRequest {
  final String nombre;
  final String? codigo;

  UpdateMateriaRequest({
    required this.nombre,
    this.codigo,
  });

  Map<String, dynamic> toJson() {
    return {
      'nombre': nombre,
      'codigo': codigo,
    };
  }
}

class CreateHorarioRequest {
  final String periodoId;
  final String grupoId;
  final String materiaId;
  final String? profesorId;
  final int diaSemana;
  final String horaInicio;
  final String horaFin;

  CreateHorarioRequest({
    required this.periodoId,
    required this.grupoId,
    required this.materiaId,
    this.profesorId,
    required this.diaSemana,
    required this.horaInicio,
    required this.horaFin,
  });

  Map<String, dynamic> toJson() {
    return {
      'periodoId': periodoId,
      'grupoId': grupoId,
      'materiaId': materiaId,
      'profesorId': profesorId,
      'diaSemana': diaSemana,
      'horaInicio': horaInicio,
      'horaFin': horaFin,
    };
  }
}

class UpdateHorarioRequest {
  final String? profesorId;
  final int diaSemana;
  final String horaInicio;
  final String horaFin;

  UpdateHorarioRequest({
    this.profesorId,
    required this.diaSemana,
    required this.horaInicio,
    required this.horaFin,
  });

  Map<String, dynamic> toJson() {
    return {
      'profesorId': profesorId,
      'diaSemana': diaSemana,
      'horaInicio': horaInicio,
      'horaFin': horaFin,
    };
  }
}
/* Fin lib\services\academic_service.dart */

/* Inicio lib\services\auth_service.dart */
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';
import '../config/app_config.dart';

class LoginResponse {
  final String accessToken;
  final String refreshToken;
  final Map<String, dynamic> user;
  final int? expiresIn;

  LoginResponse({
    required this.accessToken,
    required this.refreshToken,
    required this.user,
    this.expiresIn,
  });

  factory LoginResponse.fromJson(Map<String, dynamic> json) {

    final data = json['data'] ?? json;

    final usuario = data['usuario'] ?? data['user'];

    return LoginResponse(
      accessToken: data['accessToken'] as String,
      refreshToken: data['refreshToken'] as String,
      user: usuario is Map<String, dynamic> ? usuario : {},
      expiresIn: data['expiresIn'] as int?,
    );
  }
}

class RefreshResponse {
  final String accessToken;
  final String refreshToken;

  RefreshResponse({
    required this.accessToken,
    required this.refreshToken,
  });

  factory RefreshResponse.fromJson(Map<String, dynamic> json) {
    return RefreshResponse(
      accessToken: json['accessToken'],
      refreshToken: json['refreshToken'],
    );
  }
}

class AuthService {

  Future<LoginResponse?> login(String email, String password) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final url = '$baseUrlValue/auth/login';

      final requestBody = jsonEncode({
        'email': email,
        'password': password,
      });

      final response = await http.post(
        Uri.parse(url),
        headers: {'Content-Type': 'application/json'},
        body: requestBody,
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('   Status: ${response.statusCode}');
      debugPrint('   Body: ${response.body}');
      debugPrint('========================================');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);

        final data = responseData['data'] ?? responseData;

        if (data['accessToken'] == null || data['refreshToken'] == null) {
          debugPrint('   accessToken: ${data['accessToken']}');
          debugPrint('   refreshToken: ${data['refreshToken']}');
          debugPrint('   usuario: ${data['usuario']}');
          return null;
        }

        return LoginResponse.fromJson(responseData);
      } else {
        debugPrint('   Response: ${response.body}');

        try {
          final Map<String, dynamic> errorData = jsonDecode(response.body);
          final serverMessage = errorData['message'] ?? errorData['error'] ?? (errorData['data'] is Map ? errorData['data']['message'] : null) ?? response.body;
          throw Exception(serverMessage);
        } catch (parseError) {

          throw Exception(response.body);
        }
      }
    } catch (e, stackTrace) {
      debugPrint('Error: $e');
      debugPrint('StackTrace: $stackTrace');
      debugPrint('====================================');

      rethrow;
    }
  }

  Future<RefreshResponse?> refreshToken(String refreshToken) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/auth/refresh'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'refreshToken': refreshToken,
        }),
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        return RefreshResponse.fromJson(data);
      } else {
        debugPrint('Refresh failed: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e) {
      debugPrint('Refresh error: $e');
      return null;
    }
  }

  Future<bool> logout(String refreshToken) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/auth/logout'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'refreshToken': refreshToken,
        }),
      );

      return response.statusCode == 200;
    } catch (e) {
      debugPrint('Logout error: $e');
      return false;
    }
  }

  Future<List<Map<String, dynamic>>?> getUserInstitutions(String accessToken) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/auth/instituciones'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        if (data['success'] == true) {
          final institutions = data['data'] as List;
          return institutions.map((e) => e as Map<String, dynamic>).toList();
        }
      } else {
        debugPrint('Get user institutions failed: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e) {
      debugPrint('Get user institutions error: $e');
      return null;
    }
    return null;
  }
}
/* Fin lib\services\auth_service.dart */

/* Inicio lib\services\institution_service.dart */
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';
import '../models/institution.dart';
import '../models/user.dart';
import '../config/app_config.dart';

class PaginatedInstitutionResponse {
  final List<Institution> institutions;
  final PaginationInfo pagination;

  PaginatedInstitutionResponse({
    required this.institutions,
    required this.pagination,
  });
}

class InstitutionService {

  Future<PaginatedInstitutionResponse?> getAllInstitutions(String accessToken, {int? page, int? limit, bool? activa, String? search}) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      if (limit != null) queryParams['limit'] = limit.toString();
      if (activa != null) queryParams['activa'] = activa.toString();
      if (search != null && search.isNotEmpty) queryParams['search'] = search;

      final uri = Uri.parse('$baseUrlValue/instituciones').replace(queryParameters: queryParams);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /instituciones - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final institutions = (responseData['data'] as List)
              .map((institutionJson) => Institution.fromJson(institutionJson))
              .toList();
          final pagination = PaginationInfo.fromJson(responseData['pagination']);
          return PaginatedInstitutionResponse(institutions: institutions, pagination: pagination);
        }
      } else {
        debugPrint('Error getting institutions: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting institutions: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }

  Future<Institution?> getInstitutionById(String accessToken, String id) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/instituciones/$id'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /instituciones/$id - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Institution.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error getting institution: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting institution: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }

  Future<Institution?> createInstitution(
    String accessToken, {
    required String nombre,
    String? direccion,
    String? telefono,
    String? email,
  }) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/instituciones'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode({
          'nombre': nombre,
          if (direccion != null) 'direccion': direccion,
          if (telefono != null) 'telefono': telefono,
          if (email != null) 'email': email,
        }),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('POST /instituciones - Status: ${response.statusCode}');

      if (response.statusCode == 201) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Institution.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error creating institution: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error creating institution: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }

  Future<Institution?> updateInstitution(
    String accessToken,
    String id, {
    String? nombre,
    String? direccion,
    String? telefono,
    String? email,
    bool? activa,
  }) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.put(
        Uri.parse('$baseUrlValue/instituciones/$id'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode({
          if (nombre != null) 'nombre': nombre,
          if (direccion != null) 'direccion': direccion,
          if (telefono != null) 'telefono': telefono,
          if (email != null) 'email': email,
          if (activa != null) 'activa': activa,
        }),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PUT /instituciones/$id - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Institution.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error updating institution: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error updating institution: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }

  Future<bool> deleteInstitution(String accessToken, String id) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.delete(
        Uri.parse('$baseUrlValue/instituciones/$id'),
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('DELETE /instituciones/$id - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      } else {
        debugPrint('Error deleting institution: ${response.statusCode} - ${response.body}');
        return false;
      }
    } catch (e, stackTrace) {
      debugPrint('Error deleting institution: $e');
      debugPrint('StackTrace: $stackTrace');
      return false;
    }
  }
}
/* Fin lib\services\institution_service.dart */

/* Inicio lib\services\profesor_service.dart */
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';
import '../models/user.dart';
import '../config/app_constants.dart';
import '../config/app_config.dart';

class PaginatedUserResponse {
  final List<User> users;
  final PaginationInfo pagination;

  PaginatedUserResponse({
    required this.users,
    required this.pagination,
  });
}

class ProfesorService {

  Future<PaginatedUserResponse?> getAllProfesores(String accessToken, {int? page, int? limit, String? search, bool? activo}) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      if (limit != null) queryParams['limit'] = limit.toString();
      if (search != null && search.isNotEmpty) queryParams['search'] = search;
      if (activo != null) queryParams['activo'] = activo.toString();

      final uri = Uri.parse('$baseUrlValue/institution-admin/profesores').replace(queryParameters: queryParams.isNotEmpty ? queryParams : null);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /institution-admin/profesores - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final profesores = (responseData['data'] as List)
              .map((userJson) => User.fromJson(userJson))
              .toList();

          final pagination = responseData['pagination'] != null
              ? PaginationInfo.fromJson(responseData['pagination'])
              : PaginationInfo(
                  page: page ?? 1,
                  limit: limit ?? AppConstants.itemsPerPage,
                  total: profesores.length,
                  totalPages: 1,
                  hasNext: false,
                  hasPrev: false,
                );

          return PaginatedUserResponse(users: profesores, pagination: pagination);
        }
      } else {
        debugPrint('Error getting profesores: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting profesores: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }

  Future<User?> getProfesorById(String accessToken, String profesorId) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/institution-admin/profesores/$profesorId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /institution-admin/profesores/$profesorId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return User.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error getting profesor: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting profesor: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }

  Future<User?> createProfesor(String accessToken, CreateUserRequest profesorData) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/institution-admin/profesores'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode({
          'nombres': profesorData.nombres,
          'apellidos': profesorData.apellidos,
          'email': profesorData.email,
          'password': profesorData.password,
          'telefono': profesorData.telefono,
          'grupoId': profesorData.rolEnInstitucion, // Puede ser usado como grupoId
        }),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('POST /institution-admin/profesores - Status: ${response.statusCode}');

      if (response.statusCode == 201) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return User.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error creating profesor: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error creating profesor: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }

  Future<User?> updateProfesor(String accessToken, String profesorId, UpdateUserRequest profesorData) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;

      final Map<String, dynamic> updateData = {};
      if (profesorData.nombres != null) updateData['nombres'] = profesorData.nombres;
      if (profesorData.apellidos != null) updateData['apellidos'] = profesorData.apellidos;
      if (profesorData.email != null) updateData['email'] = profesorData.email;
      if (profesorData.telefono != null) updateData['telefono'] = profesorData.telefono;
      if (profesorData.activo != null) updateData['activo'] = profesorData.activo;

      final response = await http.put(
        Uri.parse('$baseUrlValue/institution-admin/profesores/$profesorId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(updateData),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PUT /institution-admin/profesores/$profesorId - Status: ${response.statusCode}');
      debugPrint('Update data sent: $updateData');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return User.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error updating profesor: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error updating profesor: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }

  Future<bool> deleteProfesor(String accessToken, String profesorId) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.delete(
        Uri.parse('$baseUrlValue/institution-admin/profesores/$profesorId'),
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('DELETE /institution-admin/profesores/$profesorId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      } else {
        debugPrint('Error deleting profesor: ${response.statusCode} - ${response.body}');
        return false;
      }
    } catch (e, stackTrace) {
      debugPrint('Error deleting profesor: $e');
      debugPrint('StackTrace: $stackTrace');
      return false;
    }
  }

  Future<User?> toggleProfesorStatus(String accessToken, String profesorId) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.patch(
        Uri.parse('$baseUrlValue/institution-admin/profesores/$profesorId/toggle-status'),
        headers: {
          'Authorization': 'Bearer $accessToken',

        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PATCH /institution-admin/profesores/$profesorId/toggle-status - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return User.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error toggling profesor status: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error toggling profesor status: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
}
/* Fin lib\services\profesor_service.dart */

/* Inicio lib\services\user_service.dart */
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';
import '../config/app_config.dart';
import '../models/user.dart';

class PaginatedUserResponse {
  final List<User> users;
  final PaginationInfo pagination;

  PaginatedUserResponse({
    required this.users,
    required this.pagination,
  });
}

class UserService {

  Future<PaginatedUserResponse?> getAllUsers(String accessToken, {int? page, int? limit, bool? activo, String? search, List<String>? roles}) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      if (limit != null) queryParams['limit'] = limit.toString();
      if (activo != null) queryParams['activo'] = activo.toString();
      if (search != null && search.isNotEmpty) queryParams['search'] = search;
      if (roles != null && roles.isNotEmpty) queryParams['rol'] = roles.join(',');

  final uri = Uri.parse('$baseUrlValue/usuarios').replace(queryParameters: queryParams);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /usuarios - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final users = (responseData['data'] as List)
              .map((userJson) => User.fromJson(userJson))
              .toList();
          final pagination = PaginationInfo.fromJson(responseData['pagination']);
          return PaginatedUserResponse(users: users, pagination: pagination);
        }
      } else {
        debugPrint('Error getting users: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting users: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }

  Future<User?> getUserById(String accessToken, String userId) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/usuarios/$userId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /usuarios/$userId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return User.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error getting user: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting user: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }

  Future<PaginatedUserResponse?> getUsersByRole(String accessToken, String role, {int? page, int? limit, bool? activo, String? search}) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      if (limit != null) queryParams['limit'] = limit.toString();
      if (activo != null) queryParams['activo'] = activo.toString();
      if (search != null && search.isNotEmpty) queryParams['search'] = search;

      final uri = Uri.parse('$baseUrlValue/usuarios/rol/$role').replace(queryParameters: queryParams);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /usuarios/rol/$role - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final users = (responseData['data'] as List)
              .map((userJson) => User.fromJson(userJson))
              .toList();
          final pagination = PaginationInfo.fromJson(responseData['pagination']);
          return PaginatedUserResponse(users: users, pagination: pagination);
        }
      } else {
        debugPrint('Error getting users by role: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting users by role: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }

  Future<PaginatedUserResponse?> getUsersByInstitution(String accessToken, String institutionId, {int? page, int limit = 5, String? role, bool? activo, String? search}) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      queryParams['limit'] = limit.toString();
      if (role != null && role.isNotEmpty) queryParams['rol'] = role;
      if (activo != null) queryParams['activo'] = activo.toString();
      if (search != null && search.isNotEmpty) queryParams['search'] = search;

      final uri = Uri.parse('$baseUrlValue/usuarios/institucion/$institutionId').replace(queryParameters: queryParams);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /usuarios/institucion/$institutionId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final users = (responseData['data'] as List)
              .map((userJson) => User.fromJson(userJson))
              .toList();
          final pagination = PaginationInfo.fromJson(responseData['pagination']);
          return PaginatedUserResponse(users: users, pagination: pagination);
        }
      } else {
        debugPrint('Error getting users by institution: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting users by institution: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }

  Future<List<User>?> getAdminsByInstitution(String accessToken, String institutionId) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final uri = Uri.parse('$baseUrlValue/instituciones/$institutionId/admins');

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(const Duration(seconds: 10));

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final list = (responseData['data'] as List)
              .map((item) {

                if (item is Map && item.containsKey('usuario')) {
                  return User.fromJson(item['usuario']);
                }
                if (item is Map && item.containsKey('email')) {

                  final usuarioJson = {
                    'id': item['usuarioId'] ?? item['id'],
                    'email': item['email'],
                    'nombres': item['nombres'],
                    'apellidos': item['apellidos'],
                    'rol': 'admin_institucion',
                    'telefono': item['telefono'],
                    'activo': item['activo'] ?? true,
                    'usuarioInstituciones': [
                      {
                        'institucion': {
                          'id': item['institucionId'],
                          'nombre': '',
                        },
                        'rolEnInstitucion': item['rolEnInstitucion'],
                        'activo': item['activo'] ?? true,
                      }
                    ],
                  };
                  return User.fromJson(usuarioJson);
                }
                return null;
              })
              .whereType<User>()
              .toList();

          return list;
        }
      }
      return null;
    } catch (e, st) {
      debugPrint('Error getting admins by institution: $e');
      debugPrint('StackTrace: $st');
      return null;
    }
  }

  Future<User?> assignAdminToInstitution(String accessToken, String institutionId, String userId) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final uri = Uri.parse('$baseUrlValue/instituciones/$institutionId/admins');

      final response = await http.post(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode({'userId': userId}),
      ).timeout(const Duration(seconds: 10));

      if (response.statusCode == 201 || response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final data = responseData['data'];

          if (data is Map && data['id'] != null) {
            return User.fromJson(data as Map<String, dynamic>);
          }
        }
      }
      return null;
    } catch (e, st) {
      debugPrint('Error assigning admin to institution: $e');
      debugPrint('StackTrace: $st');
      return null;
    }
  }

  Future<bool?> removeAdminFromInstitution(String accessToken, String institutionId, String userId) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final uri = Uri.parse('$baseUrlValue/instituciones/$institutionId/admins/$userId');

      final response = await http.delete(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(const Duration(seconds: 10));

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      }
      return null;
    } catch (e, st) {
      debugPrint('Error removing admin from institution: $e');
      debugPrint('StackTrace: $st');
      return null;
    }
  }

  Future<bool> changePassword(String accessToken, String userId, String newPassword) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final uri = Uri.parse('$baseUrlValue/usuarios/$userId/change-password');

      final response = await http.patch(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode({'newPassword': newPassword}),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PATCH /usuarios/$userId/change-password - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      } else {
        debugPrint('Error changePassword: ${response.statusCode} - ${response.body}');
        return false;
      }
    } catch (e, st) {
      debugPrint('Error changePassword: $e');
      debugPrint('StackTrace: $st');
      return false;
    }
  }

  Future<User?> createUser(String accessToken, CreateUserRequest userData) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/usuarios'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(userData.toJson()),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('POST /usuarios - Status: ${response.statusCode}');

      if (response.statusCode == 201) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return User.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error creating user: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error creating user: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }

  Future<User?> updateUser(String accessToken, String userId, UpdateUserRequest userData) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.put(
        Uri.parse('$baseUrlValue/usuarios/$userId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(userData.toJson()),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PUT /usuarios/$userId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return User.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error updating user: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error updating user: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }

  Future<bool> deleteUser(String accessToken, String userId) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.delete(
        Uri.parse('$baseUrlValue/usuarios/$userId'),
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('DELETE /usuarios/$userId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      } else {
        debugPrint('Error deleting user: ${response.statusCode} - ${response.body}');
        return false;
      }
    } catch (e, stackTrace) {
      debugPrint('Error deleting user: $e');
      debugPrint('StackTrace: $stackTrace');
      return false;
    }
  }
}
/* Fin lib\services\user_service.dart */

/* Inicio lib\theme\app_colors.dart */
import 'package:flutter/material.dart';
class AppColors {

  AppColors._();

  static final AppColors instance = AppColors._();
  static const Color _primaryBase = Color(0xFF0055D4)
  static const Color _secondaryBase = Color(0xFF4F46E5)
  static const Color _surfaceBase = Color(0xFFFFFFFF)
  static const Color _backgroundBase = Color(0xFFF8FAFC)
  final Color primary = _primaryBase;
  final Color primaryDark = const Color(0xFF0043B8)
  final Color primaryLight = const Color(0xFF4D9DE0)
  final Color primaryContainer = const Color(0xFFE3F2FD)
  final Color secondary = _secondaryBase;
  final Color secondaryLight = const Color(0xFF6366F1)
  final Color secondaryContainer = const Color(0xFFEEF2FF)
  final Color success = const Color(0xFF16A34A)
  final Color successLight = const Color(0xFF22C55E)
  final Color successDark = const Color(0xFF15803D)
  final Color warning = const Color(0xFFF59E0B)
  final Color warningLight = const Color(0xFFFCD34D)
  final Color warningDark = const Color(0xFFD97706)
  final Color error = const Color(0xFFDC2626)
  final Color errorLight = const Color(0xFFF87171)
  final Color errorDark = const Color(0xFFB91C1C)
  final Color info = const Color(0xFF3B82F6)
  final Color infoLight = const Color(0xFF60A5FA)
  final Color infoDark = const Color(0xFF2563EB)
  final Color featureUsers = const Color(0xFF6366F1)
  final Color featureInstitutions = const Color(0xFF0EA5E9)
  final Color featureAttendance = const Color(0xFFF59E0B)
  final Color featureReports = const Color(0xFFE11D48)
  final Color featureSchedule = const Color(0xFF14B8A6)
  final Color featureSettings = const Color(0xFF475569)
  final Color featureNotifications = const Color(0xFFF97316)
  final Color featureClasses = const Color(0xFFEF4444)
  final Color featureGrades = const Color(0xFF84CC16)
  final Color featureStudents = const Color(0xFF0055D4)
  final Color stateNoData = const Color(0xFF94A3B8)
  final Color stateInDevelopment = const Color(0xFF6366F1)
  final Color stateSuccess = const Color(0xFF22C55E)
  final Color stateInactive = const Color(0xFFE2E8F0)
  final Color stateActive = const Color(0xFF16A34A)

  final Color surface = _surfaceBase
  final Color surfaceLight = const Color(0xFFF8FAFC)
  final Color surfaceContainer = const Color(0xFFFFFFFF)
  final Color surfaceVariant = const Color(0xFFF1F5F9)

  final Color background = _backgroundBase
  final Color backgroundLight = const Color(0xFFFFFFFF)
  final Color backgroundVariant = const Color(0xFFF8FAFC)
  final Color textPrimary = const Color(0xFF0F172A)
  final Color textSecondary = const Color(0xFF334155)
  final Color textMuted = const Color(0xFF64748B)
  final Color textDisabled = const Color(0xFF94A3B8)
  final Color textOnDark = const Color(0xFFF8FAFC)
  final Color textOnDarkSecondary = const Color(0xFFE2E8F0)
  final Color textOnDarkMuted = const Color(0xFFCBD5E1)

  final Color border = const Color(0xFFE2E8F0)
  final Color borderLight = const Color(0xFFF1F5F9)
  final Color borderStrong = const Color(0xFFCBD5E1)
  final Color divider = const Color(0xFFE2E8F0)

  final Color shadow = const Color(0x0A000000)
  final Color shadowLight = const Color(0x05000000)
  final Color shadowMedium = const Color(0x0F000000)
  final Color scrim = const Color(0x0F000000)

  final Color transparent = const Color(0x00000000);
  final Color white = const Color(0xFFFFFFFF);
  final Color black = const Color(0xFF000000);
  final Color grey50 = const Color(0xFFF8FAFC);
  final Color grey100 = const Color(0xFFF1F5F9);
  final Color grey200 = const Color(0xFFE2E8F0);
  final Color grey300 = const Color(0xFFCBD5E1);
  final Color grey400 = const Color(0xFF94A3B8);
  final Color grey500 = const Color(0xFF64748B);
  final Color grey600 = const Color(0xFF475569);
  final Color grey700 = const Color(0xFF334155);
  final Color grey800 = const Color(0xFF1E293B);
  final Color grey900 = const Color(0xFF0F172A);
  Color get primaryWithOpacity => primary.withValues(alpha: 0.9);
  Color get surfaceWithOpacity => surface.withValues(alpha: 0.95);
  Color get textSecondaryWithOpacity => textSecondary.withValues(alpha: 0.8);
  Color get warningBackground => warning.withValues(alpha: 0.08);
  Color get warningBorder => warning.withValues(alpha: 0.2);
  Color get infoBackground => info.withValues(alpha: 0.08);
  Color get infoBorder => info.withValues(alpha: 0.2);
  Color get errorBackground => error.withValues(alpha: 0.08);
  Color get errorBorder => error.withValues(alpha: 0.2);
  Color get successBackground => success.withValues(alpha: 0.08);
  Color get successBorder => success.withValues(alpha: 0.2);
  Color get roleBadgeBackground => primary.withValues(alpha: 0.1);
  Color get roleBadgeText => primary;
  Color get roleBadgeIcon => primary;
  Color getTextColorForBackground(Color backgroundColor) {
    final luminance = backgroundColor.computeLuminance();
    return luminance > 0.5 ? textPrimary : textOnDark;
  }

  Color getSecondaryTextColorForBackground(Color backgroundColor) {
    final luminance = backgroundColor.computeLuminance();
    return luminance > 0.5 ? textSecondary : textOnDarkSecondary;
  }

  Color getMutedTextColorForBackground(Color backgroundColor) {
    final luminance = backgroundColor.computeLuminance();
    return luminance > 0.5 ? textMuted : textOnDarkMuted;
  }
}

/* Fin lib\theme\app_colors.dart */

/* Inicio lib\theme\app_spacing.dart */

class AppSpacing {
  AppSpacing._();
  static final AppSpacing instance = AppSpacing._();
  static const double _baseUnit = 4;
  final double xs = _baseUnit
  final double sm = _baseUnit * 2
  final double md = _baseUnit * 4
  final double lg = _baseUnit * 6
  final double xl = _baseUnit * 8
  final double xxl = _baseUnit * 12
  final double xxxl = _baseUnit * 16
  final double buttonPadding = _baseUnit * 4
  final double cardPadding = _baseUnit * 3
  final double screenPadding = _baseUnit * 4
  final double inputPadding = _baseUnit * 3
  final double iconSize = _baseUnit * 6
  final double borderRadius = _baseUnit * 2
  final double borderRadiusLarge = _baseUnit * 3
  final double appBarHeight = _baseUnit * 14
  final double borderWidth = 1
  double multiply(double factor) => _baseUnit * factor;
  double add(double value) => _baseUnit + value;
}
/* Fin lib\theme\app_spacing.dart */

/* Inicio lib\theme\app_text_styles.dart */
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'app_colors.dart';
class AppTextStyles {

  AppTextStyles._();

  static final AppTextStyles instance = AppTextStyles._();

  TextStyle _createStyle({
    required double fontSize,
    required FontWeight fontWeight,
    required double height,
    required double letterSpacing,
    Color? color,
    TextDecoration? decoration,
  }) {
    return GoogleFonts.inter(
      fontSize: fontSize,
      fontWeight: fontWeight,
      height: height,
      letterSpacing: letterSpacing,
      color: color ?? AppColors.instance.textPrimary,
      decoration: decoration,
    );
  }

  TextStyle get displayLarge => _createStyle(
    fontSize: 32,
    fontWeight: FontWeight.w700, // Bold para impacto
    height: 1.2,
    letterSpacing: -0.5, // Letter spacing negativo para tÃ­tulos grandes
  );

  TextStyle get displayMedium => _createStyle(
    fontSize: 28,
    fontWeight: FontWeight.w700,
    height: 1.25,
    letterSpacing: -0.4,
  );

  TextStyle get headlineLarge => _createStyle(
    fontSize: 24,
    fontWeight: FontWeight.w600, // SemiBold para jerarquÃ­a
    height: 1.3,
    letterSpacing: -0.3,
  );

  TextStyle get headlineMedium => _createStyle(
    fontSize: 20,
    fontWeight: FontWeight.w600,
    height: 1.4,
    letterSpacing: -0.2,
  );

  TextStyle get headlineSmall => _createStyle(
    fontSize: 18,
    fontWeight: FontWeight.w600,
    height: 1.4,
    letterSpacing: -0.1,
  );

  TextStyle get titleLarge => _createStyle(
    fontSize: 17,
    fontWeight: FontWeight.w600,
    height: 1.4,
    letterSpacing: 0.0,
  );

  TextStyle get titleMedium => _createStyle(
    fontSize: 15,
    fontWeight: FontWeight.w500, // Medium para subtÃ­tulos
    height: 1.5,
    letterSpacing: 0.0,
  );

  TextStyle get titleSmall => _createStyle(
    fontSize: 14,
    fontWeight: FontWeight.w500,
    height: 1.5,
    letterSpacing: 0.1,
  );

  TextStyle get bodyLarge => _createStyle(
    fontSize: 16,
    fontWeight: FontWeight.w400, // Regular para legibilidad
    height: 1.5,
    letterSpacing: 0.1,
    color: AppColors.instance.textPrimary,
  );

  TextStyle get bodyMedium => _createStyle(
    fontSize: 15,
    fontWeight: FontWeight.w400,
    height: 1.5,
    letterSpacing: 0.1,
    color: AppColors.instance.textPrimary,
  );

  TextStyle get bodySmall => _createStyle(
    fontSize: 13,
    fontWeight: FontWeight.w400,
    height: 1.4,
    letterSpacing: 0.2,
    color: AppColors.instance.textMuted,
  );

  TextStyle get labelLarge => _createStyle(
    fontSize: 16,
    fontWeight: FontWeight.w600, // SemiBold para botones
    height: 1.4,
    letterSpacing: 0.1,
    color: AppColors.instance.textSecondary,
  );

  TextStyle get labelMedium => _createStyle(
    fontSize: 14,
    fontWeight: FontWeight.w500,
    height: 1.4,
    letterSpacing: 0.2,
    color: AppColors.instance.textSecondary,
  );

  TextStyle get labelSmall => _createStyle(
    fontSize: 11,
    fontWeight: FontWeight.w500,
    height: 1.4,
    letterSpacing: 0.5,
    color: AppColors.instance.textMuted,
  );
  TextStyle get button => labelLarge.copyWith(
    color: null, // Usar foregroundColor del botÃ³n
    letterSpacing: 0.2, // Mejor legibilidad en botones
  );
  TextStyle get navigation => labelMedium.copyWith(
    fontWeight: FontWeight.w500,
    letterSpacing: 0.1,
  );
  TextStyle get navigationActive => navigation.copyWith(
    fontWeight: FontWeight.w600,
    color: AppColors.instance.primary,
  );
  TextStyle get navigationInactive => navigation.copyWith(
    color: AppColors.instance.textMuted,
  );
  TextStyle get kpiNumber => _createStyle(
    fontSize: 28,
    fontWeight: FontWeight.w700,
    height: 1.2,
    letterSpacing: -0.5,
    color: AppColors.instance.textPrimary,
  );
  TextStyle get kpiLabel => labelSmall.copyWith(
    fontSize: 10,
    letterSpacing: 0.8,
    fontWeight: FontWeight.w600,
  );
  TextStyle get statusText => labelSmall.copyWith(
    fontSize: 10,
    fontWeight: FontWeight.w600,
    letterSpacing: 0.5,
  );
  TextStyle get errorText => bodySmall.copyWith(
    color: AppColors.instance.error,
    fontWeight: FontWeight.w500,
  );
  TextStyle get helpText => bodySmall.copyWith(
    color: AppColors.instance.textMuted,
    fontWeight: FontWeight.w400,
  );

  TextStyle get caption => bodySmall.copyWith(
    fontSize: 12,
  );

  TextStyle get overline => labelSmall.copyWith(
    fontSize: 10,
    letterSpacing: 1.5,
    fontWeight: FontWeight.w500,
  );

  TextStyle withColor(Color color) => _createStyle(
    fontSize: 15, // default
    fontWeight: FontWeight.normal,
    height: 1.4,
    letterSpacing: 0,
    color: color,
  );

  TextStyle withWeight(FontWeight weight) => _createStyle(
    fontSize: 15, // default
    fontWeight: weight,
    height: 1.4,
    letterSpacing: 0,
  );

  TextStyle withSize(double size) => _createStyle(
    fontSize: size,
    fontWeight: FontWeight.normal,
    height: 1.4,
    letterSpacing: 0,
  );
}
/* Fin lib\theme\app_text_styles.dart */

/* Inicio lib\theme\app_theme.dart */
import 'package:flutter/material.dart';
import 'app_colors.dart';
import 'app_spacing.dart';
import 'app_text_styles.dart';
class AppTheme {

  AppTheme._();

  static final AppTheme instance = AppTheme._();
  static ThemeData get light => _createTheme(Brightness.light);
  static ThemeData get dark => _createTheme(Brightness.dark);
  static ThemeData get defaultTheme => dark;

  static ThemeData _createTheme(Brightness brightness) {
    final colors = AppColors.instance;
    final textStyles = AppTextStyles.instance;

    return ThemeData(
      brightness: brightness,
      useMaterial3: true,

      colorScheme: ColorScheme(
        brightness: brightness,
        primary: colors.primary,
        onPrimary: brightness == Brightness.light ? colors.textPrimary : colors.white, // Negro en light, blanco en dark
        primaryContainer: colors.primaryContainer,
        onPrimaryContainer: colors.textPrimary,
        secondary: colors.secondary,
        onSecondary: colors.white, // Texto blanco sobre secondary
        secondaryContainer: colors.secondaryContainer,
        onSecondaryContainer: colors.textSecondary,
        tertiary: colors.info,
        onTertiary: colors.white, // Texto blanco sobre info
        error: colors.error,
        onError: colors.white, // Texto blanco sobre error
        surface: colors.surface,
        onSurface: colors.textPrimary,
        surfaceContainerHighest: colors.surfaceLight,
        onSurfaceVariant: colors.textMuted,
        outline: colors.border,
        outlineVariant: colors.borderLight,
        shadow: colors.shadow,
        scrim: colors.scrim,
        inverseSurface: colors.primary,
        onInverseSurface: colors.white,
        inversePrimary: colors.primaryLight,
        surfaceTint: colors.primary.withValues(alpha: 0.05),
      ),

      textTheme: TextTheme(
        displayLarge: textStyles.displayLarge,
        displayMedium: textStyles.displayMedium,
        headlineLarge: textStyles.headlineLarge,
        headlineMedium: textStyles.headlineMedium,
        titleLarge: textStyles.titleLarge,
        titleMedium: textStyles.titleMedium,
        bodyLarge: textStyles.bodyLarge,
        bodyMedium: textStyles.bodyMedium,
        bodySmall: textStyles.bodySmall,
        labelLarge: textStyles.labelLarge,
        labelMedium: textStyles.labelMedium,
        labelSmall: textStyles.labelSmall,
      ),

      appBarTheme: AppBarTheme(
        backgroundColor: colors.primary,
        foregroundColor: brightness == Brightness.light ? colors.textPrimary : colors.white, // Negro en light, blanco en dark
        elevation: 0,
        shadowColor: Colors.transparent,
        surfaceTintColor: Colors.transparent,
        titleTextStyle: textStyles.headlineMedium.copyWith(
          color: brightness == Brightness.light ? colors.textPrimary : colors.white, // Negro en light, blanco en dark
          fontWeight: FontWeight.bold,
        ),
        iconTheme: IconThemeData(color: brightness == Brightness.light ? colors.textPrimary : colors.white), // Negro en light, blanco en dark
        actionsIconTheme: IconThemeData(color: brightness == Brightness.light ? colors.textPrimary : colors.white), // Negro en light, blanco en dark
        toolbarHeight: AppSpacing.instance.appBarHeight,
        centerTitle: true,
      ),

      cardTheme: CardTheme(
        color: colors.white,
        shadowColor: colors.shadowLight,
        elevation: 1, // ElevaciÃ³n sutil
        margin: EdgeInsets.zero,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          side: BorderSide(color: colors.border, width: 0.5),
        ),
      ),

      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: colors.primary,
          foregroundColor: brightness == Brightness.light ? colors.textPrimary : colors.white, // Negro en light, blanco en dark
          elevation: 1, // ElevaciÃ³n sutil
          padding: EdgeInsets.symmetric(
            horizontal: AppSpacing.instance.buttonPadding,
            vertical: AppSpacing.instance.md,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          ),
          textStyle: textStyles.button,
        ),
      ),

      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          foregroundColor: colors.primary,
          side: BorderSide(color: colors.border, width: AppSpacing.instance.borderWidth),
          elevation: 0,
          padding: EdgeInsets.symmetric(
            horizontal: AppSpacing.instance.buttonPadding,
            vertical: AppSpacing.instance.md,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          ),
          textStyle: textStyles.button, // Usar estilo sin color fijo
        ),
      ),

      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: colors.primary,
          padding: EdgeInsets.symmetric(
            horizontal: AppSpacing.instance.sm,
            vertical: AppSpacing.instance.xs,
          ),
          textStyle: textStyles.button, // Usar estilo sin color fijo
        ),
      ),

      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: colors.white,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          borderSide: BorderSide(color: colors.border, width: AppSpacing.instance.borderWidth),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          borderSide: BorderSide(color: colors.border, width: AppSpacing.instance.borderWidth),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          borderSide: BorderSide(color: colors.primaryLight, width: 1.5),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          borderSide: BorderSide(color: colors.error, width: AppSpacing.instance.borderWidth),
        ),
        contentPadding: EdgeInsets.all(AppSpacing.instance.inputPadding),
        labelStyle: textStyles.bodyMedium.copyWith(color: colors.textMuted),
        hintStyle: textStyles.bodyMedium.copyWith(color: colors.textMuted),
        errorStyle: textStyles.bodySmall.copyWith(color: colors.error),
      ),

      dialogTheme: DialogTheme(
        backgroundColor: colors.white,
        elevation: 6, // ElevaciÃ³n media para diÃ¡logos
        shadowColor: colors.shadowLight,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
        ),
      ),

      floatingActionButtonTheme: FloatingActionButtonThemeData(
        backgroundColor: colors.primary,
        foregroundColor: colors.white,
        elevation: 2, // ElevaciÃ³n sutil
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadiusLarge),
        ),
      ),

      chipTheme: ChipThemeData(
        backgroundColor: colors.surfaceLight,
        deleteIconColor: colors.textMuted,
        disabledColor: colors.stateInactive,
        selectedColor: colors.primary,
        secondarySelectedColor: colors.secondary,
        padding: EdgeInsets.symmetric(
          horizontal: AppSpacing.instance.sm,
          vertical: AppSpacing.instance.xs,
        ),
        labelStyle: textStyles.bodyMedium.copyWith(color: colors.textPrimary),
        secondaryLabelStyle: textStyles.bodyMedium.copyWith(color: colors.white),
        brightness: brightness,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          side: BorderSide(color: colors.border),
        ),
      ),

      scaffoldBackgroundColor: colors.background,
      dividerColor: colors.divider,
      shadowColor: colors.shadow,

      typography: Typography.material2021(),
      navigationBarTheme: NavigationBarThemeData(
        backgroundColor: colors.white,
        indicatorColor: colors.primary,
        labelTextStyle: WidgetStateProperty.resolveWith((states) {
          if (states.contains(WidgetState.selected)) {
            return textStyles.labelSmall.copyWith(
              color: colors.primary,
              fontWeight: FontWeight.w600,
            );
          }
          return textStyles.labelSmall.copyWith(color: colors.textMuted);
        }),
        iconTheme: WidgetStateProperty.resolveWith((states) {
          if (states.contains(WidgetState.selected)) {
            return IconThemeData(color: colors.primary);
          }
          return IconThemeData(color: colors.textMuted);
        }),
      ),
      navigationRailTheme: NavigationRailThemeData(
        backgroundColor: colors.white,
        selectedIconTheme: IconThemeData(color: colors.primary),
        unselectedIconTheme: IconThemeData(color: colors.textMuted),
        selectedLabelTextStyle: textStyles.labelSmall.copyWith(color: colors.primary),
        unselectedLabelTextStyle: textStyles.labelSmall.copyWith(color: colors.textMuted),
      ),
      bottomSheetTheme: BottomSheetThemeData(
        backgroundColor: colors.white,
        elevation: 4,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.only(
            topLeft: Radius.circular(AppSpacing.instance.borderRadius),
            topRight: Radius.circular(AppSpacing.instance.borderRadius),
          ),
        ),
      ),
    );
  }
}

/* Fin lib\theme\app_theme.dart */

/* Inicio lib\theme\index.dart */
export 'app_theme.dart';
export 'app_colors.dart';
export 'app_spacing.dart';
export 'app_text_styles.dart';
export 'theme_extensions.dart';
/* Fin lib\theme\index.dart */

/* Inicio lib\theme\theme_extensions.dart */
import 'package:flutter/material.dart';
import 'app_colors.dart';
import 'app_spacing.dart';
import 'app_text_styles.dart';
extension ThemeExtensions on BuildContext {
  AppColors get colors => AppColors.instance;
  AppTextStyles get textStyles => AppTextStyles.instance;
  AppSpacing get spacing => AppSpacing.instance;
  ThemeData get theme => Theme.of(this);
  TextTheme get textTheme => theme.textTheme;
  ColorScheme get colorScheme => theme.colorScheme;
}
extension TextStyleExtensions on TextStyle {
  TextStyle get bold => copyWith(fontWeight: FontWeight.bold);
  TextStyle get semiBold => copyWith(fontWeight: FontWeight.w600);
  TextStyle get medium => copyWith(fontWeight: FontWeight.w500);
  TextStyle get regular => copyWith(fontWeight: FontWeight.normal);
  TextStyle get light => copyWith(fontWeight: FontWeight.w300);

  TextStyle withColor(Color color) => copyWith(color: color);
  TextStyle withSize(double size) => copyWith(fontSize: size);
  TextStyle withWeight(FontWeight weight) => copyWith(fontWeight: weight);
  TextStyle get underlined => copyWith(decoration: TextDecoration.underline);
  TextStyle get lineThrough => copyWith(decoration: TextDecoration.lineThrough);
}
extension EdgeInsetsExtensions on EdgeInsets {
  static EdgeInsets get xs => EdgeInsets.all(AppSpacing.instance.xs);
  static EdgeInsets get sm => EdgeInsets.all(AppSpacing.instance.sm);
  static EdgeInsets get md => EdgeInsets.all(AppSpacing.instance.md);
  static EdgeInsets get lg => EdgeInsets.all(AppSpacing.instance.lg);
  static EdgeInsets get xl => EdgeInsets.all(AppSpacing.instance.xl);

  static EdgeInsets horizontal(double value) => EdgeInsets.symmetric(horizontal: value);
  static EdgeInsets vertical(double value) => EdgeInsets.symmetric(vertical: value);

  static EdgeInsets get cardPadding => EdgeInsets.all(AppSpacing.instance.cardPadding);
  static EdgeInsets get screenPadding => EdgeInsets.all(AppSpacing.instance.screenPadding);
  static EdgeInsets get buttonPadding => EdgeInsets.symmetric(
    horizontal: AppSpacing.instance.buttonPadding,
    vertical: AppSpacing.instance.sm,
  );
}
/* Fin lib\theme\theme_extensions.dart */

/* Inicio lib\ui\widgets\app_button.dart */
import 'package:flutter/widgets.dart';
import '../../theme/theme_extensions.dart';
import '../../theme/app_colors.dart';
import '../../config/app_constants.dart';
class AppButton extends StatefulWidget {
  final String label;
  final VoidCallback onPressed;
  final bool isLoading;
  final bool isEnabled;
  final double? width;
  final EdgeInsets? padding;

  const AppButton({
    required this.label,
    required this.onPressed,
    this.isLoading = false,
    this.isEnabled = true,
    this.width,
    this.padding,
    super.key,
  });

  @override
  State<AppButton> createState() => _AppButtonState();
}

class _AppButtonState extends State<AppButton> {
  bool _isPressed = false;

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    final buttonChild = Container(
      constraints: widget.width != null
          ? BoxConstraints(minWidth: widget.width!)
          : const BoxConstraints(minWidth: 0),
      padding: widget.padding ??
          EdgeInsets.symmetric(
            horizontal: spacing.md,
            vertical: spacing.md,
          ),
      decoration: BoxDecoration(
        color: widget.isEnabled
            ? (_isPressed ? colors.primaryDark : colors.primary)
            : colors.grey300,
        borderRadius: BorderRadius.circular(AppConstants.instance.buttonBorderRadius),
      ),
      child: Center(
        child: widget.isLoading
            ? SizedBox(
                width: AppConstants.instance.spinnerSize,
                height: AppConstants.instance.spinnerSize,
                child: _buildLoadingSpinner(context),
              )
            : Text(
                widget.label,
                style: textStyles.labelLarge.copyWith(
                  color: colors.white, // Texto blanco sobre fondo primario
                ),
              ),
      ),
    );

    return GestureDetector(
      onTapDown: widget.isEnabled && !widget.isLoading
          ? (_) => setState(() => _isPressed = true)
          : null,
      onTapUp: widget.isEnabled && !widget.isLoading
          ? (_) {
              setState(() => _isPressed = false);
              widget.onPressed();
            }
          : null,
      onTapCancel: widget.isEnabled && !widget.isLoading
          ? () => setState(() => _isPressed = false)
          : null,
      child: buttonChild,
    );
  }

  Widget _buildLoadingSpinner(BuildContext context) {
    final colors = context.colors;

    return Center(
      child: SizedBox(
        width: AppConstants.instance.spinnerSize,
        height: AppConstants.instance.spinnerSize,
        child: CustomPaint(
          painter: _SpinnerPainter(colors: colors),
        ),
      ),
    );
  }
}
class AppSecondaryButton extends StatefulWidget {
  final String label;
  final VoidCallback onPressed;
  final bool isEnabled;
  final double? width;

  const AppSecondaryButton({
    required this.label,
    required this.onPressed,
    this.isEnabled = true,
    this.width,
    super.key,
  });

  @override
  State<AppSecondaryButton> createState() => _AppSecondaryButtonState();
}

class _AppSecondaryButtonState extends State<AppSecondaryButton> {
  bool _isPressed = false;

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    final buttonChild = Container(
      constraints: widget.width != null
          ? BoxConstraints(minWidth: widget.width!)
          : const BoxConstraints(minWidth: 0),
      padding: EdgeInsets.symmetric(
        horizontal: spacing.md,
        vertical: spacing.md,
      ),
      decoration: BoxDecoration(
        border: Border.all(
          color: widget.isEnabled ? colors.primary : colors.grey300,
          width: AppConstants.instance.borderWidthNormal,
        ),
        borderRadius: BorderRadius.circular(AppConstants.instance.buttonBorderRadius),
        color: _isPressed && widget.isEnabled
            ? colors.surfaceLight
            : colors.transparent,
      ),
      child: Center(
        child: Text(
          widget.label,
          style: textStyles.labelLarge.copyWith(
            color: widget.isEnabled
                ? colors.primary // Texto primario sobre fondo transparente
                : colors.textDisabled,
          ),
        ),
      ),
    );

    return GestureDetector(
      onTapDown: widget.isEnabled
          ? (_) => setState(() => _isPressed = true)
          : null,
      onTapUp: widget.isEnabled
          ? (_) {
              setState(() => _isPressed = false);
              widget.onPressed();
            }
          : null,
      onTapCancel: widget.isEnabled
          ? () => setState(() => _isPressed = false)
          : null,
      child: buttonChild,
    );
  }
}
class _SpinnerPainter extends CustomPainter {
  final AppColors colors;

  _SpinnerPainter({required this.colors});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = colors.white // Spinner blanco sobre fondo primario
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;

    final radius = size.width / 2;
    final center = Offset(size.width / 2, size.height / 2);

    canvas.drawCircle(center, radius, paint);

    final rect = Rect.fromCircle(center: center, radius: radius);
    canvas.drawArc(rect, 0, 1.5, false, paint);
  }

  @override
  bool shouldRepaint(_SpinnerPainter oldDelegate) => true;
}

/* Fin lib\ui\widgets\app_button.dart */

/* Inicio lib\utils\app_router.dart */
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../screens/login_screen.dart';
import '../screens/institution_selection_screen.dart';
import '../screens/home_screen.dart';
import '../screens/super_admin_dashboard.dart';
import '../screens/admin_dashboard.dart';
import '../screens/teacher_dashboard.dart';
import '../screens/student_dashboard.dart';
import '../screens/users/users_list_screen.dart';
import '../screens/users/user_form_screen.dart';
import '../screens/users/user_detail_screen.dart';
import '../screens/institutions/institutions_list_screen.dart';
import '../screens/institutions/institution_admins_screen.dart';
import '../screens/institutions/institution_form_screen.dart';
import '../screens/institutions/create_institution_admin_screen.dart';
import '../screens/academic/gestion_academica_screen.dart';
import '../screens/academic/grupos_screen.dart';
import '../screens/academic/materias_screen.dart';
import '../screens/academic/horarios_screen.dart';
import '../models/institution.dart';
import '../screens/app_shell.dart';
import '../models/user.dart';
final _dashboardNavigatorKey = GlobalKey<NavigatorState>(debugLabel: 'Dashboard');
final _institutionsNavigatorKey = GlobalKey<NavigatorState>(debugLabel: 'Institutions');
final _usersNavigatorKey = GlobalKey<NavigatorState>(debugLabel: 'Users');
class AppRouter {
  final AuthProvider authProvider;

  AppRouter({
    required this.authProvider,
  });

  late final GoRouter router = GoRouter(
    debugLogDiagnostics: true,
    refreshListenable: authProvider,
    initialLocation: _getStartRoute(),
    redirect: _checkAuth,
    routes: _allRoutes(),
    errorBuilder: _errorPage,
  );
  String _getStartRoute() {
    if (authProvider.isAuthenticated) {
      return '/dashboard';
    }
    return '/login';
  }
  String? _checkAuth(BuildContext context, GoRouterState state) {
    final isLoggedIn = authProvider.isAuthenticated;
    final currentRoute = state.matchedLocation;
    if (!isLoggedIn) {
      return '/login';
    }
    final institutions = authProvider.institutions;
    final selectedInstitutionId = authProvider.selectedInstitutionId;
    final needsSelection = institutions != null &&
                          institutions.length > 1 &&
                          selectedInstitutionId == null;
    if (currentRoute == '/login') {
      return '/dashboard';
    }
    if (needsSelection && currentRoute != '/institution-selection') {
      return '/institution-selection';
    }
    if (!needsSelection && currentRoute == '/institution-selection') {
      return '/dashboard';
    }
    return null;
  }
  List<RouteBase> _allRoutes() {
    return [
      GoRoute(
        path: '/login',
        name: 'login',
        pageBuilder: (context, state) => _fadePage(
          context,
          state,
          const LoginScreen(),
        ),
      ),

      GoRoute(
        path: '/institution-selection',
        name: 'institution-selection',
        pageBuilder: (context, state) => _fadePage(
          context,
          state,
          const InstitutionSelectionScreen(),
        ),
      ),
      GoRoute(
        path: '/users/professor/create',
        name: 'create-professor',
        pageBuilder: (context, state) => MaterialPage(
          fullscreenDialog: true,
          name: 'Crear Profesor',
          child: UserFormScreen(userRole: 'profesor'),
        ),
      ),
      GoRoute(
        path: '/users/student/create',
        name: 'create-student',
        pageBuilder: (context, state) => MaterialPage(
          fullscreenDialog: true,
          name: 'Crear Estudiante',
          child: UserFormScreen(userRole: 'estudiante'),
        ),
      ),
      GoRoute(
        path: '/users/admin_institucion/create',
        name: 'create-admin-institucion',
        pageBuilder: (context, state) => MaterialPage(
          fullscreenDialog: true,
          name: 'Crear Admin InstituciÃ³n',
          child: UserFormScreen(userRole: 'admin_institucion'),
        ),
      ),
      GoRoute(
        path: '/users/super_admin/create',
        name: 'create-super-admin',
        pageBuilder: (context, state) => MaterialPage(
          fullscreenDialog: true,
          name: 'Crear Super Admin',
          child: UserFormScreen(userRole: 'super_admin'),
        ),
      ),
      GoRoute(
        path: '/users/detail/:id',
        name: 'user-detail',
        builder: (context, state) {
          final user = state.extra as User;
          return UserDetailScreen(user: user);
        },
      ),
      StatefulShellRoute.indexedStack(
        builder: (context, state, navigationShell) {
          return AppShell(navigationShell: navigationShell);
        },
        branches: [
          StatefulShellBranch(
            navigatorKey: _dashboardNavigatorKey,
            routes: [
              GoRoute(
                path: '/dashboard',
                name: 'dashboard',
                pageBuilder: (context, state) => NoTransitionPage(
                  child: _getDashboardForRole(),
                ),
              ),
              GoRoute(
                path: '/academic',
                name: 'academic-management',
                pageBuilder: (context, state) => NoTransitionPage(
                  child: const GestionAcademicaScreen(),
                ),
              ),
              GoRoute(
                path: '/academic/grupos',
                name: 'academic-grupos',
                pageBuilder: (context, state) => NoTransitionPage(
                  child: const GruposScreen(),
                ),
              ),
              GoRoute(
                path: '/academic/materias',
                name: 'academic-materias',
                pageBuilder: (context, state) => NoTransitionPage(
                  child: const MateriasScreen(),
                ),
              ),
              GoRoute(
                path: '/academic/horarios',
                name: 'academic-horarios',
                pageBuilder: (context, state) => NoTransitionPage(
                  child: const HorariosScreen(),
                ),
              ),
            ],
          ),
          StatefulShellBranch(
            navigatorKey: _institutionsNavigatorKey,
            routes: [
              GoRoute(
                path: '/institutions',
                name: 'institutions-list',
                pageBuilder: (context, state) => NoTransitionPage(
                  child: const InstitutionsListScreen(),
                ),
              ),
              GoRoute(
                path: '/institutions/form',
                name: 'institution-form',
                pageBuilder: (context, state) {
                  final institution = state.extra as Institution?;
                  return MaterialPage(
                    fullscreenDialog: true,
                    name: 'Institution Form',
                    child: InstitutionFormScreen(institution: institution),
                  );
                },
              ),
              GoRoute(
                path: '/institutions/create-admin',
                name: 'institution-create-admin',
                pageBuilder: (context, state) {
                  final institution = state.extra as Institution;
                  return MaterialPage(
                    fullscreenDialog: true,
                    name: 'Create Institution Admin',
                    child: CreateInstitutionAdminScreen(institution: institution),
                  );
                },
              ),
              GoRoute(
                path: '/institutions/:id/admins',
                name: 'institution-admins',
                pageBuilder: (context, state) {
                  final segments = state.uri.pathSegments;
                  final id = segments.length >= 2 ? segments[1] : '';
                  return MaterialPage(
                    fullscreenDialog: false,
                    name: 'Institution Admins',
                    child: InstitutionAdminsScreen(institutionId: id),
                  );
                },
              ),
            ],
          ),
          StatefulShellBranch(
            navigatorKey: _usersNavigatorKey,
            routes: [
              GoRoute(
                path: '/users',
                name: 'users-list',
                pageBuilder: (context, state) => NoTransitionPage(
                  child: const UsersListScreen(),
                ),
              ),
            ],
          ),
        ],
      ),
    ];
  }
  Widget _getDashboardForRole() {
    final role = authProvider.user?['rol'] as String?;
    switch (role) {
      case 'super_admin':
        return const SuperAdminDashboard();
      case 'admin_institucion':
        return const AdminDashboard();
      case 'profesor':
        return const TeacherDashboard();
      case 'estudiante':
        return const StudentDashboard();
      default:
        return const HomeScreen();
    }
  }
  Page _fadePage(BuildContext context, GoRouterState state, Widget child) {
    return CustomTransitionPage(
      key: state.pageKey,
      child: child,
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        return FadeTransition(opacity: animation, child: child);
      },
    );
  }
  Widget _errorPage(BuildContext context, GoRouterState state) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, size: 48, color: Colors.red),
            const SizedBox(height: 16),
            const Text('Error de NavegaciÃ³n',
              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
            const SizedBox(height: 8),
            Text('${state.error}'),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () => context.go('/login'),
              child: const Text('Ir al inicio'),
            ),
          ],
        ),
      ),
    );
  }
  void dispose() {
    router.dispose();
  }
}

/* Fin lib\utils\app_router.dart */

/* Inicio lib\utils\app_routes.dart */

class AppRoutes {
  AppRoutes._()

  static const String login = '/login';

  static const String institutionSelection = '/institution-selection';
  static const String superAdminDashboard = '/super-admin-dashboard';
  static const String adminDashboard = '/admin-dashboard';
  static const String teacherDashboard = '/teacher-dashboard';
  static const String studentDashboard = '/student-dashboard';
  static const String home = '/home';
  static const String institutionsList = '/institutions';
  static const String institutionForm = '/institutions/form';
  static const String institutionDetail = '/institutions/:id';
  static const String usersList = '/users';
  static const String userForm = '/users/form';
  static const String userDetail = '/users/:id';
  static const String createProfessor = '/users/professor/create';
  static const String createStudent = '/users/student/create';
  static String getDashboardRouteForRole(String role) {
    switch (role) {
      case 'super_admin':
      case 'admin_institucion':
      case 'profesor':
      case 'estudiante':
        return '/dashboard'
      default:
        return home;
    }
  }
  static bool requiresAuth(String route) {
    return route != login;
  }
  static bool isDashboard(String route) {
    return [
      superAdminDashboard,
      adminDashboard,
      teacherDashboard,
      studentDashboard,
      home,
    ].contains(route);
  }
}

/* Fin lib\utils\app_routes.dart */

/* Inicio lib\utils\responsive_utils.dart */
import 'package:flutter/material.dart';
import '../config/app_constants.dart';
class ResponsiveUtils {
  static final AppConstants _constants = AppConstants.instance;
  static Map<String, dynamic> getResponsiveValues(BoxConstraints constraints) {
    final screenType = _constants.getScreenType(constraints.maxWidth);
    final maxWidth = _constants.getMaxWidth(constraints.maxWidth);
    final horizontalPadding = switch (screenType) {
      ScreenType.mobileSmall => 16.0,
      ScreenType.mobileLarge => 24.0,
      ScreenType.tablet => 32.0,
      ScreenType.desktop => 48.0,
      ScreenType.largeDesktop => 64.0,
    };
    final verticalPadding = switch (screenType) {
      ScreenType.mobileSmall => 24.0,
      ScreenType.mobileLarge => 32.0,
      ScreenType.tablet => 48.0,
      ScreenType.desktop => 64.0,
      ScreenType.largeDesktop => 80.0,
    };
    final elementSpacing = switch (screenType) {
      ScreenType.mobileSmall => 16.0,
      ScreenType.mobileLarge => 20.0,
      ScreenType.tablet => 24.0,
      ScreenType.desktop => 32.0,
      ScreenType.largeDesktop => 40.0,
    };
    final titleFontSize = switch (screenType) {
      ScreenType.mobileSmall => 24.0,
      ScreenType.mobileLarge => 28.0,
      ScreenType.tablet => 32.0,
      ScreenType.desktop => 40.0,
      ScreenType.largeDesktop => 48.0,
    };

    final subtitleFontSize = switch (screenType) {
      ScreenType.mobileSmall => 14.0,
      ScreenType.mobileLarge => 16.0,
      ScreenType.tablet => 18.0,
      ScreenType.desktop => 20.0,
      ScreenType.largeDesktop => 24.0,
    };

    final bodyFontSize = switch (screenType) {
      ScreenType.mobileSmall => 14.0,
      ScreenType.mobileLarge => 16.0,
      ScreenType.tablet => 16.0,
      ScreenType.desktop => 18.0,
      ScreenType.largeDesktop => 20.0,
    };
    final buttonWidth = switch (screenType) {
      ScreenType.mobileSmall => double.infinity,
      ScreenType.mobileLarge => 280.0,
      ScreenType.tablet => 320.0,
      ScreenType.desktop => 360.0,
      ScreenType.largeDesktop => 400.0,
    };
    final minHeight = switch (screenType) {
      ScreenType.mobileSmall => 600.0,
      ScreenType.mobileLarge => 700.0,
      ScreenType.tablet => 800.0,
      ScreenType.desktop => 900.0,
      ScreenType.largeDesktop => 1000.0,
    };

    return {
      'screenType': screenType,
      'maxWidth': maxWidth,
      'horizontalPadding': horizontalPadding,
      'verticalPadding': verticalPadding,
      'elementSpacing': elementSpacing,
      'titleFontSize': titleFontSize,
      'subtitleFontSize': subtitleFontSize,
      'bodyFontSize': bodyFontSize,
      'buttonWidth': buttonWidth,
      'minHeight': minHeight,
      'isSmallScreen': screenType == ScreenType.mobileSmall,
      'isMobile': screenType == ScreenType.mobileSmall || screenType == ScreenType.mobileLarge,
      'isTablet': screenType == ScreenType.tablet,
      'isDesktop': screenType == ScreenType.desktop || screenType == ScreenType.largeDesktop,
      'isLargeDesktop': screenType == ScreenType.largeDesktop,
    };
  }
  static Widget buildResponsiveContainer({
    required BuildContext context,
    required Widget child,
    double? maxWidth,
    EdgeInsets? padding,
    bool centerContent = true,
  }) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final responsive = getResponsiveValues(constraints);
        final containerMaxWidth = maxWidth ?? responsive['maxWidth'];
        final containerPadding = padding ?? EdgeInsets.symmetric(
          horizontal: responsive['horizontalPadding'],
          vertical: responsive['verticalPadding'],
        );

        final content = ConstrainedBox(
          constraints: BoxConstraints(maxWidth: containerMaxWidth),
          child: child,
        );

        return Container(
          width: double.infinity,
          padding: containerPadding,
          constraints: BoxConstraints(minHeight: responsive['minHeight']),
          child: centerContent ? Center(child: content) : content,
        );
      },
    );
  }
  static TextStyle getResponsiveTextStyle(
    TextStyle baseStyle,
    ScreenType screenType, {
    double? fontSize,
  }) {
    final scaleFactor = switch (screenType) {
      ScreenType.mobileSmall => 0.8,
      ScreenType.mobileLarge => 0.9,
      ScreenType.tablet => 1.0,
      ScreenType.desktop => 1.1,
      ScreenType.largeDesktop => 1.2,
    };

    final scaledFontSize = fontSize ?? (baseStyle.fontSize ?? 14.0) * scaleFactor;

    return baseStyle.copyWith(fontSize: scaledFontSize);
  }
  static SliverGridDelegate getResponsiveGridDelegate(ScreenType screenType) {
    return switch (screenType) {
      ScreenType.mobileSmall => const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 1,
          crossAxisSpacing: 16,
          mainAxisSpacing: 16,
          childAspectRatio: 1.2,
        ),
      ScreenType.mobileLarge => const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 2,
          crossAxisSpacing: 16,
          mainAxisSpacing: 16,
          childAspectRatio: 1.1,
        ),
      ScreenType.tablet => const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 3,
          crossAxisSpacing: 20,
          mainAxisSpacing: 20,
          childAspectRatio: 1.0,
        ),
      ScreenType.desktop => const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 4,
          crossAxisSpacing: 24,
          mainAxisSpacing: 24,
          childAspectRatio: 0.9,
        ),
      ScreenType.largeDesktop => const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 5,
          crossAxisSpacing: 28,
          mainAxisSpacing: 28,
          childAspectRatio: 0.8,
        ),
    };
  }
}
/* Fin lib\utils\responsive_utils.dart */

/* Inicio lib\utils\role_enum.dart */

enum UserRole {
  superAdmin,       // Administrador global del sistema
  adminInstitucion, // Administrador de una instituciÃ³n
  profesor,         // Profesor de clases
  estudiante,       // Estudiante
}
extension UserRoleExtension on UserRole {
  String get value {
    switch (this) {
      case UserRole.superAdmin:
        return 'super_admin';
      case UserRole.adminInstitucion:
        return 'admin_institucion';
      case UserRole.profesor:
        return 'profesor';
      case UserRole.estudiante:
        return 'estudiante';
    }
  }
  String get displayName {
    switch (this) {
      case UserRole.superAdmin:
        return 'Super Administrador';
      case UserRole.adminInstitucion:
        return 'Administrador';
      case UserRole.profesor:
        return 'Profesor';
      case UserRole.estudiante:
        return 'Estudiante';
    }
  }
  static UserRole fromString(String role) {
    switch (role) {
      case 'super_admin':
        return UserRole.superAdmin;
      case 'admin_institucion':
        return UserRole.adminInstitucion;
      case 'profesor':
        return UserRole.profesor;
      case 'estudiante':
        return UserRole.estudiante;
      default:
        throw ArgumentError('Rol desconocido: $role');
    }
  }
  bool get isAdmin {
    return this == UserRole.superAdmin || this == UserRole.adminInstitucion;
  }
  bool get isSuperAdmin {
    return this == UserRole.superAdmin;
  }
}
/* Fin lib\utils\role_enum.dart */

/* Inicio lib\utils\route_guards.dart */
import 'package:flutter/widgets.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';

class RouteGuards {
  static bool requireAuth(BuildContext context) {
    final authProvider = context.read<AuthProvider>();
    return authProvider.isAuthenticated;
  }
  static bool isPublic(BuildContext context) {
    final authProvider = context.read<AuthProvider>();
    return !authProvider.isAuthenticated;
  }
}
class ProtectedRoute extends StatelessWidget {
  final Widget child;
  final bool Function(BuildContext) guard;
  final Widget fallback;

  const ProtectedRoute({
    required this.child,
    required this.guard,
    required this.fallback,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    return guard(context) ? child : fallback;
  }
}

/* Fin lib\utils\route_guards.dart */

/* Inicio lib\widgets\common\empty_state_widget.dart */
import 'package:flutter/material.dart';
import '../../theme/theme_extensions.dart';

class EmptyStateWidget extends StatelessWidget {
  final IconData icon;
  final String title;
  final String message;

  const EmptyStateWidget({
    super.key,
    required this.icon,
    required this.title,
    required this.message,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            icon,
            size: 64,
            color: colors.textMuted,
          ),
          SizedBox(height: spacing.lg),
          Text(
            title,
            style: textStyles.headlineMedium.withColor(colors.textSecondary),
            textAlign: TextAlign.center,
          ),
          SizedBox(height: spacing.md),
          Text(
            message,
            style: textStyles.bodyMedium.withColor(colors.textSecondary),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }
}
/* Fin lib\widgets\common\empty_state_widget.dart */

/* Inicio lib\widgets\common\index.dart */
export 'empty_state_widget.dart';
export 'management_scaffold.dart';
export 'shimmer_list_widget.dart';

/* Fin lib\widgets\common\index.dart */

/* Inicio lib\widgets\common\management_scaffold.dart */
import 'package:flutter/material.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';
import '../../models/user.dart';
import '../../theme/theme_extensions.dart';
import '../../widgets/common/empty_state_widget.dart';
import '../../widgets/common/shimmer_list_widget.dart';
import '../../widgets/pagination_widget.dart';

class ManagementScaffold extends StatelessWidget {
  final String title;
  final bool isLoading;
  final bool hasError;
  final String errorMessage;
  final int itemCount;
  final Widget Function(BuildContext, int) itemBuilder;
  final bool hasMoreData;
  final VoidCallback onRefresh;
  final ScrollController scrollController;
  final Widget? floatingActionButton;
  final List<Widget>? filterWidgets;
  final List<Widget>? statisticWidgets;
  final PaginationInfo? paginationInfo;
  final Future<void> Function(int) onPageChange;
  final String? emptyStateTitle;
  final String? emptyStateMessage;
  final IconData emptyStateIcon;

  const ManagementScaffold({
    super.key,
    required this.title,
    required this.isLoading,
    required this.hasError,
    required this.errorMessage,
    required this.itemCount,
    required this.itemBuilder,
    required this.hasMoreData,
    required this.onRefresh,
    required this.scrollController,
    this.floatingActionButton,
    this.filterWidgets,
    this.statisticWidgets,
    this.paginationInfo,
    required this.onPageChange,
    this.emptyStateTitle,
    this.emptyStateMessage,
    this.emptyStateIcon = Icons.business,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Scaffold(
      backgroundColor: colors.background,
      appBar: AppBar(
        title: Text(title, style: textStyles.headlineMedium.copyWith(color: colors.surface)),
        backgroundColor: colors.primary,
        elevation: 2,
      ),
      body: SafeArea(
        child: Column(
          children: [
            if (filterWidgets != null && filterWidgets!.isNotEmpty)
              Card(
                margin: EdgeInsets.symmetric(horizontal: spacing.lg, vertical: spacing.md),
                elevation: 2,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(spacing.borderRadius),
                ),
                child: ExpansionTile(
                  title: Text('Filtros y BÃºsqueda', style: textStyles.titleMedium),
                  children: [
                    Material(
                      color: colors.surface,
                      child: Padding(
                        padding: EdgeInsets.all(spacing.md),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: filterWidgets!,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            if (statisticWidgets != null && statisticWidgets!.isNotEmpty)
              Container(
                margin: EdgeInsets.symmetric(horizontal: spacing.lg),
                padding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
                decoration: BoxDecoration(
                  color: colors.surface,
                  borderRadius: BorderRadius.circular(spacing.borderRadius),
                  border: Border.all(color: colors.borderLight),
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: statisticWidgets!,
                ),
              ),
            Expanded(
              child: _buildListContent(context),
            ),
            if (paginationInfo != null)
              PaginationWidget(
                currentPage: paginationInfo!.page,
                totalPages: paginationInfo!.totalPages,
                totalItems: paginationInfo!.total,
                onPageChange: onPageChange,
                isLoading: isLoading,
              ),
          ],
        ),
      ),
      floatingActionButton: floatingActionButton,
    );
  }

  Widget _buildListContent(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;
    if (isLoading && itemCount == 0) {
      return ShimmerListWidget(
        itemCount: 5,
        cardBuilder: (context) => _buildShimmerCard(context),
      );
    }

    if (hasError) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline, size: 64, color: colors.error),
            SizedBox(height: spacing.lg),
            Text(
              'Error al cargar datos',
              style: textStyles.headlineMedium,
              textAlign: TextAlign.center,
            ),
            SizedBox(height: spacing.md),
            Text(
              errorMessage,
              style: textStyles.bodyMedium.withColor(colors.textSecondary),
              textAlign: TextAlign.center,
            ),
            SizedBox(height: spacing.lg),
            ElevatedButton(
              onPressed: onRefresh,
              style: ElevatedButton.styleFrom(
                backgroundColor: colors.primary,
                foregroundColor: Theme.of(context).colorScheme.onPrimary,
                padding: EdgeInsets.symmetric(
                  horizontal: spacing.lg,
                  vertical: spacing.md,
                ),
              ),
              child: Text('Reintentar', style: textStyles.button),
            ),
          ],
        ),
      );
    }

    if (itemCount == 0) {
      return EmptyStateWidget(
        icon: emptyStateIcon,
        title: emptyStateTitle ?? 'No hay elementos',
        message: emptyStateMessage ?? 'Comienza creando tu primer elemento',
      );
    }

    return AnimationLimiter(
      child: ListView.builder(
        controller: scrollController,
        padding: EdgeInsets.symmetric(horizontal: spacing.lg),
        itemCount: itemCount,
        itemBuilder: (context, index) {
          return AnimationConfiguration.staggeredList(
            position: index,
            duration: const Duration(milliseconds: 375),
            child: SlideAnimation(
              verticalOffset: 50.0,
              child: FadeInAnimation(
                child: itemBuilder(context, index),
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildShimmerCard(BuildContext context) {
    final spacing = context.spacing;
    return Card(
      margin: EdgeInsets.only(bottom: spacing.xs),
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(spacing.borderRadius),
      ),
      child: const ListTile(
        leading: CircleAvatar(),
        title: SizedBox(height: 16),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            SizedBox(height: 12),
            SizedBox(height: 12),
          ],
        ),
        trailing: SizedBox(width: 24, height: 24),
      ),
    );
  }
}
/* Fin lib\widgets\common\management_scaffold.dart */

/* Inicio lib\widgets\common\shimmer_list_widget.dart */
import 'package:flutter/material.dart';
import 'package:shimmer/shimmer.dart';
import '../../theme/theme_extensions.dart';

class ShimmerListWidget extends StatelessWidget {
  final Widget Function(BuildContext) cardBuilder;
  final int itemCount;

  const ShimmerListWidget({
    super.key,
    required this.cardBuilder,
    this.itemCount = 5,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;

    return Shimmer.fromColors(
      baseColor: colors.surface,
      highlightColor: colors.borderLight,
      child: ListView.builder(
        padding: EdgeInsets.symmetric(horizontal: spacing.lg, vertical: spacing.sm),
        itemCount: itemCount,
        itemBuilder: (context, index) {
          return cardBuilder(context);
        },
      ),
    );
  }
}
/* Fin lib\widgets\common\shimmer_list_widget.dart */

/* Inicio lib\widgets\components\clarity_components.dart */
import 'package:flutter/material.dart';
import '../../theme/app_colors.dart';
import '../../theme/app_text_styles.dart';
import '../../theme/app_spacing.dart';
class ClarityCard extends StatelessWidget {
  final Widget? leading;
  final Widget? title;
  final Widget? subtitle;
  final Widget? trailing;
  final VoidCallback? onTap;
  final EdgeInsetsGeometry? padding;
  final Color? backgroundColor;
  final double? elevation;

  const ClarityCard({
    super.key,
    this.leading,
    this.title,
    this.subtitle,
    this.trailing,
    this.onTap,
    this.padding,
    this.backgroundColor,
    this.elevation,
  });

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final spacing = AppSpacing.instance;

    return Card(
      color: backgroundColor ?? colors.surface,
      elevation: elevation ?? 1,
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(spacing.borderRadius),
        side: BorderSide(color: colors.border, width: 0.5),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(spacing.borderRadius),
        child: Padding(
          padding: padding ?? EdgeInsets.all(spacing.cardPadding),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.center, // Alinear verticalmente al centro
            children: [
              if (leading != null) ...[
                leading!,
                SizedBox(width: spacing.md),
              ],
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    if (title != null) title!,
                    if (subtitle != null && title != null) SizedBox(height: spacing.xs),
                    if (subtitle != null) subtitle!,
                  ],
                ),
              ),
              if (trailing != null) ...[
                SizedBox(width: spacing.md),
                trailing!,
              ],
            ],
          ),
        ),
      ),
    );
  }
}
class ClarityKPICard extends StatelessWidget {
  final String value;
  final String label;
  final IconData? icon;
  final Color? iconColor;
  final Color? backgroundColor;
  final VoidCallback? onTap;

  const ClarityKPICard({
    super.key,
    required this.value,
    required this.label,
    this.icon,
    this.iconColor,
    this.backgroundColor,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final textStyles = AppTextStyles.instance;
    final spacing = AppSpacing.instance;

    return Card(
      color: backgroundColor ?? colors.surface,
      elevation: 1,
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(spacing.borderRadius),
        side: BorderSide(color: colors.border, width: 0.5),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(spacing.borderRadius),
        child: Padding(
          padding: EdgeInsets.all(spacing.lg),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  if (icon != null) ...[
                    Icon(
                      icon,
                      color: iconColor ?? colors.primary,
                      size: spacing.iconSize,
                    ),
                    SizedBox(width: spacing.md),
                  ],
                  Expanded(
                    child: Text(
                      value,
                      style: textStyles.kpiNumber,
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
              SizedBox(height: spacing.sm),
              Text(
                label.toUpperCase(),
                style: textStyles.kpiLabel,
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
class ClarityStatusBadge extends StatelessWidget {
  final String text;
  final Color? backgroundColor;
  final Color? textColor;
  final double? fontSize;

  const ClarityStatusBadge({
    super.key,
    required this.text,
    this.backgroundColor,
    this.textColor,
    this.fontSize,
  });

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final textStyles = AppTextStyles.instance;
    final spacing = AppSpacing.instance;

    return Container(
      padding: EdgeInsets.symmetric(
        horizontal: spacing.sm,
        vertical: spacing.xs,
      ),
      decoration: BoxDecoration(
        color: backgroundColor ?? colors.primary.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(spacing.borderRadiusLarge),
        border: Border.all(
          color: backgroundColor?.withValues(alpha: 0.2) ?? colors.primary.withValues(alpha: 0.2),
          width: 1,
        ),
      ),
      child: Text(
        text,
        style: textStyles.statusText.copyWith(
          color: textColor ?? colors.primary,
          fontSize: fontSize,
        ),
        textAlign: TextAlign.center,
      ),
    );
  }
}
class ClarityActionButton extends StatelessWidget {
  final IconData icon;
  final String? tooltip;
  final VoidCallback? onPressed;
  final Color? color;
  final double? size;

  const ClarityActionButton({
    super.key,
    required this.icon,
    this.tooltip,
    this.onPressed,
    this.color,
    this.size,
  });

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final spacing = AppSpacing.instance;

    return IconButton(
      icon: Icon(
        icon,
        color: color ?? colors.primary,
        size: size ?? spacing.iconSize,
      ),
      tooltip: tooltip,
      onPressed: onPressed,
      padding: EdgeInsets.zero,
      constraints: BoxConstraints(
        minWidth: spacing.iconSize,
        minHeight: spacing.iconSize,
      ),
    );
  }
}
class ClaritySection extends StatelessWidget {
  final String title;
  final Widget child;
  final EdgeInsetsGeometry? padding;
  final TextStyle? titleStyle;

  const ClaritySection({
    super.key,
    required this.title,
    required this.child,
    this.padding,
    this.titleStyle,
  });

  @override
  Widget build(BuildContext context) {
    final textStyles = AppTextStyles.instance;
    final spacing = AppSpacing.instance;

    return Padding(
      padding: padding ?? EdgeInsets.all(spacing.screenPadding),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: titleStyle ?? textStyles.headlineMedium,
          ),
          SizedBox(height: spacing.md),
          child,
        ],
      ),
    );
  }
}
class ClarityEmptyState extends StatelessWidget {
  final IconData icon;
  final String title;
  final String? subtitle;
  final Widget? action;

  const ClarityEmptyState({
    super.key,
    required this.icon,
    required this.title,
    this.subtitle,
    this.action,
  });

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final textStyles = AppTextStyles.instance;
    final spacing = AppSpacing.instance;

    return Center(
      child: Padding(
        padding: EdgeInsets.all(spacing.xl),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              icon,
              size: spacing.xxl,
              color: colors.textMuted,
            ),
            SizedBox(height: spacing.lg),
            Text(
              title,
              style: textStyles.headlineMedium.copyWith(
                color: colors.textSecondary,
              ),
              textAlign: TextAlign.center,
            ),
            if (subtitle != null) ...[
              SizedBox(height: spacing.md),
              Text(
                subtitle!,
                style: textStyles.bodyMedium.copyWith(
                  color: colors.textMuted,
                ),
                textAlign: TextAlign.center,
              ),
            ],
            if (action != null) ...[
              SizedBox(height: spacing.lg),
              action!,
            ],
          ],
        ),
      ),
    );
  }
}
class ClarityCompactStat extends StatelessWidget {
  final String title;
  final String value;
  final IconData icon;
  final Color color;

  const ClarityCompactStat({
    super.key,
    required this.title,
    required this.value,
    required this.icon,
    required this.color,
  });

  @override
  Widget build(BuildContext context) {
    final textStyles = AppTextStyles.instance;

    return IntrinsicWidth(
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 14, color: color),
          const SizedBox(width: 2),
          Flexible(
            child: Text(
              '$value $title',
              style: textStyles.bodySmall.copyWith(
                color: color,
                fontWeight: FontWeight.w500,
              ),
              overflow: TextOverflow.ellipsis,
              maxLines: 1,
            ),
          ),
        ],
      ),
    );
  }
}
class ClarityManagementHeader extends StatelessWidget {
  final String title;
  final String? searchHint;
  final TextEditingController? searchController;
  final ValueChanged<String>? onSearchChanged;
  final VoidCallback? onCreatePressed;
  final String? createButtonLabel;
  final List<Widget>? filterWidgets;
  final bool showSearch;
  final bool showCreateButton;

  const ClarityManagementHeader({
    super.key,
    required this.title,
    this.searchHint,
    this.searchController,
    this.onSearchChanged,
    this.onCreatePressed,
    this.createButtonLabel,
    this.filterWidgets,
    this.showSearch = true,
    this.showCreateButton = true,
  });

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final textStyles = AppTextStyles.instance;
    final spacing = AppSpacing.instance;

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Expanded(
              child: Text(
                title,
                style: textStyles.headlineMedium,
              ),
            ),
            if (showCreateButton && onCreatePressed != null)
              ElevatedButton.icon(
                onPressed: onCreatePressed,
                icon: const Icon(Icons.add),
                label: Text(createButtonLabel ?? 'Crear'),
              ),
          ],
        ),

        SizedBox(height: spacing.md),
        if (showSearch) ...[
          TextField(
            controller: searchController,
            onChanged: onSearchChanged,
            decoration: InputDecoration(
              hintText: searchHint ?? 'Buscar...',
              prefixIcon: const Icon(Icons.search),
              suffixIcon: searchController?.text.isNotEmpty == true
                  ? IconButton(
                      icon: const Icon(Icons.clear),
                      onPressed: () {
                        searchController?.clear();
                        onSearchChanged?.call('');
                      },
                    )
                  : null,
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(spacing.borderRadius),
                borderSide: BorderSide(color: colors.border),
              ),
              contentPadding: EdgeInsets.symmetric(
                horizontal: spacing.md,
                vertical: spacing.sm,
              ),
            ),
          ),
          SizedBox(height: spacing.md),
        ],
        if (filterWidgets != null && filterWidgets!.isNotEmpty)
          Wrap(
            spacing: spacing.sm,
            runSpacing: spacing.sm,
            children: filterWidgets!,
          ),
      ],
    );
  }
}
class ClarityContextMenu extends StatelessWidget {
  final List<ClarityContextMenuAction> actions;
  final IconData icon;
  final Color? iconColor;
  final String? tooltip;

  const ClarityContextMenu({
    super.key,
    required this.actions,
    this.icon = Icons.more_vert,
    this.iconColor,
    this.tooltip,
  });

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final spacing = AppSpacing.instance;

    return PopupMenuButton<int>(
      icon: Icon(
        icon,
        color: iconColor ?? colors.primary,
        size: spacing.iconSize,
      ),
      tooltip: tooltip,
      onSelected: (index) {
        if (index < actions.length) {
          actions[index].onPressed?.call();
        }
      },
      itemBuilder: (context) => actions
          .asMap()
          .entries
          .map((entry) {
        final action = entry.value;
        return PopupMenuItem(
          value: entry.key,
          child: Row(
            children: [
              Icon(action.icon, size: 18, color: action.color),
              const SizedBox(width: 12),
              Text(action.label),
            ],
          ),
        );
      }).toList(),
    );
  }
}
class ClarityContextMenuAction {
  final String label;
  final IconData icon;
  final Color? color;
  final VoidCallback? onPressed;

  ClarityContextMenuAction({
    required this.label,
    required this.icon,
    this.color,
    this.onPressed,
  });
}
class ClarityResponsiveContainer extends StatelessWidget {
  final Widget child;
  final double? maxWidth;
  final bool centerContent;
  final EdgeInsetsGeometry? padding;

  const ClarityResponsiveContainer({
    super.key,
    required this.child,
    this.maxWidth,
    this.centerContent = true,
    this.padding,
  });

  @override
  Widget build(BuildContext context) {
    final spacing = AppSpacing.instance;

    return LayoutBuilder(
      builder: (context, constraints) {
        final responsiveMaxWidth = maxWidth ??
            (constraints.maxWidth > 1200
                ? 1200.0
                : constraints.maxWidth > 768
                    ? 900.0
                    : double.infinity);

        final responsivePadding = padding ??
            EdgeInsets.symmetric(
              horizontal: constraints.maxWidth > 768
                  ? spacing.lg
                  : spacing.md,
              vertical: spacing.md,
            );

        final content = ConstrainedBox(
          constraints: BoxConstraints(maxWidth: responsiveMaxWidth),
          child: child,
        );

        return Container(
          width: double.infinity,
          padding: responsivePadding,
          alignment: centerContent ? Alignment.center : Alignment.topLeft,
          child: content,
        );
      },
    );
  }
}
class ClarityListItem extends StatelessWidget {
  final Widget leading;
  final String title;
  final String? subtitle;
  final List<ClarityContextMenuAction>? contextActions;
  final VoidCallback? onTap;
  final Color? backgroundColor;
  final String? badgeText;
  final Color? badgeColor;

  const ClarityListItem({
    super.key,
    required this.leading,
    required this.title,
    this.subtitle,
    this.contextActions,
    this.onTap,
    this.backgroundColor,
    this.badgeText,
    this.badgeColor,
  });

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final spacing = AppSpacing.instance;

    return ClarityCard(
      backgroundColor: backgroundColor,
      onTap: onTap,
      leading: leading,
      title: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: Theme.of(context).textTheme.titleMedium,
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
          if (subtitle != null) ...[
            SizedBox(height: spacing.xs),
            Text(
              subtitle!,
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: colors.textMuted,
                  ),
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
          ],
        ],
      ),
      trailing: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          if (badgeText != null) ...[
            ClarityStatusBadge(
              text: badgeText!,
              backgroundColor: badgeColor,
            ),
            SizedBox(width: spacing.sm),
          ],
          if (contextActions != null && contextActions!.isNotEmpty)
            ClarityContextMenu(actions: contextActions!),
        ],
      ),
    );
  }
}
class ClarityAccessibilityIndicator extends StatelessWidget {
  final double contrastRatio
  final String label;

  const ClarityAccessibilityIndicator({
    super.key,
    required this.contrastRatio,
    required this.label,
  });

  bool get isCompliantAA => contrastRatio >= 4.5;
  bool get isCompliantAAA => contrastRatio >= 7.0;

  Color get complianceColor =>
      isCompliantAAA
          ? Colors.green
          : isCompliantAA
              ? Colors.orange
              : Colors.red;

  String get complianceText =>
      isCompliantAAA ? 'AAA' : isCompliantAA ? 'AA' : 'No Cumple';

  @override
  Widget build(BuildContext context) {
    final spacing = AppSpacing.instance;

    return Container(
      padding: EdgeInsets.symmetric(
        horizontal: spacing.sm,
        vertical: spacing.xs,
      ),
      decoration: BoxDecoration(
        color: complianceColor.withValues(alpha: 0.1),
        border: Border.all(color: complianceColor, width: 1),
        borderRadius: BorderRadius.circular(spacing.borderRadius),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.check_circle, size: 14, color: complianceColor),
          SizedBox(width: spacing.xs),
          Text(
            '$label ($complianceText: ${contrastRatio.toStringAsFixed(1)}:1)',
            style: Theme.of(context).textTheme.labelSmall?.copyWith(
                  color: complianceColor,
                ),
          ),
        ],
      ),
    );
  }
}
/* Fin lib\widgets\components\clarity_components.dart */

/* Inicio lib\widgets\components\clarity_management_page.dart */
import 'package:flutter/material.dart';
import '../../theme/app_colors.dart';
import '../../theme/app_text_styles.dart';
import '../../theme/app_spacing.dart';
import 'clarity_components.dart';
class ClarityManagementPage extends StatelessWidget {
  final String title;
  final bool isLoading;
  final bool hasError;
  final String? errorMessage;
  final int itemCount;
  final Widget Function(BuildContext, int) itemBuilder;
  final List<Widget>? filterWidgets;
  final List<Widget>? statisticWidgets;
  final Future<void> Function()? onRefresh;
  final Widget? floatingActionButton;
  final ScrollController? scrollController;
  final bool hasMoreData;
  final bool isLoadingMore;
  final Widget? emptyStateWidget;
  final Widget? errorStateWidget;
  final double? itemSpacing;
  final Color? backgroundColor;

  const ClarityManagementPage({
    super.key,
    required this.title,
    required this.isLoading,
    required this.hasError,
    required this.itemCount,
    required this.itemBuilder,
    this.errorMessage,
    this.filterWidgets,
    this.statisticWidgets,
    this.onRefresh,
    this.floatingActionButton,
    this.scrollController,
    this.hasMoreData = false,
    this.isLoadingMore = false,
    this.emptyStateWidget,
    this.errorStateWidget,
    this.itemSpacing,
    this.backgroundColor,
  });

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final spacing = AppSpacing.instance;
    final textStyles = AppTextStyles.instance;

    return Scaffold(
      backgroundColor: backgroundColor ?? colors.background,
      appBar: AppBar(
        backgroundColor: colors.surface,
        elevation: 0,
        title: Text(title, style: textStyles.headlineMedium),
        centerTitle: false,
      ),
      body: RefreshIndicator(
        onRefresh: onRefresh ?? () async {},
        child: CustomScrollView(
          controller: scrollController,
          slivers: [
            SliverToBoxAdapter(
              child: Container(
                color: colors.surface,
                padding: EdgeInsets.all(spacing.screenPadding),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    if (statisticWidgets != null && statisticWidgets!.isNotEmpty) ...[
                      Wrap(
                        spacing: spacing.lg,
                        runSpacing: spacing.md,
                        alignment: WrapAlignment.center,
                        children: statisticWidgets!,
                      ),
                      SizedBox(height: spacing.lg),
                    ],
                    if (filterWidgets != null && filterWidgets!.isNotEmpty)
                      ...filterWidgets!,
                  ],
                ),
              ),
            ),
            if (isLoading && itemCount == 0)
              const SliverFillRemaining(
                child: Center(child: CircularProgressIndicator()),
              )
            else if (hasError)
              SliverFillRemaining(
                child: errorStateWidget ??
                    ClarityEmptyState(
                      icon: Icons.error_outline,
                      title: 'Error al cargar datos',
                      subtitle: errorMessage ?? 'Error desconocido',
                      action: onRefresh != null
                          ? ElevatedButton.icon(
                              onPressed: onRefresh,
                              icon: const Icon(Icons.refresh),
                              label: const Text('Reintentar'),
                            )
                          : null,
                    ),
              )
            else if (itemCount == 0)
              SliverFillRemaining(
                child: emptyStateWidget ??
                    ClarityEmptyState(
                      icon: Icons.inbox_outlined,
                      title: 'No hay elementos',
                      subtitle: 'Comienza agregando tu primer elemento',
                    ),
              )
            else
              SliverPadding(
                padding: EdgeInsets.all(spacing.screenPadding),
                sliver: SliverList(
                  delegate: SliverChildBuilderDelegate(
                    (context, index) {
                      if (index >= itemCount) {
                        if (hasMoreData && !isLoadingMore) {
                          WidgetsBinding.instance.addPostFrameCallback((_) {
                          });
                        }
                        return isLoadingMore
                            ? Center(
                                child: Padding(
                                  padding: EdgeInsets.all(spacing.md),
                                  child: const CircularProgressIndicator(),
                                ),
                              )
                            : const SizedBox.shrink();
                      }
                      return Padding(
                        padding: EdgeInsets.only(
                          bottom: itemSpacing ?? spacing.md,
                        ),
                        child: itemBuilder(context, index),
                      );
                    },
                    childCount: itemCount + (hasMoreData ? 1 : 0),
                  ),
                ),
              ),
          ],
        ),
      ),
      floatingActionButton: floatingActionButton,
    );
  }
}

/* Fin lib\widgets\components\clarity_management_page.dart */

/* Inicio lib\widgets\components\command_palette.dart */
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import '../../theme/app_colors.dart';
import '../../theme/app_text_styles.dart';
import '../../theme/app_spacing.dart';
class CommandPalette extends StatefulWidget {
  final List<CommandPaletteItem> items;
  final VoidCallback? onDismiss;

  const CommandPalette({
    super.key,
    required this.items,
    this.onDismiss,
  });

  @override
  State<CommandPalette> createState() => _CommandPaletteState();
}

class _CommandPaletteState extends State<CommandPalette> {
  final TextEditingController _searchController = TextEditingController();
  late List<CommandPaletteItem> _filteredItems;
  int _selectedIndex = 0;

  @override
  void initState() {
    super.initState();
    _filteredItems = widget.items;
    _searchController.addListener(_filterItems);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      FocusScope.of(context).requestFocus(FocusNode());
    });
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  void _filterItems() {
    final query = _searchController.text.toLowerCase();
    setState(() {
      _filteredItems = widget.items
          .where((item) =>
              item.title.toLowerCase().contains(query) ||
              item.description.toLowerCase().contains(query))
          .toList();
      _selectedIndex = 0;
    });
  }

  void _executeCommand() {
    if (_filteredItems.isNotEmpty && _selectedIndex < _filteredItems.length) {
      _filteredItems[_selectedIndex].onExecute();
      Navigator.of(context).pop();
      widget.onDismiss?.call();
    }
  }

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final spacing = AppSpacing.instance;
    final textStyles = AppTextStyles.instance;

    return Dialog(
      backgroundColor: Colors.transparent,
      elevation: 0,
      insetPadding: EdgeInsets.symmetric(
        horizontal: spacing.md,
        vertical: spacing.xl,
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          SizedBox(height: spacing.xl),
          Container(
            constraints: BoxConstraints(maxWidth: 600),
            decoration: BoxDecoration(
              color: colors.surface,
              borderRadius: BorderRadius.circular(spacing.borderRadius),
              border: Border.all(color: colors.borderLight),
              boxShadow: [
                BoxShadow(
                  color: colors.shadow.withValues(alpha: 0.1),
                  blurRadius: 20,
                  offset: Offset(0, 10),
                ),
              ],
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Padding(
                  padding: EdgeInsets.all(spacing.md),
                  child: KeyboardListener(
                    focusNode: FocusNode(),
                    onKeyEvent: (KeyEvent event) {
                      if (HardwareKeyboard.instance.isLogicalKeyPressed(LogicalKeyboardKey.escape)) {
                        Navigator.of(context).pop();
                        widget.onDismiss?.call();
                      } else if (HardwareKeyboard.instance.isLogicalKeyPressed(LogicalKeyboardKey.arrowDown)) {
                        setState(() {
                          if (_selectedIndex < _filteredItems.length - 1) {
                            _selectedIndex++;
                          }
                        });
                      } else if (HardwareKeyboard.instance.isLogicalKeyPressed(LogicalKeyboardKey.arrowUp)) {
                        setState(() {
                          if (_selectedIndex > 0) {
                            _selectedIndex--;
                          }
                        });
                      } else if (HardwareKeyboard.instance.isLogicalKeyPressed(LogicalKeyboardKey.enter)) {
                        _executeCommand();
                      }
                    },
                    child: TextField(
                      controller: _searchController,
                      autofocus: true,
                      decoration: InputDecoration(
                        hintText: 'Escribe para buscar (Esc para cerrar)...',
                        prefixIcon: Icon(Icons.search, color: colors.primary),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(spacing.borderRadius),
                          borderSide: BorderSide(color: colors.border),
                        ),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(spacing.borderRadius),
                          borderSide: BorderSide(color: colors.primary, width: 2),
                        ),
                        contentPadding: EdgeInsets.symmetric(
                          horizontal: spacing.md,
                          vertical: spacing.sm,
                        ),
                      ),
                    ),
                  ),
                ),
                Divider(height: 1, color: colors.borderLight),
                ConstrainedBox(
                  constraints: BoxConstraints(maxHeight: 400),
                  child: _filteredItems.isEmpty
                      ? Padding(
                          padding: EdgeInsets.all(spacing.lg),
                          child: Text(
                            'No se encontraron resultados',
                            style: textStyles.bodyMedium.copyWith(
                              color: colors.textMuted,
                            ),
                          ),
                        )
                      : ListView.builder(
                          shrinkWrap: true,
                          itemCount: _filteredItems.length,
                          itemBuilder: (context, index) {
                            final item = _filteredItems[index];
                            final isSelected = index == _selectedIndex;

                            return Material(
                              color: isSelected
                                  ? colors.primary.withValues(alpha: 0.1)
                                  : colors.surface,
                              child: InkWell(
                                onTap: () {
                                  setState(() {
                                    _selectedIndex = index;
                                  });
                                  _executeCommand();
                                },
                                child: Padding(
                                  padding: EdgeInsets.symmetric(
                                    horizontal: spacing.md,
                                    vertical: spacing.sm,
                                  ),
                                  child: Row(
                                    children: [
                                      Icon(
                                        item.icon,
                                        color: item.color ?? colors.primary,
                                        size: 18,
                                      ),
                                      SizedBox(width: spacing.md),
                                      Expanded(
                                        child: Column(
                                          crossAxisAlignment:
                                              CrossAxisAlignment.start,
                                          children: [
                                            Text(
                                              item.title,
                                              style: textStyles.titleSmall
                                                  .copyWith(
                                                color: isSelected
                                                    ? colors.primary
                                                    : colors.textPrimary,
                                              ),
                                            ),
                                            if (item.description.isNotEmpty)
                                              Text(
                                                item.description,
                                                style: textStyles.bodySmall
                                                    .copyWith(
                                                  color: colors.textMuted,
                                                ),
                                                maxLines: 1,
                                                overflow: TextOverflow.ellipsis,
                                              ),
                                          ],
                                        ),
                                      ),
                                      SizedBox(width: spacing.md),
                                      if (item.shortcut != null)
                                        Container(
                                          padding: EdgeInsets.symmetric(
                                            horizontal: spacing.xs,
                                            vertical: spacing.xs,
                                          ),
                                          decoration: BoxDecoration(
                                            color: colors.surfaceLight,
                                            borderRadius:
                                                BorderRadius.circular(
                                              spacing.borderRadius / 2,
                                            ),
                                            border: Border.all(
                                              color: colors.borderLight,
                                            ),
                                          ),
                                          child: Text(
                                            item.shortcut!,
                                            style: textStyles.labelSmall
                                                .copyWith(
                                              color: colors.textMuted,
                                            ),
                                          ),
                                        ),
                                    ],
                                  ),
                                ),
                              ),
                            );
                          },
                        ),
                )
              ],
            ),
          ),
          SizedBox(height: spacing.xl),
        ],
      ),
    );
  }
}
class CommandPaletteItem {
  final String title;
  final String description;
  final IconData icon;
  final Color? color;
  final String? shortcut
  final VoidCallback onExecute;

  CommandPaletteItem({
    required this.title,
    this.description = '',
    required this.icon,
    this.color,
    this.shortcut,
    required this.onExecute,
  });
}
mixin CommandPaletteMixin {
  static void showCommandPalette(BuildContext context, List<CommandPaletteItem> items) {
    showDialog(
      context: context,
      builder: (context) => CommandPalette(items: items),
    );
  }

  static void setupCommandPaletteShortcut(BuildContext context, List<CommandPaletteItem> items) {
  }
}

/* Fin lib\widgets\components\command_palette.dart */

/* Inicio lib\widgets\components\index.dart */


export 'clarity_components.dart';
export 'clarity_management_page.dart';
/* Fin lib\widgets\components\index.dart */

/* Inicio lib\widgets\dashboard_widgets.dart */
import 'package:flutter/material.dart';
import '../utils/responsive_utils.dart';
import '../config/app_constants.dart';
import '../theme/theme_extensions.dart';
import 'components/clarity_components.dart';
class DashboardFeatureCard extends StatelessWidget {
  final IconData icon;
  final String title;
  final String description;
  final Color color;
  final Map<String, dynamic> responsive;
  final VoidCallback? onTap;

  const DashboardFeatureCard({
    super.key,
    required this.icon,
    required this.title,
    required this.description,
    required this.color,
    required this.responsive,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final isDesktop = responsive['isDesktop'] as bool;
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return ClarityCard(
      onTap: onTap ?? () {
      },
      title: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            icon,
            size: isDesktop ? 48 : 32,
            color: color,
          ),
          SizedBox(width: spacing.sm),
          Expanded(
            child: Text(
              title,
              style: textStyles.titleLarge.copyWith(
                color: colors.textPrimary,
                fontWeight: FontWeight.bold,
              ),
              textAlign: TextAlign.center,
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ],
      ),
      subtitle: Text(
        description,
        style: textStyles.bodyMedium.copyWith(
          color: colors.textSecondary,
        ),
        textAlign: TextAlign.center,
        maxLines: 2,
        overflow: TextOverflow.ellipsis,
      ),
      padding: EdgeInsets.all(isDesktop ? spacing.xl : spacing.lg),
    );
  }
}
class UserGreetingWidget extends StatelessWidget {
  final String userName;
  final Map<String, dynamic> responsive;
  final String? subtitle;

  const UserGreetingWidget({
    super.key,
    required this.userName,
    required this.responsive,
    this.subtitle,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return ClarityCard(
      title: Text(
        'Â¡Hola, $userName!',
        style: textStyles.headlineMedium.copyWith(
          color: colors.primary,
          fontWeight: FontWeight.bold,
        ),
        textAlign: TextAlign.center,
      ),
      subtitle: subtitle != null ? Text(
        subtitle!,
        style: textStyles.bodyLarge.copyWith(
          color: colors.textSecondary,
        ),
        textAlign: TextAlign.center,
      ) : null,
      padding: EdgeInsets.all(spacing.xl),
    );
  }
}
class DashboardOptionsGrid extends StatelessWidget {
  final List<DashboardFeatureCard> cards;
  final Map<String, dynamic> responsive;
  final bool verticalMode;

  const DashboardOptionsGrid({
    super.key,
    required this.cards,
    required this.responsive,
    this.verticalMode = false,
  });

  @override
  Widget build(BuildContext context) {
    final screenType = responsive['screenType'] as ScreenType;

    if (verticalMode) {
      return Column(
        children: [
          const SizedBox(height: 32),
          Column(
            children: cards.map((card) {
              return Padding(
                padding: const EdgeInsets.symmetric(vertical: 6.0),
                child: ListTile(
                  onTap: card.onTap,
                  tileColor: Theme.of(context).cardColor,
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                  leading: Icon(card.icon, color: card.color, size: 28),
                  title: Text(card.title, style: context.textStyles.bodyLarge),
                  subtitle: Text(card.description, style: context.textStyles.bodySmall),
                ),
              );
            }).toList(),
          ),
        ],
      );
    }

    return Column(
      children: [
        const SizedBox(height: 32),
        LayoutBuilder(
          builder: (context, constraints) {
            final gridDelegate = ResponsiveUtils.getResponsiveGridDelegate(screenType);

            return GridView(
              gridDelegate: gridDelegate,
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              children: cards,
            );
          },
        ),
      ],
    );
  }
}
class DashboardAppBar extends StatelessWidget implements PreferredSizeWidget {
  final String title;
  final Color backgroundColor;
  final List<Widget> actions;

  const DashboardAppBar({
    super.key,
    this.title = 'AsistApp',
    required this.backgroundColor,
    required this.actions,
  });

  @override
  Widget build(BuildContext context) {
    return AppBar(
      title: Text(title),
      backgroundColor: backgroundColor,
      actions: actions,
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}
class DashboardAppBarActions extends StatelessWidget {
  final String userRole;
  final IconData roleIcon;
  final VoidCallback? onLogout;

  const DashboardAppBarActions({
    super.key,
    required this.userRole,
    required this.roleIcon,
    this.onLogout,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;

    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(
          margin: const EdgeInsets.only(right: 8),
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          constraints: const BoxConstraints(maxWidth: 120), // Limitar ancho mÃ¡ximo
          decoration: BoxDecoration(
            color: colors.roleBadgeBackground,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(roleIcon, size: 14, color: colors.roleBadgeIcon),
              const SizedBox(width: 4),
              Flexible(
                child: Text(
                  userRole,
                  style: TextStyle(
                    color: colors.roleBadgeText,
                    fontSize: 11,
                    fontWeight: FontWeight.w500,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ),
            ],
          ),
        ),
        IconButton(
          icon: const Icon(Icons.logout),
          onPressed: onLogout ?? () async {
          },
        ),
      ],
    );
  }
}
class DashboardBody extends StatelessWidget {
  final Widget userGreeting;
  final Widget dashboardOptions;
  final Map<String, dynamic> responsive;

  const DashboardBody({
    super.key,
    required this.userGreeting,
    required this.dashboardOptions,
    required this.responsive,
  });

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: SingleChildScrollView(
        child: ConstrainedBox(
          constraints: BoxConstraints(maxWidth: responsive['maxWidth']),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Padding(
                padding: EdgeInsets.symmetric(
                  horizontal: responsive['horizontalPadding'],
                  vertical: responsive['verticalPadding'],
                ),
                child: Column(
                  children: [
                    userGreeting,
                    SizedBox(height: responsive['elementSpacing']),
                    dashboardOptions,
                    SizedBox(height: responsive['elementSpacing'] * 2),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
/* Fin lib\widgets\dashboard_widgets.dart */

/* Inicio lib\widgets\form_widgets.dart */
import 'package:flutter/material.dart';
import '../theme/theme_extensions.dart';

class CustomTextFormField extends StatelessWidget {
  final TextEditingController controller;
  final String labelText;
  final String hintText;
  final TextInputType keyboardType;
  final bool obscureText;
  final String? Function(String?)? validator;
  final FocusNode? focusNode;
  final GlobalKey<FormFieldState>? fieldKey;
  final int? maxLines;
  final int? minLines;
  final Widget? prefixIcon;
  final Widget? suffixIcon;
  final bool enabled;
  final void Function(String)? onChanged;
  final void Function()? onTap;
  final String? initialValue;

  const CustomTextFormField({
    super.key,
    required this.controller,
    required this.labelText,
    required this.hintText,
    this.focusNode,
    this.fieldKey,
    this.keyboardType = TextInputType.text,
    this.obscureText = false,
    this.validator,
    this.maxLines = 1,
    this.minLines,
    this.prefixIcon,
    this.suffixIcon,
    this.enabled = true,
    this.onChanged,
    this.onTap,
    this.initialValue,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Material(
      color: Colors.transparent,
      child: TextFormField(
        key: fieldKey,
        focusNode: focusNode,
        controller: controller,
        initialValue: initialValue,
        keyboardType: keyboardType,
        obscureText: obscureText,
        maxLines: maxLines,
        minLines: minLines,
        enabled: enabled,
        onChanged: onChanged,
        onTap: onTap,
        validator: validator,
        style: textStyles.bodyLarge,
        decoration: InputDecoration(
          labelText: labelText,
          hintText: hintText,
          hintStyle: textStyles.bodyMedium.withColor(colors.textMuted),
          prefixIcon: prefixIcon,
          suffixIcon: suffixIcon,
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.border),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.borderLight),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.primary, width: 2),
          ),
          errorBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.error),
          ),
          focusedErrorBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.error, width: 2),
          ),
          filled: true,
          fillColor: enabled ? colors.surface : colors.surface.withValues(alpha: 0.5),
          contentPadding: EdgeInsets.symmetric(
            horizontal: spacing.md,
            vertical: spacing.sm,
          ),
          labelStyle: textStyles.bodyMedium.withColor(colors.textSecondary),
        ),
      ),
    );
  }
}

class CustomDropdownFormField<T> extends StatelessWidget {
  final T? value;
  final String labelText;
  final String hintText;
  final List<DropdownMenuItem<T>> items;
  final String? Function(T?)? validator;
  final FocusNode? focusNode;
  final GlobalKey<FormFieldState>? fieldKey;
  final void Function(T?)? onChanged;
  final bool enabled;

  const CustomDropdownFormField({
    super.key,
    this.value,
    required this.labelText,
    required this.hintText,
    required this.items,
    this.validator,
    this.onChanged,
    this.enabled = true,
    this.focusNode,
    this.fieldKey,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Material(
      color: Colors.transparent,
      child: DropdownButtonFormField<T>(
        key: fieldKey,
        value: value,
        focusNode: focusNode,
        items: items,
        onChanged: enabled ? onChanged : null,
        validator: validator,
        style: textStyles.bodyLarge,
        decoration: InputDecoration(
          labelText: labelText,
          hintText: hintText,
          hintStyle: textStyles.bodyMedium.withColor(colors.textMuted),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.border),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.borderLight),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.primary, width: 2),
          ),
          errorBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.error),
          ),
          focusedErrorBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.error, width: 2),
          ),
          filled: true,
          fillColor: enabled ? colors.surface : colors.surface.withValues(alpha: 0.5),
          contentPadding: EdgeInsets.symmetric(
            horizontal: spacing.md,
            vertical: spacing.sm,
          ),
          labelStyle: textStyles.bodyMedium.withColor(colors.textSecondary),
        ),
        dropdownColor: colors.surface,
      ),
    );
  }
}

class CustomCheckboxFormField extends StatelessWidget {
  final bool value;
  final String title;
  final String? subtitle;
  final void Function(bool?)? onChanged;
  final String? Function(bool?)? validator;
  final bool enabled;

  const CustomCheckboxFormField({
    super.key,
    required this.value,
    required this.title,
    this.subtitle,
    this.onChanged,
    this.validator,
    this.enabled = true,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return FormField<bool>(
      initialValue: value,
      validator: validator,
      builder: (FormFieldState<bool> state) {
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            CheckboxListTile(
              value: state.value ?? false,
              onChanged: enabled ? (bool? newValue) {
                state.didChange(newValue);
                onChanged?.call(newValue);
              } : null,
              title: Text(
                title,
                style: textStyles.bodyLarge,
              ),
              subtitle: subtitle != null
                  ? Text(
                      subtitle!,
                      style: textStyles.bodySmall.withColor(colors.textSecondary),
                    )
                  : null,
              controlAffinity: ListTileControlAffinity.leading,
              activeColor: colors.primary,
              checkColor: Theme.of(context).colorScheme.onPrimary,
              tileColor: colors.surface,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(spacing.borderRadius),
              ),
              side: BorderSide(color: colors.borderLight),
            ),
            if (state.hasError)
              Padding(
                padding: EdgeInsets.only(left: spacing.lg, top: spacing.xs),
                child: Text(
                  state.errorText!,
                  style: textStyles.bodySmall.withColor(colors.error),
                ),
              ),
          ],
        );
      },
    );
  }
}

class CustomSwitchFormField extends StatelessWidget {
  final bool value;
  final String title;
  final String? subtitle;
  final void Function(bool)? onChanged;
  final bool enabled;

  const CustomSwitchFormField({
    super.key,
    required this.value,
    required this.title,
    this.subtitle,
    this.onChanged,
    this.enabled = true,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Material(
      color: Colors.transparent,
      child: Card(
        elevation: 1,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(spacing.borderRadius),
        ),
        child: Padding(
          padding: EdgeInsets.all(spacing.md),
          child: Row(
            children: [
              Icon(
                value ? Icons.check_circle : Icons.cancel,
                color: value ? colors.success : colors.error,
              ),
              SizedBox(width: spacing.md),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      style: textStyles.bodyLarge,
                    ),
                    if (subtitle != null)
                      Text(
                        subtitle!,
                        style: textStyles.bodySmall.withColor(colors.textSecondary),
                      ),
                  ],
                ),
              ),
              Switch(
                value: value,
                onChanged: enabled ? onChanged : null,
                activeColor: colors.primary,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
/* Fin lib\widgets\form_widgets.dart */

/* Inicio lib\widgets\index.dart */

export 'pagination_widget.dart';
export 'dashboard_widgets.dart';
export 'form_widgets.dart';
export 'role_guard.dart';
export 'scroll_state_keeper.dart';
export 'session_info_footer.dart';
export 'common/index.dart';
export 'components/index.dart';
export 'ui/index.dart';

/* Fin lib\widgets\index.dart */

/* Inicio lib\widgets\pagination_widget.dart */
import 'package:flutter/material.dart';
import '../theme/theme_extensions.dart';
import '../theme/app_colors.dart';
import '../theme/app_spacing.dart';
import '../theme/app_text_styles.dart';
import '../config/app_constants.dart';
typedef OnPageChangeCallback = Future<void> Function(int page);
class PaginationWidget extends StatelessWidget {
  final int currentPage;
  final int totalPages;
  final int totalItems;
  final OnPageChangeCallback onPageChange;
  final bool isLoading;
  final int maxPageButtons;

  const PaginationWidget({
    super.key,
    required this.currentPage,
    required this.totalPages,
    required this.totalItems,
    required this.onPageChange,
    this.isLoading = false,
    this.maxPageButtons = 5,
  });

  bool get _canGoPrevious => currentPage > 1;
  bool get _canGoNext => currentPage < totalPages;
  bool get _showPagination => totalPages > 1;

  Future<void> _handlePageChange(int page) async {
    if (page != currentPage && page >= 1 && page <= totalPages) {
      await onPageChange(page);
    }
  }

  List<int> _getVisiblePages() {
    final pages = <int>[];

    if (totalPages <= maxPageButtons) {
      pages.addAll(List.generate(totalPages, (i) => i + 1));
    } else {
      if (currentPage <= maxPageButtons ~/ 2 + 1) {
        pages.addAll(List.generate(maxPageButtons, (i) => i + 1));
      } else if (currentPage >= totalPages - maxPageButtons ~/ 2) {
        pages.addAll(List.generate(
          maxPageButtons,
          (i) => totalPages - maxPageButtons + i + 1,
        ));
      } else {
        final center = maxPageButtons ~/ 2;
        pages.addAll(List.generate(
          maxPageButtons,
          (i) => currentPage - center + i,
        ));
      }
    }

    return pages;
  }

  @override
  Widget build(BuildContext context) {
    if (!_showPagination) {
      return const SizedBox.shrink();
    }

    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Container(
      margin: EdgeInsets.symmetric(horizontal: spacing.lg, vertical: spacing.md),
      decoration: BoxDecoration(
        color: colors.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: colors.borderLight, width: 1),
        boxShadow: [
          BoxShadow(
            color: colors.textMuted.withValues(alpha: 0.08),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            padding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
            decoration: BoxDecoration(
              color: colors.primaryContainer.withValues(alpha: 0.3),
              borderRadius: const BorderRadius.only(
                topLeft: Radius.circular(12),
                topRight: Radius.circular(12),
              ),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.library_books_outlined,
                  size: 16,
                  color: colors.primary,
                ),
                SizedBox(width: spacing.xs),
                Text(
                  'PÃ¡gina $currentPage de $totalPages',
                  style: textStyles.bodyMedium.bold.copyWith(color: colors.primary),
                ),
                SizedBox(width: spacing.sm),
                Container(
                  padding: EdgeInsets.symmetric(horizontal: spacing.sm, vertical: 2),
                  decoration: BoxDecoration(
                    color: colors.primary.withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(
                    '$totalItems items',
                    style: textStyles.bodySmall.copyWith(
                      color: colors.primary,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
              ],
            ),
          ),
          Padding(
            padding: EdgeInsets.all(spacing.md),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                _buildPageSelector(colors, spacing, textStyles),

                SizedBox(height: spacing.md),
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    _buildNavigationButton(
                      icon: Icons.first_page,
                      label: 'Primera',
                      enabled: _canGoPrevious && !isLoading,
                      onPressed: () => _handlePageChange(1),
                      colors: colors,
                      spacing: spacing,
                      textStyles: textStyles,
                      compact: true,
                    ),

                    SizedBox(width: spacing.sm),
                    _buildNavigationButton(
                      icon: Icons.chevron_left,
                      label: 'Anterior',
                      enabled: _canGoPrevious && !isLoading,
                      onPressed: () => _handlePageChange(currentPage - 1),
                      colors: colors,
                      spacing: spacing,
                      textStyles: textStyles,
                    ),

                    SizedBox(width: spacing.md),
                    _buildNavigationButton(
                      icon: Icons.chevron_right,
                      label: 'Siguiente',
                      enabled: _canGoNext && !isLoading,
                      onPressed: () => _handlePageChange(currentPage + 1),
                      colors: colors,
                      spacing: spacing,
                      textStyles: textStyles,
                      iconOnRight: true,
                    ),

                    SizedBox(width: spacing.sm),
                    _buildNavigationButton(
                      icon: Icons.last_page,
                      label: 'Ãšltima',
                      enabled: _canGoNext && !isLoading,
                      onPressed: () => _handlePageChange(totalPages),
                      colors: colors,
                      spacing: spacing,
                      textStyles: textStyles,
                      iconOnRight: true,
                      compact: true,
                    ),
                  ],
                ),
                if (isLoading) ...[
                  SizedBox(height: spacing.sm),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      SizedBox(
                        width: 16,
                        height: 16,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          valueColor: AlwaysStoppedAnimation<Color>(colors.primary),
                        ),
                      ),
                      SizedBox(width: spacing.sm),
                      Text(
                        'Cargando...',
                        style: textStyles.bodySmall.copyWith(color: colors.textSecondary),
                      ),
                    ],
                  ),
                ],
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildNavigationButton({
    required IconData icon,
    required String label,
    required bool enabled,
    required VoidCallback onPressed,
    required AppColors colors,
    required AppSpacing spacing,
    required AppTextStyles textStyles,
    bool iconOnRight = false,
    bool compact = false,
  }) {
    return AnimatedOpacity(
      opacity: enabled ? 1.0 : 0.5,
      duration: const Duration(milliseconds: 200),
      child: ElevatedButton(
        onPressed: enabled ? onPressed : null,
        style: ElevatedButton.styleFrom(
          backgroundColor: colors.primary,
          disabledBackgroundColor: colors.borderLight,
          foregroundColor: colors.getTextColorForBackground(colors.primary),
          disabledForegroundColor: colors.textMuted,
          padding: EdgeInsets.symmetric(
            horizontal: compact ? spacing.sm : spacing.md,
            vertical: spacing.sm,
          ),
          elevation: enabled ? 2 : 0,
          shadowColor: colors.primary.withValues(alpha: 0.4),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ).copyWith(
          overlayColor: WidgetStateProperty.all(
            colors.getTextColorForBackground(colors.primary).withValues(alpha: 0.1),
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            if (!iconOnRight) ...[
              Icon(icon, size: 18),
              if (!compact) SizedBox(width: spacing.xs),
            ],
            if (!compact)
              Text(
                label,
                style: textStyles.bodySmall.bold,
              ),
            if (iconOnRight) ...[
              if (!compact) SizedBox(width: spacing.xs),
              Icon(icon, size: 18),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildPageSelector(AppColors colors, AppSpacing spacing, AppTextStyles textStyles) {
    if (totalPages <= 1) {
      return const SizedBox.shrink();
    }

    final pages = _getVisiblePages();

    return Container(
      padding: EdgeInsets.symmetric(horizontal: spacing.sm, vertical: spacing.xs),
      decoration: BoxDecoration(
        color: colors.backgroundLight,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: colors.borderLight.withValues(alpha: 0.5)),
      ),
      child: SingleChildScrollView(
        scrollDirection: Axis.horizontal,
        child: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            for (int i = 0; i < pages.length; i++) ...[
              _buildPageButton(
                pageNumber: pages[i],
                isCurrentPage: pages[i] == currentPage,
                colors: colors,
                spacing: spacing,
                textStyles: textStyles,
              ),
              if (i != pages.length - 1) SizedBox(width: spacing.xs / 2),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildPageButton({
    required int pageNumber,
    required bool isCurrentPage,
    required AppColors colors,
    required AppSpacing spacing,
    required AppTextStyles textStyles,
  }) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: !isLoading && !isCurrentPage
            ? () => _handlePageChange(pageNumber)
            : null,
        borderRadius: BorderRadius.circular(8),
        splashColor: colors.primary.withValues(alpha: 0.1),
        highlightColor: colors.primary.withValues(alpha: 0.05),
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          curve: Curves.easeInOut,
          constraints: const BoxConstraints(
            minWidth: 36,
            minHeight: 36,
          ),
          padding: EdgeInsets.symmetric(
            horizontal: spacing.sm,
            vertical: spacing.xs,
          ),
          decoration: BoxDecoration(
            color: isCurrentPage
                ? colors.primary
                : Colors.transparent,
            borderRadius: BorderRadius.circular(8),
            border: Border.all(
              color: isCurrentPage
                  ? colors.primary
                  : colors.borderLight.withValues(alpha: 0.3),
              width: isCurrentPage ? 2 : 1,
            ),
            boxShadow: isCurrentPage
                ? [
                    BoxShadow(
                      color: colors.primary.withValues(alpha: 0.3),
                      blurRadius: 8,
                      offset: const Offset(0, 2),
                    ),
                  ]
                : null,
          ),
          child: Center(
            child: Text(
              '$pageNumber',
              style: textStyles.bodyMedium.copyWith(
                color: isCurrentPage
                    ? colors.getTextColorForBackground(colors.primary)
                    : colors.textSecondary,
                fontWeight: isCurrentPage ? FontWeight.bold : FontWeight.w500,
              ),
            ),
          ),
        ),
      ),
    );
  }
}
class PaginationState {
  final int currentPage;
  final int totalPages;
  final int totalItems;
  final int itemsPerPage;
  final bool isLoading;

  PaginationState({
    this.currentPage = 1,
    this.totalPages = 1,
    this.totalItems = 0,
    this.itemsPerPage = AppConstants.itemsPerPage,
    this.isLoading = false,
  });

  bool get hasNextPage => currentPage < totalPages;
  bool get hasPreviousPage => currentPage > 1;
  bool get isFirstPage => currentPage == 1;
  bool get isLastPage => currentPage == totalPages;
  PaginationState copyWith({
    int? currentPage,
    int? totalPages,
    int? totalItems,
    int? itemsPerPage,
    bool? isLoading,
  }) {
    return PaginationState(
      currentPage: currentPage ?? this.currentPage,
      totalPages: totalPages ?? this.totalPages,
      totalItems: totalItems ?? this.totalItems,
      itemsPerPage: itemsPerPage ?? this.itemsPerPage,
      isLoading: isLoading ?? this.isLoading,
    );
  }

  @override
  String toString() =>
      'PaginationState(page: $currentPage/$totalPages, items: $totalItems, perPage: $itemsPerPage)';
}

/* Fin lib\widgets\pagination_widget.dart */

/* Inicio lib\widgets\role_guard.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../utils/role_enum.dart';
class RoleGuard extends StatelessWidget {
  final List<UserRole> allowedRoles
  final Widget child
  final Widget? fallback

  const RoleGuard({
    super.key,
    required this.allowedRoles,
    required this.child,
    this.fallback,
  });

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final userRoleString = authProvider.user?['rol'] as String?;

    if (userRoleString == null) {
      return fallback ?? const SizedBox.shrink();
    }

    UserRole? userRole;
    try {
      userRole = UserRoleExtension.fromString(userRoleString);
    } catch (e) {
      return fallback ?? const SizedBox.shrink();
    }

    if (allowedRoles.contains(userRole)) {
      return child;
    } else {
      return fallback ?? const SizedBox.shrink();
    }
  }
}
/* Fin lib\widgets\role_guard.dart */

/* Inicio lib\widgets\scroll_state_keeper.dart */
import 'package:flutter/material.dart';
class ScrollStateKeeper extends StatefulWidget {
  final String routeKey;
  final bool keepScrollPosition;
  final Widget Function(BuildContext, ScrollController) builder;

  const ScrollStateKeeper({
    super.key,
    required this.routeKey,
    this.keepScrollPosition = true,
    required this.builder,
  });

  @override
  State<ScrollStateKeeper> createState() => _ScrollStateKeeperState();
}

class _ScrollStateKeeperState extends State<ScrollStateKeeper> {
  final ScrollController _scrollController = ScrollController();

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return widget.builder(context, _scrollController);
  }
}
/* Fin lib\widgets\scroll_state_keeper.dart */

/* Inicio lib\widgets\session_info_footer.dart */
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';

class SessionInfoFooter extends StatelessWidget {
  const SessionInfoFooter({super.key});

  Future<void> _copyToClipboard(BuildContext context, String text) async {
    await Clipboard.setData(ClipboardData(text: text));

    if (context.mounted) {
      final colors = context.colors;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            'Token copiado al portapapeles',
            style: TextStyle(color: colors.getTextColorForBackground(colors.success)),
          ),
          duration: const Duration(seconds: 2),
          backgroundColor: colors.success,
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final authProvider = Provider.of<AuthProvider>(context);
    final accessToken = authProvider.accessToken;

    if (accessToken == null) return const SizedBox.shrink();

    return Container(
      width: double.infinity,
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: colors.primary,
        boxShadow: [
          BoxShadow(
            color: colors.shadow,
            blurRadius: 4,
            offset: const Offset(0, -2),
          ),
        ],
      ),
      child: Row(
        children: [
          Icon(
            Icons.security,
            size: 16,
            color: colors.success,
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              'Token: ${accessToken.substring(0, 20)}...',
              style: TextStyle(
                color: colors.textOnDark,
                fontSize: 12,
                fontFamily: 'monospace',
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
          const SizedBox(width: 8),
          IconButton(
            icon: const Icon(Icons.copy, size: 16),
            color: colors.textOnDarkSecondary,
            tooltip: 'Copiar token',
            onPressed: () => _copyToClipboard(context, accessToken),
          ),
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
            decoration: BoxDecoration(
              color: colors.success.withValues(alpha: 0.2),
              borderRadius: BorderRadius.circular(4),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(
                  Icons.timer,
                  size: 14,
                  color: colors.success,
                ),
                const SizedBox(width: 4),
                Text(
                  'Activo',
                  style: TextStyle(
                    color: colors.getTextColorForBackground(colors.success),
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
/* Fin lib\widgets\session_info_footer.dart */

/* Inicio lib\widgets\ui\app_button.dart */
import 'package:flutter/widgets.dart';
import '../../theme/theme_extensions.dart';
import '../../theme/app_colors.dart';
import '../../config/app_constants.dart';
class AppButton extends StatefulWidget {
  final String label;
  final VoidCallback onPressed;
  final bool isLoading;
  final bool isEnabled;
  final double? width;
  final EdgeInsets? padding;

  const AppButton({
    required this.label,
    required this.onPressed,
    this.isLoading = false,
    this.isEnabled = true,
    this.width,
    this.padding,
    super.key,
  });

  @override
  State<AppButton> createState() => _AppButtonState();
}

class _AppButtonState extends State<AppButton> {
  bool _isPressed = false;

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    final buttonChild = Container(
      constraints: widget.width != null
          ? BoxConstraints(minWidth: widget.width!)
          : const BoxConstraints(minWidth: 0),
      padding: widget.padding ??
          EdgeInsets.symmetric(
            horizontal: spacing.md,
            vertical: spacing.md,
          ),
      decoration: BoxDecoration(
        color: widget.isEnabled
            ? (_isPressed ? colors.primaryDark : colors.primary)
            : colors.grey300,
        borderRadius: BorderRadius.circular(AppConstants.instance.buttonBorderRadius),
      ),
      child: Center(
        child: widget.isLoading
            ? SizedBox(
                width: AppConstants.instance.spinnerSize,
                height: AppConstants.instance.spinnerSize,
                child: _buildLoadingSpinner(context),
              )
            : Text(
                widget.label,
                style: textStyles.labelLarge.copyWith(
                  color: colors.white, // Texto blanco sobre fondo primario
                ),
              ),
      ),
    );

    return GestureDetector(
      onTapDown: widget.isEnabled && !widget.isLoading
          ? (_) => setState(() => _isPressed = true)
          : null,
      onTapUp: widget.isEnabled && !widget.isLoading
          ? (_) {
              setState(() => _isPressed = false);
              widget.onPressed();
            }
          : null,
      onTapCancel: widget.isEnabled && !widget.isLoading
          ? () => setState(() => _isPressed = false)
          : null,
      child: buttonChild,
    );
  }

  Widget _buildLoadingSpinner(BuildContext context) {
    final colors = context.colors;

    return Center(
      child: SizedBox(
        width: AppConstants.instance.spinnerSize,
        height: AppConstants.instance.spinnerSize,
        child: CustomPaint(
          painter: _SpinnerPainter(colors: colors),
        ),
      ),
    );
  }
}
class AppSecondaryButton extends StatefulWidget {
  final String label;
  final VoidCallback onPressed;
  final bool isEnabled;
  final double? width;

  const AppSecondaryButton({
    required this.label,
    required this.onPressed,
    this.isEnabled = true,
    this.width,
    super.key,
  });

  @override
  State<AppSecondaryButton> createState() => _AppSecondaryButtonState();
}

class _AppSecondaryButtonState extends State<AppSecondaryButton> {
  bool _isPressed = false;

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    final buttonChild = Container(
      constraints: widget.width != null
          ? BoxConstraints(minWidth: widget.width!)
          : const BoxConstraints(minWidth: 0),
      padding: EdgeInsets.symmetric(
        horizontal: spacing.md,
        vertical: spacing.md,
      ),
      decoration: BoxDecoration(
        border: Border.all(
          color: widget.isEnabled ? colors.primary : colors.grey300,
          width: AppConstants.instance.borderWidthNormal,
        ),
        borderRadius: BorderRadius.circular(AppConstants.instance.buttonBorderRadius),
        color: _isPressed && widget.isEnabled
            ? colors.surfaceLight
            : colors.transparent,
      ),
      child: Center(
        child: Text(
          widget.label,
          style: textStyles.labelLarge.copyWith(
            color: widget.isEnabled
                ? colors.primary // Texto primario sobre fondo transparente
                : colors.textDisabled,
          ),
        ),
      ),
    );

    return GestureDetector(
      onTapDown: widget.isEnabled
          ? (_) => setState(() => _isPressed = true)
          : null,
      onTapUp: widget.isEnabled
          ? (_) {
              setState(() => _isPressed = false);
              widget.onPressed();
            }
          : null,
      onTapCancel: widget.isEnabled
          ? () => setState(() => _isPressed = false)
          : null,
      child: buttonChild,
    );
  }
}
class _SpinnerPainter extends CustomPainter {
  final AppColors colors;

  _SpinnerPainter({required this.colors});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = colors.white // Spinner blanco sobre fondo primario
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;

    final radius = size.width / 2;
    final center = Offset(size.width / 2, size.height / 2);

    canvas.drawCircle(center, radius, paint);

    final rect = Rect.fromCircle(center: center, radius: radius);
    canvas.drawArc(rect, 0, 1.5, false, paint);
  }

  @override
  bool shouldRepaint(_SpinnerPainter oldDelegate) => true;
}

/* Fin lib\widgets\ui\app_button.dart */

/* Inicio lib\widgets\ui\app_components.dart */
import 'package:flutter/material.dart';
import '../../theme/theme_extensions.dart';
class AppCard extends StatelessWidget {
  final Widget child;
  final EdgeInsets? padding;
  final VoidCallback? onTap;
  final Color? backgroundColor;
  final double? elevation;
  final BorderRadius? borderRadius;

  const AppCard({
    required this.child,
    this.padding,
    this.onTap,
    this.backgroundColor,
    this.elevation,
    this.borderRadius,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;

    return Card(
      color: backgroundColor ?? colors.surface,
      elevation: elevation ?? 2,
      shadowColor: colors.shadow,
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(
        borderRadius: borderRadius ?? BorderRadius.circular(spacing.borderRadius),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: borderRadius ?? BorderRadius.circular(spacing.borderRadius),
        child: Padding(
          padding: padding ?? EdgeInsets.all(spacing.cardPadding),
          child: child,
        ),
      ),
    );
  }
}
class AppScaffold extends StatelessWidget {
  final String? title;
  final Widget body;
  final Widget? floatingActionButton;
  final List<Widget>? actions;
  final bool showBackButton;
  final VoidCallback? onBackPressed;
  final PreferredSizeWidget? appBar;

  const AppScaffold({
    this.title,
    required this.body,
    this.floatingActionButton,
    this.actions,
    this.showBackButton = false,
    this.onBackPressed,
    this.appBar,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return Scaffold(
      backgroundColor: colors.background,
      appBar: appBar ?? (title != null ? AppBar(
        backgroundColor: colors.surface,
        foregroundColor: colors.textPrimary,
        elevation: 0,
        shadowColor: colors.shadow,
        surfaceTintColor: Colors.transparent,
        titleTextStyle: textStyles.headlineMedium,
        title: Text(title!),
        leading: showBackButton ? IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: onBackPressed ?? () => Navigator.maybePop(context),
        ) : null,
        actions: actions,
      ) : null),
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.all(spacing.screenPadding),
          child: body,
        ),
      ),
      floatingActionButton: floatingActionButton,
    );
  }
}
class AppText extends StatelessWidget {
  final String text;
  final TextStyle? style;
  final TextAlign? textAlign;
  final int? maxLines;
  final TextOverflow? overflow;
  final bool? softWrap;

  const AppText(
    this.text, {
    this.style,
    this.textAlign,
    this.maxLines,
    this.overflow,
    this.softWrap,
    super.key,
  });
  const AppText.headlineLarge(
    this.text, {
    this.textAlign,
    this.maxLines,
    this.overflow,
    this.softWrap,
    super.key,
  }) : style = null;

  const AppText.headlineMedium(
    this.text, {
    this.textAlign,
    this.maxLines,
    this.overflow,
    this.softWrap,
    super.key,
  }) : style = null;

  const AppText.bodyLarge(
    this.text, {
    this.textAlign,
    this.maxLines,
    this.overflow,
    this.softWrap,
    super.key,
  }) : style = null;

  const AppText.bodyMedium(
    this.text, {
    this.textAlign,
    this.maxLines,
    this.overflow,
    this.softWrap,
    super.key,
  }) : style = null;

  @override
  Widget build(BuildContext context) {
    final textStyles = context.textStyles;

    TextStyle resolvedStyle;
    if (style != null) {
      resolvedStyle = style!;
    } else {
      final constructorName = runtimeType.toString();
      if (constructorName.contains('headlineLarge')) {
        resolvedStyle = textStyles.headlineLarge;
      } else if (constructorName.contains('headlineMedium')) {
        resolvedStyle = textStyles.headlineMedium;
      } else if (constructorName.contains('bodyLarge')) {
        resolvedStyle = textStyles.bodyLarge;
      } else {
        resolvedStyle = textStyles.bodyMedium;
      }
    }

    return Text(
      text,
      style: resolvedStyle,
      textAlign: textAlign,
      maxLines: maxLines,
      overflow: overflow,
      softWrap: softWrap,
    );
  }
}
class AppSpacer extends StatelessWidget {
  final double? width;
  final double? height;

  const AppSpacer({this.width, this.height, super.key});
  const AppSpacer.xs({super.key}) : width = null, height = null;
  const AppSpacer.sm({super.key}) : width = null, height = null;
  const AppSpacer.md({super.key}) : width = null, height = null;
  const AppSpacer.lg({super.key}) : width = null, height = null;
  const AppSpacer.xl({super.key}) : width = null, height = null;

  @override
  Widget build(BuildContext context) {
    final spacing = context.spacing;

    double resolvedWidth = width ?? 0;
    double resolvedHeight = height ?? 0;
    if (width == null && height == null) {
      final constructorName = runtimeType.toString();
      if (constructorName.contains('xs')) {
        resolvedHeight = spacing.xs;
      } else if (constructorName.contains('sm')) {
        resolvedHeight = spacing.sm;
      } else if (constructorName.contains('md')) {
        resolvedHeight = spacing.md;
      } else if (constructorName.contains('lg')) {
        resolvedHeight = spacing.lg;
      } else if (constructorName.contains('xl')) {
        resolvedHeight = spacing.xl;
      }
    }

    return SizedBox(
      width: resolvedWidth,
      height: resolvedHeight,
    );
  }
}
/* Fin lib\widgets\ui\app_components.dart */

/* Inicio lib\widgets\ui\error_logger.dart */
import 'package:flutter/material.dart';
import '../../theme/theme_extensions.dart';
class ErrorLoggerWidget extends StatefulWidget {
  ErrorLoggerWidget() : super(key: errorLoggerKey);

  @override
  State<ErrorLoggerWidget> createState() => ErrorLoggerWidgetState();
}

class ErrorLoggerWidgetState extends State<ErrorLoggerWidget> {
  final List<String> _logs = [];
  bool _isExpanded = false;
  bool _isVisible = false;

  @override
  void initState() {
    super.initState();

  }

  void addLog(String message) {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        _addLog(message);
      }
    });
  }

  void _addLog(String message) {
    setState(() {
      final timestamp = DateTime.now().toString().substring(11, 19)
      _logs.add('[$timestamp] $message');
      if (_logs.length > 50) {
        _logs.removeAt(0)
      }
      _isVisible = true;
    });
  }

  void _clearLogs() {
    setState(() {
      _logs.clear();
      _isVisible = false;
    });
  }

  @override
  Widget build(BuildContext context) {
    if (!_isVisible) return const SizedBox.shrink();

    final colors = context.colors;

    return Positioned(
      bottom: 20,
      right: 20,
      child: Material(
        color: Colors.transparent,
        child: Container(
          width: _isExpanded ? 300 : 60,
          height: _isExpanded ? 200 : 60,
          decoration: BoxDecoration(
            color: colors.surface,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: colors.border),
            boxShadow: const [
              BoxShadow(
                color: Color.fromRGBO(0, 0, 0, 0.3),
                blurRadius: 8,
                offset: Offset(0, 4),
              ),
            ],
          ),
          child: _isExpanded ? _buildExpandedView(context) : _buildCollapsedView(context),
        ),
      ),
    );
  }

  Widget _buildCollapsedView(BuildContext context) {
    final colors = context.colors;
    final errorCount = _logs.where((log) => log.contains('ERROR')).length;

    return GestureDetector(
      onTap: () => setState(() => _isExpanded = true),
      child: Container(
        padding: const EdgeInsets.all(12),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              errorCount > 0 ? Icons.error : Icons.bug_report,
              color: errorCount > 0 ? colors.error : colors.warning,
              size: 24,
            ),
            if (errorCount > 0)
              Container(
                margin: const EdgeInsets.only(top: 4),
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                decoration: BoxDecoration(
                  color: colors.error,
                  borderRadius: BorderRadius.circular(10),
                ),
                child: Text(
                  errorCount.toString(),
                  style: TextStyle(
                    color: colors.getTextColorForBackground(colors.error),
                    fontSize: 10,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildExpandedView(BuildContext context) {
    final colors = context.colors;
    final textStyles = context.textStyles;

    return Column(
      children: [

        Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
          decoration: BoxDecoration(
            color: colors.surfaceLight,
            borderRadius: const BorderRadius.only(
              topLeft: Radius.circular(12),
              topRight: Radius.circular(12),
            ),
          ),
          child: Row(
            children: [
              Text(
                'Logs de Debug',
                style: textStyles.labelLarge,
              ),
              const Spacer(),
              GestureDetector(
                onTap: _clearLogs,
                child: const Padding(
                  padding: EdgeInsets.all(4),
                  child: Icon(Icons.clear_all, size: 16),
                ),
              ),
              GestureDetector(
                onTap: () => setState(() => _isExpanded = false),
                child: const Padding(
                  padding: EdgeInsets.all(4),
                  child: Icon(Icons.close, size: 16),
                ),
              ),
            ],
          ),
        ),

        Expanded(
          child: Container(
            padding: const EdgeInsets.all(8),
            child: _logs.isEmpty
                ? Center(
                    child: Text(
                      'No hay logs',
                      style: textStyles.bodySmall,
                    ),
                  )
                : ListView.builder(
                    itemCount: _logs.length,
                    itemBuilder: (context, index) {
                      final log = _logs[_logs.length - 1 - index]
                      final isError = log.contains('ERROR');
                      return Padding(
                        padding: const EdgeInsets.only(bottom: 4),
                        child: Text(
                          log,
                          style: TextStyle(
                            fontSize: 10,
                            color: isError ? colors.error : colors.textSecondary,
                            fontFamily: 'monospace',
                          ),
                        ),
                      );
                    },
                  ),
          ),
        ),
      ],
    );
  }
}
final GlobalKey<ErrorLoggerWidgetState> errorLoggerKey = GlobalKey<ErrorLoggerWidgetState>();

void addDebugLog(String message) {
  debugPrint(message);
  errorLoggerKey.currentState?.addLog(message);
}
/* Fin lib\widgets\ui\error_logger.dart */

/* Inicio lib\widgets\ui\index.dart */
export 'app_button.dart';
export 'app_components.dart';
export 'error_logger.dart';

/* Fin lib\widgets\ui\index.dart */

/* Inicio backend\dist\config\app.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.config = void 0;
exports.config = {
    port: parseInt(process.env.PORT || '3000', 10),
    host: process.env.HOST || '0.0.0.0',
    jwtSecret: process.env.JWT_SECRET || 'asistapp_secret_key_2025',
    jwtExpiresIn: process.env.JWT_EXPIRES_IN || '24h',
    nodeEnv: process.env.NODE_ENV || 'development',
    logLevel: process.env.LOG_LEVEL || 'info',
};
exports.default = exports.config;

/* Fin backend\dist\config\app.js */

/* Inicio backend\dist\config\database.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prisma = exports.databaseService = void 0;
const client_1 = require("@prisma/client");
class DatabaseService {
    constructor() {
        this.prisma = null;
    }
    static getInstance() {
        if (!DatabaseService.instance) {
            DatabaseService.instance = new DatabaseService();
        }
        return DatabaseService.instance;
    }
    getClient() {
        if (!this.prisma) {
            console.log('ðŸ”„ Creando cliente Prisma...');
            this.prisma = new client_1.PrismaClient({
                log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
            });
            console.log('âœ… Cliente Prisma creado');
        }
        return this.prisma;
    }
    async disconnect() {
        if (this.prisma) {
            await this.prisma.$disconnect();
            this.prisma = null;
            console.log('ðŸ”Œ Cliente Prisma desconectado');
        }
    }
    async connect() {
        const client = this.getClient();
        await client.$connect();
        console.log('ðŸ”— Conectado a la base de datos');
    }
}
exports.databaseService = DatabaseService.getInstance();
exports.prisma = exports.databaseService.getClient();

/* Fin backend\dist\config\database.js */

/* Inicio backend\dist\config\jwt.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JWTService = void 0;
const crypto_1 = __importDefault(require("crypto"));
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const app_1 = require("./app");
class JWTService {
    static signAccessToken(payload) {
        return jsonwebtoken_1.default.sign(payload, this.accessSecret, { expiresIn: this.accessExpiresIn });
    }
    static verifyAccessToken(token) {
        try {
            const decoded = jsonwebtoken_1.default.verify(token, this.accessSecret);
            return decoded;
        }
        catch (error) {
            throw new Error('Access token invÃ¡lido o expirado');
        }
    }
    static signRefreshToken(payload) {
        const tokenPayload = {
            ...payload,
            jti: crypto_1.default.randomUUID(), // JWT ID Ãºnico para evitar colisiones
        };
        return jsonwebtoken_1.default.sign(tokenPayload, this.refreshSecret, { expiresIn: this.refreshExpiresIn });
    }
    static verifyRefreshToken(token) {
        try {
            const decoded = jsonwebtoken_1.default.verify(token, this.refreshSecret);
            return decoded;
        }
        catch (error) {
            throw new Error('Refresh token invÃ¡lido o expirado');
        }
    }
    static sign(payload) {
        return this.signAccessToken(payload);
    }
    static verify(token) {
        return this.verifyAccessToken(token);
    }
    static decode(token) {
        try {
            return jsonwebtoken_1.default.decode(token);
        }
        catch (error) {
            return null;
        }
    }
}
exports.JWTService = JWTService;
JWTService.accessSecret = app_1.config.jwtSecret;
JWTService.refreshSecret = app_1.config.jwtSecret + '_refresh'
JWTService.accessExpiresIn = app_1.config.jwtExpiresIn;
JWTService.refreshExpiresIn = '7d'
exports.default = JWTService;

/* Fin backend\dist\config\jwt.js */

/* Inicio backend\dist\controllers\admin-institucion.controller.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AdminInstitucionController = void 0;
const admin_institucion_service_1 = __importDefault(require("../services/admin-institucion.service"));
const types_1 = require("../types");

class AdminInstitucionController {

    static async getAll(request, reply) {
        try {
            const { page, limit } = request.query;
            const pagination = {};
            if (page)
                pagination.page = parseInt(page, 10);
            if (limit)
                pagination.limit = parseInt(limit, 10);
            const result = await admin_institucion_service_1.default.getAll(pagination);
            return reply.code(200).send({
                success: true,
                data: result.data,
                pagination: result.pagination,
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async getById(request, reply) {
        try {
            const { id } = request.params;
            const admin = await admin_institucion_service_1.default.getById(id);
            if (!admin) {
                throw new types_1.NotFoundError('Admin de InstituciÃ³n');
            }
            return reply.code(200).send({
                success: true,
                data: admin,
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async create(request, reply) {
        try {
            const adminData = request.body;
            const newAdmin = await admin_institucion_service_1.default.create(adminData);
            return reply.code(201).send({
                success: true,
                data: newAdmin,
                message: 'Admin de instituciÃ³n creado exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async update(request, reply) {
        try {
            const { id } = request.params;
            const adminData = request.body;
            const updatedAdmin = await admin_institucion_service_1.default.update(id, adminData);
            if (!updatedAdmin) {
                throw new types_1.NotFoundError('Admin de InstituciÃ³n');
            }
            return reply.code(200).send({
                success: true,
                data: updatedAdmin,
                message: 'Admin de instituciÃ³n actualizado exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async delete(request, reply) {
        try {
            const { id } = request.params;
            const deleted = await admin_institucion_service_1.default.delete(id);
            if (!deleted) {
                throw new types_1.NotFoundError('Admin de InstituciÃ³n');
            }
            return reply.code(200).send({
                success: true,
                data: null,
                message: 'Admin de instituciÃ³n eliminado exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }
}
exports.AdminInstitucionController = AdminInstitucionController;
exports.default = AdminInstitucionController;

/* Fin backend\dist\controllers\admin-institucion.controller.js */

/* Inicio backend\dist\controllers\auth.controller.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthController = void 0;
const database_1 = require("../config/database");
const auth_service_1 = __importDefault(require("../services/auth.service"));
const types_1 = require("../types");
class AuthController {

    static async login(request, reply) {
        try {
            const credentials = request.body;
            if (!credentials.email || !credentials.password) {
                throw new types_1.ValidationError('Email y contraseÃ±a son requeridos');
            }
            const result = await auth_service_1.default.login(credentials);
            return reply.code(200).send({
                success: true,
                data: {
                    accessToken: result.accessToken,
                    refreshToken: result.refreshToken,
                    expiresIn: result.expiresIn,
                    usuario: result.usuario
                }
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async getUserInstitutions(request, reply) {
        try {
            const user = request.user;
            if (!user) {
                throw new types_1.AuthenticationError('Usuario no autenticado');
            }
            const usuario = await database_1.prisma.usuario.findUnique({
                where: { id: user.id },
                include: {
                    usuarioInstituciones: {
                        include: {
                            institucion: true,
                        },
                    },
                },
            });
            if (!usuario) {
                throw new types_1.NotFoundError('Usuario');
            }
            const instituciones = (usuario.usuarioInstituciones || [])
                .filter(ui => ui.activo && ui.institucion?.activa)
                .map((ui) => ({
                id: ui.institucion.id,
                nombre: ui.institucion.nombre,
                rolEnInstitucion: ui.rolEnInstitucion,
            }));
            return reply.code(200).send({
                success: true,
                data: instituciones,
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async logout(request, reply) {
        try {
            const refreshToken = request.body.refreshToken;
            const authReq = request;
            const user = authReq.user;
            if (!user) {
                throw new types_1.AuthenticationError('Usuario no autenticado');
            }
            await auth_service_1.default.revokeRefreshTokens(user.id, refreshToken);
            return reply.code(200).send({
                success: true,
                message: 'SesiÃ³n cerrada exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async refreshToken(request, reply) {
        try {
            const refreshToken = request.body.refreshToken;
            if (!refreshToken) {
                throw new types_1.ValidationError('Refresh token es requerido');
            }
            const result = await auth_service_1.default.refreshToken(refreshToken);
            return reply.code(200).send({
                success: true,
                data: {
                    accessToken: result.accessToken,
                    refreshToken: result.refreshToken,
                    expiresIn: result.expiresIn,
                },
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async verify(request, reply) {
        try {
            const user = request.user;
            return reply.code(200).send({
                success: true,
                data: {
                    usuario: user,
                    valid: true,
                },
            });
        }
        catch (error) {
            throw error;
        }
    }
}
exports.AuthController = AuthController;
exports.default = AuthController;

/* Fin backend\dist\controllers\auth.controller.js */

/* Inicio backend\dist\controllers\estudiante.controller.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EstudianteController = void 0;
const database_1 = require("../config/database");
const types_1 = require("../types");
class EstudianteController {

    static async getClasesHoy(request, reply) {
        try {
            const user = request.user;
            if (!user) {
                throw new types_1.ValidationError('Usuario no autenticado');
            }

            const estudiante = await database_1.prisma.estudiante.findUnique({
                where: { usuarioId: user.id },
                include: {
                    usuario: {
                        include: {
                            usuarioInstituciones: {
                                include: { institucion: true }
                            }
                        }
                    }
                }
            });
            if (!estudiante) {
                throw new types_1.NotFoundError('Estudiante');
            }

            const today = new Date().getDay() || 7;

            const clasesHoy = await database_1.prisma.horario.findMany({
                where: {
                    diaSemana: today,
                    institucionId: estudiante.usuario.usuarioInstituciones[0]?.institucionId,
                    grupo: {
                        estudiantesGrupos: {
                            some: {
                                estudianteId: estudiante.id
                            }
                        }
                    }
                },
                include: {
                    materia: true,
                    profesor: {
                        select: {
                            id: true,
                            nombres: true,
                            apellidos: true
                        }
                    },
                    grupo: true
                },
                orderBy: {
                    horaInicio: 'asc'
                }
            });
            return reply.code(200).send({
                success: true,
                data: clasesHoy,
                message: `Clases del dÃ­a ${today}`
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async getHorarioSemanal(request, reply) {
        try {
            const user = request.user;
            if (!user) {
                throw new types_1.ValidationError('Usuario no autenticado');
            }

            const estudiante = await database_1.prisma.estudiante.findUnique({
                where: { usuarioId: user.id },
                include: {
                    usuario: {
                        include: {
                            usuarioInstituciones: {
                                include: { institucion: true }
                            }
                        }
                    }
                }
            });
            if (!estudiante) {
                throw new types_1.NotFoundError('Estudiante');
            }

            const horarioSemanal = await database_1.prisma.horario.findMany({
                where: {
                    institucionId: estudiante.usuario.usuarioInstituciones[0]?.institucionId,
                    grupo: {
                        estudiantesGrupos: {
                            some: {
                                estudianteId: estudiante.id
                            }
                        }
                    }
                },
                include: {
                    materia: true,
                    profesor: {
                        select: {
                            id: true,
                            nombres: true,
                            apellidos: true
                        }
                    },
                    grupo: true
                },
                orderBy: [
                    { diaSemana: 'asc' },
                    { horaInicio: 'asc' }
                ]
            });

            const horarioPorDia = {};
            for (let dia = 1; dia <= 7; dia++) {
                horarioPorDia[dia] = horarioSemanal.filter((h) => h.diaSemana === dia);
            }
            return reply.code(200).send({
                success: true,
                data: horarioPorDia
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async getClasesPorDia(request, reply) {
        try {
            const user = request.user;
            const { diaSemana } = request.params;
            if (!user) {
                throw new types_1.ValidationError('Usuario no autenticado');
            }
            const dia = parseInt(diaSemana);
            if (dia < 1 || dia > 7) {
                throw new types_1.ValidationError('DÃ­a de semana invÃ¡lido (1-7)');
            }

            const estudiante = await database_1.prisma.estudiante.findUnique({
                where: { usuarioId: user.id },
                include: {
                    usuario: {
                        include: {
                            usuarioInstituciones: {
                                include: { institucion: true }
                            }
                        }
                    }
                }
            });
            if (!estudiante) {
                throw new types_1.NotFoundError('Estudiante');
            }

            const clasesDia = await database_1.prisma.horario.findMany({
                where: {
                    diaSemana: dia,
                    institucionId: estudiante.usuario.usuarioInstituciones[0]?.institucionId,
                    grupo: {
                        estudiantesGrupos: {
                            some: {
                                estudianteId: estudiante.id
                            }
                        }
                    }
                },
                include: {
                    materia: true,
                    profesor: {
                        select: {
                            id: true,
                            nombres: true,
                            apellidos: true
                        }
                    },
                    grupo: true
                },
                orderBy: {
                    horaInicio: 'asc'
                }
            });
            return reply.code(200).send({
                success: true,
                data: clasesDia,
                message: `Clases del dÃ­a ${dia}`
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async getPerfil(request, reply) {
        try {
            const user = request.user;
            if (!user) {
                throw new types_1.ValidationError('Usuario no autenticado');
            }
            const estudiante = await database_1.prisma.estudiante.findUnique({
                where: { usuarioId: user.id },
                include: {
                    usuario: {
                        include: {
                            usuarioInstituciones: {
                                include: {
                                    institucion: true
                                }
                            }
                        }
                    }
                }
            });
            if (!estudiante) {
                throw new types_1.NotFoundError('Estudiante');
            }
            return reply.code(200).send({
                success: true,
                data: estudiante
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async getGrupos(request, reply) {
        try {
            const user = request.user;
            if (!user) {
                throw new types_1.ValidationError('Usuario no autenticado');
            }
            const estudiante = await database_1.prisma.estudiante.findUnique({
                where: { usuarioId: user.id }
            });
            if (!estudiante) {
                throw new types_1.NotFoundError('Estudiante');
            }
            const grupos = await database_1.prisma.estudianteGrupo.findMany({
                where: {
                    estudianteId: estudiante.id
                },
                include: {
                    grupo: {
                        include: {
                            periodoAcademico: true,
                            _count: {
                                select: {
                                    estudiantesGrupos: true,
                                    horarios: true
                                }
                            }
                        }
                    }
                }
            });
            return reply.code(200).send({
                success: true,
                data: grupos.map((eg) => eg.grupo)
            });
        }
        catch (error) {
            throw error;
        }
    }
}
exports.EstudianteController = EstudianteController;

/* Fin backend\dist\controllers\estudiante.controller.js */

/* Inicio backend\dist\controllers\grupo.controller.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GrupoController = void 0;
const database_1 = require("../config/database");
const grupo_service_1 = __importDefault(require("../services/grupo.service"));
const types_1 = require("../types");
class GrupoController {

    static async getAll(request, reply) {
        try {

            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: { usuarioId: request.user.id, activo: true },
            });
            if (!usuarioInstitucion) {
                return reply.code(400).send({
                    success: false,
                    error: 'El usuario no tiene una instituciÃ³n asignada',
                });
            }
            const institucionId = usuarioInstitucion.institucionId;
            const { page, limit, periodoId, grado, seccion, search } = request.query;

            const pageNum = page ? parseInt(page, 10) : 1;
            const limitNum = limit ? parseInt(limit, 10) : 10;
            if (pageNum < 1 || limitNum < 1 || limitNum > 100) {
                throw new types_1.ValidationError('Los parÃ¡metros de paginaciÃ³n deben ser mayores a 0. El lÃ­mite mÃ¡ximo es 100.');
            }
            const pagination = {
                page: pageNum,
                limit: limitNum,
            };
            const filters = {
                periodoId: periodoId || undefined,
                grado: grado || undefined,
                seccion: seccion || undefined,
                search: search || undefined,
            };
            const result = await grupo_service_1.default.getAllGruposByInstitucion(institucionId, pagination, filters);
            return reply.code(200).send({
                success: true,
                data: result.data,
                pagination: result.pagination,
            });
        }
        catch (error) {
            console.error('Error en getAll grupos:', error);
            throw error;
        }
    }

    static async getById(request, reply) {
        try {
            const { id } = request.params;
            const grupo = await grupo_service_1.default.getGrupoById(id);
            if (!grupo) {
                throw new types_1.NotFoundError('Grupo');
            }

            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: { usuarioId: request.user.id, activo: true },
            });
            if (usuarioInstitucion && grupo.institucionId !== usuarioInstitucion.institucionId) {
                return reply.code(403).send({
                    success: false,
                    error: 'No tienes permisos para acceder a este grupo',
                });
            }
            return reply.code(200).send({
                success: true,
                data: grupo,
            });
        }
        catch (error) {
            console.error('Error en getById grupo:', error);
            throw error;
        }
    }

    static async create(request, reply) {
        try {
            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: { usuarioId: request.user.id, activo: true },
            });
            if (!usuarioInstitucion) {
                return reply.code(400).send({
                    success: false,
                    error: 'El usuario no tiene una instituciÃ³n asignada',
                });
            }
            const data = {
                ...request.body,
                institucionId: usuarioInstitucion.institucionId,
            };
            const grupo = await grupo_service_1.default.createGrupo(data);
            return reply.code(201).send({
                success: true,
                data: grupo,
                message: 'Grupo creado exitosamente',
            });
        }
        catch (error) {
            console.error('Error en create grupo:', error);
            throw error;
        }
    }

    static async update(request, reply) {
        try {
            const { id } = request.params;
            const data = request.body;

            const existingGrupo = await grupo_service_1.default.getGrupoById(id);
            if (!existingGrupo) {
                throw new types_1.NotFoundError('Grupo');
            }
            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: { usuarioId: request.user.id, activo: true },
            });
            if (usuarioInstitucion && existingGrupo.institucionId !== usuarioInstitucion.institucionId) {
                return reply.code(403).send({
                    success: false,
                    error: 'No tienes permisos para modificar este grupo',
                });
            }
            const grupo = await grupo_service_1.default.updateGrupo(id, data);
            if (!grupo) {
                throw new types_1.NotFoundError('Grupo');
            }
            return reply.code(200).send({
                success: true,
                data: grupo,
                message: 'Grupo actualizado exitosamente',
            });
        }
        catch (error) {
            console.error('Error en update grupo:', error);
            throw error;
        }
    }

    static async delete(request, reply) {
        try {
            const { id } = request.params;

            const existingGrupo = await grupo_service_1.default.getGrupoById(id);
            if (!existingGrupo) {
                throw new types_1.NotFoundError('Grupo');
            }
            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: { usuarioId: request.user.id, activo: true },
            });
            if (usuarioInstitucion && existingGrupo.institucionId !== usuarioInstitucion.institucionId) {
                return reply.code(403).send({
                    success: false,
                    error: 'No tienes permisos para eliminar este grupo',
                });
            }
            const success = await grupo_service_1.default.deleteGrupo(id);
            return reply.code(200).send({
                success: true,
                message: 'Grupo eliminado exitosamente',
            });
        }
        catch (error) {
            console.error('Error en delete grupo:', error);
            throw error;
        }
    }

    static async getGruposDisponibles(request, reply) {
        try {
            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: { usuarioId: request.user.id, activo: true },
            });
            if (!usuarioInstitucion) {
                return reply.code(400).send({
                    success: false,
                    error: 'El usuario no tiene una instituciÃ³n asignada',
                });
            }
            const grupos = await grupo_service_1.default.getGruposDisponibles(usuarioInstitucion.institucionId);
            return reply.code(200).send({
                success: true,
                data: grupos,
            });
        }
        catch (error) {
            console.error('Error en getGruposDisponibles:', error);
            throw error;
        }
    }
}
exports.GrupoController = GrupoController;
exports.default = GrupoController;

/* Fin backend\dist\controllers\grupo.controller.js */

/* Inicio backend\dist\controllers\horario.controller.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HorarioController = void 0;
const database_1 = require("../config/database");
const horario_service_1 = __importDefault(require("../services/horario.service"));
const types_1 = require("../types");
class HorarioController {

    static async getAll(request, reply) {
        try {

            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: { usuarioId: request.user.id, activo: true },
            });
            if (!usuarioInstitucion) {
                return reply.code(400).send({
                    success: false,
                    error: 'El usuario no tiene una instituciÃ³n asignada',
                });
            }
            const { page, limit, grupoId, materiaId, profesorId, diaSemana } = request.query;

            const pageNum = page ? parseInt(page, 10) : 1;
            const limitNum = limit ? parseInt(limit, 10) : 10;
            if (pageNum < 1 || limitNum < 1 || limitNum > 100) {
                throw new types_1.ValidationError('Los parÃ¡metros de paginaciÃ³n deben ser mayores a 0. El lÃ­mite mÃ¡ximo es 100.');
            }
            const pagination = {
                page: pageNum,
                limit: limitNum,
            };
            const filters = {
                grupoId: grupoId || undefined,
                materiaId: materiaId || undefined,
                profesorId: profesorId || undefined,
                diaSemana: diaSemana ? parseInt(diaSemana, 10) : undefined,
            };
            const result = await horario_service_1.default.getAllHorariosByInstitucion(usuarioInstitucion.institucionId, pagination, filters);
            return reply.code(200).send({
                success: true,
                data: result.data,
                pagination: result.pagination,
            });
        }
        catch (error) {
            console.error('Error en getAll horarios:', error);
            throw error;
        }
    }

    static async getByGrupo(request, reply) {
        try {
            const { grupoId } = request.params;

            const grupo = await database_1.prisma.grupo.findUnique({
                where: { id: grupoId },
            });
            if (!grupo) {
                throw new types_1.NotFoundError('Grupo');
            }
            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: { usuarioId: request.user.id, activo: true },
            });
            if (usuarioInstitucion && grupo.institucionId !== usuarioInstitucion.institucionId) {
                return reply.code(403).send({
                    success: false,
                    error: 'No tienes permisos para acceder a los horarios de este grupo',
                });
            }
            const horarios = await horario_service_1.default.getHorariosByGrupo(grupoId);
            return reply.code(200).send({
                success: true,
                data: horarios,
            });
        }
        catch (error) {
            console.error('Error en getByGrupo horarios:', error);
            throw error;
        }
    }

    static async getById(request, reply) {
        try {
            const { id } = request.params;
            const horario = await horario_service_1.default.getHorarioById(id);
            if (!horario) {
                throw new types_1.NotFoundError('Horario');
            }

            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: { usuarioId: request.user.id, activo: true },
            });
            if (usuarioInstitucion && horario.institucionId !== usuarioInstitucion.institucionId) {
                return reply.code(403).send({
                    success: false,
                    error: 'No tienes permisos para acceder a este horario',
                });
            }
            return reply.code(200).send({
                success: true,
                data: horario,
            });
        }
        catch (error) {
            console.error('Error en getById horario:', error);
            throw error;
        }
    }

    static async create(request, reply) {
        try {
            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: { usuarioId: request.user.id, activo: true },
            });
            if (!usuarioInstitucion) {
                return reply.code(400).send({
                    success: false,
                    error: 'El usuario no tiene una instituciÃ³n asignada',
                });
            }
            const data = {
                ...request.body,
                institucionId: usuarioInstitucion.institucionId,
            };
            const horario = await horario_service_1.default.createHorario(data);
            return reply.code(201).send({
                success: true,
                data: horario,
                message: 'Horario creado exitosamente',
            });
        }
        catch (error) {
            console.error('Error en create horario:', error);
            throw error;
        }
    }

    static async update(request, reply) {
        try {
            const { id } = request.params;
            const data = request.body;

            const existingHorario = await horario_service_1.default.getHorarioById(id);
            if (!existingHorario) {
                throw new types_1.NotFoundError('Horario');
            }
            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: { usuarioId: request.user.id, activo: true },
            });
            if (usuarioInstitucion && existingHorario.institucionId !== usuarioInstitucion.institucionId) {
                return reply.code(403).send({
                    success: false,
                    error: 'No tienes permisos para modificar este horario',
                });
            }
            const horario = await horario_service_1.default.updateHorario(id, data);
            if (!horario) {
                throw new types_1.NotFoundError('Horario');
            }
            return reply.code(200).send({
                success: true,
                data: horario,
                message: 'Horario actualizado exitosamente',
            });
        }
        catch (error) {
            console.error('Error en update horario:', error);
            throw error;
        }
    }

    static async delete(request, reply) {
        try {
            const { id } = request.params;

            const existingHorario = await horario_service_1.default.getHorarioById(id);
            if (!existingHorario) {
                throw new types_1.NotFoundError('Horario');
            }
            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: { usuarioId: request.user.id, activo: true },
            });
            if (usuarioInstitucion && existingHorario.institucionId !== usuarioInstitucion.institucionId) {
                return reply.code(403).send({
                    success: false,
                    error: 'No tienes permisos para eliminar este horario',
                });
            }
            const success = await horario_service_1.default.deleteHorario(id);
            return reply.code(200).send({
                success: true,
                message: 'Horario eliminado exitosamente',
            });
        }
        catch (error) {
            console.error('Error en delete horario:', error);
            throw error;
        }
    }
}
exports.HorarioController = HorarioController;
exports.default = HorarioController;

/* Fin backend\dist\controllers\horario.controller.js */

/* Inicio backend\dist\controllers\institucion.controller.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstitucionController = void 0;
const institucion_service_1 = __importDefault(require("../services/institucion.service"));
const types_1 = require("../types");
class InstitucionController {
    static async getAll(request, reply) {
        try {
            const { page, limit, activa, search } = request.query;

            const pageNum = page ? parseInt(page, 10) : 1;
            const limitNum = limit ? parseInt(limit, 10) : 10;
            if (pageNum < 1 || limitNum < 1 || limitNum > 100) {
                return reply.code(400).send({
                    success: false,
                    error: 'Los parÃ¡metros de paginaciÃ³n deben ser mayores a 0. El lÃ­mite mÃ¡ximo es 100.',
                });
            }
            const pagination = {
                page: pageNum,
                limit: limitNum,
            };
            const filters = {
                activa: activa !== undefined ? activa === 'true' : undefined,
                search: search || undefined,
            };
            const result = await institucion_service_1.default.getAllInstitutions(pagination, filters);
            return reply.code(200).send({
                success: true,
                data: result.data,
                pagination: result.pagination,
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async getById(request, reply) {
        try {
            const { id } = request.params;
            const institution = await institucion_service_1.default.getInstitutionById(id);
            if (!institution) {
                throw new types_1.NotFoundError('InstituciÃ³n');
            }
            return reply.code(200).send({
                success: true,
                data: institution,
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async create(request, reply) {
        try {
            const data = request.body;
            const institution = await institucion_service_1.default.createInstitution(data);
            return reply.code(201).send({
                success: true,
                data: institution,
                message: 'InstituciÃ³n creada exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async update(request, reply) {
        try {
            const { id } = request.params;
            const data = request.body;
            const institution = await institucion_service_1.default.updateInstitution(id, data);
            if (!institution) {
                throw new types_1.NotFoundError('InstituciÃ³n');
            }
            return reply.code(200).send({
                success: true,
                data: institution,
                message: 'InstituciÃ³n actualizada exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async delete(request, reply) {
        try {
            const { id } = request.params;
            const success = await institucion_service_1.default.deleteInstitution(id);
            return reply.code(200).send({
                success: true,
                message: 'InstituciÃ³n eliminada exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async getAdminsByInstitution(request, reply) {
        try {
            const { id } = request.params;
            const admins = await institucion_service_1.default.getAdminsByInstitution(id);
            return reply.code(200).send({
                success: true,
                data: admins,
            });
        }
        catch (error) {
            throw error;
        }
    }
    static async assignAdminToInstitution(request, reply) {
        try {
            const { id } = request.params;
            const { userId } = request.body;
            const result = await institucion_service_1.default.assignAdminToInstitution(id, userId);
            return reply.code(201).send({
                success: true,
                data: result,
                message: 'Administrador asignado a la instituciÃ³n exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }
    static async removeAdminFromInstitution(request, reply) {
        try {
            const { id, userId } = request.params;
            const result = await institucion_service_1.default.removeAdminFromInstitution(id, userId);
            return reply.code(200).send({
                success: true,
                data: result,
                message: 'Administrador removido de la instituciÃ³n exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }
}
exports.InstitucionController = InstitucionController;
exports.default = InstitucionController;

/* Fin backend\dist\controllers\institucion.controller.js */

/* Inicio backend\dist\controllers\institution-admin.controller.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstitutionAdminController = void 0;
const database_1 = require("../config/database");
const profesor_service_1 = __importDefault(require("../services/profesor.service"));
const types_1 = require("../types");

class InstitutionAdminController {

    static async getAllProfesores(request, reply) {
        try {
            const user = request.user;
            const { page, limit, activo, search } = request.query;

            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: {
                    usuarioId: user.id,
                    activo: true,
                },
                include: {
                    institucion: true,
                },
            });
            if (!usuarioInstitucion) {
                return reply.code(403).send({
                    success: false,
                    message: 'No tienes una instituciÃ³n asignada',
                });
            }
            const institucionId = usuarioInstitucion.institucionId;

            const pagination = {};
            if (page) {
                const pageNum = parseInt(page, 10);
                if (pageNum < 1) {
                    throw new types_1.ValidationError('El parÃ¡metro page debe ser mayor a 0.');
                }
                pagination.page = pageNum;
            }
            if (limit) {
                const limitNum = parseInt(limit, 10);
                if (limitNum < 1 || limitNum > 100) {
                    throw new types_1.ValidationError('El parÃ¡metro limit debe ser mayor a 0 y mÃ¡ximo 100.');
                }
                pagination.limit = limitNum;
            }

            const filters = { institucionId };
            if (activo !== undefined && activo !== null) {
                filters.activo = String(activo).toLowerCase() === 'true';
            }
            if (search)
                filters.search = search;

            const result = await profesor_service_1.default.getAll(institucionId, pagination, filters);
            return reply.code(200).send({
                success: true,
                data: result.data,
                pagination: result.pagination,
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async getProfesorById(request, reply) {
        try {
            const user = request.user;
            const { id } = request.params;

            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: {
                    usuarioId: user.id,
                    activo: true,
                },
                include: {
                    institucion: true,
                },
            });
            if (!usuarioInstitucion) {
                return reply.code(403).send({
                    success: false,
                    message: 'No tienes una instituciÃ³n asignada',
                });
            }
            const institucionId = usuarioInstitucion.institucionId;
            const profesor = await profesor_service_1.default.getById(id, institucionId);
            if (!profesor) {
                throw new types_1.NotFoundError('Profesor');
            }
            return reply.code(200).send({
                success: true,
                data: profesor,
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async createProfesor(request, reply) {
        try {
            const user = request.user;
            const profesorData = request.body;

            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: {
                    usuarioId: user.id,
                    activo: true,
                },
                include: {
                    institucion: true,
                },
            });
            if (!usuarioInstitucion) {
                return reply.code(403).send({
                    success: false,
                    message: 'No tienes una instituciÃ³n asignada',
                });
            }
            const institucionId = usuarioInstitucion.institucionId;

            const newProfesor = await profesor_service_1.default.create({
                nombres: profesorData.nombres,
                apellidos: profesorData.apellidos,
                email: profesorData.email,
                password: profesorData.password,
                institucionId: institucionId,
                grupoId: profesorData.grupoId,
            }, user.id);
            return reply.code(201).send({
                success: true,
                data: newProfesor,
                message: 'Profesor creado exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async updateProfesor(request, reply) {
        try {
            const user = request.user;
            const { id } = request.params;
            const profesorData = request.body;

            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: {
                    usuarioId: user.id,
                    activo: true,
                },
                include: {
                    institucion: true,
                },
            });
            if (!usuarioInstitucion) {
                return reply.code(403).send({
                    success: false,
                    message: 'No tienes una instituciÃ³n asignada',
                });
            }
            const institucionId = usuarioInstitucion.institucionId;
            const updatedProfesor = await profesor_service_1.default.update(id, institucionId, profesorData);
            if (!updatedProfesor) {
                throw new types_1.NotFoundError('Profesor');
            }
            return reply.code(200).send({
                success: true,
                data: updatedProfesor,
                message: 'Profesor actualizado exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async deleteProfesor(request, reply) {
        try {
            const user = request.user;
            const { id } = request.params;

            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: {
                    usuarioId: user.id,
                    activo: true,
                },
                include: {
                    institucion: true,
                },
            });
            if (!usuarioInstitucion) {
                return reply.code(403).send({
                    success: false,
                    message: 'No tienes una instituciÃ³n asignada',
                });
            }
            const institucionId = usuarioInstitucion.institucionId;
            const deleted = await profesor_service_1.default.delete(id, institucionId);
            if (!deleted) {
                throw new types_1.NotFoundError('Profesor');
            }
            return reply.code(200).send({
                success: true,
                data: null,
                message: 'Profesor eliminado exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async toggleProfesorStatus(request, reply) {
        try {
            const user = request.user;
            const { id } = request.params;

            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: {
                    usuarioId: user.id,
                    activo: true,
                },
                include: {
                    institucion: true,
                },
            });
            if (!usuarioInstitucion) {
                return reply.code(403).send({
                    success: false,
                    message: 'No tienes una instituciÃ³n asignada',
                });
            }
            const institucionId = usuarioInstitucion.institucionId;
            const profesor = await profesor_service_1.default.toggleStatus(id, institucionId);
            if (!profesor) {
                throw new types_1.NotFoundError('Profesor');
            }
            return reply.code(200).send({
                success: true,
                data: profesor,
                message: `Profesor ${profesor.activo ? 'activado' : 'desactivado'} exitosamente`,
            });
        }
        catch (error) {
            throw error;
        }
    }
}
exports.InstitutionAdminController = InstitutionAdminController;
exports.default = InstitutionAdminController;

/* Fin backend\dist\controllers\institution-admin.controller.js */

/* Inicio backend\dist\controllers\materia.controller.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MateriaController = void 0;
const database_1 = require("../config/database");
const materia_service_1 = __importDefault(require("../services/materia.service"));
const types_1 = require("../types");
class MateriaController {

    static async getAll(request, reply) {
        try {

            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: { usuarioId: request.user.id, activo: true },
            });
            if (!usuarioInstitucion) {
                return reply.code(400).send({
                    success: false,
                    error: 'El usuario no tiene una instituciÃ³n asignada',
                });
            }
            const { page, limit, search } = request.query;

            const pageNum = page ? parseInt(page, 10) : 1;
            const limitNum = limit ? parseInt(limit, 10) : 10;
            if (pageNum < 1 || limitNum < 1 || limitNum > 100) {
                throw new types_1.ValidationError('Los parÃ¡metros de paginaciÃ³n deben ser mayores a 0. El lÃ­mite mÃ¡ximo es 100.');
            }
            const pagination = {
                page: pageNum,
                limit: limitNum,
            };
            const filters = {
                search: search || undefined,
            };
            const result = await materia_service_1.default.getAllMateriasByInstitucion(usuarioInstitucion.institucionId, pagination, filters);
            return reply.code(200).send({
                success: true,
                data: result.data,
                pagination: result.pagination,
            });
        }
        catch (error) {
            console.error('Error en getAll materias:', error);
            throw error;
        }
    }

    static async getById(request, reply) {
        try {
            const { id } = request.params;
            const materia = await materia_service_1.default.getMateriaById(id);
            if (!materia) {
                throw new types_1.NotFoundError('Materia');
            }

            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: { usuarioId: request.user.id, activo: true },
            });
            if (usuarioInstitucion && materia.institucionId !== usuarioInstitucion.institucionId) {
                return reply.code(403).send({
                    success: false,
                    error: 'No tienes permisos para acceder a esta materia',
                });
            }
            return reply.code(200).send({
                success: true,
                data: materia,
            });
        }
        catch (error) {
            console.error('Error en getById materia:', error);
            throw error;
        }
    }

    static async create(request, reply) {
        try {
            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: { usuarioId: request.user.id, activo: true },
            });
            if (!usuarioInstitucion) {
                return reply.code(400).send({
                    success: false,
                    error: 'El usuario no tiene una instituciÃ³n asignada',
                });
            }
            const data = {
                ...request.body,
                institucionId: usuarioInstitucion.institucionId,
            };
            const materia = await materia_service_1.default.createMateria(data);
            return reply.code(201).send({
                success: true,
                data: materia,
                message: 'Materia creada exitosamente',
            });
        }
        catch (error) {
            console.error('Error en create materia:', error);
            throw error;
        }
    }

    static async update(request, reply) {
        try {
            const { id } = request.params;
            const data = request.body;

            const existingMateria = await materia_service_1.default.getMateriaById(id);
            if (!existingMateria) {
                throw new types_1.NotFoundError('Materia');
            }
            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: { usuarioId: request.user.id, activo: true },
            });
            if (usuarioInstitucion && existingMateria.institucionId !== usuarioInstitucion.institucionId) {
                return reply.code(403).send({
                    success: false,
                    error: 'No tienes permisos para modificar esta materia',
                });
            }
            const materia = await materia_service_1.default.updateMateria(id, data);
            if (!materia) {
                throw new types_1.NotFoundError('Materia');
            }
            return reply.code(200).send({
                success: true,
                data: materia,
                message: 'Materia actualizada exitosamente',
            });
        }
        catch (error) {
            console.error('Error en update materia:', error);
            throw error;
        }
    }

    static async delete(request, reply) {
        try {
            const { id } = request.params;

            const existingMateria = await materia_service_1.default.getMateriaById(id);
            if (!existingMateria) {
                throw new types_1.NotFoundError('Materia');
            }
            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: { usuarioId: request.user.id, activo: true },
            });
            if (usuarioInstitucion && existingMateria.institucionId !== usuarioInstitucion.institucionId) {
                return reply.code(403).send({
                    success: false,
                    error: 'No tienes permisos para eliminar esta materia',
                });
            }
            const success = await materia_service_1.default.deleteMateria(id);
            return reply.code(200).send({
                success: true,
                message: 'Materia eliminada exitosamente',
            });
        }
        catch (error) {
            console.error('Error en delete materia:', error);
            throw error;
        }
    }

    static async getMateriasDisponibles(request, reply) {
        try {
            const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: { usuarioId: request.user.id, activo: true },
            });
            if (!usuarioInstitucion) {
                return reply.code(400).send({
                    success: false,
                    error: 'El usuario no tiene una instituciÃ³n asignada',
                });
            }
            const materias = await materia_service_1.default.getMateriasDisponibles(usuarioInstitucion.institucionId);
            return reply.code(200).send({
                success: true,
                data: materias,
            });
        }
        catch (error) {
            console.error('Error en getMateriasDisponibles:', error);
            throw error;
        }
    }
}
exports.MateriaController = MateriaController;
exports.default = MateriaController;

/* Fin backend\dist\controllers\materia.controller.js */

/* Inicio backend\dist\controllers\profesor.controller.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProfesorController = void 0;
const profesor_service_1 = require("../services/profesor.service");
class ProfesorController {

    static async getClasesDelDia(request, reply) {
        try {
            const profesorId = request.user.id;
            const clases = await profesor_service_1.ProfesorService.getClasesDelDia(profesorId);
            return reply.status(200).send({
                success: true,
                data: clases,
                message: 'Clases del dÃ­a obtenidas exitosamente',
            });
        }
        catch (error) {
            console.error('Error en getClasesDelDia:', error);
            return reply.status(500).send({
                success: false,
                message: 'Error interno del servidor',
            });
        }
    }

    static async getClasesPorDia(request, reply) {
        try {
            const profesorId = request.user.id;
            const diaSemana = parseInt(request.params.diaSemana);

            if (isNaN(diaSemana) || diaSemana < 1 || diaSemana > 7) {
                return reply.status(400).send({
                    success: false,
                    message: 'El dÃ­a de la semana debe ser un nÃºmero entre 1 (Lunes) y 7 (Domingo)',
                });
            }
            const clases = await profesor_service_1.ProfesorService.getClasesPorDia(profesorId, diaSemana);
            return reply.status(200).send({
                success: true,
                data: clases,
                message: `Clases del dÃ­a ${diaSemana} obtenidas exitosamente`,
            });
        }
        catch (error) {
            console.error('Error en getClasesPorDia:', error);
            return reply.status(500).send({
                success: false,
                message: 'Error interno del servidor',
            });
        }
    }

    static async getHorarioSemanal(request, reply) {
        try {
            const profesorId = request.user.id;
            const horarioSemanal = await profesor_service_1.ProfesorService.getHorarioSemanal(profesorId);
            return reply.status(200).send({
                success: true,
                data: horarioSemanal,
                message: 'Horario semanal obtenido exitosamente',
            });
        }
        catch (error) {
            console.error('Error en getHorarioSemanal:', error);
            return reply.status(500).send({
                success: false,
                message: 'Error interno del servidor',
            });
        }
    }
}
exports.ProfesorController = ProfesorController;
exports.default = ProfesorController;

/* Fin backend\dist\controllers\profesor.controller.js */

/* Inicio backend\dist\controllers\user.controller.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserController = void 0;
const database_1 = require("../config/database");
const user_service_1 = __importDefault(require("../services/user.service"));
const types_1 = require("../types");

class UserController {

    static async getAllUsers(request, reply) {
        try {
            const { page, limit, rol, institucionId, activo, search } = request.query;

            const pagination = {};
            if (page) {
                const pageNum = parseInt(page, 10);
                if (pageNum < 1) {
                    return reply.code(400).send({
                        success: false,
                        error: 'El parÃ¡metro page debe ser mayor a 0.',
                    });
                }
                pagination.page = pageNum;
            }
            if (limit) {
                const limitNum = parseInt(limit, 10);
                if (limitNum < 1 || limitNum > 100) {
                    return reply.code(400).send({
                        success: false,
                        error: 'El parÃ¡metro limit debe ser mayor a 0 y mÃ¡ximo 100.',
                    });
                }
                pagination.limit = limitNum;
            }

            const filters = {};
            if (rol)
                filters.rol = rol;
            if (institucionId)
                filters.institucionId = institucionId;
            if (activo !== undefined)
                filters.activo = activo === 'true';
            if (search)
                filters.search = search;
            const result = await user_service_1.default.getAllUsers(pagination, filters);
            return reply.code(200).send({
                success: true,
                data: result.data,
                pagination: result.pagination,
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async changePassword(request, reply) {
        try {
            const { id } = request.params;
            const { newPassword } = request.body;

            const authReq = request;
            const invoker = authReq.user;
            if (invoker.rol === 'admin_institucion') {

                const usuarioInstitucion = await database_1.prisma.usuarioInstitucion.findFirst({
                    where: { usuarioId: invoker.id, activo: true },
                });
                if (!usuarioInstitucion) {
                    throw new types_1.AuthorizationError('No tienes una instituciÃ³n asignada');
                }
                const institucionId = usuarioInstitucion.institucionId;

                const targetRelation = await database_1.prisma.usuarioInstitucion.findFirst({
                    where: { usuarioId: id, institucionId, activo: true },
                });
                if (!targetRelation) {
                    throw new types_1.AuthorizationError('No tienes permiso para cambiar la contraseÃ±a de este usuario');
                }
            }
            await user_service_1.default.changeUserPassword(id, newPassword);
            return reply.code(200).send({ success: true, message: 'ContraseÃ±a actualizada exitosamente' });
        }
        catch (error) {
            throw error;
        }
    }

    static async getUserById(request, reply) {
        try {
            const { id } = request.params;
            const user = await user_service_1.default.getUserById(id);
            if (!user) {
                throw new types_1.NotFoundError('Usuario');
            }
            return reply.code(200).send({
                success: true,
                data: user,
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async getUsersByRole(request, reply) {
        try {
            const { role } = request.params;
            const { page, limit, institucionId, activo, search } = request.query;

            const pagination = {};
            if (page) {
                const pageNum = parseInt(page, 10);
                if (pageNum < 1) {
                    return reply.code(400).send({
                        success: false,
                        error: 'El parÃ¡metro page debe ser mayor a 0.',
                    });
                }
                pagination.page = pageNum;
            }
            if (limit) {
                const limitNum = parseInt(limit, 10);
                if (limitNum < 1 || limitNum > 100) {
                    return reply.code(400).send({
                        success: false,
                        error: 'El parÃ¡metro limit debe ser mayor a 0 y mÃ¡ximo 100.',
                    });
                }
                pagination.limit = limitNum;
            }

            const filters = {};
            if (institucionId)
                filters.institucionId = institucionId;
            if (activo !== undefined)
                filters.activo = activo === 'true';
            if (search)
                filters.search = search;
            const result = await user_service_1.default.getUsersByRole(role, pagination, filters);
            return reply.code(200).send({
                success: true,
                data: result.data,
                pagination: result.pagination,
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async getUsersByInstitution(request, reply) {
        try {
            const { institucionId } = request.params;
            const { page, limit, rol, activo, search } = request.query;

            const pagination = {};
            if (page) {
                const pageNum = parseInt(page, 10);
                if (pageNum < 1) {
                    return reply.code(400).send({
                        success: false,
                        error: 'El parÃ¡metro page debe ser mayor a 0.',
                    });
                }
                pagination.page = pageNum;
            }
            if (limit) {
                const limitNum = parseInt(limit, 10);
                if (limitNum < 1 || limitNum > 100) {
                    return reply.code(400).send({
                        success: false,
                        error: 'El parÃ¡metro limit debe ser mayor a 0 y mÃ¡ximo 100.',
                    });
                }
                pagination.limit = limitNum;
            }

            const filters = {};
            if (rol)
                filters.rol = rol;
            if (activo !== undefined)
                filters.activo = activo === 'true';
            if (search)
                filters.search = search;
            const result = await user_service_1.default.getUsersByInstitution(institucionId, pagination, filters);
            return reply.code(200).send({
                success: true,
                data: result.data,
                pagination: result.pagination,
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async createUser(request, reply) {
        try {
            const userData = request.body;
            const invokerRole = request.user.rol;
            const result = await user_service_1.default.createUser(userData, invokerRole);
            return reply.code(201).send({
                success: true,
                data: result,
                message: 'Usuario creado exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async updateUser(request, reply) {
        try {
            const { id } = request.params;
            const userData = request.body;
            const result = await user_service_1.default.updateUser(id, userData);
            if (!result) {
                throw new types_1.NotFoundError('Usuario');
            }
            return reply.code(200).send({
                success: true,
                data: result,
                message: 'Usuario actualizado exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }

    static async deleteUser(request, reply) {
        try {
            const { id } = request.params;
            const result = await user_service_1.default.deleteUser(id);
            return reply.code(200).send({
                success: true,
                data: { deleted: result },
                message: 'Usuario eliminado exitosamente',
            });
        }
        catch (error) {
            throw error;
        }
    }
}
exports.UserController = UserController;
exports.default = UserController;

/* Fin backend\dist\controllers\user.controller.js */

/* Inicio backend\dist\index.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cors_1 = __importDefault(require("@fastify/cors"));
const formbody_1 = __importDefault(require("@fastify/formbody"));
const fastify_1 = __importDefault(require("fastify"));
const app_1 = require("./config/app");
const database_1 = require("./config/database");
const errorHandler_1 = __importDefault(require("./middleware/errorHandler"));
const routes_1 = __importDefault(require("./routes"));
const auth_service_1 = __importDefault(require("./services/auth.service"));
const fastify = (0, fastify_1.default)({
    logger: app_1.config.nodeEnv === 'development',
});
fastify.register(cors_1.default, {
    origin: true, // Permite cualquier origen
    credentials: true, // Permite el envÃ­o de cookies y credenciales
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization'],
});
fastify.register(formbody_1.default);

(0, errorHandler_1.default)(fastify);
fastify.register(routes_1.default);
const start = async () => {
    try {
        console.log('ðŸš€ Iniciando AsistApp Backend v2.0...');
        await database_1.databaseService.connect();
        await auth_service_1.default.ensureAdminUser();
        console.log('ðŸŒ Iniciando servidor...');
        await fastify.listen({
            port: app_1.config.port,
            host: app_1.config.host
        });
        console.log('âœ… Servidor corriendo en:');
        console.log(`   - Local:   http://localhost:${app_1.config.port}`);
        console.log(`   - Red:     http://192.168.20.22:${app_1.config.port}`);
        console.log('ðŸŽ¯ API lista para recibir conexiones');
        console.log('ðŸ“š DocumentaciÃ³n disponible en las URLs anteriores');
        if (app_1.config.nodeEnv === 'production') {
            setInterval(() => {
                console.log('ðŸ’“ Servidor activo...');
            }, 300000)
        }
    }
    catch (err) {
        console.error('âŒ Error al iniciar servidor:', err);
        fastify.log.error(err);
        process.exit(1);
    }
};
process.on('SIGINT', async () => {
    console.log('\nðŸ›‘ Recibida seÃ±al SIGINT, cerrando servidor...');
});
process.on('SIGTERM', async () => {
    console.log('\nðŸ›‘ Recibida seÃ±al SIGTERM, cerrando servidor...');
    await gracefulShutdown();
});
const gracefulShutdown = async () => {
    try {
        console.log('ï¿½ Cerrando conexiones...');
        await fastify.close();
        await database_1.databaseService.disconnect();
        console.log('âœ… Servidor cerrado correctamente');
        process.exit(0);
    }
    catch (error) {
        console.error('âŒ Error durante el cierre:', error);
        process.exit(1);
    }
};
process.on('uncaughtException', (err) => {
    console.error('âŒ Uncaught Exception:', err);
    process.exit(1);
});
process.on('unhandledRejection', (reason, promise) => {
    console.error('âŒ Unhandled Rejection at:', promise, 'reason:', reason);
    process.exit(1);
});
start();
exports.default = fastify;

/* Fin backend\dist\index.js */

/* Inicio backend\dist\middleware\auth.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.optionalAuthenticate = exports.authorize = exports.authenticate = void 0;
const auth_service_1 = __importDefault(require("../services/auth.service"));
const types_1 = require("../types");

const authenticate = async (request, reply) => {
    try {
        const authHeader = request.headers.authorization;
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            throw new types_1.AuthenticationError('Token de autenticaciÃ³n requerido');
        }
        const token = authHeader.substring(7)
        if (!token) {
            throw new types_1.AuthenticationError('Token de autenticaciÃ³n requerido');
        }
        const decoded = await auth_service_1.default.verifyToken(token);
        request.user = decoded;
    }
    catch (error) {
        if (error instanceof types_1.AuthenticationError) {
            return reply.code(error.statusCode).send({
                success: false,
                error: error.message,
                code: error.code,
            });
        }
        if (error instanceof Error && (error.message.includes('invÃ¡lido') || error.message.includes('expirado'))) {
            return reply.code(401).send({
                success: false,
                error: 'Token de autenticaciÃ³n invÃ¡lido',
                code: 'AUTHENTICATION_ERROR',
            });
        }
        throw error;
    }
};
exports.authenticate = authenticate;

const authorize = (allowedRoles) => {
    return async (request, reply) => {
        try {
            if (!request.user) {
                throw new types_1.AuthenticationError('Usuario no autenticado');
            }
            if (!allowedRoles.includes(request.user.rol)) {
                throw new types_1.AuthorizationError('Acceso denegado: rol insuficiente');
            }
        }
        catch (error) {
            if (error instanceof types_1.AuthenticationError || error instanceof types_1.AuthorizationError) {
                return reply.code(error.statusCode).send({
                    success: false,
                    error: error.message,
                    code: error.code,
                });
            }
            throw error;
        }
    };
};
exports.authorize = authorize;

const optionalAuthenticate = async (request, reply) => {
    try {
        const authHeader = request.headers.authorization;
        if (authHeader && authHeader.startsWith('Bearer ')) {
            const token = authHeader.substring(7);
            if (token) {
                const decoded = await auth_service_1.default.verifyToken(token);
                request.user = decoded;
            }
        }
    }
    catch (error) {
        console.warn('Error en autenticaciÃ³n opcional:', error);
    }
};
exports.optionalAuthenticate = optionalAuthenticate;
exports.default = {
    authenticate: exports.authenticate,
    authorize: exports.authorize,
    optionalAuthenticate: exports.optionalAuthenticate,
};

/* Fin backend\dist\middleware\auth.js */

/* Inicio backend\dist\middleware\errorHandler.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupErrorHandler = void 0;
const types_1 = require("../types");

const setupErrorHandler = (fastify) => {
    fastify.setErrorHandler((error, request, reply) => {
        fastify.log.error(error);
        if (error instanceof types_1.AppError) {
            return reply.code(error.statusCode).send({
                success: false,
                error: error.message,
                code: error.code,
            });
        }
        if ('validation' in error && error.validation) {
            return reply.code(400).send({
                success: false,
                error: 'Datos de entrada invÃ¡lidos',
                code: 'VALIDATION_ERROR',
                details: error.validation,
            });
        }
        if (error instanceof Error && 'code' in error && typeof error.code === 'string') {
            const prismaError = error;
            if ('code' in prismaError) {
                if (prismaError.code === 'P2003') {
                    return reply.code(400).send({
                        success: false,
                        error: 'Datos de referencia invÃ¡lidos',
                        code: 'FOREIGN_KEY_ERROR',
                    });
                }
                if (prismaError.code === 'P2002') {
                    return reply.code(409).send({
                        success: false,
                        error: 'El registro ya existe',
                        code: 'UNIQUE_CONSTRAINT_ERROR',
                    });
                }
                if (prismaError.code === 'P2025') {
                    return reply.code(404).send({
                        success: false,
                        error: 'Registro no encontrado',
                        code: 'NOT_FOUND_ERROR',
                    });
                }
                if (prismaError.code === 'P2000' || prismaError.code === 'P2001') {
                    return reply.code(400).send({
                        success: false,
                        error: 'Datos invÃ¡lidos',
                        code: 'VALIDATION_ERROR',
                    });
                }
            }
        }
        if (error.message) {
            let statusCode = 500;
            let code = 'INTERNAL_ERROR';
            if (error.message.includes('Credenciales invÃ¡lidas') || error.message.includes('Usuario inactivo')) {
                statusCode = 401;
                code = 'AUTHENTICATION_ERROR';
            }
            else if (error.message.includes('Refresh token') || error.message.includes('Token invÃ¡lido')) {
                statusCode = 401;
                code = 'AUTHENTICATION_ERROR';
            }
            else if (error.message.includes('Acceso denegado')) {
                statusCode = 403;
                code = 'AUTHORIZATION_ERROR';
            }
            else if (error.message.includes('no encontrado')) {
                statusCode = 404;
                code = 'NOT_FOUND_ERROR';
            }
            return reply.code(statusCode).send({
                success: false,
                error: error.message,
                code,
            });
        }
        return reply.code(500).send({
            success: false,
            error: 'Error interno del servidor',
            code: 'INTERNAL_ERROR',
        });
    });
    fastify.setNotFoundHandler((request, reply) => {
        return reply.code(404).send({
            success: false,
            error: 'Ruta no encontrada',
            code: 'NOT_FOUND_ERROR',
        });
    });
};
exports.setupErrorHandler = setupErrorHandler;
exports.default = exports.setupErrorHandler;

/* Fin backend\dist\middleware\errorHandler.js */

/* Inicio backend\dist\routes\admin-institucion.routes.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = adminInstitucionRoutes;
const admin_institucion_controller_1 = __importDefault(require("../controllers/admin-institucion.controller"));
const auth_1 = require("../middleware/auth");
async function adminInstitucionRoutes(fastify) {
    fastify.register(async function (adminInstitucionRoutes) {
        adminInstitucionRoutes.addHook('preHandler', auth_1.authenticate);
        adminInstitucionRoutes.addHook('preHandler', (0, auth_1.authorize)(['super_admin']));
        adminInstitucionRoutes.get('/', {
            handler: admin_institucion_controller_1.default.getAll,
        });
        adminInstitucionRoutes.get('/:id', {
            handler: admin_institucion_controller_1.default.getById,
        });
        adminInstitucionRoutes.post('/', {
            handler: admin_institucion_controller_1.default.create,
        });
        adminInstitucionRoutes.put('/:id', {
            handler: admin_institucion_controller_1.default.update,
        });
        adminInstitucionRoutes.delete('/:id', {
            handler: admin_institucion_controller_1.default.delete,
        });
    });
}

/* Fin backend\dist\routes\admin-institucion.routes.js */

/* Inicio backend\dist\routes\auth.routes.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = authRoutes;
const auth_controller_1 = __importDefault(require("../controllers/auth.controller"));
const auth_1 = require("../middleware/auth");
async function authRoutes(fastify) {
    fastify.register(async function (authRoutes) {
        authRoutes.post('/login', {
            handler: auth_controller_1.default.login,
        });
        authRoutes.post('/login-test', {
            handler: auth_controller_1.default.login,
        });
        authRoutes.get('/verify', {
            preHandler: auth_1.authenticate,
            handler: auth_controller_1.default.verify,
        });
        authRoutes.get('/instituciones', {
            preHandler: auth_1.authenticate,
            handler: auth_controller_1.default.getUserInstitutions,
        });
        authRoutes.post('/logout', {
            preHandler: auth_1.authenticate,
            handler: auth_controller_1.default.logout,
        });
        authRoutes.post('/refresh', {
            config: {
                rateLimit: {
                    max: 10,
                    timeWindow: '15 minutes',
                },
            },
            handler: auth_controller_1.default.refreshToken,
        });
    });
}

/* Fin backend\dist\routes\auth.routes.js */

/* Inicio backend\dist\routes\estudiante.routes.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = estudianteRoutes;
async function estudianteRoutes(fastify) {
    console.log('ðŸŽ“ Registrando rutas del estudiante...');
    fastify.get('/dashboard/clases-hoy', async (request, reply) => {
        return { success: true, message: 'Ruta del estudiante funcionando' };
    });
    console.log('âœ… Rutas del estudiante registradas exitosamente');
}

/* Fin backend\dist\routes\estudiante.routes.js */

/* Inicio backend\dist\routes\grupo.routes.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = grupoRoutes;
const grupo_controller_1 = __importDefault(require("../controllers/grupo.controller"));
const auth_1 = require("../middleware/auth");
async function grupoRoutes(fastify) {
    fastify.register(async function (grupoRoutes) {
        grupoRoutes.addHook('preHandler', auth_1.authenticate);
        grupoRoutes.addHook('preHandler', (0, auth_1.authorize)(['admin_institucion']));

        grupoRoutes.get('/', {
            handler: grupo_controller_1.default.getAll,
            schema: {
                description: 'Obtener todos los grupos de la instituciÃ³n',
                tags: ['Grupos'],
                querystring: {
                    type: 'object',
                    properties: {
                        page: { type: 'string', description: 'NÃºmero de pÃ¡gina' },
                        limit: { type: 'string', description: 'Elementos por pÃ¡gina' },
                        periodoId: { type: 'string', description: 'Filtrar por periodo acadÃ©mico' },
                        grado: { type: 'string', description: 'Filtrar por grado' },
                        seccion: { type: 'string', description: 'Filtrar por secciÃ³n' },
                        search: { type: 'string', description: 'Buscar por nombre' },
                    },
                },
                response: {
                    200: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            data: {
                                type: 'array',
                                items: {
                                    type: 'object',
                                    properties: {
                                        id: { type: 'string' },
                                        nombre: { type: 'string' },
                                        grado: { type: 'string' },
                                        seccion: { type: 'string', nullable: true },
                                        periodoId: { type: 'string' },
                                        institucionId: { type: 'string' },
                                        createdAt: { type: 'string' },
                                        periodoAcademico: {
                                            type: 'object',
                                            properties: {
                                                id: { type: 'string' },
                                                nombre: { type: 'string' },
                                                fechaInicio: { type: 'string' },
                                                fechaFin: { type: 'string' },
                                                activo: { type: 'boolean' },
                                            },
                                        },
                                        _count: {
                                            type: 'object',
                                            properties: {
                                                estudiantesGrupos: { type: 'number' },
                                                horarios: { type: 'number' },
                                            },
                                        },
                                    },
                                },
                            },
                            pagination: {
                                type: 'object',
                                properties: {
                                    page: { type: 'number' },
                                    limit: { type: 'number' },
                                    total: { type: 'number' },
                                    totalPages: { type: 'number' },
                                    hasNext: { type: 'boolean' },
                                    hasPrev: { type: 'boolean' },
                                },
                            },
                        },
                    },
                },
            },
        });

        grupoRoutes.get('/disponibles', {
            handler: grupo_controller_1.default.getGruposDisponibles,
            schema: {
                description: 'Obtener grupos disponibles para asignar estudiantes',
                tags: ['Grupos'],
                response: {
                    200: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            data: {
                                type: 'array',
                                items: {
                                    type: 'object',
                                    properties: {
                                        id: { type: 'string' },
                                        nombre: { type: 'string' },
                                        grado: { type: 'string' },
                                        seccion: { type: 'string', nullable: true },
                                        periodoId: { type: 'string' },
                                        institucionId: { type: 'string' },
                                        createdAt: { type: 'string' },
                                        periodoAcademico: {
                                            type: 'object',
                                            properties: {
                                                id: { type: 'string' },
                                                nombre: { type: 'string' },
                                                fechaInicio: { type: 'string' },
                                                fechaFin: { type: 'string' },
                                                activo: { type: 'boolean' },
                                            },
                                        },
                                        _count: {
                                            type: 'object',
                                            properties: {
                                                estudiantesGrupos: { type: 'number' },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            },
        });

        grupoRoutes.get('/:id', {
            handler: grupo_controller_1.default.getById,
            schema: {
                description: 'Obtener un grupo por ID',
                tags: ['Grupos'],
                params: {
                    type: 'object',
                    properties: {
                        id: { type: 'string', description: 'ID del grupo' },
                    },
                    required: ['id'],
                },
                response: {
                    200: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            data: {
                                type: 'object',
                                properties: {
                                    id: { type: 'string' },
                                    nombre: { type: 'string' },
                                    grado: { type: 'string' },
                                    seccion: { type: 'string', nullable: true },
                                    periodoId: { type: 'string' },
                                    institucionId: { type: 'string' },
                                    createdAt: { type: 'string' },
                                    periodoAcademico: {
                                        type: 'object',
                                        properties: {
                                            id: { type: 'string' },
                                            nombre: { type: 'string' },
                                            fechaInicio: { type: 'string' },
                                            fechaFin: { type: 'string' },
                                            activo: { type: 'boolean' },
                                        },
                                    },
                                    _count: {
                                        type: 'object',
                                        properties: {
                                            estudiantesGrupos: { type: 'number' },
                                            horarios: { type: 'number' },
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            },
        });

        grupoRoutes.post('/', {
            handler: grupo_controller_1.default.create,
            schema: {
                description: 'Crear un nuevo grupo',
                tags: ['Grupos'],
                body: {
                    type: 'object',
                    properties: {
                        nombre: { type: 'string', description: 'Nombre del grupo' },
                        grado: { type: 'string', description: 'Grado del grupo' },
                        seccion: { type: 'string', description: 'SecciÃ³n del grupo (opcional)' },
                        periodoId: { type: 'string', description: 'ID del periodo acadÃ©mico' },
                    },
                    required: ['nombre', 'grado', 'periodoId'],
                },
                response: {
                    201: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            data: {
                                type: 'object',
                                properties: {
                                    id: { type: 'string' },
                                    nombre: { type: 'string' },
                                    grado: { type: 'string' },
                                    seccion: { type: 'string', nullable: true },
                                    periodoId: { type: 'string' },
                                    institucionId: { type: 'string' },
                                    createdAt: { type: 'string' },
                                    periodoAcademico: {
                                        type: 'object',
                                        properties: {
                                            id: { type: 'string' },
                                            nombre: { type: 'string' },
                                            fechaInicio: { type: 'string' },
                                            fechaFin: { type: 'string' },
                                            activo: { type: 'boolean' },
                                        },
                                    },
                                    _count: {
                                        type: 'object',
                                        properties: {
                                            estudiantesGrupos: { type: 'number' },
                                            horarios: { type: 'number' },
                                        },
                                    },
                                },
                            },
                            message: { type: 'string' },
                        },
                    },
                },
            },
        });

        grupoRoutes.put('/:id', {
            handler: grupo_controller_1.default.update,
            schema: {
                description: 'Actualizar un grupo',
                tags: ['Grupos'],
                params: {
                    type: 'object',
                    properties: {
                        id: { type: 'string', description: 'ID del grupo' },
                    },
                    required: ['id'],
                },
                body: {
                    type: 'object',
                    properties: {
                        nombre: { type: 'string', description: 'Nombre del grupo' },
                        grado: { type: 'string', description: 'Grado del grupo' },
                        seccion: { type: 'string', description: 'SecciÃ³n del grupo (opcional)' },
                        periodoId: { type: 'string', description: 'ID del periodo acadÃ©mico' },
                    },
                },
                response: {
                    200: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            data: {
                                type: 'object',
                                properties: {
                                    id: { type: 'string' },
                                    nombre: { type: 'string' },
                                    grado: { type: 'string' },
                                    seccion: { type: 'string', nullable: true },
                                    periodoId: { type: 'string' },
                                    institucionId: { type: 'string' },
                                    createdAt: { type: 'string' },
                                    periodoAcademico: {
                                        type: 'object',
                                        properties: {
                                            id: { type: 'string' },
                                            nombre: { type: 'string' },
                                            fechaInicio: { type: 'string' },
                                            fechaFin: { type: 'string' },
                                            activo: { type: 'boolean' },
                                        },
                                    },
                                    _count: {
                                        type: 'object',
                                        properties: {
                                            estudiantesGrupos: { type: 'number' },
                                            horarios: { type: 'number' },
                                        },
                                    },
                                },
                            },
                            message: { type: 'string' },
                        },
                    },
                },
            },
        });

        grupoRoutes.delete('/:id', {
            handler: grupo_controller_1.default.delete,
            schema: {
                description: 'Eliminar un grupo',
                tags: ['Grupos'],
                params: {
                    type: 'object',
                    properties: {
                        id: { type: 'string', description: 'ID del grupo' },
                    },
                    required: ['id'],
                },
                response: {
                    200: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            message: { type: 'string' },
                        },
                    },
                },
            },
        });
    });
}

/* Fin backend\dist\routes\grupo.routes.js */

/* Inicio backend\dist\routes\horario.routes.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = horarioRoutes;
const horario_controller_1 = __importDefault(require("../controllers/horario.controller"));
const auth_1 = require("../middleware/auth");
async function horarioRoutes(fastify) {
    fastify.register(async function (horarioRoutes) {
        horarioRoutes.addHook('preHandler', auth_1.authenticate);
        horarioRoutes.addHook('preHandler', (0, auth_1.authorize)(['admin_institucion']));

        horarioRoutes.get('/', {
            handler: horario_controller_1.default.getAll,
            schema: {
                description: 'Obtener todos los horarios de la instituciÃ³n',
                tags: ['Horarios'],
                querystring: {
                    type: 'object',
                    properties: {
                        page: { type: 'string', description: 'NÃºmero de pÃ¡gina' },
                        limit: { type: 'string', description: 'Elementos por pÃ¡gina' },
                        grupoId: { type: 'string', description: 'Filtrar por grupo' },
                        materiaId: { type: 'string', description: 'Filtrar por materia' },
                        profesorId: { type: 'string', description: 'Filtrar por profesor' },
                        diaSemana: { type: 'string', description: 'Filtrar por dÃ­a de la semana (1-7)' },
                    },
                },
                response: {
                    200: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            data: {
                                type: 'array',
                                items: {
                                    type: 'object',
                                    properties: {
                                        id: { type: 'string' },
                                        periodoId: { type: 'string' },
                                        grupoId: { type: 'string' },
                                        materiaId: { type: 'string' },
                                        profesorId: { type: 'string', nullable: true },
                                        diaSemana: { type: 'number' },
                                        horaInicio: { type: 'string' },
                                        horaFin: { type: 'string' },
                                        institucionId: { type: 'string' },
                                        createdAt: { type: 'string' },
                                        periodoAcademico: {
                                            type: 'object',
                                            properties: {
                                                id: { type: 'string' },
                                                nombre: { type: 'string' },
                                                fechaInicio: { type: 'string' },
                                                fechaFin: { type: 'string' },
                                                activo: { type: 'boolean' },
                                            },
                                        },
                                        grupo: {
                                            type: 'object',
                                            properties: {
                                                id: { type: 'string' },
                                                nombre: { type: 'string' },
                                                grado: { type: 'string' },
                                                seccion: { type: 'string', nullable: true },
                                            },
                                        },
                                        materia: {
                                            type: 'object',
                                            properties: {
                                                id: { type: 'string' },
                                                nombre: { type: 'string' },
                                                codigo: { type: 'string', nullable: true },
                                            },
                                        },
                                        profesor: {
                                            type: 'object',
                                            nullable: true,
                                            properties: {
                                                id: { type: 'string' },
                                                nombres: { type: 'string' },
                                                apellidos: { type: 'string' },
                                            },
                                        },
                                        _count: {
                                            type: 'object',
                                            properties: {
                                                asistencias: { type: 'number' },
                                            },
                                        },
                                    },
                                },
                            },
                            pagination: {
                                type: 'object',
                                properties: {
                                    page: { type: 'number' },
                                    limit: { type: 'number' },
                                    total: { type: 'number' },
                                    totalPages: { type: 'number' },
                                    hasNext: { type: 'boolean' },
                                    hasPrev: { type: 'boolean' },
                                },
                            },
                        },
                    },
                },
            },
        });

        horarioRoutes.get('/grupo/:grupoId', {
            handler: horario_controller_1.default.getByGrupo,
            schema: {
                description: 'Obtener todos los horarios de un grupo especÃ­fico',
                tags: ['Horarios'],
                params: {
                    type: 'object',
                    properties: {
                        grupoId: { type: 'string', description: 'ID del grupo' },
                    },
                    required: ['grupoId'],
                },
                response: {
                    200: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            data: {
                                type: 'array',
                                items: {
                                    type: 'object',
                                    properties: {
                                        id: { type: 'string' },
                                        periodoId: { type: 'string' },
                                        grupoId: { type: 'string' },
                                        materiaId: { type: 'string' },
                                        profesorId: { type: 'string', nullable: true },
                                        diaSemana: { type: 'number' },
                                        horaInicio: { type: 'string' },
                                        horaFin: { type: 'string' },
                                        institucionId: { type: 'string' },
                                        createdAt: { type: 'string' },
                                        periodoAcademico: {
                                            type: 'object',
                                            properties: {
                                                id: { type: 'string' },
                                                nombre: { type: 'string' },
                                                fechaInicio: { type: 'string' },
                                                fechaFin: { type: 'string' },
                                                activo: { type: 'boolean' },
                                            },
                                        },
                                        grupo: {
                                            type: 'object',
                                            properties: {
                                                id: { type: 'string' },
                                                nombre: { type: 'string' },
                                                grado: { type: 'string' },
                                                seccion: { type: 'string', nullable: true },
                                            },
                                        },
                                        materia: {
                                            type: 'object',
                                            properties: {
                                                id: { type: 'string' },
                                                nombre: { type: 'string' },
                                                codigo: { type: 'string', nullable: true },
                                            },
                                        },
                                        profesor: {
                                            type: 'object',
                                            nullable: true,
                                            properties: {
                                                id: { type: 'string' },
                                                nombres: { type: 'string' },
                                                apellidos: { type: 'string' },
                                            },
                                        },
                                        _count: {
                                            type: 'object',
                                            properties: {
                                                asistencias: { type: 'number' },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            },
        });

        horarioRoutes.get('/:id', {
            handler: horario_controller_1.default.getById,
            schema: {
                description: 'Obtener un horario por ID',
                tags: ['Horarios'],
                params: {
                    type: 'object',
                    properties: {
                        id: { type: 'string', description: 'ID del horario' },
                    },
                    required: ['id'],
                },
                response: {
                    200: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            data: {
                                type: 'object',
                                properties: {
                                    id: { type: 'string' },
                                    periodoId: { type: 'string' },
                                    grupoId: { type: 'string' },
                                    materiaId: { type: 'string' },
                                    profesorId: { type: 'string', nullable: true },
                                    diaSemana: { type: 'number' },
                                    horaInicio: { type: 'string' },
                                    horaFin: { type: 'string' },
                                    institucionId: { type: 'string' },
                                    createdAt: { type: 'string' },
                                    periodoAcademico: {
                                        type: 'object',
                                        properties: {
                                            id: { type: 'string' },
                                            nombre: { type: 'string' },
                                            fechaInicio: { type: 'string' },
                                            fechaFin: { type: 'string' },
                                            activo: { type: 'boolean' },
                                        },
                                    },
                                    grupo: {
                                        type: 'object',
                                        properties: {
                                            id: { type: 'string' },
                                            nombre: { type: 'string' },
                                            grado: { type: 'string' },
                                            seccion: { type: 'string', nullable: true },
                                        },
                                    },
                                    materia: {
                                        type: 'object',
                                        properties: {
                                            id: { type: 'string' },
                                            nombre: { type: 'string' },
                                            codigo: { type: 'string', nullable: true },
                                        },
                                    },
                                    profesor: {
                                        type: 'object',
                                        nullable: true,
                                        properties: {
                                            id: { type: 'string' },
                                            nombres: { type: 'string' },
                                            apellidos: { type: 'string' },
                                        },
                                    },
                                    _count: {
                                        type: 'object',
                                        properties: {
                                            asistencias: { type: 'number' },
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            },
        });

        horarioRoutes.post('/', {
            handler: horario_controller_1.default.create,
            schema: {
                description: 'Crear un nuevo horario',
                tags: ['Horarios'],
                body: {
                    type: 'object',
                    properties: {
                        periodoId: { type: 'string', description: 'ID del periodo acadÃ©mico' },
                        grupoId: { type: 'string', description: 'ID del grupo' },
                        materiaId: { type: 'string', description: 'ID de la materia' },
                        profesorId: { type: 'string', description: 'ID del profesor (opcional)' },
                        diaSemana: { type: 'number', description: 'DÃ­a de la semana (1=Lunes, 7=Domingo)' },
                        horaInicio: { type: 'string', description: 'Hora de inicio (HH:MM)' },
                        horaFin: { type: 'string', description: 'Hora de fin (HH:MM)' },
                    },
                    required: ['periodoId', 'grupoId', 'materiaId', 'diaSemana', 'horaInicio', 'horaFin'],
                },
                response: {
                    201: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            data: {
                                type: 'object',
                                properties: {
                                    id: { type: 'string' },
                                    periodoId: { type: 'string' },
                                    grupoId: { type: 'string' },
                                    materiaId: { type: 'string' },
                                    profesorId: { type: 'string', nullable: true },
                                    diaSemana: { type: 'number' },
                                    horaInicio: { type: 'string' },
                                    horaFin: { type: 'string' },
                                    institucionId: { type: 'string' },
                                    createdAt: { type: 'string' },
                                    periodoAcademico: {
                                        type: 'object',
                                        properties: {
                                            id: { type: 'string' },
                                            nombre: { type: 'string' },
                                            fechaInicio: { type: 'string' },
                                            fechaFin: { type: 'string' },
                                            activo: { type: 'boolean' },
                                        },
                                    },
                                    grupo: {
                                        type: 'object',
                                        properties: {
                                            id: { type: 'string' },
                                            nombre: { type: 'string' },
                                            grado: { type: 'string' },
                                            seccion: { type: 'string', nullable: true },
                                        },
                                    },
                                    materia: {
                                        type: 'object',
                                        properties: {
                                            id: { type: 'string' },
                                            nombre: { type: 'string' },
                                            codigo: { type: 'string', nullable: true },
                                        },
                                    },
                                    profesor: {
                                        type: 'object',
                                        nullable: true,
                                        properties: {
                                            id: { type: 'string' },
                                            nombres: { type: 'string' },
                                            apellidos: { type: 'string' },
                                        },
                                    },
                                    _count: {
                                        type: 'object',
                                        properties: {
                                            asistencias: { type: 'number' },
                                        },
                                    },
                                },
                            },
                            message: { type: 'string' },
                        },
                    },
                },
            },
        });

        horarioRoutes.put('/:id', {
            handler: horario_controller_1.default.update,
            schema: {
                description: 'Actualizar un horario',
                tags: ['Horarios'],
                params: {
                    type: 'object',
                    properties: {
                        id: { type: 'string', description: 'ID del horario' },
                    },
                    required: ['id'],
                },
                body: {
                    type: 'object',
                    properties: {
                        grupoId: { type: 'string', description: 'ID del grupo' },
                        materiaId: { type: 'string', description: 'ID de la materia' },
                        profesorId: { type: 'string', description: 'ID del profesor (opcional)' },
                        diaSemana: { type: 'number', description: 'DÃ­a de la semana (1=Lunes, 7=Domingo)' },
                        horaInicio: { type: 'string', description: 'Hora de inicio (HH:MM)' },
                        horaFin: { type: 'string', description: 'Hora de fin (HH:MM)' },
                    },
                },
                response: {
                    200: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            data: {
                                type: 'object',
                                properties: {
                                    id: { type: 'string' },
                                    periodoId: { type: 'string' },
                                    grupoId: { type: 'string' },
                                    materiaId: { type: 'string' },
                                    profesorId: { type: 'string', nullable: true },
                                    diaSemana: { type: 'number' },
                                    horaInicio: { type: 'string' },
                                    horaFin: { type: 'string' },
                                    institucionId: { type: 'string' },
                                    createdAt: { type: 'string' },
                                    periodoAcademico: {
                                        type: 'object',
                                        properties: {
                                            id: { type: 'string' },
                                            nombre: { type: 'string' },
                                            fechaInicio: { type: 'string' },
                                            fechaFin: { type: 'string' },
                                            activo: { type: 'boolean' },
                                        },
                                    },
                                    grupo: {
                                        type: 'object',
                                        properties: {
                                            id: { type: 'string' },
                                            nombre: { type: 'string' },
                                            grado: { type: 'string' },
                                            seccion: { type: 'string', nullable: true },
                                        },
                                    },
                                    materia: {
                                        type: 'object',
                                        properties: {
                                            id: { type: 'string' },
                                            nombre: { type: 'string' },
                                            codigo: { type: 'string', nullable: true },
                                        },
                                    },
                                    profesor: {
                                        type: 'object',
                                        nullable: true,
                                        properties: {
                                            id: { type: 'string' },
                                            nombres: { type: 'string' },
                                            apellidos: { type: 'string' },
                                        },
                                    },
                                    _count: {
                                        type: 'object',
                                        properties: {
                                            asistencias: { type: 'number' },
                                        },
                                    },
                                },
                            },
                            message: { type: 'string' },
                        },
                    },
                },
            },
        });

        horarioRoutes.delete('/:id', {
            handler: horario_controller_1.default.delete,
            schema: {
                description: 'Eliminar un horario',
                tags: ['Horarios'],
                params: {
                    type: 'object',
                    properties: {
                        id: { type: 'string', description: 'ID del horario' },
                    },
                    required: ['id'],
                },
                response: {
                    200: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            message: { type: 'string' },
                        },
                    },
                },
            },
        });
    });
}

/* Fin backend\dist\routes\horario.routes.js */

/* Inicio backend\dist\routes\index.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = routes;
const admin_institucion_routes_1 = __importDefault(require("./admin-institucion.routes"));
const auth_routes_1 = __importDefault(require("./auth.routes"));
const estudiante_routes_1 = __importDefault(require("./estudiante.routes"));
const grupo_routes_1 = __importDefault(require("./grupo.routes"));
const horario_routes_1 = __importDefault(require("./horario.routes"));
const institucion_routes_1 = __importDefault(require("./institucion.routes"));
const institution_admin_routes_1 = __importDefault(require("./institution-admin.routes"));
const materia_routes_1 = __importDefault(require("./materia.routes"));
const profesor_routes_1 = __importDefault(require("./profesor.routes"));
const user_routes_1 = __importDefault(require("./user.routes"));
console.log('ðŸ”„ Iniciando registro de rutas...');
async function routes(fastify) {
    console.log('ðŸ“‹ Registrando rutas bÃ¡sicas...');
    fastify.get('/', async (request, reply) => {
        return {
            success: true,
            message: 'Hola Mundo desde AsistApp Backend v2.0!',
            timestamp: new Date().toISOString(),
        };
    });
    fastify.get('/health', async (request, reply) => {
        return reply.code(200).send({
            success: true,
            status: 'healthy',
            timestamp: new Date().toISOString(),
            services: {
                server: 'running'
            },
            uptime: process.uptime()
        });
    });
    await fastify.register(auth_routes_1.default, { prefix: '/auth' });
    await fastify.register(user_routes_1.default, { prefix: '/usuarios' });
    await fastify.register(admin_institucion_routes_1.default, { prefix: '/admin-institucion' });
    await fastify.register(institution_admin_routes_1.default, { prefix: '/institution-admin' });
    await fastify.register(institucion_routes_1.default, { prefix: '/instituciones' });
    await fastify.register(grupo_routes_1.default, { prefix: '/grupos' });
    await fastify.register(materia_routes_1.default, { prefix: '/materias' });
    await fastify.register(horario_routes_1.default, { prefix: '/horarios' });
    await fastify.register(profesor_routes_1.default, { prefix: '/profesores' });
    console.log('ðŸŽ“ Registrando rutas del estudiante...');
    await fastify.register(estudiante_routes_1.default, { prefix: '/estudiantes' });
    console.log('âœ… Rutas del estudiante registradas');
    console.log('ðŸŽ‰ Todas las rutas registradas exitosamente');
}

/* Fin backend\dist\routes\index.js */

/* Inicio backend\dist\routes\institucion.routes.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = institucionRoutes;
const institucion_controller_1 = __importDefault(require("../controllers/institucion.controller"));
const auth_1 = require("../middleware/auth");
async function institucionRoutes(fastify) {
    fastify.register(async function (institucionRoutes) {
        institucionRoutes.addHook('preHandler', auth_1.authenticate);
        institucionRoutes.addHook('preHandler', (0, auth_1.authorize)(['super_admin']));
        institucionRoutes.get('/', {
            handler: institucion_controller_1.default.getAll,
        });
        institucionRoutes.get('/:id', {
            handler: institucion_controller_1.default.getById,
        });

        institucionRoutes.get('/:id/admins', {
            handler: institucion_controller_1.default.getAdminsByInstitution,
        });
        institucionRoutes.post('/:id/admins', {
            handler: institucion_controller_1.default.assignAdminToInstitution,
        });
        institucionRoutes.delete('/:id/admins/:userId', {
            handler: institucion_controller_1.default.removeAdminFromInstitution,
        });
        institucionRoutes.post('/', {
            handler: institucion_controller_1.default.create,
        });
        institucionRoutes.put('/:id', {
            handler: institucion_controller_1.default.update,
        });
        institucionRoutes.delete('/:id', {
            handler: institucion_controller_1.default.delete,
        });
    });
}

/* Fin backend\dist\routes\institucion.routes.js */

/* Inicio backend\dist\routes\institution-admin.routes.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = institutionAdminRoutes;
const institution_admin_controller_1 = __importDefault(require("../controllers/institution-admin.controller"));
const auth_1 = require("../middleware/auth");

async function institutionAdminRoutes(fastify) {

    fastify.addHook('preHandler', auth_1.authenticate);
    fastify.addHook('preHandler', (0, auth_1.authorize)(['admin_institucion']));

    fastify.get('/profesores', institution_admin_controller_1.default.getAllProfesores);

    fastify.get('/profesores/:id', institution_admin_controller_1.default.getProfesorById);

    fastify.post('/profesores', institution_admin_controller_1.default.createProfesor);

    fastify.put('/profesores/:id', institution_admin_controller_1.default.updateProfesor);

    fastify.delete('/profesores/:id', institution_admin_controller_1.default.deleteProfesor);

    fastify.patch('/profesores/:id/toggle-status', institution_admin_controller_1.default.toggleProfesorStatus);

}

/* Fin backend\dist\routes\institution-admin.routes.js */

/* Inicio backend\dist\routes\materia.routes.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = materiaRoutes;
const materia_controller_1 = __importDefault(require("../controllers/materia.controller"));
const auth_1 = require("../middleware/auth");
async function materiaRoutes(fastify) {
    fastify.register(async function (materiaRoutes) {
        materiaRoutes.addHook('preHandler', auth_1.authenticate);
        materiaRoutes.addHook('preHandler', (0, auth_1.authorize)(['admin_institucion']));

        materiaRoutes.get('/', {
            handler: materia_controller_1.default.getAll,
            schema: {
                description: 'Obtener todas las materias de la instituciÃ³n',
                tags: ['Materias'],
                querystring: {
                    type: 'object',
                    properties: {
                        page: { type: 'string', description: 'NÃºmero de pÃ¡gina' },
                        limit: { type: 'string', description: 'Elementos por pÃ¡gina' },
                        search: { type: 'string', description: 'Buscar por nombre o cÃ³digo' },
                    },
                },
                response: {
                    200: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            data: {
                                type: 'array',
                                items: {
                                    type: 'object',
                                    properties: {
                                        id: { type: 'string' },
                                        nombre: { type: 'string' },
                                        codigo: { type: 'string', nullable: true },
                                        institucionId: { type: 'string' },
                                        createdAt: { type: 'string' },
                                        _count: {
                                            type: 'object',
                                            properties: {
                                                horarios: { type: 'number' },
                                            },
                                        },
                                    },
                                },
                            },
                            pagination: {
                                type: 'object',
                                properties: {
                                    page: { type: 'number' },
                                    limit: { type: 'number' },
                                    total: { type: 'number' },
                                    totalPages: { type: 'number' },
                                    hasNext: { type: 'boolean' },
                                    hasPrev: { type: 'boolean' },
                                },
                            },
                        },
                    },
                },
            },
        });

        materiaRoutes.get('/disponibles', {
            handler: materia_controller_1.default.getMateriasDisponibles,
            schema: {
                description: 'Obtener materias disponibles para crear horarios',
                tags: ['Materias'],
                response: {
                    200: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            data: {
                                type: 'array',
                                items: {
                                    type: 'object',
                                    properties: {
                                        id: { type: 'string' },
                                        nombre: { type: 'string' },
                                        codigo: { type: 'string', nullable: true },
                                        institucionId: { type: 'string' },
                                        createdAt: { type: 'string' },
                                        _count: {
                                            type: 'object',
                                            properties: {
                                                horarios: { type: 'number' },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            },
        });

        materiaRoutes.get('/:id', {
            handler: materia_controller_1.default.getById,
            schema: {
                description: 'Obtener una materia por ID',
                tags: ['Materias'],
                params: {
                    type: 'object',
                    properties: {
                        id: { type: 'string', description: 'ID de la materia' },
                    },
                    required: ['id'],
                },
                response: {
                    200: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            data: {
                                type: 'object',
                                properties: {
                                    id: { type: 'string' },
                                    nombre: { type: 'string' },
                                    codigo: { type: 'string', nullable: true },
                                    institucionId: { type: 'string' },
                                    createdAt: { type: 'string' },
                                    _count: {
                                        type: 'object',
                                        properties: {
                                            horarios: { type: 'number' },
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            },
        });

        materiaRoutes.post('/', {
            handler: materia_controller_1.default.create,
            schema: {
                description: 'Crear una nueva materia',
                tags: ['Materias'],
                body: {
                    type: 'object',
                    properties: {
                        nombre: { type: 'string', description: 'Nombre de la materia' },
                        codigo: { type: 'string', description: 'CÃ³digo de la materia (opcional)' },
                    },
                    required: ['nombre'],
                },
                response: {
                    201: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            data: {
                                type: 'object',
                                properties: {
                                    id: { type: 'string' },
                                    nombre: { type: 'string' },
                                    codigo: { type: 'string', nullable: true },
                                    institucionId: { type: 'string' },
                                    createdAt: { type: 'string' },
                                    _count: {
                                        type: 'object',
                                        properties: {
                                            horarios: { type: 'number' },
                                        },
                                    },
                                },
                            },
                            message: { type: 'string' },
                        },
                    },
                },
            },
        });

        materiaRoutes.put('/:id', {
            handler: materia_controller_1.default.update,
            schema: {
                description: 'Actualizar una materia',
                tags: ['Materias'],
                params: {
                    type: 'object',
                    properties: {
                        id: { type: 'string', description: 'ID de la materia' },
                    },
                    required: ['id'],
                },
                body: {
                    type: 'object',
                    properties: {
                        nombre: { type: 'string', description: 'Nombre de la materia' },
                        codigo: { type: 'string', description: 'CÃ³digo de la materia (opcional)' },
                    },
                },
                response: {
                    200: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            data: {
                                type: 'object',
                                properties: {
                                    id: { type: 'string' },
                                    nombre: { type: 'string' },
                                    codigo: { type: 'string', nullable: true },
                                    institucionId: { type: 'string' },
                                    createdAt: { type: 'string' },
                                    _count: {
                                        type: 'object',
                                        properties: {
                                            horarios: { type: 'number' },
                                        },
                                    },
                                },
                            },
                            message: { type: 'string' },
                        },
                    },
                },
            },
        });

        materiaRoutes.delete('/:id', {
            handler: materia_controller_1.default.delete,
            schema: {
                description: 'Eliminar una materia',
                tags: ['Materias'],
                params: {
                    type: 'object',
                    properties: {
                        id: { type: 'string', description: 'ID de la materia' },
                    },
                    required: ['id'],
                },
                response: {
                    200: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            message: { type: 'string' },
                        },
                    },
                },
            },
        });
    });
}

/* Fin backend\dist\routes\materia.routes.js */

/* Inicio backend\dist\routes\profesor.routes.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = profesorRoutes;
const profesor_controller_1 = require("../controllers/profesor.controller");
const auth_1 = require("../middleware/auth");
async function profesorRoutes(fastify) {
    fastify.register(async function (profesorRoutes) {
        profesorRoutes.addHook('preHandler', auth_1.authenticate);
        profesorRoutes.addHook('preHandler', (0, auth_1.authorize)(['profesor']));
        profesorRoutes.get('/dashboard/clases-hoy', {
            handler: profesor_controller_1.ProfesorController.getClasesDelDia,
            schema: {
                description: 'Obtiene las clases que el profesor tiene hoy',
                tags: ['Profesores - Dashboard'],
                summary: 'Clases del dÃ­a',
                security: [{ bearerAuth: [] }],
                response: {
                    200: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            data: {
                                type: 'array',
                                items: {
                                    type: 'object',
                                    properties: {
                                        id: { type: 'string' },
                                        diaSemana: { type: 'number', minimum: 1, maximum: 7 },
                                        horaInicio: { type: 'string', format: 'time' },
                                        horaFin: { type: 'string', format: 'time' },
                                        grupo: {
                                            type: 'object',
                                            properties: {
                                                id: { type: 'string' },
                                                nombre: { type: 'string' },
                                                grado: { type: 'string' },
                                                seccion: { type: 'string', nullable: true },
                                            },
                                        },
                                        materia: {
                                            type: 'object',
                                            properties: {
                                                id: { type: 'string' },
                                                nombre: { type: 'string' },
                                                codigo: { type: 'string', nullable: true },
                                            },
                                        },
                                        periodoAcademico: {
                                            type: 'object',
                                            properties: {
                                                id: { type: 'string' },
                                                nombre: { type: 'string' },
                                                activo: { type: 'boolean' },
                                            },
                                        },
                                        institucion: {
                                            type: 'object',
                                            properties: {
                                                id: { type: 'string' },
                                                nombre: { type: 'string' },
                                            },
                                        },
                                    },
                                },
                            },
                            message: { type: 'string' },
                        },
                    },
                    401: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            message: { type: 'string' },
                        },
                    },
                    403: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            message: { type: 'string' },
                        },
                    },
                    500: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            message: { type: 'string' },
                        },
                    },
                },
            },
        });
        profesorRoutes.get('/dashboard/clases/:diaSemana', {
            handler: profesor_controller_1.ProfesorController.getClasesPorDia,
            schema: {
                description: 'Obtiene las clases que el profesor tiene en un dÃ­a especÃ­fico de la semana',
                tags: ['Profesores - Dashboard'],
                summary: 'Clases por dÃ­a de la semana',
                security: [{ bearerAuth: [] }],
                params: {
                    type: 'object',
                    properties: {
                        diaSemana: {
                            type: 'string',
                            pattern: '^[1-7]$',
                            description: 'DÃ­a de la semana (1=Lunes, 2=Martes, ..., 7=Domingo)',
                        },
                    },
                    required: ['diaSemana'],
                },
                response: {
                    200: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            data: {
                                type: 'array',
                                items: {
                                    type: 'object',
                                    properties: {
                                        id: { type: 'string' },
                                        diaSemana: { type: 'number', minimum: 1, maximum: 7 },
                                        horaInicio: { type: 'string', format: 'time' },
                                        horaFin: { type: 'string', format: 'time' },
                                        grupo: {
                                            type: 'object',
                                            properties: {
                                                id: { type: 'string' },
                                                nombre: { type: 'string' },
                                                grado: { type: 'string' },
                                                seccion: { type: 'string', nullable: true },
                                            },
                                        },
                                        materia: {
                                            type: 'object',
                                            properties: {
                                                id: { type: 'string' },
                                                nombre: { type: 'string' },
                                                codigo: { type: 'string', nullable: true },
                                            },
                                        },
                                        periodoAcademico: {
                                            type: 'object',
                                            properties: {
                                                id: { type: 'string' },
                                                nombre: { type: 'string' },
                                                activo: { type: 'boolean' },
                                            },
                                        },
                                        institucion: {
                                            type: 'object',
                                            properties: {
                                                id: { type: 'string' },
                                                nombre: { type: 'string' },
                                            },
                                        },
                                    },
                                },
                            },
                            message: { type: 'string' },
                        },
                    },
                    400: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            message: { type: 'string' },
                        },
                    },
                    401: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            message: { type: 'string' },
                        },
                    },
                    403: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            message: { type: 'string' },
                        },
                    },
                    500: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            message: { type: 'string' },
                        },
                    },
                },
            },
        });
        profesorRoutes.get('/dashboard/horario-semanal', {
            handler: profesor_controller_1.ProfesorController.getHorarioSemanal,
            schema: {
                description: 'Obtiene el horario semanal completo del profesor',
                tags: ['Profesores - Dashboard'],
                summary: 'Horario semanal completo',
                security: [{ bearerAuth: [] }],
                response: {
                    200: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            data: {
                                type: 'object',
                                patternProperties: {
                                    '^[1-7]$': {
                                        type: 'array',
                                        items: {
                                            type: 'object',
                                            properties: {
                                                id: { type: 'string' },
                                                diaSemana: { type: 'number', minimum: 1, maximum: 7 },
                                                horaInicio: { type: 'string', format: 'time' },
                                                horaFin: { type: 'string', format: 'time' },
                                                grupo: {
                                                    type: 'object',
                                                    properties: {
                                                        id: { type: 'string' },
                                                        nombre: { type: 'string' },
                                                        grado: { type: 'string' },
                                                        seccion: { type: 'string', nullable: true },
                                                    },
                                                },
                                                materia: {
                                                    type: 'object',
                                                    properties: {
                                                        id: { type: 'string' },
                                                        nombre: { type: 'string' },
                                                        codigo: { type: 'string', nullable: true },
                                                    },
                                                },
                                                periodoAcademico: {
                                                    type: 'object',
                                                    properties: {
                                                        id: { type: 'string' },
                                                        nombre: { type: 'string' },
                                                        activo: { type: 'boolean' },
                                                    },
                                                },
                                                institucion: {
                                                    type: 'object',
                                                    properties: {
                                                        id: { type: 'string' },
                                                        nombre: { type: 'string' },
                                                    },
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                            message: { type: 'string' },
                        },
                    },
                    401: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            message: { type: 'string' },
                        },
                    },
                    403: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            message: { type: 'string' },
                        },
                    },
                    500: {
                        type: 'object',
                        properties: {
                            success: { type: 'boolean' },
                            message: { type: 'string' },
                        },
                    },
                },
            },
        });
    });
}

/* Fin backend\dist\routes\profesor.routes.js */

/* Inicio backend\dist\routes\user.routes.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = userRoutes;
const user_controller_1 = __importDefault(require("../controllers/user.controller"));
const auth_1 = require("../middleware/auth");

async function userRoutes(fastify) {

    fastify.addHook('preHandler', auth_1.authenticate);

    fastify.get('/', {
        preHandler: (0, auth_1.authorize)(['super_admin']),
        handler: user_controller_1.default.getAllUsers,
    });

    fastify.get('/:id', user_controller_1.default.getUserById);

    fastify.get('/rol/:role', user_controller_1.default.getUsersByRole);

    fastify.get('/institucion/:institucionId', user_controller_1.default.getUsersByInstitution);

    fastify.post('/', {
        preHandler: (0, auth_1.authorize)(['super_admin', 'admin_institucion']),
        handler: user_controller_1.default.createUser,
    });

    fastify.put('/:id', {
        preHandler: (0, auth_1.authorize)(['super_admin', 'admin_institucion']),
        handler: user_controller_1.default.updateUser,
    });

    fastify.delete('/:id', {
        preHandler: (0, auth_1.authorize)(['super_admin', 'admin_institucion']),
        handler: user_controller_1.default.deleteUser,
    });

    fastify.patch('/:id/change-password', {
        preHandler: (0, auth_1.authorize)(['super_admin', 'admin_institucion']),
        handler: user_controller_1.default.changePassword,
    });

}

/* Fin backend\dist\routes\user.routes.js */

/* Inicio backend\dist\scripts\cleanup-tokens.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const database_1 = require("../config/database");

async function cleanupExpiredRefreshTokens() {
    try {
        console.log('ðŸ§¹ Iniciando limpieza de refresh tokens expirados...');
        const prisma = database_1.databaseService.getClient();
        const result = await prisma.refreshToken.deleteMany({
            where: {
                OR: [
                    { expiresAt: { lt: new Date() } }, // Expirados
                    { revoked: true }, // Revocados
                ],
            },
        });
        console.log(`âœ… Eliminados ${result.count} refresh tokens expirados/revocados`);
        const remainingTokens = await prisma.refreshToken.count();
        console.log(`ðŸ“Š Tokens restantes en DB: ${remainingTokens}`);
    }
    catch (error) {
        console.error('âŒ Error durante la limpieza:', error);
        process.exit(1);
    }
    finally {
        await database_1.databaseService.disconnect();
    }
}
if (require.main === module) {
    cleanupExpiredRefreshTokens();
}
exports.default = cleanupExpiredRefreshTokens;

/* Fin backend\dist\scripts\cleanup-tokens.js */

/* Inicio backend\dist\services\admin-institucion.service.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AdminInstitucionService = void 0;
const bcryptjs_1 = __importDefault(require("bcryptjs"));
const database_1 = require("../config/database");
const types_1 = require("../types");
class AdminInstitucionService {

    static async getAll(pagination) {
        try {
            const page = pagination?.page || 1;
            const limit = pagination?.limit || 20;
            const skip = (page - 1) * limit;

            const total = await database_1.prisma.usuario.count({
                where: { rol: 'admin_institucion' },
            });

            const admins = await database_1.prisma.usuario.findMany({
                where: { rol: 'admin_institucion' },
                include: {
                    usuarioInstituciones: {
                        where: { activo: true },
                        include: {
                            institucion: true,
                        },
                    },
                },
                orderBy: {
                    createdAt: 'desc',
                },
                skip,
                take: limit,
            });
            const totalPages = Math.ceil(total / limit);
            const data = admins.map((admin) => ({
                id: admin.id,
                email: admin.email,
                nombres: admin.nombres,
                apellidos: admin.apellidos,
                telefono: admin.telefono,
                activo: admin.activo,
                institucion: admin.usuarioInstituciones[0] ? {
                    id: admin.usuarioInstituciones[0].institucion.id,
                    nombre: admin.usuarioInstituciones[0].institucion.nombre,
                } : { id: '', nombre: '' },
                createdAt: admin.createdAt.toISOString(),
                updatedAt: admin.updatedAt.toISOString(),
            }));
            return {
                data,
                pagination: {
                    page,
                    limit,
                    total,
                    totalPages,
                    hasNext: page < totalPages,
                    hasPrev: page > 1,
                },
            };
        }
        catch (error) {
            console.error('Error al obtener admins de instituciÃ³n:', error);
            throw error;
        }
    }

    static async getById(id) {
        try {
            const admin = await database_1.prisma.usuario.findFirst({
                where: {
                    id,
                    rol: 'admin_institucion',
                },
                include: {
                    usuarioInstituciones: {
                        where: { activo: true },
                        include: {
                            institucion: true,
                        },
                    },
                },
            });
            if (!admin) {
                return null;
            }
            return {
                id: admin.id,
                email: admin.email,
                nombres: admin.nombres,
                apellidos: admin.apellidos,
                telefono: admin.telefono,
                activo: admin.activo,
                institucion: admin.usuarioInstituciones[0] ? {
                    id: admin.usuarioInstituciones[0].institucion.id,
                    nombre: admin.usuarioInstituciones[0].institucion.nombre,
                } : { id: '', nombre: '' },
                createdAt: admin.createdAt.toISOString(),
                updatedAt: admin.updatedAt.toISOString(),
            };
        }
        catch (error) {
            console.error(`Error al obtener admin de instituciÃ³n ${id}:`, error);
            throw error;
        }
    }

    static async create(data) {
        try {

            if (!data.email || !data.password || !data.nombres || !data.apellidos || !data.institucionId) {
                throw new types_1.ValidationError('Campos requeridos faltantes');
            }

            const institucion = await database_1.prisma.institucion.findUnique({
                where: { id: data.institucionId },
            });
            if (!institucion) {
                throw new types_1.ValidationError('InstituciÃ³n no encontrada');
            }

            const existingAdmin = await database_1.prisma.usuarioInstitucion.findFirst({
                where: {
                    institucionId: data.institucionId,
                    rolEnInstitucion: 'admin',
                    activo: true,
                },
            });
            if (existingAdmin) {
                throw new types_1.ConflictError('Ya existe un admin para esta instituciÃ³n');
            }

            const emailExists = await database_1.prisma.usuario.findUnique({
                where: { email: data.email.toLowerCase() },
            });
            if (emailExists) {
                throw new types_1.ConflictError('El email ya estÃ¡ registrado');
            }

            const hashedPassword = await bcryptjs_1.default.hash(data.password, 10);

            const result = await database_1.prisma.$transaction(async (tx) => {
                const admin = await tx.usuario.create({
                    data: {
                        email: data.email.toLowerCase(),
                        passwordHash: hashedPassword,
                        nombres: data.nombres,
                        apellidos: data.apellidos,
                        rol: 'admin_institucion',
                        telefono: data.telefono,
                    },
                });
                await tx.usuarioInstitucion.create({
                    data: {
                        usuarioId: admin.id,
                        institucionId: data.institucionId,
                        rolEnInstitucion: 'admin',
                    },
                });
                return admin;
            });

            return await this.getById(result.id);
        }
        catch (error) {
            console.error('Error al crear admin de instituciÃ³n:', error);
            throw error;
        }
    }

    static async update(id, data) {
        try {

            const existingAdmin = await this.getById(id);
            if (!existingAdmin) {
                throw new types_1.ValidationError('Admin de instituciÃ³n no encontrado');
            }

            if (data.email && data.email !== existingAdmin.email) {
                const emailExists = await database_1.prisma.usuario.findUnique({
                    where: { email: data.email.toLowerCase() },
                });
                if (emailExists) {
                    throw new types_1.ConflictError('El email ya estÃ¡ registrado');
                }
            }

            await database_1.prisma.usuario.update({
                where: { id },
                data: {
                    email: data.email?.toLowerCase(),
                    nombres: data.nombres,
                    apellidos: data.apellidos,
                    telefono: data.telefono,
                    activo: data.activo,
                },
            });
            return await this.getById(id);
        }
        catch (error) {
            console.error(`Error al actualizar admin de instituciÃ³n ${id}:`, error);
            throw error;
        }
    }

    static async delete(id) {
        try {
            const existingAdmin = await this.getById(id);
            if (!existingAdmin) {
                throw new types_1.ValidationError('Admin de instituciÃ³n no encontrado');
            }
            await database_1.prisma.usuario.update({
                where: { id },
                data: { activo: false },
            });
            return true;
        }
        catch (error) {
            console.error(`Error al eliminar admin de instituciÃ³n ${id}:`, error);
            throw error;
        }
    }

    static async isAdminOfInstitution(userId, institucionId) {
        try {
            const relacion = await database_1.prisma.usuarioInstitucion.findFirst({
                where: {
                    usuarioId: userId,
                    institucionId,
                    rolEnInstitucion: 'admin',
                    activo: true,
                },
            });
            return !!relacion;
        }
        catch (error) {
            console.error(`Error al verificar admin de instituciÃ³n ${userId}:`, error);
            return false;
        }
    }
}
exports.AdminInstitucionService = AdminInstitucionService;
exports.default = AdminInstitucionService;

/* Fin backend\dist\services\admin-institucion.service.js */

/* Inicio backend\dist\services\auth.service.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthService = void 0;
const bcryptjs_1 = __importDefault(require("bcryptjs"));
const crypto_1 = __importDefault(require("crypto"));
const database_1 = require("../config/database");
const jwt_1 = __importDefault(require("../config/jwt"));
const types_1 = require("../types");
class AuthService {

    static async login(credentials) {
        const { email, password } = credentials;
        const usuario = await database_1.prisma.usuario.findUnique({
            where: { email },
            include: {
                usuarioInstituciones: {
                    include: {
                        institucion: true,
                    },
                },
            },
        });
        if (!usuario) {
            throw new types_1.AuthenticationError('Credenciales invÃ¡lidas');
        }
        if (!usuario.activo) {
            throw new types_1.AuthenticationError('Tu cuenta de usuario estÃ¡ inactiva. Contacta al administrador.');
        }
        const passwordMatch = await bcryptjs_1.default.compare(password, usuario.passwordHash);
        if (!passwordMatch) {
            throw new types_1.AuthenticationError('Credenciales invÃ¡lidas');
        }

        const institucionesActivas = (usuario.usuarioInstituciones || []).filter((ui) => ui.activo && ui.institucion?.activa);

        if (usuario.rol !== 'super_admin' && institucionesActivas.length === 0) {
            throw new types_1.AuthenticationError('No tienes acceso a ninguna instituciÃ³n activa. Contacta al administrador.');
        }
        const accessToken = jwt_1.default.signAccessToken({
            id: usuario.id,
            rol: usuario.rol,
            email: usuario.email,
            tokenVersion: usuario.tokenVersion,
        });
        const refreshToken = jwt_1.default.signRefreshToken({
            id: usuario.id,
            rol: usuario.rol,
            email: usuario.email,
            tokenVersion: usuario.tokenVersion,
        });
        try {
            const decodedRefresh = jwt_1.default.decode(refreshToken);
            const exp = decodedRefresh?.exp
            const expiresAt = exp ? new Date(exp * 1000) : new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);
            const hashed = crypto_1.default.createHash('sha256').update(refreshToken).digest('hex');
            await database_1.prisma.refreshToken.create({
                data: {
                    usuarioId: usuario.id,
                    token: hashed,
                    expiresAt,
                },
            });
        }
        catch (err) {
            console.warn('No se pudo guardar refresh token en DB:', err);
        }
        const expiresIn = 24 * 60 * 60
        return {
            accessToken,
            refreshToken,
            usuario: {
                id: usuario.id,
                nombres: usuario.nombres,
                apellidos: usuario.apellidos,
                rol: usuario.rol,
                instituciones: institucionesActivas.map((ui) => ({
                    id: ui.institucion.id,
                    nombre: ui.institucion.nombre,
                    rolEnInstitucion: ui.rolEnInstitucion,
                })),
            },
            expiresIn,
        };
    }

    static async verifyToken(token) {
        const decoded = jwt_1.default.verify(token);
        const usuario = await database_1.prisma.usuario.findUnique({
            where: { id: decoded.id },
            select: { tokenVersion: true, activo: true },
        });
        if (!usuario || !usuario.activo) {
            throw new types_1.AuthenticationError('Usuario no encontrado o inactivo');
        }
        if (usuario.tokenVersion !== decoded.tokenVersion) {
            throw new types_1.AuthenticationError('Token revocado por cambio de versiÃ³n');
        }
        return decoded;
    }

    static async refreshToken(refreshToken) {
        try {
            const decoded = jwt_1.default.verifyRefreshToken(refreshToken);
            const hashed = crypto_1.default.createHash('sha256').update(refreshToken).digest('hex');
            const tokenRecord = await database_1.prisma.refreshToken.findFirst({
                where: {
                    usuarioId: decoded.id,
                    token: hashed,
                    revoked: false,
                },
            });
            if (!tokenRecord) {
                throw new types_1.AuthenticationError('Refresh token invÃ¡lido o revocado');
            }
            if (tokenRecord.expiresAt <= new Date()) {
                await database_1.prisma.refreshToken.update({ where: { id: tokenRecord.id }, data: { revoked: true } });
                throw new types_1.AuthenticationError('Refresh token expirado');
            }
            const usuario = await database_1.prisma.usuario.findUnique({
                where: { id: decoded.id },
                include: {
                    usuarioInstituciones: {
                        include: {
                            institucion: true,
                        },
                    },
                },
            });
            if (!usuario || !usuario.activo) {
                throw new types_1.AuthenticationError('Usuario no encontrado o inactivo');
            }
            if (usuario.tokenVersion !== decoded.tokenVersion) {
                throw new types_1.AuthenticationError('Refresh token revocado por cambio de versiÃ³n');
            }
            await database_1.prisma.refreshToken.update({ where: { id: tokenRecord.id }, data: { revoked: true } });

            const institucionesActivas = (usuario.usuarioInstituciones || []).filter((ui) => ui.activo && ui.institucion?.activa);
            const newAccessToken = jwt_1.default.signAccessToken({
                id: usuario.id,
                rol: usuario.rol,
                email: usuario.email,
                tokenVersion: usuario.tokenVersion,
            });
            const newRefreshToken = jwt_1.default.signRefreshToken({
                id: usuario.id,
                rol: usuario.rol,
                email: usuario.email,
                tokenVersion: usuario.tokenVersion,
            });
            try {
                const decodedNew = jwt_1.default.decode(newRefreshToken);
                const exp = decodedNew?.exp;
                const expiresAt = exp ? new Date(exp * 1000) : new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);
                const hashedNew = crypto_1.default.createHash('sha256').update(newRefreshToken).digest('hex');
                await database_1.prisma.refreshToken.create({
                    data: {
                        usuarioId: usuario.id,
                        token: hashedNew,
                        expiresAt,
                    },
                });
            }
            catch (err) {
                console.warn('No se pudo guardar nuevo refresh token en DB:', err);
            }
            const expiresIn = 24 * 60 * 60
            return {
                accessToken: newAccessToken,
                refreshToken: newRefreshToken,
                expiresIn,
            };
        }
        catch (error) {
            if (error instanceof types_1.AuthenticationError) {
                throw error;
            }
            throw new types_1.AuthenticationError(error instanceof Error ? error.message : 'Refresh token invÃ¡lido');
        }
    }

    static async revokeRefreshTokens(usuarioId, refreshToken) {
        if (refreshToken) {
            const hashed = crypto_1.default.createHash('sha256').update(refreshToken).digest('hex');
            await database_1.prisma.refreshToken.updateMany({ where: { usuarioId, token: hashed }, data: { revoked: true } });
            return;
        }
        await database_1.prisma.refreshToken.updateMany({ where: { usuarioId, revoked: false }, data: { revoked: true } });
    }

    static async revokeAllUserTokens(usuarioId) {
        await database_1.prisma.usuario.update({
            where: { id: usuarioId },
            data: { tokenVersion: { increment: 1 } },
        });
    }

    static async hashPassword(password) {
        const saltRounds = 10;
        return bcryptjs_1.default.hash(password, saltRounds);
    }

    static async ensureAdminUser() {
        try {
            console.log('ðŸ” Verificando usuario administrador...');
            const adminExists = await database_1.prisma.usuario.findUnique({
                where: { email: 'admin@asistapp.com' }
            });
            if (!adminExists) {
                console.log('âš ï¸ No se encontrÃ³ usuario administrador. Creando usuario por defecto...');
                const adminPassword = await this.hashPassword('pollo');
                const admin = await database_1.prisma.usuario.create({
                    data: {
                        email: 'admin@asistapp.com',
                        passwordHash: adminPassword,
                        nombres: 'Administrador',
                        apellidos: 'Sistema',
                        rol: 'super_admin',
                        activo: true,
                    },
                });
                console.log('âœ… Usuario administrador creado exitosamente:', admin.email);
            }
            else {
                console.log('âœ… Usuario administrador ya existe:', adminExists.email);
            }
        }
        catch (error) {
            console.error('âŒ Error al verificar/crear usuario administrador:', error);
            throw error;
        }
    }
}
exports.AuthService = AuthService;
exports.default = AuthService;

/* Fin backend\dist\services\auth.service.js */

/* Inicio backend\dist\services\grupo.service.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GrupoService = void 0;
const database_1 = require("../config/database");
const types_1 = require("../types");
class GrupoService {

    static async getAllGruposByInstitucion(institucionId, pagination, filters) {
        try {

            const page = pagination?.page || 1;
            const limit = pagination?.limit || 10;
            if (page < 1 || limit < 1 || limit > 100) {
                throw new types_1.ValidationError('Los parÃ¡metros de paginaciÃ³n deben ser mayores a 0. El lÃ­mite mÃ¡ximo es 100.');
            }
            const skip = (page - 1) * limit;

            const where = {
                institucionId: institucionId,
            };
            if (filters?.periodoId) {
                where.periodoId = filters.periodoId;
            }
            if (filters?.grado) {
                where.grado = filters.grado;
            }
            if (filters?.seccion) {
                where.seccion = filters.seccion;
            }
            if (filters?.search) {
                where.nombre = {
                    contains: filters.search,
                    mode: 'insensitive',
                };
            }

            const total = await database_1.prisma.grupo.count({ where });

            const grupos = await database_1.prisma.grupo.findMany({
                where,
                skip,
                take: limit,
                orderBy: [
                    { grado: 'asc' },
                    { seccion: 'asc' },
                    { nombre: 'asc' },
                ],
                include: {
                    periodoAcademico: {
                        select: {
                            id: true,
                            nombre: true,
                            fechaInicio: true,
                            fechaFin: true,
                            activo: true,
                        },
                    },
                    _count: {
                        select: {
                            estudiantesGrupos: true,
                            horarios: true,
                        },
                    },
                },
            });
            const totalPages = Math.ceil(total / limit);
            return {
                data: grupos.map((grupo) => ({
                    id: grupo.id,
                    nombre: grupo.nombre,
                    grado: grupo.grado,
                    seccion: grupo.seccion,
                    periodoId: grupo.periodoId,
                    institucionId: grupo.institucionId,
                    createdAt: grupo.createdAt.toISOString(),
                    periodoAcademico: {
                        id: grupo.periodoAcademico.id,
                        nombre: grupo.periodoAcademico.nombre,
                        fechaInicio: grupo.periodoAcademico.fechaInicio.toISOString(),
                        fechaFin: grupo.periodoAcademico.fechaFin.toISOString(),
                        activo: grupo.periodoAcademico.activo,
                    },
                    _count: grupo._count,
                })),
                pagination: {
                    page,
                    limit,
                    total,
                    totalPages,
                    hasNext: page < totalPages,
                    hasPrev: page > 1,
                },
            };
        }
        catch (error) {
            console.error('Error al obtener grupos:', error);
            if (error instanceof types_1.ValidationError) {
                throw error;
            }
            throw new Error('Error al obtener los grupos');
        }
    }

    static async getGrupoById(id) {
        try {
            const grupo = await database_1.prisma.grupo.findUnique({
                where: { id },
                include: {
                    periodoAcademico: {
                        select: {
                            id: true,
                            nombre: true,
                            fechaInicio: true,
                            fechaFin: true,
                            activo: true,
                        },
                    },
                    _count: {
                        select: {
                            estudiantesGrupos: true,
                            horarios: true,
                        },
                    },
                },
            });
            if (!grupo) {
                return null;
            }
            return {
                id: grupo.id,
                nombre: grupo.nombre,
                grado: grupo.grado,
                seccion: grupo.seccion,
                periodoId: grupo.periodoId,
                institucionId: grupo.institucionId,
                createdAt: grupo.createdAt.toISOString(),
                periodoAcademico: {
                    id: grupo.periodoAcademico.id,
                    nombre: grupo.periodoAcademico.nombre,
                    fechaInicio: grupo.periodoAcademico.fechaInicio.toISOString(),
                    fechaFin: grupo.periodoAcademico.fechaFin.toISOString(),
                    activo: grupo.periodoAcademico.activo,
                },
                _count: grupo._count,
            };
        }
        catch (error) {
            console.error('Error al obtener grupo:', error);
            throw new Error('Error al obtener el grupo');
        }
    }

    static async createGrupo(data) {
        try {

            if (!data.nombre || data.nombre.trim() === '') {
                throw new types_1.ValidationError('El nombre del grupo es requerido');
            }
            if (!data.grado || data.grado.trim() === '') {
                throw new types_1.ValidationError('El grado del grupo es requerido');
            }

            const periodo = await database_1.prisma.periodoAcademico.findFirst({
                where: {
                    id: data.periodoId,
                    institucionId: data.institucionId,
                },
            });
            if (!periodo) {
                throw new types_1.ValidationError('El periodo acadÃ©mico no existe o no pertenece a esta instituciÃ³n');
            }

            const existingGrupo = await database_1.prisma.grupo.findFirst({
                where: {
                    nombre: data.nombre.trim(),
                    periodoId: data.periodoId,
                    institucionId: data.institucionId,
                },
            });
            if (existingGrupo) {
                throw new types_1.ConflictError('Ya existe un grupo con este nombre en el periodo acadÃ©mico seleccionado');
            }
            const grupo = await database_1.prisma.grupo.create({
                data: {
                    nombre: data.nombre.trim(),
                    grado: data.grado.trim(),
                    seccion: data.seccion?.trim() || null,
                    periodoId: data.periodoId,
                    institucionId: data.institucionId,
                },
                include: {
                    periodoAcademico: {
                        select: {
                            id: true,
                            nombre: true,
                            fechaInicio: true,
                            fechaFin: true,
                            activo: true,
                        },
                    },
                    _count: {
                        select: {
                            estudiantesGrupos: true,
                            horarios: true,
                        },
                    },
                },
            });
            return {
                id: grupo.id,
                nombre: grupo.nombre,
                grado: grupo.grado,
                seccion: grupo.seccion,
                periodoId: grupo.periodoId,
                institucionId: grupo.institucionId,
                createdAt: grupo.createdAt.toISOString(),
                periodoAcademico: {
                    id: grupo.periodoAcademico.id,
                    nombre: grupo.periodoAcademico.nombre,
                    fechaInicio: grupo.periodoAcademico.fechaInicio.toISOString(),
                    fechaFin: grupo.periodoAcademico.fechaFin.toISOString(),
                    activo: grupo.periodoAcademico.activo,
                },
                _count: grupo._count,
            };
        }
        catch (error) {
            console.error('Error al crear grupo:', error);
            if (error instanceof types_1.ValidationError || error instanceof types_1.ConflictError) {
                throw error;
            }
            throw new Error('Error al crear el grupo');
        }
    }

    static async updateGrupo(id, data) {
        try {

            const existingGrupo = await database_1.prisma.grupo.findUnique({
                where: { id },
            });
            if (!existingGrupo) {
                throw new types_1.NotFoundError('Grupo');
            }

            if (data.periodoId && data.periodoId !== existingGrupo.periodoId) {
                const periodo = await database_1.prisma.periodoAcademico.findFirst({
                    where: {
                        id: data.periodoId,
                        institucionId: existingGrupo.institucionId,
                    },
                });
                if (!periodo) {
                    throw new types_1.ValidationError('El periodo acadÃ©mico no existe o no pertenece a esta instituciÃ³n');
                }
            }

            if (data.nombre && data.nombre !== existingGrupo.nombre) {
                const periodoId = data.periodoId || existingGrupo.periodoId;
                const existingGrupoWithName = await database_1.prisma.grupo.findFirst({
                    where: {
                        nombre: data.nombre,
                        periodoId: periodoId,
                        institucionId: existingGrupo.institucionId,
                        id: { not: id },
                    },
                });
                if (existingGrupoWithName) {
                    throw new types_1.ConflictError('Ya existe un grupo con este nombre en el periodo acadÃ©mico seleccionado');
                }
            }
            const grupo = await database_1.prisma.grupo.update({
                where: { id },
                data: {
                    nombre: data.nombre,
                    grado: data.grado,
                    seccion: data.seccion,
                    periodoId: data.periodoId,
                },
                include: {
                    periodoAcademico: {
                        select: {
                            id: true,
                            nombre: true,
                            fechaInicio: true,
                            fechaFin: true,
                            activo: true,
                        },
                    },
                    _count: {
                        select: {
                            estudiantesGrupos: true,
                            horarios: true,
                        },
                    },
                },
            });
            return {
                id: grupo.id,
                nombre: grupo.nombre,
                grado: grupo.grado,
                seccion: grupo.seccion,
                periodoId: grupo.periodoId,
                institucionId: grupo.institucionId,
                createdAt: grupo.createdAt.toISOString(),
                periodoAcademico: {
                    id: grupo.periodoAcademico.id,
                    nombre: grupo.periodoAcademico.nombre,
                    fechaInicio: grupo.periodoAcademico.fechaInicio.toISOString(),
                    fechaFin: grupo.periodoAcademico.fechaFin.toISOString(),
                    activo: grupo.periodoAcademico.activo,
                },
                _count: grupo._count,
            };
        }
        catch (error) {
            console.error('Error al actualizar grupo:', error);
            if (error instanceof types_1.NotFoundError || error instanceof types_1.ValidationError || error instanceof types_1.ConflictError) {
                throw error;
            }
            throw new Error('Error al actualizar el grupo');
        }
    }

    static async deleteGrupo(id) {
        try {

            const existingGrupo = await database_1.prisma.grupo.findUnique({
                where: { id },
                include: {
                    _count: {
                        select: {
                            estudiantesGrupos: true,
                            horarios: true,
                            asistencias: true,
                        },
                    },
                },
            });
            if (!existingGrupo) {
                throw new types_1.NotFoundError('Grupo');
            }

            if (existingGrupo._count.estudiantesGrupos > 0) {
                throw new types_1.ValidationError('No se puede eliminar el grupo porque tiene estudiantes asignados');
            }

            if (existingGrupo._count.horarios > 0) {
                throw new types_1.ValidationError('No se puede eliminar el grupo porque tiene horarios asignados');
            }

            if (existingGrupo._count.asistencias > 0) {
                throw new types_1.ValidationError('No se puede eliminar el grupo porque tiene asistencias registradas');
            }
            await database_1.prisma.grupo.delete({
                where: { id },
            });
            return true;
        }
        catch (error) {
            console.error('Error al eliminar grupo:', error);
            if (error instanceof types_1.NotFoundError || error instanceof types_1.ValidationError) {
                throw error;
            }
            throw new Error('Error al eliminar el grupo');
        }
    }

    static async getGruposDisponibles(institucionId) {
        try {
            const grupos = await database_1.prisma.grupo.findMany({
                where: {
                    institucionId: institucionId,
                    periodoAcademico: {
                        activo: true,
                    },
                },
                orderBy: [
                    { grado: 'asc' },
                    { seccion: 'asc' },
                    { nombre: 'asc' },
                ],
                include: {
                    periodoAcademico: {
                        select: {
                            id: true,
                            nombre: true,
                            fechaInicio: true,
                            fechaFin: true,
                            activo: true,
                        },
                    },
                    _count: {
                        select: {
                            estudiantesGrupos: true,
                            horarios: true,
                        },
                    },
                },
            });
            return grupos.map((grupo) => ({
                id: grupo.id,
                nombre: grupo.nombre,
                grado: grupo.grado,
                seccion: grupo.seccion,
                periodoId: grupo.periodoId,
                institucionId: grupo.institucionId,
                createdAt: grupo.createdAt.toISOString(),
                periodoAcademico: {
                    id: grupo.periodoAcademico.id,
                    nombre: grupo.periodoAcademico.nombre,
                    fechaInicio: grupo.periodoAcademico.fechaInicio.toISOString(),
                    fechaFin: grupo.periodoAcademico.fechaFin.toISOString(),
                    activo: grupo.periodoAcademico.activo,
                },
                _count: grupo._count,
            }));
        }
        catch (error) {
            console.error('Error al obtener grupos disponibles:', error);
            throw new Error('Error al obtener los grupos disponibles');
        }
    }
}
exports.GrupoService = GrupoService;
exports.default = GrupoService;

/* Fin backend\dist\services\grupo.service.js */

/* Inicio backend\dist\services\horario.service.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HorarioService = void 0;
const database_1 = require("../config/database");
const types_1 = require("../types");
class HorarioService {

    static async getAllHorariosByInstitucion(institucionId, pagination, filters) {
        try {

            const page = pagination?.page || 1;
            const limit = pagination?.limit || 10;
            if (page < 1 || limit < 1 || limit > 100) {
                throw new types_1.ValidationError('Los parÃ¡metros de paginaciÃ³n deben ser mayores a 0. El lÃ­mite mÃ¡ximo es 100.');
            }
            const skip = (page - 1) * limit;

            const where = {
                institucionId: institucionId,
            };
            if (filters?.grupoId) {
                where.grupoId = filters.grupoId;
            }
            if (filters?.materiaId) {
                where.materiaId = filters.materiaId;
            }
            if (filters?.profesorId) {
                where.profesorId = filters.profesorId;
            }
            if (filters?.diaSemana !== undefined) {
                where.diaSemana = filters.diaSemana;
            }

            const total = await database_1.prisma.horario.count({ where });

            const horarios = await database_1.prisma.horario.findMany({
                where,
                skip,
                take: limit,
                orderBy: [
                    { diaSemana: 'asc' },
                    { horaInicio: 'asc' },
                    { grupo: { nombre: 'asc' } },
                ],
                include: {
                    periodoAcademico: {
                        select: {
                            id: true,
                            nombre: true,
                            fechaInicio: true,
                            fechaFin: true,
                            activo: true,
                        },
                    },
                    grupo: {
                        select: {
                            id: true,
                            nombre: true,
                            grado: true,
                            seccion: true,
                        },
                    },
                    materia: {
                        select: {
                            id: true,
                            nombre: true,
                            codigo: true,
                        },
                    },
                    profesor: {
                        select: {
                            id: true,
                            nombres: true,
                            apellidos: true,
                        },
                    },
                    _count: {
                        select: {
                            asistencias: true,
                        },
                    },
                },
            });
            const totalPages = Math.ceil(total / limit);
            return {
                data: horarios.map((horario) => ({
                    id: horario.id,
                    periodoId: horario.periodoId,
                    grupoId: horario.grupoId,
                    materiaId: horario.materiaId,
                    profesorId: horario.profesorId,
                    diaSemana: horario.diaSemana,
                    horaInicio: horario.horaInicio,
                    horaFin: horario.horaFin,
                    institucionId: horario.institucionId,
                    createdAt: horario.createdAt.toISOString(),
                    periodoAcademico: {
                        id: horario.periodoAcademico.id,
                        nombre: horario.periodoAcademico.nombre,
                        fechaInicio: horario.periodoAcademico.fechaInicio.toISOString(),
                        fechaFin: horario.periodoAcademico.fechaFin.toISOString(),
                        activo: horario.periodoAcademico.activo,
                    },
                    grupo: {
                        id: horario.grupo.id,
                        nombre: horario.grupo.nombre,
                        grado: horario.grupo.grado,
                        seccion: horario.grupo.seccion,
                    },
                    materia: {
                        id: horario.materia.id,
                        nombre: horario.materia.nombre,
                        codigo: horario.materia.codigo,
                    },
                    profesor: horario.profesor ? {
                        id: horario.profesor.id,
                        nombres: horario.profesor.nombres,
                        apellidos: horario.profesor.apellidos,
                    } : null,
                    _count: horario._count,
                })),
                pagination: {
                    page,
                    limit,
                    total,
                    totalPages,
                    hasNext: page < totalPages,
                    hasPrev: page > 1,
                },
            };
        }
        catch (error) {
            console.error('Error al obtener horarios:', error);
            if (error instanceof types_1.ValidationError) {
                throw error;
            }
            throw new Error('Error al obtener los horarios');
        }
    }

    static async getHorariosByGrupo(grupoId) {
        try {
            const horarios = await database_1.prisma.horario.findMany({
                where: { grupoId },
                orderBy: [
                    { diaSemana: 'asc' },
                    { horaInicio: 'asc' },
                ],
                include: {
                    periodoAcademico: {
                        select: {
                            id: true,
                            nombre: true,
                            fechaInicio: true,
                            fechaFin: true,
                            activo: true,
                        },
                    },
                    grupo: {
                        select: {
                            id: true,
                            nombre: true,
                            grado: true,
                            seccion: true,
                        },
                    },
                    materia: {
                        select: {
                            id: true,
                            nombre: true,
                            codigo: true,
                        },
                    },
                    profesor: {
                        select: {
                            id: true,
                            nombres: true,
                            apellidos: true,
                        },
                    },
                    _count: {
                        select: {
                            asistencias: true,
                        },
                    },
                },
            });
            return horarios.map((horario) => ({
                id: horario.id,
                periodoId: horario.periodoId,
                grupoId: horario.grupoId,
                materiaId: horario.materiaId,
                profesorId: horario.profesorId,
                diaSemana: horario.diaSemana,
                horaInicio: horario.horaInicio,
                horaFin: horario.horaFin,
                institucionId: horario.institucionId,
                createdAt: horario.createdAt.toISOString(),
                periodoAcademico: {
                    id: horario.periodoAcademico.id,
                    nombre: horario.periodoAcademico.nombre,
                    fechaInicio: horario.periodoAcademico.fechaInicio.toISOString(),
                    fechaFin: horario.periodoAcademico.fechaFin.toISOString(),
                    activo: horario.periodoAcademico.activo,
                },
                grupo: {
                    id: horario.grupo.id,
                    nombre: horario.grupo.nombre,
                    grado: horario.grupo.grado,
                    seccion: horario.grupo.seccion,
                },
                materia: {
                    id: horario.materia.id,
                    nombre: horario.materia.nombre,
                    codigo: horario.materia.codigo,
                },
                profesor: horario.profesor ? {
                    id: horario.profesor.id,
                    nombres: horario.profesor.nombres,
                    apellidos: horario.profesor.apellidos,
                } : null,
                _count: horario._count,
            }));
        }
        catch (error) {
            console.error('Error al obtener horarios del grupo:', error);
            throw new Error('Error al obtener los horarios del grupo');
        }
    }

    static async getHorarioById(id) {
        try {
            const horario = await database_1.prisma.horario.findUnique({
                where: { id },
                include: {
                    periodoAcademico: {
                        select: {
                            id: true,
                            nombre: true,
                            fechaInicio: true,
                            fechaFin: true,
                            activo: true,
                        },
                    },
                    grupo: {
                        select: {
                            id: true,
                            nombre: true,
                            grado: true,
                            seccion: true,
                        },
                    },
                    materia: {
                        select: {
                            id: true,
                            nombre: true,
                            codigo: true,
                        },
                    },
                    profesor: {
                        select: {
                            id: true,
                            nombres: true,
                            apellidos: true,
                        },
                    },
                    _count: {
                        select: {
                            asistencias: true,
                        },
                    },
                },
            });
            if (!horario) {
                return null;
            }
            return {
                id: horario.id,
                periodoId: horario.periodoId,
                grupoId: horario.grupoId,
                materiaId: horario.materiaId,
                profesorId: horario.profesorId,
                diaSemana: horario.diaSemana,
                horaInicio: horario.horaInicio,
                horaFin: horario.horaFin,
                institucionId: horario.institucionId,
                createdAt: horario.createdAt.toISOString(),
                periodoAcademico: {
                    id: horario.periodoAcademico.id,
                    nombre: horario.periodoAcademico.nombre,
                    fechaInicio: horario.periodoAcademico.fechaInicio.toISOString(),
                    fechaFin: horario.periodoAcademico.fechaFin.toISOString(),
                    activo: horario.periodoAcademico.activo,
                },
                grupo: {
                    id: horario.grupo.id,
                    nombre: horario.grupo.nombre,
                    grado: horario.grupo.grado,
                    seccion: horario.grupo.seccion,
                },
                materia: {
                    id: horario.materia.id,
                    nombre: horario.materia.nombre,
                    codigo: horario.materia.codigo,
                },
                profesor: horario.profesor ? {
                    id: horario.profesor.id,
                    nombres: horario.profesor.nombres,
                    apellidos: horario.profesor.apellidos,
                } : null,
                _count: horario._count,
            };
        }
        catch (error) {
            console.error('Error al obtener horario:', error);
            throw new Error('Error al obtener el horario');
        }
    }

    static async validateHorarioConflict(grupoId, profesorId, diaSemana, horaInicio, horaFin, excludeId) {

        const timeRegex = /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/;
        if (!timeRegex.test(horaInicio) || !timeRegex.test(horaFin)) {
            throw new types_1.ValidationError('El formato de hora debe ser HH:MM');
        }

        if (horaInicio >= horaFin) {
            throw new types_1.ValidationError('La hora de inicio debe ser anterior a la hora de fin');
        }

        if (diaSemana < 1 || diaSemana > 7) {
            throw new types_1.ValidationError('El dÃ­a de la semana debe estar entre 1 (Lunes) y 7 (Domingo)');
        }

        const grupoConflicts = await database_1.prisma.horario.findMany({
            where: {
                grupoId: grupoId,
                diaSemana: diaSemana,
                OR: [
                    {
                        AND: [
                            { horaInicio: { lte: horaInicio } },
                            { horaFin: { gt: horaInicio } }
                        ]
                    },
                    {
                        AND: [
                            { horaInicio: { lt: horaFin } },
                            { horaFin: { gte: horaFin } }
                        ]
                    },
                    {
                        AND: [
                            { horaInicio: { gte: horaInicio } },
                            { horaFin: { lte: horaFin } }
                        ]
                    }
                ],
                ...(excludeId && { id: { not: excludeId } })
            },
        });
        if (grupoConflicts.length > 0) {
            throw new types_1.ConflictError('El grupo ya tiene una clase programada en este horario');
        }

        if (profesorId) {
            const profesorConflicts = await database_1.prisma.horario.findMany({
                where: {
                    profesorId: profesorId,
                    diaSemana: diaSemana,
                    OR: [
                        {
                            AND: [
                                { horaInicio: { lte: horaInicio } },
                                { horaFin: { gt: horaInicio } }
                            ]
                        },
                        {
                            AND: [
                                { horaInicio: { lt: horaFin } },
                                { horaFin: { gte: horaFin } }
                            ]
                        },
                        {
                            AND: [
                                { horaInicio: { gte: horaInicio } },
                                { horaFin: { lte: horaFin } }
                            ]
                        }
                    ],
                    ...(excludeId && { id: { not: excludeId } })
                },
            });
            if (profesorConflicts.length > 0) {
                throw new types_1.ConflictError('El profesor ya tiene una clase programada en este horario');
            }
        }
    }

    static async createHorario(data) {
        try {

            const periodo = await database_1.prisma.periodoAcademico.findFirst({
                where: {
                    id: data.periodoId,
                    institucionId: data.institucionId,
                },
            });
            if (!periodo) {
                throw new types_1.ValidationError('El periodo acadÃ©mico no existe o no pertenece a esta instituciÃ³n');
            }

            const grupo = await database_1.prisma.grupo.findFirst({
                where: {
                    id: data.grupoId,
                    institucionId: data.institucionId,
                    periodoId: data.periodoId,
                },
            });
            if (!grupo) {
                throw new types_1.ValidationError('El grupo no existe o no pertenece a esta instituciÃ³n y periodo');
            }

            const materia = await database_1.prisma.materia.findFirst({
                where: {
                    id: data.materiaId,
                    institucionId: data.institucionId,
                },
            });
            if (!materia) {
                throw new types_1.ValidationError('La materia no existe o no pertenece a esta instituciÃ³n');
            }

            if (data.profesorId) {
                const profesor = await database_1.prisma.usuario.findFirst({
                    where: {
                        id: data.profesorId,
                        rol: 'profesor',
                        usuarioInstituciones: {
                            some: {
                                institucionId: data.institucionId,
                                activo: true,
                            },
                        },
                    },
                });
                if (!profesor) {
                    throw new types_1.ValidationError('El profesor no existe o no pertenece a esta instituciÃ³n');
                }
            }

            await this.validateHorarioConflict(data.grupoId, data.profesorId || null, data.diaSemana, data.horaInicio, data.horaFin);
            const horario = await database_1.prisma.horario.create({
                data: {
                    periodoId: data.periodoId,
                    grupoId: data.grupoId,
                    materiaId: data.materiaId,
                    profesorId: data.profesorId,
                    diaSemana: data.diaSemana,
                    horaInicio: data.horaInicio,
                    horaFin: data.horaFin,
                    institucionId: data.institucionId,
                },
                include: {
                    periodoAcademico: {
                        select: {
                            id: true,
                            nombre: true,
                            fechaInicio: true,
                            fechaFin: true,
                            activo: true,
                        },
                    },
                    grupo: {
                        select: {
                            id: true,
                            nombre: true,
                            grado: true,
                            seccion: true,
                        },
                    },
                    materia: {
                        select: {
                            id: true,
                            nombre: true,
                            codigo: true,
                        },
                    },
                    profesor: {
                        select: {
                            id: true,
                            nombres: true,
                            apellidos: true,
                        },
                    },
                    _count: {
                        select: {
                            asistencias: true,
                        },
                    },
                },
            });
            return {
                id: horario.id,
                periodoId: horario.periodoId,
                grupoId: horario.grupoId,
                materiaId: horario.materiaId,
                profesorId: horario.profesorId,
                diaSemana: horario.diaSemana,
                horaInicio: horario.horaInicio,
                horaFin: horario.horaFin,
                institucionId: horario.institucionId,
                createdAt: horario.createdAt.toISOString(),
                periodoAcademico: {
                    id: horario.periodoAcademico.id,
                    nombre: horario.periodoAcademico.nombre,
                    fechaInicio: horario.periodoAcademico.fechaInicio.toISOString(),
                    fechaFin: horario.periodoAcademico.fechaFin.toISOString(),
                    activo: horario.periodoAcademico.activo,
                },
                grupo: {
                    id: horario.grupo.id,
                    nombre: horario.grupo.nombre,
                    grado: horario.grupo.grado,
                    seccion: horario.grupo.seccion,
                },
                materia: {
                    id: horario.materia.id,
                    nombre: horario.materia.nombre,
                    codigo: horario.materia.codigo,
                },
                profesor: horario.profesor ? {
                    id: horario.profesor.id,
                    nombres: horario.profesor.nombres,
                    apellidos: horario.profesor.apellidos,
                } : null,
                _count: horario._count,
            };
        }
        catch (error) {
            console.error('Error al crear horario:', error);
            if (error instanceof types_1.ValidationError || error instanceof types_1.ConflictError) {
                throw error;
            }
            throw new Error('Error al crear el horario');
        }
    }

    static async updateHorario(id, data) {
        try {

            const existingHorario = await database_1.prisma.horario.findUnique({
                where: { id },
            });
            if (!existingHorario) {
                throw new types_1.NotFoundError('Horario');
            }

            const grupoId = data.grupoId || existingHorario.grupoId;
            const profesorId = data.profesorId !== undefined ? data.profesorId : existingHorario.profesorId;
            const diaSemana = data.diaSemana !== undefined ? data.diaSemana : existingHorario.diaSemana;
            const horaInicio = data.horaInicio || existingHorario.horaInicio;
            const horaFin = data.horaFin || existingHorario.horaFin;

            if (data.grupoId && data.grupoId !== existingHorario.grupoId) {
                const grupo = await database_1.prisma.grupo.findFirst({
                    where: {
                        id: data.grupoId,
                        institucionId: existingHorario.institucionId,
                        periodoId: existingHorario.periodoId,
                    },
                });
                if (!grupo) {
                    throw new types_1.ValidationError('El grupo no existe o no pertenece a esta instituciÃ³n y periodo');
                }
            }

            if (data.materiaId && data.materiaId !== existingHorario.materiaId) {
                const materia = await database_1.prisma.materia.findFirst({
                    where: {
                        id: data.materiaId,
                        institucionId: existingHorario.institucionId,
                    },
                });
                if (!materia) {
                    throw new types_1.ValidationError('La materia no existe o no pertenece a esta instituciÃ³n');
                }
            }

            if (data.profesorId !== undefined && data.profesorId !== existingHorario.profesorId) {
                if (data.profesorId) {
                    const profesor = await database_1.prisma.usuario.findFirst({
                        where: {
                            id: data.profesorId,
                            rol: 'profesor',
                            usuarioInstituciones: {
                                some: {
                                    institucionId: existingHorario.institucionId,
                                    activo: true,
                                },
                            },
                        },
                    });
                    if (!profesor) {
                        throw new types_1.ValidationError('El profesor no existe o no pertenece a esta instituciÃ³n');
                    }
                }
            }

            await this.validateHorarioConflict(grupoId, profesorId, diaSemana, horaInicio, horaFin, id);
            const horario = await database_1.prisma.horario.update({
                where: { id },
                data: {
                    grupoId: data.grupoId,
                    materiaId: data.materiaId,
                    profesorId: data.profesorId,
                    diaSemana: data.diaSemana,
                    horaInicio: data.horaInicio,
                    horaFin: data.horaFin,
                },
                include: {
                    periodoAcademico: {
                        select: {
                            id: true,
                            nombre: true,
                            fechaInicio: true,
                            fechaFin: true,
                            activo: true,
                        },
                    },
                    grupo: {
                        select: {
                            id: true,
                            nombre: true,
                            grado: true,
                            seccion: true,
                        },
                    },
                    materia: {
                        select: {
                            id: true,
                            nombre: true,
                            codigo: true,
                        },
                    },
                    profesor: {
                        select: {
                            id: true,
                            nombres: true,
                            apellidos: true,
                        },
                    },
                    _count: {
                        select: {
                            asistencias: true,
                        },
                    },
                },
            });
            return {
                id: horario.id,
                periodoId: horario.periodoId,
                grupoId: horario.grupoId,
                materiaId: horario.materiaId,
                profesorId: horario.profesorId,
                diaSemana: horario.diaSemana,
                horaInicio: horario.horaInicio,
                horaFin: horario.horaFin,
                institucionId: horario.institucionId,
                createdAt: horario.createdAt.toISOString(),
                periodoAcademico: {
                    id: horario.periodoAcademico.id,
                    nombre: horario.periodoAcademico.nombre,
                    fechaInicio: horario.periodoAcademico.fechaInicio.toISOString(),
                    fechaFin: horario.periodoAcademico.fechaFin.toISOString(),
                    activo: horario.periodoAcademico.activo,
                },
                grupo: {
                    id: horario.grupo.id,
                    nombre: horario.grupo.nombre,
                    grado: horario.grupo.grado,
                    seccion: horario.grupo.seccion,
                },
                materia: {
                    id: horario.materia.id,
                    nombre: horario.materia.nombre,
                    codigo: horario.materia.codigo,
                },
                profesor: horario.profesor ? {
                    id: horario.profesor.id,
                    nombres: horario.profesor.nombres,
                    apellidos: horario.profesor.apellidos,
                } : null,
                _count: horario._count,
            };
        }
        catch (error) {
            console.error('Error al actualizar horario:', error);
            if (error instanceof types_1.NotFoundError || error instanceof types_1.ValidationError || error instanceof types_1.ConflictError) {
                throw error;
            }
            throw new Error('Error al actualizar el horario');
        }
    }

    static async deleteHorario(id) {
        try {

            const existingHorario = await database_1.prisma.horario.findUnique({
                where: { id },
                include: {
                    _count: {
                        select: {
                            asistencias: true,
                        },
                    },
                },
            });
            if (!existingHorario) {
                throw new types_1.NotFoundError('Horario');
            }

            if (existingHorario._count.asistencias > 0) {
                throw new types_1.ValidationError('No se puede eliminar el horario porque tiene asistencias registradas');
            }
            await database_1.prisma.horario.delete({
                where: { id },
            });
            return true;
        }
        catch (error) {
            console.error('Error al eliminar horario:', error);
            if (error instanceof types_1.NotFoundError || error instanceof types_1.ValidationError) {
                throw error;
            }
            throw new Error('Error al eliminar el horario');
        }
    }
}
exports.HorarioService = HorarioService;
exports.default = HorarioService;

/* Fin backend\dist\services\horario.service.js */

/* Inicio backend\dist\services\institucion.service.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstitucionService = void 0;
const database_1 = require("../config/database");
const types_1 = require("../types");
class InstitucionService {

    static async getAllInstitutions(pagination, filters) {
        try {

            const page = pagination?.page || 1;
            const limit = pagination?.limit || 10;
            if (page < 1 || limit < 1 || limit > 100) {
                throw new types_1.ValidationError('Los parÃ¡metros de paginaciÃ³n deben ser mayores a 0. El lÃ­mite mÃ¡ximo es 100.');
            }
            const skip = (page - 1) * limit;

            const where = {};
            if (filters?.activa !== undefined) {
                where.activa = filters.activa;
            }
            if (filters?.search) {
                where.OR = [
                    { nombre: { contains: filters.search, mode: 'insensitive' } },

                    { email: { contains: filters.search, mode: 'insensitive' } },
                ];
            }

            const total = await database_1.prisma.institucion.count({ where });

            const institutions = await database_1.prisma.institucion.findMany({
                orderBy: {
                    createdAt: 'desc',
                },
                skip,
                take: limit,
                where,
            });
            const totalPages = Math.ceil(total / limit);
            const data = institutions.map((inst) => ({
                id: inst.id,
                nombre: inst.nombre,
                direccion: inst.direccion,
                telefono: inst.telefono,
                email: inst.email,
                activa: inst.activa,
                createdAt: inst.createdAt.toISOString(),
                updatedAt: inst.updatedAt.toISOString(),
            }));
            const result = {
                data,
                pagination: {
                    page,
                    limit,
                    total,
                    totalPages,
                    hasNext: page < totalPages,
                    hasPrev: page > 1,
                },
            };
            return result;
        }
        catch (error) {
            console.error('Error al obtener todas las instituciones:', error);
            if (error instanceof types_1.ValidationError) {
                throw error;
            }
            throw new Error('Error al obtener las instituciones');
        }
    }

    static async getAdminsByInstitution(institutionId) {
        try {
            if (!institutionId)
                throw new types_1.ValidationError('ID de instituciÃ³n invÃ¡lido');
            const relations = await database_1.prisma.usuarioInstitucion.findMany({
                where: {
                    institucionId: institutionId,
                    rolEnInstitucion: 'admin',
                    activo: true,
                },
                include: {
                    usuario: true,
                },
            });

            const admins = relations.map((rel) => ({
                usuarioId: rel.usuario.id,
                email: rel.usuario.email,
                nombres: rel.usuario.nombres,
                apellidos: rel.usuario.apellidos,
                telefono: rel.usuario.telefono,
                activo: rel.usuario.activo,
                institucionId: rel.institucionId,
                rolEnInstitucion: rel.rolEnInstitucion,
            }));
            return admins;
        }
        catch (error) {
            console.error(`Error al obtener admins de la instituciÃ³n ${institutionId}:`, error);
            throw error;
        }
    }

    static async assignAdminToInstitution(institutionId, userId) {
        try {
            if (!institutionId || !userId)
                throw new types_1.ValidationError('ParÃ¡metros invÃ¡lidos');

            const institucion = await database_1.prisma.institucion.findUnique({ where: { id: institutionId } });
            if (!institucion)
                throw new types_1.ValidationError('InstituciÃ³n no encontrada');

            const usuario = await database_1.prisma.usuario.findUnique({ where: { id: userId } });
            if (!usuario)
                throw new types_1.ValidationError('Usuario no encontrado');

            if (usuario.rol !== 'admin_institucion') {
                await database_1.prisma.usuario.update({ where: { id: userId }, data: { rol: 'admin_institucion' } });
            }

            const existingRel = await database_1.prisma.usuarioInstitucion.findUnique({
                where: { usuarioId_institucionId: { usuarioId: userId, institucionId: institutionId } },
            });
            if (existingRel) {

                await database_1.prisma.usuarioInstitucion.update({
                    where: { usuarioId_institucionId: { usuarioId: userId, institucionId: institutionId } },
                    data: { rolEnInstitucion: 'admin', activo: true },
                });
            }
            else {
                await database_1.prisma.usuarioInstitucion.create({
                    data: { usuarioId: userId, institucionId: institutionId, rolEnInstitucion: 'admin', activo: true },
                });
            }

            const updatedUser = await database_1.prisma.usuario.findUnique({ where: { id: userId } });
            return updatedUser;
        }
        catch (error) {
            console.error(`Error al asignar admin ${userId} a instituciÃ³n ${institutionId}:`, error);
            throw error;
        }
    }

    static async removeAdminFromInstitution(institutionId, userId) {
        try {
            if (!institutionId || !userId)
                throw new types_1.ValidationError('ParÃ¡metros invÃ¡lidos');
            const rel = await database_1.prisma.usuarioInstitucion.findUnique({
                where: { usuarioId_institucionId: { usuarioId: userId, institucionId: institutionId } },
            });
            if (!rel) {
                throw new types_1.ValidationError('RelaciÃ³n usuario-instituciÃ³n no encontrada');
            }

            await database_1.prisma.usuarioInstitucion.update({
                where: { usuarioId_institucionId: { usuarioId: userId, institucionId: institutionId } },
                data: { activo: false },
            });

            const otherActiveAdmin = await database_1.prisma.usuarioInstitucion.findFirst({
                where: { usuarioId: userId, rolEnInstitucion: 'admin', activo: true },
            });
            if (!otherActiveAdmin) {

                const usuario = await database_1.prisma.usuario.findUnique({ where: { id: userId } });
                if (usuario && usuario.rol === 'admin_institucion') {
                    await database_1.prisma.usuario.update({ where: { id: userId }, data: { rol: 'user' } });
                }
            }
            return { usuarioId: userId, institutionId, removed: true };
        }
        catch (error) {
            console.error(`Error al remover admin ${userId} de instituciÃ³n ${institutionId}:`, error);
            throw error;
        }
    }

    static async getInstitutionById(id) {
        try {
            if (!id || typeof id !== 'string') {
                throw new types_1.ValidationError('ID de instituciÃ³n invÃ¡lido');
            }
            const institution = await database_1.prisma.institucion.findUnique({
                where: { id },
            });
            if (!institution) {
                return null;
            }
            return {
                id: institution.id,
                nombre: institution.nombre,
                direccion: institution.direccion,
                telefono: institution.telefono,
                email: institution.email,
                activa: institution.activa,
                createdAt: institution.createdAt.toISOString(),
                updatedAt: institution.updatedAt.toISOString(),
            };
        }
        catch (error) {
            console.error(`Error al obtener instituciÃ³n con ID ${id}:`, error);
            throw error;
        }
    }

    static async createInstitution(data) {
        try {

            if (!data.nombre) {
                throw new types_1.ValidationError('Nombre es requerido');
            }
            const institution = await database_1.prisma.institucion.create({
                data: {
                    nombre: data.nombre,
                    direccion: data.direccion,
                    telefono: data.telefono,
                    email: data.email,
                },
            });
            return {
                id: institution.id,
                nombre: institution.nombre,
                direccion: institution.direccion,
                telefono: institution.telefono,
                email: institution.email,
                activa: institution.activa,
                createdAt: institution.createdAt.toISOString(),
                updatedAt: institution.updatedAt.toISOString(),
            };
        }
        catch (error) {
            console.error('Error al crear instituciÃ³n:', error);
            throw error;
        }
    }

    static async updateInstitution(id, data) {
        try {
            if (!id || typeof id !== 'string') {
                throw new types_1.ValidationError('ID de instituciÃ³n invÃ¡lido');
            }

            const existingInstitution = await this.getInstitutionById(id);
            if (!existingInstitution) {
                throw new types_1.ValidationError('InstituciÃ³n no encontrada');
            }
            const institution = await database_1.prisma.institucion.update({
                where: { id },
                data: {
                    nombre: data.nombre,
                    direccion: data.direccion,
                    telefono: data.telefono,
                    email: data.email,
                    activa: data.activa,
                },
            });
            return {
                id: institution.id,
                nombre: institution.nombre,
                direccion: institution.direccion,
                telefono: institution.telefono,
                email: institution.email,
                activa: institution.activa,
                createdAt: institution.createdAt.toISOString(),
                updatedAt: institution.updatedAt.toISOString(),
            };
        }
        catch (error) {
            console.error(`Error al actualizar instituciÃ³n con ID ${id}:`, error);
            throw error;
        }
    }

    static async deleteInstitution(id) {
        try {
            if (!id || typeof id !== 'string') {
                throw new types_1.ValidationError('ID de instituciÃ³n invÃ¡lido');
            }

            const existingInstitution = await this.getInstitutionById(id);
            if (!existingInstitution) {
                throw new types_1.ValidationError('InstituciÃ³n no encontrada');
            }

            const usuariosCount = await database_1.prisma.usuarioInstitucion.count({
                where: { institucionId: id, activo: true },
            });
            if (usuariosCount > 0) {
                throw new types_1.ConflictError('No se puede eliminar la instituciÃ³n porque tiene usuarios activos asociados');
            }
            await database_1.prisma.institucion.delete({
                where: { id },
            });
            return true;
        }
        catch (error) {
            console.error(`Error al eliminar instituciÃ³n con ID ${id}:`, error);
            throw error;
        }
    }
}
exports.InstitucionService = InstitucionService;
exports.default = InstitucionService;

/* Fin backend\dist\services\institucion.service.js */

/* Inicio backend\dist\services\materia.service.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MateriaService = void 0;
const database_1 = require("../config/database");
const types_1 = require("../types");
class MateriaService {

    static async getAllMateriasByInstitucion(institucionId, pagination, filters) {
        try {

            const page = pagination?.page || 1;
            const limit = pagination?.limit || 10;
            if (page < 1 || limit < 1 || limit > 100) {
                throw new types_1.ValidationError('Los parÃ¡metros de paginaciÃ³n deben ser mayores a 0. El lÃ­mite mÃ¡ximo es 100.');
            }
            const skip = (page - 1) * limit;

            const where = {
                institucionId: institucionId,
            };
            if (filters?.search) {
                where.OR = [
                    { nombre: { contains: filters.search, mode: 'insensitive' } },
                    { codigo: { contains: filters.search, mode: 'insensitive' } },
                ];
            }

            const total = await database_1.prisma.materia.count({ where });

            const materias = await database_1.prisma.materia.findMany({
                where,
                skip,
                take: limit,
                orderBy: [
                    { nombre: 'asc' },
                ],
                include: {
                    _count: {
                        select: {
                            horarios: true,
                        },
                    },
                },
            });
            const totalPages = Math.ceil(total / limit);
            return {
                data: materias.map((materia) => ({
                    id: materia.id,
                    nombre: materia.nombre,
                    codigo: materia.codigo,
                    institucionId: materia.institucionId,
                    createdAt: materia.createdAt.toISOString(),
                    _count: materia._count,
                })),
                pagination: {
                    page,
                    limit,
                    total,
                    totalPages,
                    hasNext: page < totalPages,
                    hasPrev: page > 1,
                },
            };
        }
        catch (error) {
            console.error('Error al obtener materias:', error);
            if (error instanceof types_1.ValidationError) {
                throw error;
            }
            throw new Error('Error al obtener las materias');
        }
    }

    static async getMateriaById(id) {
        try {
            const materia = await database_1.prisma.materia.findUnique({
                where: { id },
                include: {
                    _count: {
                        select: {
                            horarios: true,
                        },
                    },
                },
            });
            if (!materia) {
                return null;
            }
            return {
                id: materia.id,
                nombre: materia.nombre,
                codigo: materia.codigo,
                institucionId: materia.institucionId,
                createdAt: materia.createdAt.toISOString(),
                _count: materia._count,
            };
        }
        catch (error) {
            console.error('Error al obtener materia:', error);
            throw new Error('Error al obtener la materia');
        }
    }

    static async createMateria(data) {
        try {

            if (!data.nombre || data.nombre.trim() === '') {
                throw new types_1.ValidationError('El nombre de la materia es requerido');
            }

            const existingMateria = await database_1.prisma.materia.findFirst({
                where: {
                    nombre: data.nombre.trim(),
                    institucionId: data.institucionId,
                },
            });
            if (existingMateria) {
                throw new types_1.ConflictError('Ya existe una materia con este nombre en la instituciÃ³n');
            }

            if (data.codigo && data.codigo.trim() !== '') {
                const existingCodigo = await database_1.prisma.materia.findFirst({
                    where: {
                        codigo: data.codigo.trim(),
                        institucionId: data.institucionId,
                    },
                });
                if (existingCodigo) {
                    throw new types_1.ConflictError('Ya existe una materia con este cÃ³digo en la instituciÃ³n');
                }
            }
            const materia = await database_1.prisma.materia.create({
                data: {
                    nombre: data.nombre.trim(),
                    codigo: data.codigo?.trim() || null,
                    institucionId: data.institucionId,
                },
                include: {
                    _count: {
                        select: {
                            horarios: true,
                        },
                    },
                },
            });
            return {
                id: materia.id,
                nombre: materia.nombre,
                codigo: materia.codigo,
                institucionId: materia.institucionId,
                createdAt: materia.createdAt.toISOString(),
                _count: materia._count,
            };
        }
        catch (error) {
            console.error('Error al crear materia:', error);
            if (error instanceof types_1.ValidationError || error instanceof types_1.ConflictError) {
                throw error;
            }
            throw new Error('Error al crear la materia');
        }
    }

    static async updateMateria(id, data) {
        try {

            const existingMateria = await database_1.prisma.materia.findUnique({
                where: { id },
            });
            if (!existingMateria) {
                throw new types_1.NotFoundError('Materia');
            }

            if (data.nombre && data.nombre !== existingMateria.nombre) {
                const existingMateriaWithName = await database_1.prisma.materia.findFirst({
                    where: {
                        nombre: data.nombre,
                        institucionId: existingMateria.institucionId,
                        id: { not: id },
                    },
                });
                if (existingMateriaWithName) {
                    throw new types_1.ConflictError('Ya existe una materia con este nombre en la instituciÃ³n');
                }
            }

            if (data.codigo && data.codigo !== existingMateria.codigo) {
                const existingMateriaWithCodigo = await database_1.prisma.materia.findFirst({
                    where: {
                        codigo: data.codigo,
                        institucionId: existingMateria.institucionId,
                        id: { not: id },
                    },
                });
                if (existingMateriaWithCodigo) {
                    throw new types_1.ConflictError('Ya existe una materia con este cÃ³digo en la instituciÃ³n');
                }
            }
            const materia = await database_1.prisma.materia.update({
                where: { id },
                data: {
                    nombre: data.nombre,
                    codigo: data.codigo,
                },
                include: {
                    _count: {
                        select: {
                            horarios: true,
                        },
                    },
                },
            });
            return {
                id: materia.id,
                nombre: materia.nombre,
                codigo: materia.codigo,
                institucionId: materia.institucionId,
                createdAt: materia.createdAt.toISOString(),
                _count: materia._count,
            };
        }
        catch (error) {
            console.error('Error al actualizar materia:', error);
            if (error instanceof types_1.NotFoundError || error instanceof types_1.ValidationError || error instanceof types_1.ConflictError) {
                throw error;
            }
            throw new Error('Error al actualizar la materia');
        }
    }

    static async deleteMateria(id) {
        try {

            const existingMateria = await database_1.prisma.materia.findUnique({
                where: { id },
                include: {
                    _count: {
                        select: {
                            horarios: true,
                        },
                    },
                },
            });
            if (!existingMateria) {
                throw new types_1.NotFoundError('Materia');
            }

            if (existingMateria._count.horarios > 0) {
                throw new types_1.ValidationError('No se puede eliminar la materia porque tiene horarios asignados');
            }
            await database_1.prisma.materia.delete({
                where: { id },
            });
            return true;
        }
        catch (error) {
            console.error('Error al eliminar materia:', error);
            if (error instanceof types_1.NotFoundError || error instanceof types_1.ValidationError) {
                throw error;
            }
            throw new Error('Error al eliminar la materia');
        }
    }

    static async getMateriasDisponibles(institucionId) {
        try {
            const materias = await database_1.prisma.materia.findMany({
                where: {
                    institucionId: institucionId,
                },
                orderBy: [
                    { nombre: 'asc' },
                ],
                include: {
                    _count: {
                        select: {
                            horarios: true,
                        },
                    },
                },
            });
            return materias.map((materia) => ({
                id: materia.id,
                nombre: materia.nombre,
                codigo: materia.codigo,
                institucionId: materia.institucionId,
                createdAt: materia.createdAt.toISOString(),
                _count: materia._count,
            }));
        }
        catch (error) {
            console.error('Error al obtener materias disponibles:', error);
            throw new Error('Error al obtener las materias disponibles');
        }
    }
}
exports.MateriaService = MateriaService;
exports.default = MateriaService;

/* Fin backend\dist\services\materia.service.js */

/* Inicio backend\dist\services\profesor.service.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProfesorService = void 0;
const client_1 = require("@prisma/client");
const bcryptjs_1 = __importDefault(require("bcryptjs"));
const types_1 = require("../types");
const prisma = new client_1.PrismaClient();

class ProfesorService {

    static async getAll(institucionId, pagination, filters) {
        try {

            const page = pagination?.page || 1;
            const limit = pagination?.limit || 10;
            if (page < 1 || limit < 1 || limit > 100) {
                throw new types_1.ValidationError('Los parÃ¡metros de paginaciÃ³n deben ser mayores a 0. El lÃ­mite mÃ¡ximo es 100.');
            }
            const skip = (page - 1) * limit;

            const where = {
                rol: 'profesor',
                usuarioInstituciones: {
                    some: {
                        institucionId,
                        activo: true,
                    },
                },
            };
            if (filters?.activo !== undefined) {
                where.activo = filters.activo;
            }
            if (filters?.search) {
                where.OR = [
                    { nombres: { contains: filters.search, mode: 'insensitive' } },
                    { apellidos: { contains: filters.search, mode: 'insensitive' } },
                    { email: { contains: filters.search, mode: 'insensitive' } },
                ];
            }

            const total = await prisma.usuario.count({ where });

            const profesores = await prisma.usuario.findMany({
                where,
                skip,
                take: limit,
                include: {
                    usuarioInstituciones: {
                        where: {
                            institucionId,
                            activo: true,
                        },
                        include: {
                            institucion: {
                                select: {
                                    id: true,
                                    nombre: true,
                                },
                            },
                        },
                    },
                },
                orderBy: {
                    apellidos: 'asc',
                },
            });

            const formattedProfesores = profesores.map((profesor) => ({
                id: profesor.id,
                nombres: profesor.nombres,
                apellidos: profesor.apellidos,
                email: profesor.email,
                telefono: profesor.telefono,
                activo: profesor.activo,
                institucion: profesor.usuarioInstituciones[0]?.institucion,
                createdAt: profesor.createdAt,
            }));
            return {
                data: formattedProfesores,
                pagination: {
                    page,
                    limit,
                    total,
                    totalPages: Math.ceil(total / limit),
                },
            };
        }
        catch (error) {
            console.error('Error al obtener profesores:', error);
            if (error instanceof types_1.ValidationError) {
                throw error;
            }
            throw new Error('Error al obtener los profesores');
        }
    }

    static async getById(id, institucionId) {
        const profesor = await prisma.usuario.findFirst({
            where: {
                id,
                rol: 'profesor',
                usuarioInstituciones: {
                    some: {
                        institucionId,
                        activo: true,
                    },
                },
            },
            include: {
                usuarioInstituciones: {
                    where: {
                        institucionId,
                        activo: true,
                    },
                    include: {
                        institucion: {
                            select: {
                                id: true,
                                nombre: true,
                            },
                        },
                    },
                },
            },
        });
        if (!profesor)
            return null;
        return {
            id: profesor.id,
            nombres: profesor.nombres,
            apellidos: profesor.apellidos,
            email: profesor.email,
            telefono: profesor.telefono,
            activo: profesor.activo,
            institucion: profesor.usuarioInstituciones[0]?.institucion,
            createdAt: profesor.createdAt,
        };
    }

    static async create(data, createdBy) {

        const existingUser = await prisma.usuario.findUnique({
            where: { email: data.email },
        });
        if (existingUser) {
            throw new types_1.ValidationError('El email ya estÃ¡ registrado');
        }

        const institucion = await prisma.institucion.findUnique({
            where: { id: data.institucionId },
        });
        if (!institucion) {
            throw new types_1.NotFoundError('InstituciÃ³n');
        }

        const hashedPassword = await bcryptjs_1.default.hash(data.password, 10);

        const newProfesor = await prisma.usuario.create({
            data: {
                email: data.email,
                passwordHash: hashedPassword,
                nombres: data.nombres,
                apellidos: data.apellidos,
                rol: 'profesor',
                activo: true,
            },
        });

        await prisma.usuarioInstitucion.create({
            data: {
                usuarioId: newProfesor.id,
                institucionId: data.institucionId,
                activo: true,
            },
        });

        const profesorWithInstitucion = await this.getById(newProfesor.id, data.institucionId);
        return profesorWithInstitucion;
    }

    static async update(id, institucionId, data) {

        const existingProfesor = await prisma.usuario.findFirst({
            where: {
                id,
                rol: 'profesor',
                usuarioInstituciones: {
                    some: {
                        institucionId,
                        activo: true,
                    },
                },
            },
        });
        if (!existingProfesor) {
            throw new types_1.NotFoundError('Profesor');
        }

        if (data.email && data.email !== existingProfesor.email) {
            const emailExists = await prisma.usuario.findUnique({
                where: { email: data.email },
            });
            if (emailExists) {
                throw new types_1.ValidationError('El email ya estÃ¡ registrado para otro usuario');
            }
        }
        const updatedProfesor = await prisma.usuario.update({
            where: { id },
            data: {
                nombres: data.nombres,
                apellidos: data.apellidos,
                email: data.email,
                activo: data.activo,
            },
            include: {
                usuarioInstituciones: {
                    where: {
                        institucionId,
                        activo: true,
                    },
                    include: {
                        institucion: {
                            select: {
                                id: true,
                                nombre: true,
                            },
                        },
                    },
                },
            },
        });
        return {
            id: updatedProfesor.id,
            nombres: updatedProfesor.nombres,
            apellidos: updatedProfesor.apellidos,
            email: updatedProfesor.email,
            telefono: updatedProfesor.telefono,
            activo: updatedProfesor.activo,
            institucion: updatedProfesor.usuarioInstituciones[0]?.institucion,
            createdAt: updatedProfesor.createdAt,
        };
    }

    static async delete(id, institucionId) {

        const existingProfesor = await prisma.usuario.findFirst({
            where: {
                id,
                rol: 'profesor',
                usuarioInstituciones: {
                    some: {
                        institucionId,
                        activo: true,
                    },
                },
            },
        });
        if (!existingProfesor) {
            return false;
        }

        await prisma.usuario.update({
            where: { id },
            data: { activo: false },
        });
        return true;
    }

    static async toggleStatus(id, institucionId) {

        const existingProfesor = await prisma.usuario.findFirst({
            where: {
                id,
                rol: 'profesor',
                usuarioInstituciones: {
                    some: {
                        institucionId,
                        activo: true,
                    },
                },
            },
        });
        if (!existingProfesor) {
            throw new types_1.NotFoundError('Profesor');
        }
        const updatedProfesor = await prisma.usuario.update({
            where: { id },
            data: { activo: !existingProfesor.activo },
            include: {
                usuarioInstituciones: {
                    where: {
                        institucionId,
                        activo: true,
                    },
                    include: {
                        institucion: {
                            select: {
                                id: true,
                                nombre: true,
                            },
                        },
                    },
                },
            },
        });
        return {
            id: updatedProfesor.id,
            nombres: updatedProfesor.nombres,
            apellidos: updatedProfesor.apellidos,
            email: updatedProfesor.email,
            telefono: updatedProfesor.telefono,
            activo: updatedProfesor.activo,
            institucion: updatedProfesor.usuarioInstituciones[0]?.institucion,
            createdAt: updatedProfesor.createdAt,
        };
    }

    static async getClasesDelDia(profesorId) {
        try {

            const hoy = new Date();
            const diaSemana = hoy.getDay() === 0 ? 7 : hoy.getDay()

            const clases = await prisma.horario.findMany({
                where: {
                    profesorId: profesorId,
                    diaSemana: diaSemana,
                    periodoAcademico: {
                        activo: true, // Solo periodos activos
                    },
                },
                orderBy: [
                    { horaInicio: 'asc' },
                ],
                include: {
                    grupo: {
                        select: {
                            id: true,
                            nombre: true,
                            grado: true,
                            seccion: true,
                        },
                    },
                    materia: {
                        select: {
                            id: true,
                            nombre: true,
                            codigo: true,
                        },
                    },
                    periodoAcademico: {
                        select: {
                            id: true,
                            nombre: true,
                            activo: true,
                        },
                    },
                    institucion: {
                        select: {
                            id: true,
                            nombre: true,
                        },
                    },
                },
            });
            return clases.map((clase) => ({
                id: clase.id,
                diaSemana: clase.diaSemana,
                horaInicio: clase.horaInicio,
                horaFin: clase.horaFin,
                grupo: {
                    id: clase.grupo.id,
                    nombre: clase.grupo.nombre,
                    grado: clase.grupo.grado,
                    seccion: clase.grupo.seccion,
                },
                materia: {
                    id: clase.materia.id,
                    nombre: clase.materia.nombre,
                    codigo: clase.materia.codigo,
                },
                periodoAcademico: {
                    id: clase.periodoAcademico.id,
                    nombre: clase.periodoAcademico.nombre,
                    activo: clase.periodoAcademico.activo,
                },
                institucion: {
                    id: clase.institucion.id,
                    nombre: clase.institucion.nombre,
                },
            }));
        }
        catch (error) {
            console.error('Error al obtener clases del dÃ­a:', error);
            throw new Error('Error al obtener las clases del dÃ­a');
        }
    }

    static async getClasesPorDia(profesorId, diaSemana) {
        try {

            if (diaSemana < 1 || diaSemana > 7) {
                throw new Error('El dÃ­a de la semana debe estar entre 1 (Lunes) y 7 (Domingo)');
            }
            const clases = await prisma.horario.findMany({
                where: {
                    profesorId: profesorId,
                    diaSemana: diaSemana,
                    periodoAcademico: {
                        activo: true, // Solo periodos activos
                    },
                },
                orderBy: [
                    { horaInicio: 'asc' },
                ],
                include: {
                    grupo: {
                        select: {
                            id: true,
                            nombre: true,
                            grado: true,
                            seccion: true,
                        },
                    },
                    materia: {
                        select: {
                            id: true,
                            nombre: true,
                            codigo: true,
                        },
                    },
                    periodoAcademico: {
                        select: {
                            id: true,
                            nombre: true,
                            activo: true,
                        },
                    },
                    institucion: {
                        select: {
                            id: true,
                            nombre: true,
                        },
                    },
                },
            });
            return clases.map((clase) => ({
                id: clase.id,
                diaSemana: clase.diaSemana,
                horaInicio: clase.horaInicio,
                horaFin: clase.horaFin,
                grupo: {
                    id: clase.grupo.id,
                    nombre: clase.grupo.nombre,
                    grado: clase.grupo.grado,
                    seccion: clase.grupo.seccion,
                },
                materia: {
                    id: clase.materia.id,
                    nombre: clase.materia.nombre,
                    codigo: clase.materia.codigo,
                },
                periodoAcademico: {
                    id: clase.periodoAcademico.id,
                    nombre: clase.periodoAcademico.nombre,
                    activo: clase.periodoAcademico.activo,
                },
                institucion: {
                    id: clase.institucion.id,
                    nombre: clase.institucion.nombre,
                },
            }));
        }
        catch (error) {
            console.error('Error al obtener clases por dÃ­a:', error);
            throw new Error('Error al obtener las clases por dÃ­a');
        }
    }

    static async getHorarioSemanal(profesorId) {
        try {
            const horarioSemanal = {};

            for (let dia = 1; dia <= 7; dia++) {
                horarioSemanal[dia] = await this.getClasesPorDia(profesorId, dia);
            }
            return horarioSemanal;
        }
        catch (error) {
            console.error('Error al obtener horario semanal:', error);
            throw new Error('Error al obtener el horario semanal');
        }
    }
}
exports.ProfesorService = ProfesorService;
exports.default = ProfesorService;

/* Fin backend\dist\services\profesor.service.js */

/* Inicio backend\dist\services\user.service.js */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserService = void 0;
const bcryptjs_1 = __importDefault(require("bcryptjs"));
const crypto_1 = require("crypto");
const database_1 = require("../config/database");
const types_1 = require("../types");
class UserService {

    static async getAllUsers(pagination, filters) {
        try {

            const page = pagination?.page || 1;
            const limit = pagination?.limit || 50;
            if (page < 1 || limit < 1 || limit > 100) {
                throw new types_1.ValidationError('Los parÃ¡metros de paginaciÃ³n deben ser mayores a 0. El lÃ­mite mÃ¡ximo es 100.');
            }
            const skip = (page - 1) * limit;

            const where = {};
            if (filters?.activo !== undefined) {
                where.activo = filters.activo;
            }
            if (filters?.rol) {

                const rolFilter = filters.rol;
                if (Array.isArray(rolFilter)) {
                    where.rol = { in: rolFilter };
                }
                else if (typeof rolFilter === 'string' && rolFilter.includes(',')) {
                    where.rol = { in: rolFilter.split(',').map(r => r.trim()) };
                }
                else {
                    where.rol = rolFilter;
                }
            }
            if (filters?.institucionId) {
                where.usuarioInstituciones = {
                    some: { institucionId: filters.institucionId, activo: true },
                };
            }
            if (filters?.search) {
                where.OR = [
                    { nombres: { contains: filters.search, mode: 'insensitive' } },
                    { apellidos: { contains: filters.search, mode: 'insensitive' } },
                    { email: { contains: filters.search, mode: 'insensitive' } },
                ];
            }

            const total = await database_1.prisma.usuario.count({ where });

            const users = await database_1.prisma.usuario.findMany({
                include: {
                    usuarioInstituciones: {
                        where: { activo: true },
                        include: {
                            institucion: true,
                        },
                    },
                },
                orderBy: {
                    createdAt: 'desc',
                },
                skip,
                take: limit,
                where,
            });
            const totalPages = Math.ceil(total / limit);
            return {
                data: users,
                pagination: {
                    page,
                    limit,
                    total,
                    totalPages,
                    hasNext: page < totalPages,
                    hasPrev: page > 1,
                },
            };
        }
        catch (error) {
            console.error('Error al obtener todos los usuarios:', error);
            if (error instanceof types_1.ValidationError) {
                throw error;
            }
            throw new Error('Error al obtener los usuarios');
        }
    }

    static async getUserById(id) {
        try {
            if (!id || typeof id !== 'string') {
                throw new types_1.ValidationError('ID de usuario invÃ¡lido');
            }
            const user = await database_1.prisma.usuario.findUnique({
                where: { id },
                include: {
                    usuarioInstituciones: {
                        where: { activo: true },
                        include: {
                            institucion: true,
                        },
                    },
                    estudiante: true,
                },
            });
            return user;
        }
        catch (error) {
            console.error(`Error al obtener usuario con ID ${id}:`, error);
            throw error;
        }
    }

    static async getUserByEmail(email) {
        try {
            if (!email || typeof email !== 'string' || !email.includes('@')) {
                throw new types_1.ValidationError('Email invÃ¡lido');
            }
            const user = await database_1.prisma.usuario.findUnique({
                where: { email: email.toLowerCase() },
                include: {
                    usuarioInstituciones: {
                        where: { activo: true },
                        include: {
                            institucion: true,
                        },
                    },
                },
            });
            return user;
        }
        catch (error) {
            console.error(`Error al obtener usuario con email ${email}:`, error);
            throw error;
        }
    }

    static async getUsersByRole(role, pagination, filters) {
        const combinedFilters = { ...filters, rol: role };
        return this.getAllUsers(pagination, combinedFilters);
    }

    static async getUsersByInstitution(institucionId, pagination, filters) {
        const combinedFilters = { ...filters, institucionId };
        return this.getAllUsers(pagination, combinedFilters);
    }

    static async createUser(userData, invokerRole) {
        try {

            if (invokerRole === 'super_admin' && userData.rol !== 'admin_institucion' && userData.rol !== 'super_admin') {
                throw new types_1.AuthorizationError('Un Super Admin solo puede crear usuarios de tipo Administrador de InstituciÃ³n o Super Admin.');
            }
            if (invokerRole === 'super_admin' && userData.rol === 'admin_institucion' && !userData.institucionId) {
                throw new types_1.ValidationError('Se requiere un institucionId para crear un Administrador de InstituciÃ³n.');
            }
            if (invokerRole === 'admin_institucion' && (userData.rol !== 'profesor' && userData.rol !== 'estudiante')) {
                throw new types_1.AuthorizationError('Un Administrador de InstituciÃ³n solo puede crear profesores o estudiantes.');
            }

            if (!userData.email || !userData.password || !userData.nombres || !userData.apellidos || !userData.rol) {
                throw new types_1.ValidationError('Campos requeridos faltantes');
            }
            const validRoles = ['super_admin', 'admin_institucion', 'profesor', 'estudiante'];
            if (!validRoles.includes(userData.rol)) {
                throw new types_1.ValidationError('Rol invÃ¡lido');
            }

            const emailAvailable = await this.isEmailAvailable(userData.email);
            if (!emailAvailable) {
                throw new types_1.ConflictError('El email ya estÃ¡ registrado');
            }

            const hashedPassword = await bcryptjs_1.default.hash(userData.password, 10);

            let codigoQr;
            if (userData.rol === 'estudiante') {
                if (!userData.identificacion) {
                    throw new types_1.ValidationError('La identificaciÃ³n es requerida para estudiantes');
                }
                codigoQr = this.generateUniqueQRCode();
            }

            const result = await database_1.prisma.$transaction(async (tx) => {

                const newUser = await tx.usuario.create({
                    data: {
                        email: userData.email.toLowerCase(),
                        passwordHash: hashedPassword,
                        nombres: userData.nombres,
                        apellidos: userData.apellidos,
                        rol: userData.rol,
                        telefono: userData.telefono,
                    },
                });

                if (userData.institucionId) {
                    await tx.usuarioInstitucion.create({
                        data: {
                            usuarioId: newUser.id,
                            institucionId: userData.institucionId,
                            rolEnInstitucion: userData.rolEnInstitucion,
                        },
                    });
                }

                let estudianteData = null;
                if (userData.rol === 'estudiante' && userData.identificacion) {
                    estudianteData = await tx.estudiante.create({
                        data: {
                            usuarioId: newUser.id,
                            identificacion: userData.identificacion,
                            codigoQr: codigoQr,
                            nombreResponsable: userData.nombreResponsable,
                            telefonoResponsable: userData.telefonoResponsable,
                        },
                    });
                }
                return { newUser, estudianteData };
            });

            const userWithRelations = await this.getUserById(result.newUser.id);
            if (!userWithRelations) {
                throw new Error('Error al obtener usuario creado');
            }

            const response = {
                id: userWithRelations.id,
                email: userWithRelations.email,
                nombres: userWithRelations.nombres,
                apellidos: userWithRelations.apellidos,
                rol: userWithRelations.rol,
                telefono: userWithRelations.telefono,
                activo: userWithRelations.activo,
                instituciones: userWithRelations.usuarioInstituciones?.map(ui => ({
                    id: ui.institucion.id,
                    nombre: ui.institucion.nombre,
                    rolEnInstitucion: ui.rolEnInstitucion,
                    activo: ui.activo,
                })) || [],
            };
            if (result.estudianteData) {
                response.estudiante = {
                    id: result.estudianteData.id,
                    identificacion: result.estudianteData.identificacion,
                    codigoQr: result.estudianteData.codigoQr,
                    nombreResponsable: result.estudianteData.nombreResponsable,
                    telefonoResponsable: result.estudianteData.telefonoResponsable,
                };
            }
            return response;
        }
        catch (error) {
            console.error('Error al crear usuario:', error);
            throw error;
        }
    }

    static async updateUser(id, userData) {
        try {
            if (!id || typeof id !== 'string') {
                throw new types_1.ValidationError('ID de usuario invÃ¡lido');
            }

            const existingUser = await this.getUserById(id);
            if (!existingUser) {
                throw new types_1.ValidationError('Usuario no encontrado');
            }

            if (userData.email && userData.email !== existingUser.email) {
                const emailAvailable = await this.isEmailAvailable(userData.email, id);
                if (!emailAvailable) {
                    throw new types_1.ConflictError('El email ya estÃ¡ registrado');
                }
            }

            const result = await database_1.prisma.$transaction(async (tx) => {

                const updateData = {};
                if (userData.email !== undefined)
                    updateData.email = userData.email.toLowerCase();
                if (userData.nombres !== undefined)
                    updateData.nombres = userData.nombres;
                if (userData.apellidos !== undefined)
                    updateData.apellidos = userData.apellidos;
                if (userData.telefono !== undefined)
                    updateData.telefono = userData.telefono;
                if (userData.activo !== undefined)
                    updateData.activo = userData.activo;
                const updatedUser = await tx.usuario.update({
                    where: { id },
                    data: updateData,
                });

                if (existingUser.rol === 'estudiante' && (userData.identificacion || userData.nombreResponsable || userData.telefonoResponsable)) {
                    const estudianteUpdateData = {};
                    if (userData.identificacion !== undefined)
                        estudianteUpdateData.identificacion = userData.identificacion;
                    if (userData.nombreResponsable !== undefined)
                        estudianteUpdateData.nombreResponsable = userData.nombreResponsable;
                    if (userData.telefonoResponsable !== undefined)
                        estudianteUpdateData.telefonoResponsable = userData.telefonoResponsable;
                    await tx.estudiante.update({
                        where: { usuarioId: id },
                        data: estudianteUpdateData,
                    });
                }
                return updatedUser;
            });

            return await this.getUserById(id);
        }
        catch (error) {
            console.error(`Error al actualizar usuario con ID ${id}:`, error);
            throw error;
        }
    }

    static async changeUserPassword(userId, newPassword) {
        try {
            if (!userId || typeof userId !== 'string') {
                throw new types_1.ValidationError('ID de usuario invÃ¡lido');
            }
            if (!newPassword || typeof newPassword !== 'string' || newPassword.length < 8) {
                throw new types_1.ValidationError('La nueva contraseÃ±a debe tener al menos 8 caracteres');
            }
            const user = await database_1.prisma.usuario.findUnique({ where: { id: userId } });
            if (!user) {
                throw new types_1.NotFoundError('Usuario');
            }
            const hashed = await bcryptjs_1.default.hash(newPassword, 10);
            await database_1.prisma.usuario.update({
                where: { id: userId },
                data: {
                    passwordHash: hashed,
                    tokenVersion: (user.tokenVersion ?? 0) + 1,
                },
            });
            return true;
        }
        catch (error) {
            console.error(`Error changing password for user ${userId}:`, error);
            throw error;
        }
    }

    static async deleteUser(id) {
        try {
            if (!id || typeof id !== 'string') {
                throw new types_1.ValidationError('ID de usuario invÃ¡lido');
            }

            const existingUser = await this.getUserById(id);
            if (!existingUser) {
                throw new types_1.ValidationError('Usuario no encontrado');
            }

            await database_1.prisma.usuario.update({
                where: { id },
                data: { activo: false },
            });
            return true;
        }
        catch (error) {
            console.error(`Error al eliminar usuario con ID ${id}:`, error);
            throw error;
        }
    }

    static generateUniqueQRCode() {
        return (0, crypto_1.randomBytes)(16).toString('hex').toUpperCase();
    }

    static async userExists(id) {
        try {
            if (!id || typeof id !== 'string') {
                return false;
            }
            const count = await database_1.prisma.usuario.count({
                where: { id },
            });
            return count > 0;
        }
        catch (error) {
            console.error(`Error al verificar existencia de usuario ${id}:`, error);
            return false;
        }
    }

    static async isEmailAvailable(email, excludeUserId) {
        try {
            if (!email || typeof email !== 'string' || !email.includes('@')) {
                return false;
            }
            const whereClause = { email: email.toLowerCase() };
            if (excludeUserId) {
                whereClause.id = { not: excludeUserId };
            }
            const count = await database_1.prisma.usuario.count({
                where: whereClause,
            });
            return count === 0;
        }
        catch (error) {
            console.error(`Error al verificar disponibilidad de email ${email}:`, error);
            return false;
        }
    }
}
exports.UserService = UserService;
exports.default = UserService;

/* Fin backend\dist\services\user.service.js */

/* Inicio backend\dist\types\index.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConflictError = exports.NotFoundError = exports.AuthorizationError = exports.AuthenticationError = exports.ValidationError = exports.AppError = void 0;
class AppError extends Error {
    constructor(message, statusCode = 500, code = 'INTERNAL_ERROR') {
        super(message);
        this.statusCode = statusCode;
        this.code = code;
        this.isOperational = true;
        Error.captureStackTrace(this, this.constructor);
    }
}
exports.AppError = AppError;
class ValidationError extends AppError {
    constructor(message) {
        super(message, 400, 'VALIDATION_ERROR');
    }
}
exports.ValidationError = ValidationError;
class AuthenticationError extends AppError {
    constructor(message = 'No autorizado') {
        super(message, 401, 'AUTHENTICATION_ERROR');
    }
}
exports.AuthenticationError = AuthenticationError;
class AuthorizationError extends AppError {
    constructor(message = 'Acceso denegado') {
        super(message, 403, 'AUTHORIZATION_ERROR');
    }
}
exports.AuthorizationError = AuthorizationError;
class NotFoundError extends AppError {
    constructor(resource = 'Recurso') {
        super(`${resource} no encontrado`, 404, 'NOT_FOUND_ERROR');
    }
}
exports.NotFoundError = NotFoundError;
class ConflictError extends AppError {
    constructor(message) {
        super(message, 409, 'CONFLICT_ERROR');
    }
}
exports.ConflictError = ConflictError;

/* Fin backend\dist\types\index.js */

/* Inicio backend\dist\utils\index.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormatUtil = exports.ValidationUtil = exports.ResponseUtil = void 0;

class ResponseUtil {

    static success(data, message) {
        return {
            success: true,
            data,
            message,
        };
    }

    static error(message, code) {
        return {
            success: false,
            error: message,
            message: code,
        };
    }

    static paginated(data, total, page, limit, message) {
        return {
            success: true,
            data: {
                items: data,
                pagination: {
                    total,
                    page,
                    limit,
                    totalPages: Math.ceil(total / limit),
                },
            },
            message,
        };
    }
}
exports.ResponseUtil = ResponseUtil;

class ValidationUtil {

    static isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }

    static isNotEmpty(value) {
        return Boolean(value && value.trim().length > 0);
    }

    static hasMinLength(value, minLength) {
        return Boolean(value && value.length >= minLength);
    }
}
exports.ValidationUtil = ValidationUtil;

class FormatUtil {

    static capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
    }

    static snakeToCamel(str) {
        return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
    }

    static camelToSnake(str) {
        return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
    }
}
exports.FormatUtil = FormatUtil;
exports.default = {
    ResponseUtil,
    ValidationUtil,
    FormatUtil,
};

/* Fin backend\dist\utils\index.js */

/* Inicio backend\jest.unit.config.js */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src', '<rootDir>/tests'],
  testMatch: ['**/__tests__*.ts', '**/?(*.)+(spec|test).ts'],
  transform: {
    '^.+\\.ts$': ['ts-jest', { tsconfig: 'tsconfig.test.json' }]
  },
  setupFilesAfterEnv: [],
  collectCoverageFrom: [],
  moduleFileExtensions: ['ts', 'js', 'json'],
  extensionsToTreatAsEsm: [],
};
/* Fin backend\jest.unit.config.js */

/* Inicio backend\prisma\seed.js */


const { PrismaClient } = require('@prisma/client');
const bcrypt = require('bcryptjs');

const prisma = new PrismaClient();

async function main() {
  console.log('ðŸš€ Iniciando seed maestro v2 para AsistApp...');

  console.log('ðŸ§¹ Limpiando base de datos...');
  await prisma.asistencia.deleteMany();
  await prisma.horario.deleteMany();
  await prisma.estudianteGrupo.deleteMany();
  await prisma.materia.deleteMany();
  await prisma.grupo.deleteMany();
  await prisma.periodoAcademico.deleteMany();
  await prisma.usuarioInstitucion.deleteMany();
  await prisma.estudiante.deleteMany();
  await prisma.usuario.deleteMany();
  await prisma.institucion.deleteMany();
  console.log('âœ… Base de datos limpia.');

  console.log('ðŸ« Creando instituciones...');
  const sanJose = await prisma.institucion.create({
    data: {
      nombre: 'Colegio San JosÃ©',
      activa: true,
    },
  });

  const santander = await prisma.institucion.create({
    data: {
      nombre: 'IE Santander',
      activa: true,
    },
  });

  const inactiva = await prisma.institucion.create({
    data: {
      nombre: 'Liceo del Pasado (Inactivo)',
      activa: false,
    },
  });
  console.log('âœ… Instituciones creadas.');

  console.log('ðŸ“… Creando periodos acadÃ©micos...');
  const periodoSanJose = await prisma.periodoAcademico.create({
    data: {
      nombre: 'AÃ±o Lectivo 2025',
      fechaInicio: new Date('2025-01-20'),
      fechaFin: new Date('2025-11-28'),
      activo: true,
      institucionId: sanJose.id,
    },
  });

  const periodoSantander = await prisma.periodoAcademico.create({
    data: {
      nombre: 'Semestre 2025-1',
      fechaInicio: new Date('2025-02-01'),
      fechaFin: new Date('2025-06-15'),
      activo: true,
      institucionId: santander.id,
    },
  });
  console.log('âœ… Periodos acadÃ©micos creados.');

  console.log('ðŸ‘¥ Creando usuarios (admins, profesores, estudiantes)...');
  const hash = (pass: string) => bcrypt.hashSync(pass, 10);

  const usuarios = await prisma.usuario.createMany({
    data: [

      { email: 'superadmin@asistapp.com', passwordHash: hash('Admin123!'), nombres: 'Super', apellidos: 'Admin', rol: 'super_admin', activo: true },
      { email: 'admin@sanjose.edu', passwordHash: hash('SanJose123!'), nombres: 'Ana', apellidos: 'LÃ³pez', rol: 'admin_institucion', activo: true },
      { email: 'admin@santander.edu', passwordHash: hash('Santander123!'), nombres: 'Luis', apellidos: 'Rojas', rol: 'admin_institucion', activo: true },
      { email: 'multiadmin@asistapp.com', passwordHash: hash('Multi123!'), nombres: 'Pedro', apellidos: 'PÃ¡ramo', rol: 'admin_institucion', activo: true },

      { email: 'juan.perez@sanjose.edu', passwordHash: hash('Prof123!'), nombres: 'Juan', apellidos: 'PÃ©rez', rol: 'profesor', activo: true },
      { email: 'laura.gomez@sanjose.edu', passwordHash: hash('Prof123!'), nombres: 'Laura', apellidos: 'GÃ³mez', rol: 'profesor', activo: true },
      { email: 'vacio.profe@sanjose.edu', passwordHash: hash('Prof123!'), nombres: 'Profe', apellidos: 'Sin Clases', rol: 'profesor', activo: true },

      { email: 'carlos.diaz@santander.edu', passwordHash: hash('Prof123!'), nombres: 'Carlos', apellidos: 'DÃ­az', rol: 'profesor', activo: true },

      { email: 'santiago.mendoza@sanjose.edu', passwordHash: hash('Est123!'), nombres: 'Santiago', apellidos: 'Mendoza', rol: 'estudiante', activo: true },
      { email: 'valentina.rojas@sanjose.edu', passwordHash: hash('Est123!'), nombres: 'Valentina', apellidos: 'Rojas', rol: 'estudiante', activo: true },
      { email: 'mateo.castro@sanjose.edu', passwordHash: hash('Est123!'), nombres: 'Mateo', apellidos: 'Castro', rol: 'estudiante', activo: true },
      { email: 'camila.ortiz@sanjose.edu', passwordHash: hash('Est123!'), nombres: 'Camila', apellidos: 'Ortiz', rol: 'estudiante', activo: true },

      { email: 'sofia.nunez@santander.edu', passwordHash: hash('Est123!'), nombres: 'SofÃ­a', apellidos: 'NÃºÃ±ez', rol: 'estudiante', activo: true },
    ],
  });
  console.log(`âœ… ${usuarios.count} usuarios creados.`);

  const findUser = async (email: string) => (await prisma.usuario.findUnique({ where: { email } }))!;

  const superAdmin = await findUser('superadmin@asistapp.com');
  const adminSanJose = await findUser('admin@sanjose.edu');
  const adminSantander = await findUser('admin@santander.edu');
  const multiAdmin = await findUser('multiadmin@asistapp.com');
  const profJuan = await findUser('juan.perez@sanjose.edu');
  const profLaura = await findUser('laura.gomez@sanjose.edu');
  const profVacio = await findUser('vacio.profe@sanjose.edu');
  const profCarlos = await findUser('carlos.diaz@santander.edu');
  const estSantiago = await findUser('santiago.mendoza@sanjose.edu');
  const estValentina = await findUser('valentina.rojas@sanjose.edu');
  const estMateo = await findUser('mateo.castro@sanjose.edu');
  const estCamila = await findUser('camila.ortiz@sanjose.edu');
  const estSofia = await findUser('sofia.nunez@santander.edu');

  console.log('ðŸ”— Vinculando usuarios a instituciones...');
  await prisma.usuarioInstitucion.createMany({
    data: [
      { usuarioId: adminSanJose.id, institucionId: sanJose.id, rolEnInstitucion: 'admin' },
      { usuarioId: adminSantander.id, institucionId: santander.id, rolEnInstitucion: 'admin' },
      { usuarioId: multiAdmin.id, institucionId: sanJose.id, rolEnInstitucion: 'admin' },
      { usuarioId: multiAdmin.id, institucionId: santander.id, rolEnInstitucion: 'admin' },
      { usuarioId: profJuan.id, institucionId: sanJose.id, rolEnInstitucion: 'profesor' },
      { usuarioId: profLaura.id, institucionId: sanJose.id, rolEnInstitucion: 'profesor' },
      { usuarioId: profVacio.id, institucionId: sanJose.id, rolEnInstitucion: 'profesor' },
      { usuarioId: profCarlos.id, institucionId: santander.id, rolEnInstitucion: 'profesor' },
      { usuarioId: estSantiago.id, institucionId: sanJose.id, rolEnInstitucion: 'estudiante' },
      { usuarioId: estValentina.id, institucionId: sanJose.id, rolEnInstitucion: 'estudiante' },
      { usuarioId: estMateo.id, institucionId: sanJose.id, rolEnInstitucion: 'estudiante' },
      { usuarioId: estCamila.id, institucionId: sanJose.id, rolEnInstitucion: 'estudiante' },
      { usuarioId: estSofia.id, institucionId: santander.id, rolEnInstitucion: 'estudiante' },
    ],
  });
  console.log('âœ… VÃ­nculos creados.');

  console.log('ðŸ‘¨â€ðŸŽ“ Creando perfiles de estudiante...');
  const estudiantes = await prisma.estudiante.createMany({
    data: [
      { usuarioId: estSantiago.id, identificacion: '1001', codigoQr: 'QR-SANTIAGO' },
      { usuarioId: estValentina.id, identificacion: '1002', codigoQr: 'QR-VALENTINA' },
      { usuarioId: estMateo.id, identificacion: '1003', codigoQr: 'QR-MATEO' },
      { usuarioId: estCamila.id, identificacion: '1004', codigoQr: 'QR-CAMILA' },
      { usuarioId: estSofia.id, identificacion: '2001', codigoQr: 'QR-SOFIA' },
    ],
  });
  console.log(`âœ… ${estudiantes.count} perfiles de estudiante creados.`);
  const santiago = (await prisma.estudiante.findUnique({where: {usuarioId: estSantiago.id}}))!;
  const valentina = (await prisma.estudiante.findUnique({where: {usuarioId: estValentina.id}}))!;
  const mateo = (await prisma.estudiante.findUnique({where: {usuarioId: estMateo.id}}))!;
  const camila = (await prisma.estudiante.findUnique({where: {usuarioId: estCamila.id}}))!;
  const sofia = (await prisma.estudiante.findUnique({where: {usuarioId: estSofia.id}}))!;

  console.log('ðŸ“š Creando grupos y materias...');
  const grupo10A = await prisma.grupo.create({ data: { nombre: 'DÃ©cimo A', grado: '10', seccion: 'A', periodoId: periodoSanJose.id, institucionId: sanJose.id } });
  const grupo11B = await prisma.grupo.create({ data: { nombre: 'Once B', grado: '11', seccion: 'B', periodoId: periodoSanJose.id, institucionId: sanJose.id } });
  const grupo6_1 = await prisma.grupo.create({ data: { nombre: 'Sexto Uno', grado: '6', seccion: '1', periodoId: periodoSantander.id, institucionId: santander.id } });

  const mat = await prisma.materia.create({ data: { nombre: 'MatemÃ¡ticas', institucionId: sanJose.id } });
  const fis = await prisma.materia.create({ data: { nombre: 'FÃ­sica', institucionId: sanJose.id } });
  const qui = await prisma.materia.create({ data: { nombre: 'QuÃ­mica', institucionId: sanJose.id } });
  const esp = await prisma.materia.create({ data: { nombre: 'EspaÃ±ol', institucionId: santander.id } });
  const ing = await prisma.materia.create({ data: { nombre: 'InglÃ©s', institucionId: santander.id } });
  console.log('âœ… Grupos y materias creados.');

  console.log('ðŸ”— Asignando estudiantes a grupos...');
  await prisma.estudianteGrupo.createMany({
    data: [
      { estudianteId: santiago.id, grupoId: grupo10A.id },
      { estudianteId: valentina.id, grupoId: grupo10A.id },
      { estudianteId: mateo.id, grupoId: grupo11B.id },
      { estudianteId: camila.id, grupoId: grupo11B.id },
      { estudianteId: sofia.id, grupoId: grupo6_1.id },
    ],
  });
  console.log('âœ… Estudiantes asignados.');

  console.log('ðŸ“… Creando horarios...');
  await prisma.horario.createMany({
    data: [

      { diaSemana: 1, horaInicio: '07:00', horaFin: '08:00', materiaId: mat.id, profesorId: profJuan.id, grupoId: grupo10A.id, periodoId: periodoSanJose.id, institucionId: sanJose.id },
      { diaSemana: 1, horaInicio: '08:00', horaFin: '09:00', materiaId: fis.id, profesorId: profLaura.id, grupoId: grupo10A.id, periodoId: periodoSanJose.id, institucionId: sanJose.id },
      { diaSemana: 3, horaInicio: '10:00', horaFin: '11:00', materiaId: mat.id, profesorId: profJuan.id, grupoId: grupo10A.id, periodoId: periodoSanJose.id, institucionId: sanJose.id },

      { diaSemana: 2, horaInicio: '09:00', horaFin: '10:00', materiaId: qui.id, profesorId: profLaura.id, grupoId: grupo11B.id, periodoId: periodoSanJose.id, institucionId: sanJose.id },

      { diaSemana: 4, horaInicio: '11:00', horaFin: '12:00', materiaId: esp.id, profesorId: profCarlos.id, grupoId: grupo6_1.id, periodoId: periodoSantander.id, institucionId: santander.id },
      { diaSemana: 5, horaInicio: '11:00', horaFin: '12:00', materiaId: ing.id, profesorId: profCarlos.id, grupoId: grupo6_1.id, periodoId: periodoSantander.id, institucionId: santander.id },
    ],
  });
  console.log('âœ… Horarios creados.');

  console.log('\nðŸŽ‰ Seed maestro completado exitosamente!');
}

main()
  .catch((e) => {
    console.error('âŒ Error durante el seed:', e);
    throw e;
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

/* Fin backend\prisma\seed.js */

/* Inicio backend\prisma\seed.ts */


const { PrismaClient } = require('@prisma/client');
const bcrypt = require('bcryptjs');

const prisma = new PrismaClient();

async function main() {
  console.log('ðŸš€ Iniciando seed maestro v2 para AsistApp...');

  console.log('ðŸ§¹ Limpiando base de datos...');
  await prisma.asistencia.deleteMany();
  await prisma.horario.deleteMany();
  await prisma.estudianteGrupo.deleteMany();
  await prisma.materia.deleteMany();
  await prisma.grupo.deleteMany();
  await prisma.periodoAcademico.deleteMany();
  await prisma.usuarioInstitucion.deleteMany();
  await prisma.estudiante.deleteMany();
  await prisma.usuario.deleteMany();
  await prisma.institucion.deleteMany();
  console.log('âœ… Base de datos limpia.');

  console.log('ðŸ« Creando instituciones...');
  const sanJose = await prisma.institucion.create({
    data: {
      nombre: 'Colegio San JosÃ©',
      activa: true,
    },
  });

  const santander = await prisma.institucion.create({
    data: {
      nombre: 'IE Santander',
      activa: true,
    },
  });

  const inactiva = await prisma.institucion.create({
    data: {
      nombre: 'Liceo del Pasado (Inactivo)',
      activa: false,
    },
  });
  console.log('âœ… Instituciones creadas.');

  console.log('ðŸ“… Creando periodos acadÃ©micos...');
  const periodoSanJose = await prisma.periodoAcademico.create({
    data: {
      nombre: 'AÃ±o Lectivo 2025',
      fechaInicio: new Date('2025-01-20'),
      fechaFin: new Date('2025-11-28'),
      activo: true,
      institucionId: sanJose.id,
    },
  });

  const periodoSantander = await prisma.periodoAcademico.create({
    data: {
      nombre: 'Semestre 2025-1',
      fechaInicio: new Date('2025-02-01'),
      fechaFin: new Date('2025-06-15'),
      activo: true,
      institucionId: santander.id,
    },
  });
  console.log('âœ… Periodos acadÃ©micos creados.');

  console.log('ðŸ‘¥ Creando usuarios (admins, profesores, estudiantes)...');
  const hash = (pass: string) => bcrypt.hashSync(pass, 10);

  const usuarios = await prisma.usuario.createMany({
    data: [

      { email: 'superadmin@asistapp.com', passwordHash: hash('Admin123!'), nombres: 'Super', apellidos: 'Admin', rol: 'super_admin', activo: true },
      { email: 'admin@sanjose.edu', passwordHash: hash('SanJose123!'), nombres: 'Ana', apellidos: 'LÃ³pez', rol: 'admin_institucion', activo: true },
      { email: 'admin@santander.edu', passwordHash: hash('Santander123!'), nombres: 'Luis', apellidos: 'Rojas', rol: 'admin_institucion', activo: true },
      { email: 'multiadmin@asistapp.com', passwordHash: hash('Multi123!'), nombres: 'Pedro', apellidos: 'PÃ¡ramo', rol: 'admin_institucion', activo: true },

      { email: 'juan.perez@sanjose.edu', passwordHash: hash('Prof123!'), nombres: 'Juan', apellidos: 'PÃ©rez', rol: 'profesor', activo: true },
      { email: 'laura.gomez@sanjose.edu', passwordHash: hash('Prof123!'), nombres: 'Laura', apellidos: 'GÃ³mez', rol: 'profesor', activo: true },
      { email: 'vacio.profe@sanjose.edu', passwordHash: hash('Prof123!'), nombres: 'Profe', apellidos: 'Sin Clases', rol: 'profesor', activo: true },

      { email: 'carlos.diaz@santander.edu', passwordHash: hash('Prof123!'), nombres: 'Carlos', apellidos: 'DÃ­az', rol: 'profesor', activo: true },

      { email: 'santiago.mendoza@sanjose.edu', passwordHash: hash('Est123!'), nombres: 'Santiago', apellidos: 'Mendoza', rol: 'estudiante', activo: true },
      { email: 'valentina.rojas@sanjose.edu', passwordHash: hash('Est123!'), nombres: 'Valentina', apellidos: 'Rojas', rol: 'estudiante', activo: true },
      { email: 'mateo.castro@sanjose.edu', passwordHash: hash('Est123!'), nombres: 'Mateo', apellidos: 'Castro', rol: 'estudiante', activo: true },
      { email: 'camila.ortiz@sanjose.edu', passwordHash: hash('Est123!'), nombres: 'Camila', apellidos: 'Ortiz', rol: 'estudiante', activo: true },

      { email: 'sofia.nunez@santander.edu', passwordHash: hash('Est123!'), nombres: 'SofÃ­a', apellidos: 'NÃºÃ±ez', rol: 'estudiante', activo: true },
    ],
  });
  console.log(`âœ… ${usuarios.count} usuarios creados.`);

  const findUser = async (email: string) => (await prisma.usuario.findUnique({ where: { email } }))!;

  const superAdmin = await findUser('superadmin@asistapp.com');
  const adminSanJose = await findUser('admin@sanjose.edu');
  const adminSantander = await findUser('admin@santander.edu');
  const multiAdmin = await findUser('multiadmin@asistapp.com');
  const profJuan = await findUser('juan.perez@sanjose.edu');
  const profLaura = await findUser('laura.gomez@sanjose.edu');
  const profVacio = await findUser('vacio.profe@sanjose.edu');
  const profCarlos = await findUser('carlos.diaz@santander.edu');
  const estSantiago = await findUser('santiago.mendoza@sanjose.edu');
  const estValentina = await findUser('valentina.rojas@sanjose.edu');
  const estMateo = await findUser('mateo.castro@sanjose.edu');
  const estCamila = await findUser('camila.ortiz@sanjose.edu');
  const estSofia = await findUser('sofia.nunez@santander.edu');

  console.log('ðŸ”— Vinculando usuarios a instituciones...');
  await prisma.usuarioInstitucion.createMany({
    data: [
      { usuarioId: adminSanJose.id, institucionId: sanJose.id, rolEnInstitucion: 'admin' },
      { usuarioId: adminSantander.id, institucionId: santander.id, rolEnInstitucion: 'admin' },
      { usuarioId: multiAdmin.id, institucionId: sanJose.id, rolEnInstitucion: 'admin' },
      { usuarioId: multiAdmin.id, institucionId: santander.id, rolEnInstitucion: 'admin' },
      { usuarioId: profJuan.id, institucionId: sanJose.id, rolEnInstitucion: 'profesor' },
      { usuarioId: profLaura.id, institucionId: sanJose.id, rolEnInstitucion: 'profesor' },
      { usuarioId: profVacio.id, institucionId: sanJose.id, rolEnInstitucion: 'profesor' },
      { usuarioId: profCarlos.id, institucionId: santander.id, rolEnInstitucion: 'profesor' },
      { usuarioId: estSantiago.id, institucionId: sanJose.id, rolEnInstitucion: 'estudiante' },
      { usuarioId: estValentina.id, institucionId: sanJose.id, rolEnInstitucion: 'estudiante' },
      { usuarioId: estMateo.id, institucionId: sanJose.id, rolEnInstitucion: 'estudiante' },
      { usuarioId: estCamila.id, institucionId: sanJose.id, rolEnInstitucion: 'estudiante' },
      { usuarioId: estSofia.id, institucionId: santander.id, rolEnInstitucion: 'estudiante' },
    ],
  });
  console.log('âœ… VÃ­nculos creados.');

  console.log('ðŸ‘¨â€ðŸŽ“ Creando perfiles de estudiante...');
  const estudiantes = await prisma.estudiante.createMany({
    data: [
      { usuarioId: estSantiago.id, identificacion: '1001', codigoQr: 'QR-SANTIAGO' },
      { usuarioId: estValentina.id, identificacion: '1002', codigoQr: 'QR-VALENTINA' },
      { usuarioId: estMateo.id, identificacion: '1003', codigoQr: 'QR-MATEO' },
      { usuarioId: estCamila.id, identificacion: '1004', codigoQr: 'QR-CAMILA' },
      { usuarioId: estSofia.id, identificacion: '2001', codigoQr: 'QR-SOFIA' },
    ],
  });
  console.log(`âœ… ${estudiantes.count} perfiles de estudiante creados.`);
  const santiago = (await prisma.estudiante.findUnique({where: {usuarioId: estSantiago.id}}))!;
  const valentina = (await prisma.estudiante.findUnique({where: {usuarioId: estValentina.id}}))!;
  const mateo = (await prisma.estudiante.findUnique({where: {usuarioId: estMateo.id}}))!;
  const camila = (await prisma.estudiante.findUnique({where: {usuarioId: estCamila.id}}))!;
  const sofia = (await prisma.estudiante.findUnique({where: {usuarioId: estSofia.id}}))!;

  console.log('ðŸ“š Creando grupos y materias...');
  const grupo10A = await prisma.grupo.create({ data: { nombre: 'DÃ©cimo A', grado: '10', seccion: 'A', periodoId: periodoSanJose.id, institucionId: sanJose.id } });
  const grupo11B = await prisma.grupo.create({ data: { nombre: 'Once B', grado: '11', seccion: 'B', periodoId: periodoSanJose.id, institucionId: sanJose.id } });
  const grupo6_1 = await prisma.grupo.create({ data: { nombre: 'Sexto Uno', grado: '6', seccion: '1', periodoId: periodoSantander.id, institucionId: santander.id } });

  const mat = await prisma.materia.create({ data: { nombre: 'MatemÃ¡ticas', institucionId: sanJose.id } });
  const fis = await prisma.materia.create({ data: { nombre: 'FÃ­sica', institucionId: sanJose.id } });
  const qui = await prisma.materia.create({ data: { nombre: 'QuÃ­mica', institucionId: sanJose.id } });
  const esp = await prisma.materia.create({ data: { nombre: 'EspaÃ±ol', institucionId: santander.id } });
  const ing = await prisma.materia.create({ data: { nombre: 'InglÃ©s', institucionId: santander.id } });
  console.log('âœ… Grupos y materias creados.');

  console.log('ðŸ”— Asignando estudiantes a grupos...');
  await prisma.estudianteGrupo.createMany({
    data: [
      { estudianteId: santiago.id, grupoId: grupo10A.id },
      { estudianteId: valentina.id, grupoId: grupo10A.id },
      { estudianteId: mateo.id, grupoId: grupo11B.id },
      { estudianteId: camila.id, grupoId: grupo11B.id },
      { estudianteId: sofia.id, grupoId: grupo6_1.id },
    ],
  });
  console.log('âœ… Estudiantes asignados.');

  console.log('ðŸ“… Creando horarios...');
  await prisma.horario.createMany({
    data: [

      { diaSemana: 1, horaInicio: '07:00', horaFin: '08:00', materiaId: mat.id, profesorId: profJuan.id, grupoId: grupo10A.id, periodoId: periodoSanJose.id, institucionId: sanJose.id },
      { diaSemana: 1, horaInicio: '08:00', horaFin: '09:00', materiaId: fis.id, profesorId: profLaura.id, grupoId: grupo10A.id, periodoId: periodoSanJose.id, institucionId: sanJose.id },
      { diaSemana: 3, horaInicio: '10:00', horaFin: '11:00', materiaId: mat.id, profesorId: profJuan.id, grupoId: grupo10A.id, periodoId: periodoSanJose.id, institucionId: sanJose.id },

      { diaSemana: 2, horaInicio: '09:00', horaFin: '10:00', materiaId: qui.id, profesorId: profLaura.id, grupoId: grupo11B.id, periodoId: periodoSanJose.id, institucionId: sanJose.id },

      { diaSemana: 4, horaInicio: '11:00', horaFin: '12:00', materiaId: esp.id, profesorId: profCarlos.id, grupoId: grupo6_1.id, periodoId: periodoSantander.id, institucionId: santander.id },
      { diaSemana: 5, horaInicio: '11:00', horaFin: '12:00', materiaId: ing.id, profesorId: profCarlos.id, grupoId: grupo6_1.id, periodoId: periodoSantander.id, institucionId: santander.id },
    ],
  });
  console.log('âœ… Horarios creados.');

  console.log('\nðŸŽ‰ Seed maestro completado exitosamente!');
}

main()
  .catch((e) => {
    console.error('âŒ Error durante el seed:', e);
    throw e;
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

/* Fin backend\prisma\seed.ts */

/* Inicio backend\setup-test-data.ts */
#!/usr/bin/env ts-node

import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';

const prisma = new PrismaClient();

async function setupCompleteTestData() {
  console.log('ðŸš€ Iniciando setup completo de datos de prueba...\n');

  try {
    console.log('ðŸ« FASE 1: Creando instituciones...');

    const instituciones = [
      {
        nombre: 'Colegio San JosÃ©',
        direccion: 'Calle 123 #45-67, BogotÃ¡',
        email: 'admin@sanjose.edu',
        telefono: '555-0101',
        activa: true,
      },
      {
        nombre: 'Liceo Nacional',
        direccion: 'Carrera 10 #20-30, MedellÃ­n',
        email: 'admin@liceonacional.edu',
        telefono: '555-0202',
        activa: true,
      },
      {
        nombre: 'Instituto TecnolÃ³gico',
        direccion: 'Avenida Siempre Viva 742, Cali',
        email: 'admin@institutotecnologico.edu',
        telefono: '555-0303',
        activa: false, // InstituciÃ³n inactiva para pruebas
      },
    ];

    const institucionesCreadas: any[] = [];
    for (const instData of instituciones) {
      let institucion = await prisma.institucion.findFirst({
        where: { nombre: instData.nombre }
      });

      if (!institucion) {
        institucion = await prisma.institucion.create({ data: instData });
        console.log(`   âœ… InstituciÃ³n creada: ${instData.nombre}`);
      } else {
        console.log(`   âœ… InstituciÃ³n ya existe: ${instData.nombre}`);
      }
      institucionesCreadas.push(institucion);
    }
    console.log('\nðŸ“… FASE 2: Creando periodos acadÃ©micos...');

    const periodos = [];
    for (const institucion of institucionesCreadas.filter(i => i.activa)) {
      let periodo = await prisma.periodoAcademico.findFirst({
        where: {
          institucionId: institucion.id,
          activo: true
        }
      });

      if (!periodo) {
        const fechaInicio = new Date();
        const fechaFin = new Date();
        fechaFin.setMonth(fechaFin.getMonth() + 6);

        periodo = await prisma.periodoAcademico.create({
          data: {
            nombre: `Periodo ${new Date().getFullYear()}-1`,
            fechaInicio,
            fechaFin,
            activo: true,
            institucionId: institucion.id,
          },
        });
        console.log(`   âœ… Periodo creado para ${institucion.nombre}`);
      } else {
        console.log(`   âœ… Periodo ya existe para ${institucion.nombre}`);
      }
      periodos.push({ institucion, periodo });
    }
    console.log('\nðŸ‘¥ FASE 3: Creando usuarios completos...');
    const superAdminPassword = await bcrypt.hash('SuperAdmin123!', 10);
    const superAdmin = await prisma.usuario.upsert({
      where: { email: 'superadmin@asistapp.com' },
      update: { passwordHash: superAdminPassword },
      create: {
        email: 'superadmin@asistapp.com',
        passwordHash: superAdminPassword,
        nombres: 'Super',
        apellidos: 'Admin',
        rol: 'super_admin',
        activo: true,
      },
    });
    console.log('   âœ… Super Admin creado');
    const adminsData = [
      { email: 'admin@sanjose.edu', nombres: 'MarÃ­a', apellidos: 'GonzÃ¡lez', institucion: institucionesCreadas[0] },
      { email: 'admin@liceonacional.edu', nombres: 'Carlos', apellidos: 'RodrÃ­guez', institucion: institucionesCreadas[1] },
    ];

    const admins = [];
    for (const adminData of adminsData) {
      const adminPassword = await bcrypt.hash('Admin123!', 10);
      const admin = await prisma.usuario.upsert({
        where: { email: adminData.email },
        update: { passwordHash: adminPassword },
        create: {
          email: adminData.email,
          passwordHash: adminPassword,
          nombres: adminData.nombres,
          apellidos: adminData.apellidos,
          rol: 'admin_institucion',
          activo: true,
        },
      });

      await prisma.usuarioInstitucion.upsert({
        where: {
          usuarioId_institucionId: {
            usuarioId: admin.id,
            institucionId: adminData.institucion.id
          }
        },
        update: {},
        create: {
          usuarioId: admin.id,
          institucionId: adminData.institucion.id,
          rolEnInstitucion: 'admin'
        }
      });

      admins.push(admin);
      console.log(`   âœ… Admin creado: ${adminData.email}`);
    }
    const profesoresData = [
      { email: 'ana.lopez@sanjose.edu', nombres: 'Ana', apellidos: 'LÃ³pez', institucion: institucionesCreadas[0] },
      { email: 'pedro.garcia@sanjose.edu', nombres: 'Pedro', apellidos: 'GarcÃ­a', institucion: institucionesCreadas[0] },
      { email: 'maria.rodriguez@sanjose.edu', nombres: 'MarÃ­a', apellidos: 'RodrÃ­guez', institucion: institucionesCreadas[0] },
      { email: 'juan.martinez@liceonacional.edu', nombres: 'Juan', apellidos: 'MartÃ­nez', institucion: institucionesCreadas[1] },
      { email: 'laura.sanchez@liceonacional.edu', nombres: 'Laura', apellidos: 'SÃ¡nchez', institucion: institucionesCreadas[1] },
    ];

    const profesores = [];
    for (const profData of profesoresData) {
      const profPassword = await bcrypt.hash('Prof123!', 10);
      const profesor = await prisma.usuario.upsert({
        where: { email: profData.email },
        update: { passwordHash: profPassword },
        create: {
          email: profData.email,
          passwordHash: profPassword,
          nombres: profData.nombres,
          apellidos: profData.apellidos,
          rol: 'profesor',
          activo: true,
        },
      });

      await prisma.usuarioInstitucion.upsert({
        where: {
          usuarioId_institucionId: {
            usuarioId: profesor.id,
            institucionId: profData.institucion.id
          }
        },
        update: {},
        create: {
          usuarioId: profesor.id,
          institucionId: profData.institucion.id,
          rolEnInstitucion: 'profesor'
        }
      });

      profesores.push(profesor);
      console.log(`   âœ… Profesor creado: ${profData.email}`);
    }
    const estudiantesData = [
      { email: 'juan.perez@sanjose.edu', nombres: 'Juan', apellidos: 'PÃ©rez', institucion: institucionesCreadas[0] },
      { email: 'maria.gomez@sanjose.edu', nombres: 'MarÃ­a', apellidos: 'GÃ³mez', institucion: institucionesCreadas[0] },
      { email: 'carlos.lopez@sanjose.edu', nombres: 'Carlos', apellidos: 'LÃ³pez', institucion: institucionesCreadas[0] },
      { email: 'ana.martinez@sanjose.edu', nombres: 'Ana', apellidos: 'MartÃ­nez', institucion: institucionesCreadas[0] },
      { email: 'luis.rodriguez@sanjose.edu', nombres: 'Luis', apellidos: 'RodrÃ­guez', institucion: institucionesCreadas[0] },
      { email: 'sofia.garcia@liceonacional.edu', nombres: 'SofÃ­a', apellidos: 'GarcÃ­a', institucion: institucionesCreadas[1] },
      { email: 'mateo.silva@liceonacional.edu', nombres: 'Mateo', apellidos: 'Silva', institucion: institucionesCreadas[1] },
      { email: 'valentina.moreno@liceonacional.edu', nombres: 'Valentina', apellidos: 'Moreno', institucion: institucionesCreadas[1] },
    ];

    const estudiantes = [];
    for (let i = 0; i < estudiantesData.length; i++) {
      const estData = estudiantesData[i];
      const estPassword = await bcrypt.hash('Est123!', 10);
      const estudianteUsuario = await prisma.usuario.upsert({
        where: { email: estData.email },
        update: { passwordHash: estPassword },
        create: {
          email: estData.email,
          passwordHash: estPassword,
          nombres: estData.nombres,
          apellidos: estData.apellidos,
          rol: 'estudiante',
          activo: true,
        },
      });

      await prisma.usuarioInstitucion.upsert({
        where: {
          usuarioId_institucionId: {
            usuarioId: estudianteUsuario.id,
            institucionId: estData.institucion.id
          }
        },
        update: {},
        create: {
          usuarioId: estudianteUsuario.id,
          institucionId: estData.institucion.id,
          rolEnInstitucion: 'estudiante'
        }
      });

      const estudiante = await prisma.estudiante.upsert({
        where: { usuarioId: estudianteUsuario.id },
        update: {},
        create: {
          usuarioId: estudianteUsuario.id,
          identificacion: `ID${String(i + 1).padStart(3, '0')}`,
          codigoQr: `QR${String(i + 1).padStart(3, '0')}`,
          nombreResponsable: `Responsable ${estData.apellidos.split(' ')[0]}`,
          telefonoResponsable: `300-111-${String(i + 1).padStart(4, '0')}`,
        },
      });

      estudiantes.push({ usuario: estudianteUsuario, estudiante });
      console.log(`   âœ… Estudiante creado: ${estData.email}`);
    }
    console.log('\nðŸ“š FASE 4: Creando materias...');

    const materiasData = [
      { nombre: 'MatemÃ¡ticas', codigo: 'MAT101', institucion: institucionesCreadas[0] },
      { nombre: 'FÃ­sica', codigo: 'FIS101', institucion: institucionesCreadas[0] },
      { nombre: 'QuÃ­mica', codigo: 'QUI101', institucion: institucionesCreadas[0] },
      { nombre: 'BiologÃ­a', codigo: 'BIO101', institucion: institucionesCreadas[0] },
      { nombre: 'Historia', codigo: 'HIS101', institucion: institucionesCreadas[0] },
      { nombre: 'EspaÃ±ol', codigo: 'ESP101', institucion: institucionesCreadas[1] },
      { nombre: 'InglÃ©s', codigo: 'ING101', institucion: institucionesCreadas[1] },
      { nombre: 'ProgramaciÃ³n', codigo: 'PRO101', institucion: institucionesCreadas[1] },
    ];

    const materias = [];
    for (const matData of materiasData) {
      const existingMateria = await prisma.materia.findFirst({
        where: {
          nombre: matData.nombre,
          institucionId: matData.institucion.id
        }
      });

      if (!existingMateria) {
        const materia = await prisma.materia.create({
          data: {
            nombre: matData.nombre,
            codigo: matData.codigo,
            institucionId: matData.institucion.id,
          },
        });
        materias.push(materia);
        console.log(`   âœ… Materia creada: ${matData.nombre} (${matData.institucion.nombre})`);
      } else {
        materias.push(existingMateria);
        console.log(`   âœ… Materia ya existe: ${matData.nombre}`);
      }
    }
    console.log('\nðŸ« FASE 5: Creando grupos...');

    const gruposData = [];
    for (const { institucion, periodo } of periodos) {
      const gruposInstitucion = [
        { nombre: 'Grupo A', grado: '1ro', seccion: 'A' },
        { nombre: 'Grupo B', grado: '1ro', seccion: 'B' },
        { nombre: 'Grupo C', grado: '2do', seccion: 'A' },
        { nombre: 'Grupo D', grado: '2do', seccion: 'B' },
      ];

      for (const grupoData of gruposInstitucion) {
        const existingGrupo = await prisma.grupo.findFirst({
          where: {
            nombre: grupoData.nombre,
            institucionId: institucion.id
          }
        });

        if (!existingGrupo) {
          const grupo = await prisma.grupo.create({
            data: {
              nombre: grupoData.nombre,
              grado: grupoData.grado,
              seccion: grupoData.seccion,
              periodoId: periodo.id,
              institucionId: institucion.id,
            },
          });
          gruposData.push(grupo);
          console.log(`   âœ… Grupo creado: ${grupoData.nombre} (${institucion.nombre})`);
        } else {
          gruposData.push(existingGrupo);
          console.log(`   âœ… Grupo ya existe: ${grupoData.nombre}`);
        }
      }
    }
    console.log('\nðŸ‘¨â€ðŸŽ“ FASE 6: Asignando estudiantes a grupos...');
    const grupoSanJoseA = gruposData.find(g => g.nombre === 'Grupo A' && g.institucionId === institucionesCreadas[0].id);
    if (grupoSanJoseA) {
      for (let i = 0; i < 3; i++) {
        const estudiante = estudiantes[i];
        if (estudiante) {
          const existingAsignacion = await prisma.estudianteGrupo.findFirst({
            where: {
              estudianteId: estudiante.estudiante.id,
              grupoId: grupoSanJoseA.id
            }
          });

          if (!existingAsignacion) {
            await prisma.estudianteGrupo.create({
              data: {
                estudianteId: estudiante.estudiante.id,
                grupoId: grupoSanJoseA.id,
              },
            });
          }
          console.log(`   âœ… Estudiante ${estudiante.usuario.email} asignado a ${grupoSanJoseA.nombre}`);
        }
      }
    }
    const grupoSanJoseB = gruposData.find(g => g.nombre === 'Grupo B' && g.institucionId === institucionesCreadas[0].id);
    if (grupoSanJoseB) {
      for (let i = 3; i < 5; i++) {
        const estudiante = estudiantes[i];
        if (estudiante) {
          const existingAsignacion = await prisma.estudianteGrupo.findFirst({
            where: {
              estudianteId: estudiante.estudiante.id,
              grupoId: grupoSanJoseB.id
            }
          });

          if (!existingAsignacion) {
            await prisma.estudianteGrupo.create({
              data: {
                estudianteId: estudiante.estudiante.id,
                grupoId: grupoSanJoseB.id,
              },
            });
          }
          console.log(`   âœ… Estudiante ${estudiante.usuario.email} asignado a ${grupoSanJoseB.nombre}`);
        }
      }
    }
    const grupoLiceoA = gruposData.find(g => g.nombre === 'Grupo A' && g.institucionId === institucionesCreadas[1].id);
    if (grupoLiceoA) {
      for (let i = 5; i < 8; i++) {
        const estudiante = estudiantes[i];
        if (estudiante) {
          const existingAsignacion = await prisma.estudianteGrupo.findFirst({
            where: {
              estudianteId: estudiante.estudiante.id,
              grupoId: grupoLiceoA.id
            }
          });

          if (!existingAsignacion) {
            await prisma.estudianteGrupo.create({
              data: {
                estudianteId: estudiante.estudiante.id,
                grupoId: grupoLiceoA.id,
              },
            });
          }
          console.log(`   âœ… Estudiante ${estudiante.usuario.email} asignado a ${grupoLiceoA.nombre}`);
        }
      }
    }
    console.log('\nðŸ“… FASE 7: Creando horarios completos...');
    const horariosSanJose = [
      { grupo: grupoSanJoseA, materia: materias[0], profesor: profesores[0], diaSemana: 1, horaInicio: '08:00', horaFin: '09:00' },
      { grupo: grupoSanJoseA, materia: materias[1], profesor: profesores[1], diaSemana: 1, horaInicio: '09:00', horaFin: '10:00' },
      { grupo: grupoSanJoseB, materia: materias[2], profesor: profesores[2], diaSemana: 1, horaInicio: '08:00', horaFin: '09:00' },
      { grupo: grupoSanJoseA, materia: materias[3], profesor: profesores[0], diaSemana: 2, horaInicio: '08:00', horaFin: '09:00' },
      { grupo: grupoSanJoseA, materia: materias[4], profesor: profesores[1], diaSemana: 2, horaInicio: '09:00', horaFin: '10:00' },
      { grupo: grupoSanJoseB, materia: materias[0], profesor: profesores[2], diaSemana: 2, horaInicio: '08:00', horaFin: '09:00' },
      { grupo: grupoSanJoseA, materia: materias[1], profesor: profesores[0], diaSemana: 3, horaInicio: '08:00', horaFin: '09:00' },
      { grupo: grupoSanJoseB, materia: materias[3], profesor: profesores[1], diaSemana: 3, horaInicio: '08:00', horaFin: '09:00' },
    ];

    for (const horarioData of horariosSanJose) {
      if (horarioData.grupo && horarioData.materia && horarioData.profesor) {
        const existingHorario = await prisma.horario.findFirst({
          where: {
            grupoId: horarioData.grupo.id,
            materiaId: horarioData.materia.id,
            diaSemana: horarioData.diaSemana,
            horaInicio: horarioData.horaInicio,
          }
        });

        if (!existingHorario) {
          await prisma.horario.create({
            data: {
              periodoId: horarioData.grupo.periodoId,
              grupoId: horarioData.grupo.id,
              materiaId: horarioData.materia.id,
              profesorId: horarioData.profesor.id,
              diaSemana: horarioData.diaSemana,
              horaInicio: horarioData.horaInicio,
              horaFin: horarioData.horaFin,
              institucionId: horarioData.grupo.institucionId,
            },
          });
          console.log(`   âœ… Horario creado: ${horarioData.materia.nombre} - ${horarioData.grupo.nombre} (${horarioData.profesor.email})`);
        } else {
          console.log(`   âœ… Horario ya existe: ${horarioData.materia.nombre} - ${horarioData.grupo.nombre}`);
        }
      }
    }
    const horariosLiceo = [
      { grupo: grupoLiceoA, materia: materias[5], profesor: profesores[3], diaSemana: 1, horaInicio: '08:00', horaFin: '09:00' },
      { grupo: grupoLiceoA, materia: materias[6], profesor: profesores[4], diaSemana: 1, horaInicio: '09:00', horaFin: '10:00' },
      { grupo: grupoLiceoA, materia: materias[7], profesor: profesores[3], diaSemana: 2, horaInicio: '08:00', horaFin: '09:00' },
    ];

    for (const horarioData of horariosLiceo) {
      if (horarioData.grupo && horarioData.materia && horarioData.profesor) {
        const existingHorario = await prisma.horario.findFirst({
          where: {
            grupoId: horarioData.grupo.id,
            materiaId: horarioData.materia.id,
            diaSemana: horarioData.diaSemana,
            horaInicio: horarioData.horaInicio,
          }
        });

        if (!existingHorario) {
          await prisma.horario.create({
            data: {
              periodoId: horarioData.grupo.periodoId,
              grupoId: horarioData.grupo.id,
              materiaId: horarioData.materia.id,
              profesorId: horarioData.profesor.id,
              diaSemana: horarioData.diaSemana,
              horaInicio: horarioData.horaInicio,
              horaFin: horarioData.horaFin,
              institucionId: horarioData.grupo.institucionId,
            },
          });
          console.log(`   âœ… Horario creado: ${horarioData.materia.nombre} - ${horarioData.grupo.nombre} (${horarioData.profesor.email})`);
        } else {
          console.log(`   âœ… Horario ya existe: ${horarioData.materia.nombre} - ${horarioData.grupo.nombre}`);
        }
      }
    }
    console.log('\nâœ… FASE 8: VerificaciÃ³n final...');

    const stats = {
      instituciones: await prisma.institucion.count(),
      usuarios: await prisma.usuario.count(),
      periodos: await prisma.periodoAcademico.count(),
      profesores: await prisma.usuario.count({ where: { rol: 'profesor' } }),
      estudiantes: await prisma.estudiante.count(),
      materias: await prisma.materia.count(),
      grupos: await prisma.grupo.count(),
      horarios: await prisma.horario.count(),
      asignaciones: await prisma.estudianteGrupo.count(),
    };

    console.log('ðŸ“Š EstadÃ­sticas del universo de pruebas:');
    console.log(`   ðŸ« Instituciones: ${stats.instituciones}`);
    console.log(`   ðŸ‘¥ Usuarios totales: ${stats.usuarios}`);
    console.log(`   ðŸ“… Periodos acadÃ©micos: ${stats.periodos}`);
    console.log(`   ðŸ‘¨â€ðŸ« Profesores: ${stats.profesores}`);
    console.log(`   ðŸ‘¨â€ðŸŽ“ Estudiantes: ${stats.estudiantes}`);
    console.log(`   ðŸ“š Materias: ${stats.materias}`);
    console.log(`   ðŸ« Grupos: ${stats.grupos}`);
    console.log(`   ðŸ“… Horarios: ${stats.horarios}`);
    console.log(`   ðŸ”— Asignaciones estudiante-grupo: ${stats.asignaciones}`);

    console.log('\nðŸŽ‰ Setup completo exitosamente!');
    console.log('\nðŸ“‹ CREDENCIALES DE PRUEBA:');
    console.log('\nðŸ”‘ SUPER ADMIN:');
    console.log('   superadmin@asistapp.com / SuperAdmin123!');

    console.log('\nðŸ‘¨â€ðŸ’¼ ADMINS DE INSTITUCIÃ“N:');
    console.log('   admin@sanjose.edu / Admin123!');
    console.log('   admin@liceonacional.edu / Admin123!');

    console.log('\nðŸ‘¨â€ðŸ« PROFESORES:');
    console.log('   ana.lopez@sanjose.edu / Prof123!');
    console.log('   pedro.garcia@sanjose.edu / Prof123!');
    console.log('   maria.rodriguez@sanjose.edu / Prof123!');
    console.log('   juan.martinez@liceonacional.edu / Prof123!');
    console.log('   laura.sanchez@liceonacional.edu / Prof123!');

    console.log('\nðŸ‘¨â€ðŸŽ“ ESTUDIANTES:');
    console.log('   juan.perez@sanjose.edu / Est123!');
    console.log('   maria.gomez@sanjose.edu / Est123!');
    console.log('   carlos.lopez@sanjose.edu / Est123!');
    console.log('   ana.martinez@sanjose.edu / Est123!');
    console.log('   luis.rodriguez@sanjose.edu / Est123!');
    console.log('   sofia.garcia@liceonacional.edu / Est123!');
    console.log('   mateo.silva@liceonacional.edu / Est123!');
    console.log('   valentina.moreno@liceonacional.edu / Est123!');

    console.log('\nðŸ« INSTITUCIONES Y GRUPOS:');
    console.log('   ðŸ“š Colegio San JosÃ©: Grupos A, B, C, D');
    console.log('   ðŸ“š Liceo Nacional: Grupos A, B, C, D');
    console.log('   ðŸ“… Horarios completos para identificar clases en tiempo real');

  } catch (error) {
    console.error('âŒ Error durante el setup:', error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}
setupCompleteTestData().catch(console.error);
/* Fin backend\setup-test-data.ts */

/* Inicio backend\show-student-example.ts */
import { prisma } from './src/config/database';

async function showStudentExample() {
  try {
    console.log('ðŸŽ“ EJEMPLO: ESTUDIANTE CON SUS MATERIAS Y HORARIOS\n');
    console.log('='.repeat(80));
    const estudiante = await prisma.estudiante.findFirst({
      include: {
        usuario: {
          include: {
            usuarioInstituciones: {
              include: { institucion: true }
            }
          }
        }
      }
    });

    if (!estudiante) {
      console.log('âŒ No se encontraron estudiantes en la base de datos');
      return;
    }
    console.log('ðŸ“‹ INFORMACIÃ“N DEL ESTUDIANTE:');
    console.log('-'.repeat(50));
    console.log(`ID: ${estudiante.id}`);
    console.log(`Nombre: ${estudiante.usuario.nombres} ${estudiante.usuario.apellidos}`);
    console.log(`Email: ${estudiante.usuario.email}`);
    console.log(`InstituciÃ³n: ${estudiante.usuario.usuarioInstituciones[0]?.institucion.nombre || 'N/A'}`);
    console.log(`IdentificaciÃ³n: ${estudiante.identificacion}`);
    console.log(`CÃ³digo QR: ${estudiante.codigoQr}`);
    console.log(`Responsable: ${estudiante.nombreResponsable || 'N/A'}`);
    console.log(`TelÃ©fono Responsable: ${estudiante.telefonoResponsable || 'N/A'}`);
    console.log(`TelÃ©fono Personal: ${estudiante.usuario.telefono || 'N/A'}`);
    console.log('');
    const gruposEstudiante = await prisma.estudianteGrupo.findMany({
      where: { estudianteId: estudiante.id },
      include: {
        grupo: {
          include: {
            periodoAcademico: true,
            _count: {
              select: {
                estudiantesGrupos: true,
                horarios: true
              }
            }
          }
        }
      }
    });

    console.log('ðŸ‘¥ GRUPOS ASIGNADOS:');
    console.log('-'.repeat(50));
    if (gruposEstudiante.length === 0) {
      console.log('No tiene grupos asignados');
    } else {
      gruposEstudiante.forEach((eg, index) => {
        const grupo = eg.grupo;
        console.log(`${index + 1}. ${grupo.nombre} (${grupo.grado}Â° ${grupo.seccion})`);
        console.log(`   PerÃ­odo: ${grupo.periodoAcademico.nombre}`);
        console.log(`   Estudiantes: ${grupo._count.estudiantesGrupos}`);
        console.log(`   Horarios: ${grupo._count.horarios}`);
        console.log('');
      });
    }
    console.log('ðŸ“… HORARIO SEMANAL COMPLETO:');
    console.log('-'.repeat(50));

    const diasSemana = ['Domingo', 'Lunes', 'Martes', 'MiÃ©rcoles', 'Jueves', 'Viernes', 'SÃ¡bado'];

    for (let dia = 1; dia <= 7; dia++) {
      const clasesDia = await prisma.horario.findMany({
        where: {
          diaSemana: dia,
          institucionId: estudiante.usuario.usuarioInstituciones[0]?.institucionId,
          grupo: {
            estudiantesGrupos: {
              some: {
                estudianteId: estudiante.id
              }
            }
          }
        },
        include: {
          materia: true,
          profesor: {
            select: {
              id: true,
              nombres: true,
              apellidos: true
            }
          },
          grupo: true
        },
        orderBy: {
          horaInicio: 'asc'
        }
      });

      console.log(`\nðŸ“† ${diasSemana[dia]} (DÃ­a ${dia}):`);
      console.log('-'.repeat(40));

      if (clasesDia.length === 0) {
        console.log('  ðŸ“ Sin clases');
      } else {
        console.log('â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
        console.log('â”‚ Hora    â”‚ Materia         â”‚ Profesor             â”‚ Grupo                â”‚');
        console.log('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤');

        clasesDia.forEach((clase) => {
          const hora = `${clase.horaInicio.slice(0, 5)}-${clase.horaFin.slice(0, 5)}`;
          const materia = clase.materia.nombre.length > 15
            ? clase.materia.nombre.substring(0, 12) + '...'
            : clase.materia.nombre.padEnd(15);
          const profesorNombre = clase.profesor
            ? `${clase.profesor.nombres} ${clase.profesor.apellidos}`
            : 'Sin asignar';
          const profesor = profesorNombre.length > 20
            ? profesorNombre.substring(0, 17) + '...'
            : profesorNombre.padEnd(20);
          const grupo = `${clase.grupo.nombre} (${clase.grupo.grado}Â°${clase.grupo.seccion})`.length > 20
            ? `${clase.grupo.nombre} (${clase.grupo.grado}Â°${clase.grupo.seccion})`.substring(0, 17) + '...'
            : `${clase.grupo.nombre} (${clase.grupo.grado}Â°${clase.grupo.seccion})`.padEnd(20);

          console.log(`â”‚ ${hora.padEnd(7)} â”‚ ${materia} â”‚ ${profesor} â”‚ ${grupo} â”‚`);
        });

        console.log('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜');
      }
    }
    console.log('\nðŸ“š RESUMEN DE MATERIAS:');
    console.log('-'.repeat(50));

    const todasLasMaterias = await prisma.horario.findMany({
      where: {
        institucionId: estudiante.usuario.usuarioInstituciones[0]?.institucionId,
        grupo: {
          estudiantesGrupos: {
            some: {
              estudianteId: estudiante.id
            }
          }
        }
      },
      include: {
        materia: true,
        profesor: {
          select: {
            id: true,
            nombres: true,
            apellidos: true
          }
        }
      },
      distinct: ['materiaId']
    });

    if (todasLasMaterias.length === 0) {
      console.log('No tiene materias asignadas');
    } else {
      console.log('â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
      console.log('â”‚ Materia         â”‚ Profesor             â”‚ CÃ³digo      â”‚');
      console.log('â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤');

      todasLasMaterias.forEach((horario) => {
        const materia = horario.materia.nombre.length > 15
          ? horario.materia.nombre.substring(0, 12) + '...'
          : horario.materia.nombre.padEnd(15);
        const profesorNombre = horario.profesor
          ? `${horario.profesor.nombres} ${horario.profesor.apellidos}`
          : 'Sin asignar';
        const profesor = profesorNombre.length > 20
          ? profesorNombre.substring(0, 17) + '...'
          : profesorNombre.padEnd(20);
        const codigo = (horario.materia.codigo || 'N/A').padEnd(11);

        console.log(`â”‚ ${materia} â”‚ ${profesor} â”‚ ${codigo} â”‚`);
      });

      console.log('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜');
      console.log(`\nTotal de materias: ${todasLasMaterias.length}`);
    }

    console.log('\nðŸŽ‰ Â¡Ejemplo completado exitosamente!');

  } catch (error) {
    console.error('âŒ Error al mostrar el ejemplo:', error);
  } finally {
    await prisma.$disconnect();
  }
}
showStudentExample();
/* Fin backend\show-student-example.ts */

/* Inicio backend\src\config\app.ts */
import { AppConfig } from '../types';

export const config: AppConfig = {
  port: parseInt(process.env.PORT || '3000', 10),
  host: process.env.HOST || '0.0.0.0',
  jwtSecret: process.env.JWT_SECRET || 'asistapp_secret_key_2025',
  jwtExpiresIn: process.env.JWT_EXPIRES_IN || '24h',
  nodeEnv: process.env.NODE_ENV || 'development',
  logLevel: process.env.LOG_LEVEL || 'info',
};

export default config;
/* Fin backend\src\config\app.ts */

/* Inicio backend\src\config\database.ts */
import { PrismaClient } from '@prisma/client';

class DatabaseService {
  private static instance: DatabaseService;
  private prisma: PrismaClient | null = null;

  private constructor() {}

  public static getInstance(): DatabaseService {
    if (!DatabaseService.instance) {
      DatabaseService.instance = new DatabaseService();
    }
    return DatabaseService.instance;
  }

  public getClient(): PrismaClient {
    if (!this.prisma) {
      console.log('ðŸ”„ Creando cliente Prisma...');
      this.prisma = new PrismaClient({
        log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
      });
      console.log('âœ… Cliente Prisma creado');
    }
    return this.prisma;
  }

  public async disconnect(): Promise<void> {
    if (this.prisma) {
      await this.prisma.$disconnect();
      this.prisma = null;
      console.log('ðŸ”Œ Cliente Prisma desconectado');
    }
  }

  public async connect(): Promise<void> {
    const client = this.getClient();
    await client.$connect();
    console.log('ðŸ”— Conectado a la base de datos');
  }
}

export const databaseService = DatabaseService.getInstance();
export const prisma = databaseService.getClient();
/* Fin backend\src\config\database.ts */

/* Inicio backend\src\config\jwt.ts */
import crypto from 'crypto';
import jwt, { SignOptions } from 'jsonwebtoken';
import { JWTPayload } from '../types';
import { config } from './app';

export class JWTService {
  private static accessSecret: string = config.jwtSecret;
  private static refreshSecret: string = config.jwtSecret + '_refresh'
  private static accessExpiresIn: string = config.jwtExpiresIn;
  private static refreshExpiresIn: string = '7d'

  public static signAccessToken(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {
    return jwt.sign(payload, this.accessSecret, { expiresIn: this.accessExpiresIn } as SignOptions);
  }

  public static verifyAccessToken(token: string): JWTPayload {
    try {
      const decoded = jwt.verify(token, this.accessSecret) as JWTPayload;
      return decoded;
    } catch (error) {
      throw new Error('Access token invÃ¡lido o expirado');
    }
  }

  public static signRefreshToken(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {
    const tokenPayload = {
      ...payload,
      jti: crypto.randomUUID(), // JWT ID Ãºnico para evitar colisiones
    };
    return jwt.sign(tokenPayload, this.refreshSecret, { expiresIn: this.refreshExpiresIn } as SignOptions);
  }

  public static verifyRefreshToken(token: string): JWTPayload {
    try {
      const decoded = jwt.verify(token, this.refreshSecret) as JWTPayload;
      return decoded;
    } catch (error) {
      throw new Error('Refresh token invÃ¡lido o expirado');
    }
  }

  public static sign(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {
    return this.signAccessToken(payload);
  }

  public static verify(token: string): JWTPayload {
    return this.verifyAccessToken(token);
  }

  public static decode(token: string): JWTPayload | null {
    try {
      return jwt.decode(token) as JWTPayload;
    } catch (error) {
      return null;
    }
  }
}

export default JWTService;
/* Fin backend\src\config\jwt.ts */

/* Inicio backend\src\controllers\admin-institucion.controller.ts */
import { FastifyReply, FastifyRequest } from 'fastify';
import AdminInstitucionService, { CreateAdminInstitucionRequest, UpdateAdminInstitucionRequest } from '../services/admin-institucion.service';
import { ApiResponse, NotFoundError, PaginationParams } from '../types';

export class AdminInstitucionController {

  public static async getAll(request: FastifyRequest<{ Querystring: { page?: string; limit?: string } }>, reply: FastifyReply) {
    try {
      const { page, limit } = request.query;

      const pagination: PaginationParams = {};
      if (page) pagination.page = parseInt(page, 10);
      if (limit) pagination.limit = parseInt(limit, 10);

      const result = await AdminInstitucionService.getAll(pagination);

      return reply.code(200).send({
        success: true,
        data: result.data,
        pagination: result.pagination,
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async getById(request: FastifyRequest<{ Params: { id: string } }>, reply: FastifyReply) {
    try {
      const { id } = request.params;

      const admin = await AdminInstitucionService.getById(id);

      if (!admin) {
        throw new NotFoundError('Admin de InstituciÃ³n');
      }

      return reply.code(200).send({
        success: true,
        data: admin,
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async create(request: FastifyRequest<{ Body: CreateAdminInstitucionRequest }>, reply: FastifyReply) {
    try {
      const adminData = request.body;
      const newAdmin = await AdminInstitucionService.create(adminData);

      return reply.code(201).send({
        success: true,
        data: newAdmin,
        message: 'Admin de instituciÃ³n creado exitosamente',
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async update(request: FastifyRequest<{ Params: { id: string }; Body: UpdateAdminInstitucionRequest }>, reply: FastifyReply) {
    try {
      const { id } = request.params;
      const adminData = request.body;

      const updatedAdmin = await AdminInstitucionService.update(id, adminData);

      if (!updatedAdmin) {
        throw new NotFoundError('Admin de InstituciÃ³n');
      }

      return reply.code(200).send({
        success: true,
        data: updatedAdmin,
        message: 'Admin de instituciÃ³n actualizado exitosamente',
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async delete(request: FastifyRequest<{ Params: { id: string } }>, reply: FastifyReply) {
    try {
      const { id } = request.params;

      const deleted = await AdminInstitucionService.delete(id);

      if (!deleted) {
        throw new NotFoundError('Admin de InstituciÃ³n');
      }

      return reply.code(200).send({
        success: true,
        data: null,
        message: 'Admin de instituciÃ³n eliminado exitosamente',
      } as ApiResponse<null>);
    } catch (error) {
      throw error;
    }
  }
}

export default AdminInstitucionController;
/* Fin backend\src\controllers\admin-institucion.controller.ts */

/* Inicio backend\src\controllers\auth.controller.ts */
import { FastifyReply, FastifyRequest } from 'fastify';
import { prisma } from '../config/database';
import { AuthenticatedRequest } from '../middleware/auth';
import AuthService from '../services/auth.service';
import { ApiResponse, AuthenticationError, LoginRequest, NotFoundError, RefreshTokenResponse, UsuarioConInstituciones, ValidationError } from '../types';

export class AuthController {

  public static async login(request: FastifyRequest<{ Body: LoginRequest }>, reply: FastifyReply) {
    try {
      const credentials = request.body;

      if (!credentials.email || !credentials.password) {
        throw new ValidationError('Email y contraseÃ±a son requeridos');
      }

      const result = await AuthService.login(credentials);

      return reply.code(200).send({
        success: true,
        data: {
          accessToken: result.accessToken,
          refreshToken: result.refreshToken,
          expiresIn: result.expiresIn,
          usuario: result.usuario
        }
      });

    } catch (error) {
      throw error;
    }
  }

  public static async getUserInstitutions(request: AuthenticatedRequest, reply: FastifyReply) {
    try {
      const user = request.user;

      if (!user) {
        throw new AuthenticationError('Usuario no autenticado');
      }

      const usuario = await prisma.usuario.findUnique({
        where: { id: user.id },
        include: {
          usuarioInstituciones: {
            include: {
              institucion: true,
            },
          },
        },
      }) as UsuarioConInstituciones | null;

      if (!usuario) {
        throw new NotFoundError('Usuario');
      }

      const instituciones = (usuario.usuarioInstituciones || [])
        .filter(ui => ui.activo && ui.institucion?.activa)
        .map((ui) => ({
          id: ui.institucion.id,
          nombre: ui.institucion.nombre,
          rolEnInstitucion: ui.rolEnInstitucion,
        }));

      return reply.code(200).send({
        success: true,
        data: instituciones,
      });
    } catch (error) {
      throw error;
    }
  }

  public static async logout(request: FastifyRequest<{ Body: { refreshToken?: string } }>, reply: FastifyReply) {
    try {

      const refreshToken = request.body.refreshToken;

      const authReq = request as unknown as AuthenticatedRequest;
      const user = authReq.user;

      if (!user) {
        throw new AuthenticationError('Usuario no autenticado');
      }

      await AuthService.revokeRefreshTokens(user.id, refreshToken);

      return reply.code(200).send({
        success: true,
        message: 'SesiÃ³n cerrada exitosamente',
      });
    } catch (error) {
      throw error;
    }
  }

  public static async refreshToken(request: FastifyRequest<{ Body: { refreshToken: string } }>, reply: FastifyReply) {
    try {

      const refreshToken = request.body.refreshToken;

      if (!refreshToken) {
        throw new ValidationError('Refresh token es requerido');
      }

      const result = await AuthService.refreshToken(refreshToken);

      return reply.code(200).send({
        success: true,
        data: {
          accessToken: result.accessToken,
          refreshToken: result.refreshToken,
          expiresIn: result.expiresIn,
        },
      } as ApiResponse<RefreshTokenResponse>);

    } catch (error) {
      throw error;
    }
  }

  public static async verify(request: AuthenticatedRequest, reply: FastifyReply) {
    try {
      const user = request.user;

      return reply.code(200).send({
        success: true,
        data: {
          usuario: user,
          valid: true,
        },
      });
    } catch (error) {
      throw error;
    }
  }
}

export default AuthController;
/* Fin backend\src\controllers\auth.controller.ts */

/* Inicio backend\src\controllers\estudiante.controller.ts */
import { FastifyReply } from 'fastify';
import { prisma } from '../config/database';
import { AuthenticatedRequest } from '../middleware/auth';
import { NotFoundError, ValidationError } from '../types';

export class EstudianteController {

  public static async getClasesHoy(request: AuthenticatedRequest, reply: FastifyReply) {
    try {
      const user = request.user;
      if (!user) {
        throw new ValidationError('Usuario no autenticado');
      }
      const estudiante = await prisma.estudiante.findUnique({
        where: { usuarioId: user.id },
        include: {
          usuario: {
            include: {
              usuarioInstituciones: {
                include: { institucion: true }
              }
            }
          }
        }
      });

      if (!estudiante) {
        throw new NotFoundError('Estudiante');
      }
      const today = new Date().getDay() || 7;
      const clasesHoy = await prisma.horario.findMany({
        where: {
          diaSemana: today,
          institucionId: estudiante.usuario.usuarioInstituciones[0]?.institucionId,
          grupo: {
            estudiantesGrupos: {
              some: {
                estudianteId: estudiante.id
              }
            }
          }
        },
        include: {
          materia: true,
          profesor: {
            select: {
              id: true,
              nombres: true,
              apellidos: true
            }
          },
          grupo: true
        },
        orderBy: {
          horaInicio: 'asc'
        }
      });

      return reply.code(200).send({
        success: true,
        data: clasesHoy,
        message: `Clases del dÃ­a ${today}`
      });

    } catch (error) {
      throw error;
    }
  }

  public static async getHorarioSemanal(request: AuthenticatedRequest, reply: FastifyReply) {
    try {
      const user = request.user;
      if (!user) {
        throw new ValidationError('Usuario no autenticado');
      }
      const estudiante = await prisma.estudiante.findUnique({
        where: { usuarioId: user.id },
        include: {
          usuario: {
            include: {
              usuarioInstituciones: {
                include: { institucion: true }
              }
            }
          }
        }
      });

      if (!estudiante) {
        throw new NotFoundError('Estudiante');
      }
      const horarioSemanal = await prisma.horario.findMany({
        where: {
          institucionId: estudiante.usuario.usuarioInstituciones[0]?.institucionId,
          grupo: {
            estudiantesGrupos: {
              some: {
                estudianteId: estudiante.id
              }
            }
          }
        },
        include: {
          materia: true,
          profesor: {
            select: {
              id: true,
              nombres: true,
              apellidos: true
            }
          },
          grupo: true
        },
        orderBy: [
          { diaSemana: 'asc' },
          { horaInicio: 'asc' }
        ]
      });
      const horarioPorDia: { [key: number]: any[] } = {};
      for (let dia = 1; dia <= 7; dia++) {
        horarioPorDia[dia] = horarioSemanal.filter((h: any) => h.diaSemana === dia);
      }

      return reply.code(200).send({
        success: true,
        data: horarioPorDia
      });

    } catch (error) {
      throw error;
    }
  }

  public static async getClasesPorDia(request: AuthenticatedRequest & { params: { diaSemana: string } }, reply: FastifyReply) {
    try {
      const user = request.user;
      const { diaSemana } = request.params;

      if (!user) {
        throw new ValidationError('Usuario no autenticado');
      }

      const dia = parseInt(diaSemana);
      if (dia < 1 || dia > 7) {
        throw new ValidationError('DÃ­a de semana invÃ¡lido (1-7)');
      }
      const estudiante = await prisma.estudiante.findUnique({
        where: { usuarioId: user.id },
        include: {
          usuario: {
            include: {
              usuarioInstituciones: {
                include: { institucion: true }
              }
            }
          }
        }
      });

      if (!estudiante) {
        throw new NotFoundError('Estudiante');
      }
      const clasesDia = await prisma.horario.findMany({
        where: {
          diaSemana: dia,
          institucionId: estudiante.usuario.usuarioInstituciones[0]?.institucionId,
          grupo: {
            estudiantesGrupos: {
              some: {
                estudianteId: estudiante.id
              }
            }
          }
        },
        include: {
          materia: true,
          profesor: {
            select: {
              id: true,
              nombres: true,
              apellidos: true
            }
          },
          grupo: true
        },
        orderBy: {
          horaInicio: 'asc'
        }
      });

      return reply.code(200).send({
        success: true,
        data: clasesDia,
        message: `Clases del dÃ­a ${dia}`
      });

    } catch (error) {
      throw error;
    }
  }

  public static async getPerfil(request: AuthenticatedRequest, reply: FastifyReply) {
    try {
      const user = request.user;
      if (!user) {
        throw new ValidationError('Usuario no autenticado');
      }

      const estudiante = await prisma.estudiante.findUnique({
        where: { usuarioId: user.id },
        include: {
          usuario: {
            include: {
              usuarioInstituciones: {
                include: {
                  institucion: true
                }
              }
            }
          }
        }
      });

      if (!estudiante) {
        throw new NotFoundError('Estudiante');
      }

      return reply.code(200).send({
        success: true,
        data: estudiante
      });

    } catch (error) {
      throw error;
    }
  }

  public static async getGrupos(request: AuthenticatedRequest, reply: FastifyReply) {
    try {
      const user = request.user;
      if (!user) {
        throw new ValidationError('Usuario no autenticado');
      }

      const estudiante = await prisma.estudiante.findUnique({
        where: { usuarioId: user.id }
      });

      if (!estudiante) {
        throw new NotFoundError('Estudiante');
      }

      const grupos = await prisma.estudianteGrupo.findMany({
        where: {
          estudianteId: estudiante.id
        },
        include: {
          grupo: {
            include: {
              periodoAcademico: true,
              _count: {
                select: {
                  estudiantesGrupos: true,
                  horarios: true
                }
              }
            }
          }
        }
      });

      return reply.code(200).send({
        success: true,
        data: grupos.map((eg: any) => eg.grupo)
      });

    } catch (error) {
      throw error;
    }
  }
}
/* Fin backend\src\controllers\estudiante.controller.ts */

/* Inicio backend\src\controllers\grupo.controller.ts */
import { FastifyReply, FastifyRequest } from 'fastify';
import { prisma } from '../config/database';
import { AuthenticatedRequest } from '../middleware/auth';
import GrupoService from '../services/grupo.service';
import { NotFoundError, ValidationError } from '../types';

interface GetGruposQuery {
  page?: string;
  limit?: string;
  periodoId?: string;
  grado?: string;
  seccion?: string;
  search?: string;
}

interface GetGrupoParams {
  id: string;
}

interface CreateGrupoBody {
  nombre: string;
  grado: string;
  seccion?: string;
  periodoId: string;
}

interface UpdateGrupoBody {
  nombre?: string;
  grado?: string;
  seccion?: string;
  periodoId?: string;
}

export class GrupoController {

  public static async getAll(request: AuthenticatedRequest & FastifyRequest<{ Querystring: GetGruposQuery }>, reply: FastifyReply) {
    try {
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: { usuarioId: request.user!.id, activo: true },
      });

      if (!usuarioInstitucion) {
        return reply.code(400).send({
          success: false,
          error: 'El usuario no tiene una instituciÃ³n asignada',
        });
      }

      const institucionId = usuarioInstitucion.institucionId;

      const { page, limit, periodoId, grado, seccion, search } = request.query;
      const pageNum = page ? parseInt(page, 10) : 1;
      const limitNum = limit ? parseInt(limit, 10) : 10;

      if (pageNum < 1 || limitNum < 1 || limitNum > 100) {
        throw new ValidationError('Los parÃ¡metros de paginaciÃ³n deben ser mayores a 0. El lÃ­mite mÃ¡ximo es 100.');
      }

      const pagination = {
        page: pageNum,
        limit: limitNum,
      };

      const filters = {
        periodoId: periodoId || undefined,
        grado: grado || undefined,
        seccion: seccion || undefined,
        search: search || undefined,
      };

      const result = await GrupoService.getAllGruposByInstitucion(institucionId, pagination, filters);

      return reply.code(200).send({
        success: true,
        data: result.data,
        pagination: result.pagination,
      });
    } catch (error) {
      console.error('Error en getAll grupos:', error);
      throw error;
    }
  }

  public static async getById(request: AuthenticatedRequest & FastifyRequest<{ Params: GetGrupoParams }>, reply: FastifyReply) {
    try {
      const { id } = request.params;

      const grupo = await GrupoService.getGrupoById(id);

      if (!grupo) {
        throw new NotFoundError('Grupo');
      }
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: { usuarioId: request.user!.id, activo: true },
      });

      if (usuarioInstitucion && grupo.institucionId !== usuarioInstitucion.institucionId) {
        return reply.code(403).send({
          success: false,
          error: 'No tienes permisos para acceder a este grupo',
        });
      }

      return reply.code(200).send({
        success: true,
        data: grupo,
      });
    } catch (error) {
      console.error('Error en getById grupo:', error);
      throw error;
    }
  }

  public static async create(request: AuthenticatedRequest & FastifyRequest<{ Body: CreateGrupoBody }>, reply: FastifyReply) {
    try {
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: { usuarioId: request.user!.id, activo: true },
      });

      if (!usuarioInstitucion) {
        return reply.code(400).send({
          success: false,
          error: 'El usuario no tiene una instituciÃ³n asignada',
        });
      }

      const data = {
        ...request.body,
        institucionId: usuarioInstitucion.institucionId,
      };

      const grupo = await GrupoService.createGrupo(data);

      return reply.code(201).send({
        success: true,
        data: grupo,
        message: 'Grupo creado exitosamente',
      });
    } catch (error) {
      console.error('Error en create grupo:', error);
      throw error;
    }
  }

  public static async update(request: AuthenticatedRequest & FastifyRequest<{ Params: GetGrupoParams; Body: UpdateGrupoBody }>, reply: FastifyReply) {
    try {
      const { id } = request.params;
      const data = request.body;
      const existingGrupo = await GrupoService.getGrupoById(id);
      if (!existingGrupo) {
        throw new NotFoundError('Grupo');
      }

      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: { usuarioId: request.user!.id, activo: true },
      });

      if (usuarioInstitucion && existingGrupo.institucionId !== usuarioInstitucion.institucionId) {
        return reply.code(403).send({
          success: false,
          error: 'No tienes permisos para modificar este grupo',
        });
      }

      const grupo = await GrupoService.updateGrupo(id, data);

      if (!grupo) {
        throw new NotFoundError('Grupo');
      }

      return reply.code(200).send({
        success: true,
        data: grupo,
        message: 'Grupo actualizado exitosamente',
      });
    } catch (error) {
      console.error('Error en update grupo:', error);
      throw error;
    }
  }

  public static async delete(request: AuthenticatedRequest & FastifyRequest<{ Params: GetGrupoParams }>, reply: FastifyReply) {
    try {
      const { id } = request.params;
      const existingGrupo = await GrupoService.getGrupoById(id);
      if (!existingGrupo) {
        throw new NotFoundError('Grupo');
      }

      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: { usuarioId: request.user!.id, activo: true },
      });

      if (usuarioInstitucion && existingGrupo.institucionId !== usuarioInstitucion.institucionId) {
        return reply.code(403).send({
          success: false,
          error: 'No tienes permisos para eliminar este grupo',
        });
      }

      const success = await GrupoService.deleteGrupo(id);

      return reply.code(200).send({
        success: true,
        message: 'Grupo eliminado exitosamente',
      });
    } catch (error) {
      console.error('Error en delete grupo:', error);
      throw error;
    }
  }

  public static async getGruposDisponibles(request: AuthenticatedRequest, reply: FastifyReply) {
    try {
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: { usuarioId: request.user!.id, activo: true },
      });

      if (!usuarioInstitucion) {
        return reply.code(400).send({
          success: false,
          error: 'El usuario no tiene una instituciÃ³n asignada',
        });
      }

      const grupos = await GrupoService.getGruposDisponibles(usuarioInstitucion.institucionId);

      return reply.code(200).send({
        success: true,
        data: grupos,
      });
    } catch (error) {
      console.error('Error en getGruposDisponibles:', error);
      throw error;
    }
  }
}

export default GrupoController;
/* Fin backend\src\controllers\grupo.controller.ts */

/* Inicio backend\src\controllers\horario.controller.ts */
import { FastifyReply, FastifyRequest } from 'fastify';
import { prisma } from '../config/database';
import { AuthenticatedRequest } from '../middleware/auth';
import HorarioService from '../services/horario.service';
import { NotFoundError, ValidationError } from '../types';

interface GetHorariosQuery {
  page?: string;
  limit?: string;
  grupoId?: string;
  materiaId?: string;
  profesorId?: string;
  diaSemana?: string;
}

interface GetHorarioParams {
  id: string;
}

interface GetHorariosByGrupoParams {
  grupoId: string;
}

interface CreateHorarioBody {
  periodoId: string;
  grupoId: string;
  materiaId: string;
  profesorId?: string;
  diaSemana: number;
  horaInicio: string;
  horaFin: string;
}

interface UpdateHorarioBody {
  grupoId?: string;
  materiaId?: string;
  profesorId?: string;
  diaSemana?: number;
  horaInicio?: string;
  horaFin?: string;
}

export class HorarioController {

  public static async getAll(request: AuthenticatedRequest & FastifyRequest<{ Querystring: GetHorariosQuery }>, reply: FastifyReply) {
    try {
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: { usuarioId: request.user!.id, activo: true },
      });

      if (!usuarioInstitucion) {
        return reply.code(400).send({
          success: false,
          error: 'El usuario no tiene una instituciÃ³n asignada',
        });
      }

      const { page, limit, grupoId, materiaId, profesorId, diaSemana } = request.query;
      const pageNum = page ? parseInt(page, 10) : 1;
      const limitNum = limit ? parseInt(limit, 10) : 10;

      if (pageNum < 1 || limitNum < 1 || limitNum > 100) {
        throw new ValidationError('Los parÃ¡metros de paginaciÃ³n deben ser mayores a 0. El lÃ­mite mÃ¡ximo es 100.');
      }

      const pagination = {
        page: pageNum,
        limit: limitNum,
      };

      const filters = {
        grupoId: grupoId || undefined,
        materiaId: materiaId || undefined,
        profesorId: profesorId || undefined,
        diaSemana: diaSemana ? parseInt(diaSemana, 10) : undefined,
      };

      const result = await HorarioService.getAllHorariosByInstitucion(usuarioInstitucion.institucionId, pagination, filters);

      return reply.code(200).send({
        success: true,
        data: result.data,
        pagination: result.pagination,
      });
    } catch (error) {
      console.error('Error en getAll horarios:', error);
      throw error;
    }
  }

  public static async getByGrupo(request: AuthenticatedRequest & FastifyRequest<{ Params: GetHorariosByGrupoParams }>, reply: FastifyReply) {
    try {
      const { grupoId } = request.params;
      const grupo = await prisma.grupo.findUnique({
        where: { id: grupoId },
      });

      if (!grupo) {
        throw new NotFoundError('Grupo');
      }

      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: { usuarioId: request.user!.id, activo: true },
      });

      if (usuarioInstitucion && grupo.institucionId !== usuarioInstitucion.institucionId) {
        return reply.code(403).send({
          success: false,
          error: 'No tienes permisos para acceder a los horarios de este grupo',
        });
      }

      const horarios = await HorarioService.getHorariosByGrupo(grupoId);

      return reply.code(200).send({
        success: true,
        data: horarios,
      });
    } catch (error) {
      console.error('Error en getByGrupo horarios:', error);
      throw error;
    }
  }

  public static async getById(request: AuthenticatedRequest & FastifyRequest<{ Params: GetHorarioParams }>, reply: FastifyReply) {
    try {
      const { id } = request.params;

      const horario = await HorarioService.getHorarioById(id);

      if (!horario) {
        throw new NotFoundError('Horario');
      }
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: { usuarioId: request.user!.id, activo: true },
      });

      if (usuarioInstitucion && horario.institucionId !== usuarioInstitucion.institucionId) {
        return reply.code(403).send({
          success: false,
          error: 'No tienes permisos para acceder a este horario',
        });
      }

      return reply.code(200).send({
        success: true,
        data: horario,
      });
    } catch (error) {
      console.error('Error en getById horario:', error);
      throw error;
    }
  }

  public static async create(request: AuthenticatedRequest & FastifyRequest<{ Body: CreateHorarioBody }>, reply: FastifyReply) {
    try {
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: { usuarioId: request.user!.id, activo: true },
      });

      if (!usuarioInstitucion) {
        return reply.code(400).send({
          success: false,
          error: 'El usuario no tiene una instituciÃ³n asignada',
        });
      }
      const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      const { periodoId, grupoId, materiaId, profesorId } = request.body;

      if (!uuidRegex.test(periodoId) || !uuidRegex.test(grupoId) || !uuidRegex.test(materiaId)) {
        return reply.code(400).send({
          success: false,
          error: 'Formato de ID invÃ¡lido',
          code: 'VALIDATION_ERROR'
        });
      }

      if (profesorId && !uuidRegex.test(profesorId)) {
        return reply.code(400).send({
          success: false,
          error: 'Formato de ID del profesor invÃ¡lido',
          code: 'VALIDATION_ERROR'
        });
      }

      const data = {
        ...request.body,
        institucionId: usuarioInstitucion.institucionId,
      };

      const horario = await HorarioService.createHorario(data);

      return reply.code(201).send({
        success: true,
        data: horario,
        message: 'Horario creado exitosamente',
      });
    } catch (error) {
      console.error('Error en create horario:', error);
      if ((error as any).code === 'P2025' || (error as any).code === 'P2003') {
        return reply.code(400).send({
          success: false,
          error: 'IDs invÃ¡lidos en la solicitud',
          code: 'VALIDATION_ERROR'
        });
      }

      throw error;
    }
  }

  public static async update(request: AuthenticatedRequest & FastifyRequest<{ Params: GetHorarioParams; Body: UpdateHorarioBody }>, reply: FastifyReply) {
    try {
      const { id } = request.params;
      const data = request.body;
      const existingHorario = await HorarioService.getHorarioById(id);
      if (!existingHorario) {
        throw new NotFoundError('Horario');
      }

      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: { usuarioId: request.user!.id, activo: true },
      });

      if (usuarioInstitucion && existingHorario.institucionId !== usuarioInstitucion.institucionId) {
        return reply.code(403).send({
          success: false,
          error: 'No tienes permisos para modificar este horario',
        });
      }

      const horario = await HorarioService.updateHorario(id, data);

      if (!horario) {
        throw new NotFoundError('Horario');
      }

      return reply.code(200).send({
        success: true,
        data: horario,
        message: 'Horario actualizado exitosamente',
      });
    } catch (error) {
      console.error('Error en update horario:', error);
      throw error;
    }
  }

  public static async delete(request: AuthenticatedRequest & FastifyRequest<{ Params: GetHorarioParams }>, reply: FastifyReply) {
    try {
      const { id } = request.params;
      const existingHorario = await HorarioService.getHorarioById(id);
      if (!existingHorario) {
        throw new NotFoundError('Horario');
      }

      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: { usuarioId: request.user!.id, activo: true },
      });

      if (usuarioInstitucion && existingHorario.institucionId !== usuarioInstitucion.institucionId) {
        return reply.code(403).send({
          success: false,
          error: 'No tienes permisos para eliminar este horario',
        });
      }

      const success = await HorarioService.deleteHorario(id);

      return reply.code(200).send({
        success: true,
        message: 'Horario eliminado exitosamente',
      });
    } catch (error) {
      console.error('Error en delete horario:', error);
      throw error;
    }
  }
}

export default HorarioController;
/* Fin backend\src\controllers\horario.controller.ts */

/* Inicio backend\src\controllers\institucion.controller.ts */
import { FastifyReply, FastifyRequest } from 'fastify';
import { AuthenticatedRequest } from '../middleware/auth';
import InstitucionService from '../services/institucion.service';
import { NotFoundError } from '../types';

interface GetInstitucionParams {
  id: string;
}

interface CreateInstitucionBody {
  nombre: string;
  direccion?: string;
  telefono?: string;
  email?: string;
}

interface UpdateInstitucionBody {
  nombre?: string;
  direccion?: string;
  telefono?: string;
  email?: string;
  activa?: boolean;
}

export class InstitucionController {
  public static async getAll(request: AuthenticatedRequest, reply: FastifyReply) {
    try {
      const { page, limit, activa, search } = request.query as {
        page?: string;
        limit?: string;
        activa?: string;
        search?: string;
      };
      const pageNum = page ? parseInt(page, 10) : 1;
      const limitNum = limit ? parseInt(limit, 10) : 10;

      if (pageNum < 1 || limitNum < 1 || limitNum > 100) {
        return reply.code(400).send({
          success: false,
          error: 'Los parÃ¡metros de paginaciÃ³n deben ser mayores a 0. El lÃ­mite mÃ¡ximo es 100.',
        });
      }

      const pagination = {
        page: pageNum,
        limit: limitNum,
      };

      const filters = {
        activa: activa !== undefined ? activa === 'true' : undefined,
        search: search || undefined,
      };

      const result = await InstitucionService.getAllInstitutions(pagination, filters);

      return reply.code(200).send({
        success: true,
        data: result.data,
        pagination: result.pagination,
      });
    } catch (error) {
      throw error;
    }
  }

  public static async getById(request: AuthenticatedRequest & FastifyRequest<{ Params: GetInstitucionParams }>, reply: FastifyReply) {
    try {
      const { id } = request.params;

      const institution = await InstitucionService.getInstitutionById(id);

      if (!institution) {
        throw new NotFoundError('InstituciÃ³n');
      }

      return reply.code(200).send({
        success: true,
        data: institution,
      });
    } catch (error) {
      throw error;
    }
  }

  public static async create(request: AuthenticatedRequest & FastifyRequest<{ Body: CreateInstitucionBody }>, reply: FastifyReply) {
    try {
      const data = request.body;

      const institution = await InstitucionService.createInstitution(data);

      return reply.code(201).send({
        success: true,
        data: institution,
        message: 'InstituciÃ³n creada exitosamente',
      });
    } catch (error) {
      throw error;
    }
  }

  public static async update(request: AuthenticatedRequest & FastifyRequest<{ Params: GetInstitucionParams; Body: UpdateInstitucionBody }>, reply: FastifyReply) {
    try {
      const { id } = request.params;
      const data = request.body;

      const institution = await InstitucionService.updateInstitution(id, data);

      if (!institution) {
        throw new NotFoundError('InstituciÃ³n');
      }

      return reply.code(200).send({
        success: true,
        data: institution,
        message: 'InstituciÃ³n actualizada exitosamente',
      });
    } catch (error) {
      throw error;
    }
  }

  public static async delete(request: AuthenticatedRequest & FastifyRequest<{ Params: GetInstitucionParams }>, reply: FastifyReply) {
    try {
      const { id } = request.params;

      const success = await InstitucionService.deleteInstitution(id);

      return reply.code(200).send({
        success: true,
        message: 'InstituciÃ³n eliminada exitosamente',
      });
    } catch (error) {
      throw error;
    }
  }
  public static async getAdminsByInstitution(request: AuthenticatedRequest & FastifyRequest<{ Params: GetInstitucionParams }>, reply: FastifyReply) {
    try {
      const { id } = request.params;
      const admins = await InstitucionService.getAdminsByInstitution(id);

      return reply.code(200).send({
        success: true,
        data: admins,
      });
    } catch (error) {
      throw error;
    }
  }

  public static async assignAdminToInstitution(request: AuthenticatedRequest & FastifyRequest<{ Params: GetInstitucionParams; Body: { userId: string } }>, reply: FastifyReply) {
    try {
      const { id } = request.params;
      const { userId } = request.body as { userId: string };

      const result = await InstitucionService.assignAdminToInstitution(id, userId);

      return reply.code(201).send({
        success: true,
        data: result,
        message: 'Administrador asignado a la instituciÃ³n exitosamente',
      });
    } catch (error) {
      throw error;
    }
  }

  public static async removeAdminFromInstitution(request: AuthenticatedRequest & FastifyRequest<{ Params: { id: string; userId: string } }>, reply: FastifyReply) {
    try {
      const { id, userId } = request.params;

      const result = await InstitucionService.removeAdminFromInstitution(id, userId);

      return reply.code(200).send({
        success: true,
        data: result,
        message: 'Administrador removido de la instituciÃ³n exitosamente',
      });
    } catch (error) {
      throw error;
    }
  }
}

export default InstitucionController;
/* Fin backend\src\controllers\institucion.controller.ts */

/* Inicio backend\src\controllers\institution-admin.controller.ts */
import { FastifyReply, FastifyRequest } from 'fastify';
import { prisma } from '../config/database';
import ProfesorService, { ProfesorFilters, UpdateProfesorRequest } from '../services/profesor.service';
import { ApiResponse, AuthenticatedRequest, NotFoundError, PaginationParams, ValidationError } from '../types';

interface CreateProfesorBody {
  nombres: string;
  apellidos: string;
  email: string;
  password: string;
  grupoId?: string;
}

export class InstitutionAdminController {

  public static async getAllProfesores(
    request: FastifyRequest<{
      Querystring: {
        page?: string;
        limit?: string;
        activo?: string;
        search?: string;
      };
    }>,
    reply: FastifyReply
  ) {
    try {
      const user = (request as AuthenticatedRequest).user;
      const { page, limit, activo, search } = request.query;
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: {
          usuarioId: user.id,
          activo: true,
        },
        include: {
          institucion: true,
        },
      });

      if (!usuarioInstitucion) {
        return reply.code(403).send({
          success: false,
          message: 'No tienes una instituciÃ³n asignada',
        });
      }

      const institucionId = usuarioInstitucion.institucionId;
      const pagination: PaginationParams = {};
      if (page) {
        const pageNum = parseInt(page, 10);
        if (pageNum < 1) {
          throw new ValidationError('El parÃ¡metro page debe ser mayor a 0.');
        }
        pagination.page = pageNum;
      }
      if (limit) {
        const limitNum = parseInt(limit, 10);
        if (limitNum < 1 || limitNum > 100) {
          throw new ValidationError('El parÃ¡metro limit debe ser mayor a 0 y mÃ¡ximo 100.');
        }
        pagination.limit = limitNum;
      }
      const filters: ProfesorFilters = { institucionId };
      if (activo !== undefined && activo !== null) {
        filters.activo = String(activo).toLowerCase() === 'true';
      }
      if (search) filters.search = search;
      const result = await ProfesorService.getAll(institucionId, pagination, filters);

      return reply.code(200).send({
        success: true,
        data: result.data,
        pagination: result.pagination,
      });
    } catch (error) {
      throw error;
    }
  }

  public static async getProfesorById(
    request: FastifyRequest<{ Params: { id: string } }>,
    reply: FastifyReply
  ) {
    try {
      const user = (request as AuthenticatedRequest).user;
      const { id } = request.params;
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: {
          usuarioId: user.id,
          activo: true,
        },
        include: {
          institucion: true,
        },
      });

      if (!usuarioInstitucion) {
        return reply.code(403).send({
          success: false,
          message: 'No tienes una instituciÃ³n asignada',
        });
      }

      const institucionId = usuarioInstitucion.institucionId;

      const profesor = await ProfesorService.getById(id, institucionId);

      if (!profesor) {
        throw new NotFoundError('Profesor');
      }

      return reply.code(200).send({
        success: true,
        data: profesor,
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async createProfesor(
    request: FastifyRequest<{ Body: CreateProfesorBody }>,
    reply: FastifyReply
  ) {
    try {
      const user = (request as AuthenticatedRequest).user;
      const profesorData = request.body;
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: {
          usuarioId: user.id,
          activo: true,
        },
        include: {
          institucion: true,
        },
      });

      if (!usuarioInstitucion) {
        return reply.code(403).send({
          success: false,
          message: 'No tienes una instituciÃ³n asignada',
        });
      }

      const institucionId = usuarioInstitucion.institucionId;

      const newProfesor = await ProfesorService.create({
        nombres: profesorData.nombres,
        apellidos: profesorData.apellidos,
        email: profesorData.email,
        password: profesorData.password,
        institucionId: institucionId,
        grupoId: profesorData.grupoId,
      }, user.id);

      return reply.code(201).send({
        success: true,
        data: newProfesor,
        message: 'Profesor creado exitosamente',
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async updateProfesor(
    request: FastifyRequest<{
      Params: { id: string };
      Body: UpdateProfesorRequest;
    }>,
    reply: FastifyReply
  ) {
    try {
      const user = (request as AuthenticatedRequest).user;
      const { id } = request.params;
      const profesorData = request.body;
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: {
          usuarioId: user.id,
          activo: true,
        },
        include: {
          institucion: true,
        },
      });

      if (!usuarioInstitucion) {
        return reply.code(403).send({
          success: false,
          message: 'No tienes una instituciÃ³n asignada',
        });
      }

      const institucionId = usuarioInstitucion.institucionId;

      const updatedProfesor = await ProfesorService.update(id, institucionId, profesorData);

      if (!updatedProfesor) {
        throw new NotFoundError('Profesor');
      }

      return reply.code(200).send({
        success: true,
        data: updatedProfesor,
        message: 'Profesor actualizado exitosamente',
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async deleteProfesor(
    request: FastifyRequest<{ Params: { id: string } }>,
    reply: FastifyReply
  ) {
    try {
      const user = (request as AuthenticatedRequest).user;
      const { id } = request.params;
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: {
          usuarioId: user.id,
          activo: true,
        },
        include: {
          institucion: true,
        },
      });

      if (!usuarioInstitucion) {
        return reply.code(403).send({
          success: false,
          message: 'No tienes una instituciÃ³n asignada',
        });
      }

      const institucionId = usuarioInstitucion.institucionId;

      const deleted = await ProfesorService.delete(id, institucionId);

      if (!deleted) {
        throw new NotFoundError('Profesor');
      }

      return reply.code(200).send({
        success: true,
        data: null,
        message: 'Profesor eliminado exitosamente',
      } as ApiResponse<null>);
    } catch (error) {
      throw error;
    }
  }

  public static async toggleProfesorStatus(
    request: FastifyRequest<{ Params: { id: string } }>,
    reply: FastifyReply
  ) {
    try {
      const user = (request as AuthenticatedRequest).user;
      const { id } = request.params;
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: {
          usuarioId: user.id,
          activo: true,
        },
        include: {
          institucion: true,
        },
      });

      if (!usuarioInstitucion) {
        return reply.code(403).send({
          success: false,
          message: 'No tienes una instituciÃ³n asignada',
        });
      }

      const institucionId = usuarioInstitucion.institucionId;

      const profesor = await ProfesorService.toggleStatus(id, institucionId);

      if (!profesor) {
        throw new NotFoundError('Profesor');
      }

      return reply.code(200).send({
        success: true,
        data: profesor,
        message: `Profesor ${profesor.activo ? 'activado' : 'desactivado'} exitosamente`,
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }
}

export default InstitutionAdminController;
/* Fin backend\src\controllers\institution-admin.controller.ts */

/* Inicio backend\src\controllers\materia.controller.ts */
import { FastifyReply, FastifyRequest } from 'fastify';
import { prisma } from '../config/database';
import { AuthenticatedRequest } from '../middleware/auth';
import MateriaService from '../services/materia.service';
import { NotFoundError, ValidationError } from '../types';

interface GetMateriasQuery {
  page?: string;
  limit?: string;
  search?: string;
}

interface GetMateriaParams {
  id: string;
}

interface CreateMateriaBody {
  nombre: string;
  codigo?: string;
}

interface UpdateMateriaBody {
  nombre?: string;
  codigo?: string;
}

export class MateriaController {

  public static async getAll(request: AuthenticatedRequest & FastifyRequest<{ Querystring: GetMateriasQuery }>, reply: FastifyReply) {
    try {
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: { usuarioId: request.user!.id, activo: true },
      });

      if (!usuarioInstitucion) {
        return reply.code(400).send({
          success: false,
          error: 'El usuario no tiene una instituciÃ³n asignada',
        });
      }

      const { page, limit, search } = request.query;
      const pageNum = page ? parseInt(page, 10) : 1;
      const limitNum = limit ? parseInt(limit, 10) : 10;

      if (pageNum < 1 || limitNum < 1 || limitNum > 100) {
        throw new ValidationError('Los parÃ¡metros de paginaciÃ³n deben ser mayores a 0. El lÃ­mite mÃ¡ximo es 100.');
      }

      const pagination = {
        page: pageNum,
        limit: limitNum,
      };

      const filters = {
        search: search || undefined,
      };

      const result = await MateriaService.getAllMateriasByInstitucion(usuarioInstitucion.institucionId, pagination, filters);

      return reply.code(200).send({
        success: true,
        data: result.data,
        pagination: result.pagination,
      });
    } catch (error) {
      console.error('Error en getAll materias:', error);
      throw error;
    }
  }

  public static async getById(request: AuthenticatedRequest & FastifyRequest<{ Params: GetMateriaParams }>, reply: FastifyReply) {
    try {
      const { id } = request.params;

      const materia = await MateriaService.getMateriaById(id);

      if (!materia) {
        throw new NotFoundError('Materia');
      }
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: { usuarioId: request.user!.id, activo: true },
      });

      if (usuarioInstitucion && materia.institucionId !== usuarioInstitucion.institucionId) {
        return reply.code(403).send({
          success: false,
          error: 'No tienes permisos para acceder a esta materia',
        });
      }

      return reply.code(200).send({
        success: true,
        data: materia,
      });
    } catch (error) {
      console.error('Error en getById materia:', error);
      throw error;
    }
  }

  public static async create(request: AuthenticatedRequest & FastifyRequest<{ Body: CreateMateriaBody }>, reply: FastifyReply) {
    try {
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: { usuarioId: request.user!.id, activo: true },
      });

      if (!usuarioInstitucion) {
        return reply.code(400).send({
          success: false,
          error: 'El usuario no tiene una instituciÃ³n asignada',
        });
      }

      const data = {
        ...request.body,
        institucionId: usuarioInstitucion.institucionId,
      };

      const materia = await MateriaService.createMateria(data);

      return reply.code(201).send({
        success: true,
        data: materia,
        message: 'Materia creada exitosamente',
      });
    } catch (error) {
      console.error('Error en create materia:', error);
      throw error;
    }
  }

  public static async update(request: AuthenticatedRequest & FastifyRequest<{ Params: GetMateriaParams; Body: UpdateMateriaBody }>, reply: FastifyReply) {
    try {
      const { id } = request.params;
      const data = request.body;
      const existingMateria = await MateriaService.getMateriaById(id);
      if (!existingMateria) {
        throw new NotFoundError('Materia');
      }

      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: { usuarioId: request.user!.id, activo: true },
      });

      if (usuarioInstitucion && existingMateria.institucionId !== usuarioInstitucion.institucionId) {
        return reply.code(403).send({
          success: false,
          error: 'No tienes permisos para modificar esta materia',
        });
      }

      const materia = await MateriaService.updateMateria(id, data);

      if (!materia) {
        throw new NotFoundError('Materia');
      }

      return reply.code(200).send({
        success: true,
        data: materia,
        message: 'Materia actualizada exitosamente',
      });
    } catch (error) {
      console.error('Error en update materia:', error);
      throw error;
    }
  }

  public static async delete(request: AuthenticatedRequest & FastifyRequest<{ Params: GetMateriaParams }>, reply: FastifyReply) {
    try {
      const { id } = request.params;
      const existingMateria = await MateriaService.getMateriaById(id);
      if (!existingMateria) {
        throw new NotFoundError('Materia');
      }

      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: { usuarioId: request.user!.id, activo: true },
      });

      if (usuarioInstitucion && existingMateria.institucionId !== usuarioInstitucion.institucionId) {
        return reply.code(403).send({
          success: false,
          error: 'No tienes permisos para eliminar esta materia',
        });
      }

      const success = await MateriaService.deleteMateria(id);

      return reply.code(200).send({
        success: true,
        message: 'Materia eliminada exitosamente',
      });
    } catch (error) {
      console.error('Error en delete materia:', error);
      throw error;
    }
  }

  public static async getMateriasDisponibles(request: AuthenticatedRequest, reply: FastifyReply) {
    try {
      const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
        where: { usuarioId: request.user!.id, activo: true },
      });

      if (!usuarioInstitucion) {
        return reply.code(400).send({
          success: false,
          error: 'El usuario no tiene una instituciÃ³n asignada',
        });
      }

      const materias = await MateriaService.getMateriasDisponibles(usuarioInstitucion.institucionId);

      return reply.code(200).send({
        success: true,
        data: materias,
      });
    } catch (error) {
      console.error('Error en getMateriasDisponibles:', error);
      throw error;
    }
  }
}

export default MateriaController;
/* Fin backend\src\controllers\materia.controller.ts */

/* Inicio backend\src\controllers\profesor.controller.ts */
import { FastifyReply } from 'fastify';
import { ProfesorService } from '../services/profesor.service';
import { AuthenticatedRequest } from '../types';

export class ProfesorController {

  public static async getClasesDelDia(
    request: AuthenticatedRequest,
    reply: FastifyReply
  ) {
    try {
      const profesorId = request.user.id;

      const clases = await ProfesorService.getClasesDelDia(profesorId);

      return reply.status(200).send({
        success: true,
        data: clases,
        message: 'Clases del dÃ­a obtenidas exitosamente',
      });
    } catch (error) {
      console.error('Error en getClasesDelDia:', error);
      return reply.status(500).send({
        success: false,
        message: 'Error interno del servidor',
      });
    }
  }

  public static async getClasesPorDia(
    request: AuthenticatedRequest & { params: { diaSemana: string } },
    reply: FastifyReply
  ) {
    try {
      const profesorId = request.user.id;
      const diaSemana = parseInt(request.params.diaSemana);
      if (isNaN(diaSemana) || diaSemana < 1 || diaSemana > 7) {
        return reply.status(400).send({
          success: false,
          message: 'El dÃ­a de la semana debe ser un nÃºmero entre 1 (Lunes) y 7 (Domingo)',
        });
      }

      const clases = await ProfesorService.getClasesPorDia(profesorId, diaSemana);

      return reply.status(200).send({
        success: true,
        data: clases,
        message: `Clases del dÃ­a ${diaSemana} obtenidas exitosamente`,
      });
    } catch (error) {
      console.error('Error en getClasesPorDia:', error);
      return reply.status(500).send({
        success: false,
        message: 'Error interno del servidor',
      });
    }
  }

  public static async getHorarioSemanal(
    request: AuthenticatedRequest,
    reply: FastifyReply
  ) {
    try {
      const profesorId = request.user.id;

      const horarioSemanal = await ProfesorService.getHorarioSemanal(profesorId);

      return reply.status(200).send({
        success: true,
        data: horarioSemanal,
        message: 'Horario semanal obtenido exitosamente',
      });
    } catch (error) {
      console.error('Error en getHorarioSemanal:', error);
      return reply.status(500).send({
        success: false,
        message: 'Error interno del servidor',
      });
    }
  }
}

export default ProfesorController;
/* Fin backend\src\controllers\profesor.controller.ts */

/* Inicio backend\src\controllers\user.controller.ts */
import { FastifyReply, FastifyRequest } from 'fastify';
import { prisma } from '../config/database';
import UserService from '../services/user.service';
import { ApiResponse, AuthenticatedRequest, AuthorizationError, NotFoundError, PaginationParams, UserFilters } from '../types';

export class UserController {

  public static async getAllUsers(
    request: FastifyRequest<{
      Querystring: {
        page?: string;
        limit?: string;
        rol?: string;
        institucionId?: string;
        activo?: string;
        search?: string;
      };
    }>,
    reply: FastifyReply
  ) {
    try {
      const { page, limit, rol, institucionId, activo, search } = request.query;
      const pagination: PaginationParams = {};
      if (page) {
        const pageNum = parseInt(page, 10);
        if (pageNum < 1) {
          return reply.code(400).send({
            success: false,
            error: 'El parÃ¡metro page debe ser mayor a 0.',
          });
        }
        pagination.page = pageNum;
      }
      if (limit) {
        const limitNum = parseInt(limit, 10);
        if (limitNum < 1 || limitNum > 100) {
          return reply.code(400).send({
            success: false,
            error: 'El parÃ¡metro limit debe ser mayor a 0 y mÃ¡ximo 100.',
          });
        }
        pagination.limit = limitNum;
      }
      const filters: UserFilters = {};
      if (rol) filters.rol = rol as any;
      if (institucionId) filters.institucionId = institucionId;
      if (activo !== undefined) filters.activo = activo === 'true';
      if (search) filters.search = search;

      const result = await UserService.getAllUsers(pagination, filters);

      return reply.code(200).send({
        success: true,
        data: result.data,
        pagination: result.pagination,
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async changePassword(
    request: FastifyRequest<{ Params: { id: string }; Body: { newPassword: string } }>,
    reply: FastifyReply
  ) {
    try {
      const { id } = request.params;
      const { newPassword } = request.body as { newPassword: string };
      const authReq = request as AuthenticatedRequest;
      const invoker = authReq.user;

      if (invoker.rol === 'admin_institucion') {
        const usuarioInstitucion = await prisma.usuarioInstitucion.findFirst({
          where: { usuarioId: invoker.id, activo: true },
        });

        if (!usuarioInstitucion) {
          throw new AuthorizationError('No tienes una instituciÃ³n asignada');
        }

        const institucionId = usuarioInstitucion.institucionId;
        const targetRelation = await prisma.usuarioInstitucion.findFirst({
          where: { usuarioId: id, institucionId, activo: true },
        });

        if (!targetRelation) {
          throw new AuthorizationError('No tienes permiso para cambiar la contraseÃ±a de este usuario');
        }
      }

      await UserService.changeUserPassword(id, newPassword);

      return reply.code(200).send({ success: true, message: 'ContraseÃ±a actualizada exitosamente' });
    } catch (error) {
      throw error;
    }
  }

  public static async getUserById(
    request: FastifyRequest<{ Params: { id: string } }>,
    reply: FastifyReply
  ) {
    try {
      const { id } = request.params;

      const user = await UserService.getUserById(id);

      if (!user) {
        throw new NotFoundError('Usuario');
      }

      return reply.code(200).send({
        success: true,
        data: user,
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async getUsersByRole(
    request: FastifyRequest<{
      Params: { role: string };
      Querystring: {
        page?: string;
        limit?: string;
        institucionId?: string;
        activo?: string;
        search?: string;
      };
    }>,
    reply: FastifyReply
  ) {
    try {
      const { role } = request.params;
      const { page, limit, institucionId, activo, search } = request.query;
      const pagination: PaginationParams = {};
      if (page) {
        const pageNum = parseInt(page, 10);
        if (pageNum < 1) {
          return reply.code(400).send({
            success: false,
            error: 'El parÃ¡metro page debe ser mayor a 0.',
          });
        }
        pagination.page = pageNum;
      }
      if (limit) {
        const limitNum = parseInt(limit, 10);
        if (limitNum < 1 || limitNum > 100) {
          return reply.code(400).send({
            success: false,
            error: 'El parÃ¡metro limit debe ser mayor a 0 y mÃ¡ximo 100.',
          });
        }
        pagination.limit = limitNum;
      }
      const filters: UserFilters = {};
      if (institucionId) filters.institucionId = institucionId;
      if (activo !== undefined) filters.activo = activo === 'true';
      if (search) filters.search = search;

      const result = await UserService.getUsersByRole(role, pagination, filters);

      return reply.code(200).send({
        success: true,
        data: result.data,
        pagination: result.pagination,
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async getUsersByInstitution(
    request: FastifyRequest<{
      Params: { institucionId: string };
      Querystring: {
        page?: string;
        limit?: string;
        rol?: string;
        activo?: string;
        search?: string;
      };
    }>,
    reply: FastifyReply
  ) {
    try {
      const { institucionId } = request.params;
      const { page, limit, rol, activo, search } = request.query;
      const pagination: PaginationParams = {};
      if (page) {
        const pageNum = parseInt(page, 10);
        if (pageNum < 1) {
          return reply.code(400).send({
            success: false,
            error: 'El parÃ¡metro page debe ser mayor a 0.',
          });
        }
        pagination.page = pageNum;
      }
      if (limit) {
        const limitNum = parseInt(limit, 10);
        if (limitNum < 1 || limitNum > 100) {
          return reply.code(400).send({
            success: false,
            error: 'El parÃ¡metro limit debe ser mayor a 0 y mÃ¡ximo 100.',
          });
        }
        pagination.limit = limitNum;
      }
      const filters: UserFilters = {};
      if (rol) filters.rol = rol as any;
      if (activo !== undefined) filters.activo = activo === 'true';
      if (search) filters.search = search;

      const result = await UserService.getUsersByInstitution(institucionId, pagination, filters);

      return reply.code(200).send({
        success: true,
        data: result.data,
        pagination: result.pagination,
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async createUser(
    request: FastifyRequest<{ Body: any }>,
    reply: FastifyReply
  ) {
    try {
      const userData = request.body as any;
      const invokerRole = (request as AuthenticatedRequest).user.rol;

      const result = await UserService.createUser(userData, invokerRole);

      return reply.code(201).send({
        success: true,
        data: result,
        message: 'Usuario creado exitosamente',
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async updateUser(
    request: FastifyRequest<{
      Params: { id: string };
      Body: any;
    }>,
    reply: FastifyReply
  ) {
    try {
      const { id } = request.params;
      const userData = request.body as any;

      const result = await UserService.updateUser(id, userData);

      if (!result) {
        throw new NotFoundError('Usuario');
      }

      return reply.code(200).send({
        success: true,
        data: result,
        message: 'Usuario actualizado exitosamente',
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }

  public static async deleteUser(
    request: FastifyRequest<{ Params: { id: string } }>,
    reply: FastifyReply
  ) {
    try {
      const { id } = request.params;

      const result = await UserService.deleteUser(id);

      return reply.code(200).send({
        success: true,
        data: { deleted: result },
        message: 'Usuario eliminado exitosamente',
      } as ApiResponse<any>);
    } catch (error) {
      throw error;
    }
  }
}

export default UserController;
/* Fin backend\src\controllers\user.controller.ts */

/* Inicio backend\src\index.ts */
import fastifyCors from '@fastify/cors';
import fastifyFormbody from '@fastify/formbody';
import Fastify from 'fastify';
import { config } from './config/app';
import { databaseService } from './config/database';
import setupErrorHandler from './middleware/errorHandler';
import routes from './routes';
import AuthService from './services/auth.service';

const fastify = Fastify({
  logger: config.nodeEnv === 'development',
});

fastify.register(fastifyCors, {
  origin: true, // Permite cualquier origen
  credentials: true, // Permite el envÃ­o de cookies y credenciales
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
});

fastify.register(fastifyFormbody);

setupErrorHandler(fastify);

fastify.register(routes);

const start = async () => {
  try {
    console.log('ðŸš€ Iniciando AsistApp Backend v2.0...');

    await databaseService.connect();

    await AuthService.ensureAdminUser();

    console.log('ðŸŒ Iniciando servidor...');
    await fastify.listen({
      port: config.port,
      host: config.host
    });

    console.log('âœ… Servidor corriendo en:');
    console.log(`   - Local:   http://localhost:${config.port}`);
    console.log(`   - Red:     http://192.168.20.22:${config.port}`);
    console.log('ðŸŽ¯ API lista para recibir conexiones');
    console.log('ðŸ“š DocumentaciÃ³n disponible en las URLs anteriores');

    if (config.nodeEnv === 'production') {
      setInterval(() => {
        console.log('ðŸ’“ Servidor activo...');
      }, 300000)
    }

  } catch (err) {
    console.error('âŒ Error al iniciar servidor:', err);
    fastify.log.error(err);
    process.exit(1);
  }
};

process.on('SIGINT', async () => {
  console.log('\nðŸ›‘ Recibida seÃ±al SIGINT, cerrando servidor...');

});

process.on('SIGTERM', async () => {
  console.log('\nðŸ›‘ Recibida seÃ±al SIGTERM, cerrando servidor...');
  await gracefulShutdown();
});

const gracefulShutdown = async () => {
  try {
    console.log('ï¿½ Cerrando conexiones...');

    await fastify.close();

    await databaseService.disconnect();

    console.log('âœ… Servidor cerrado correctamente');
    process.exit(0);
  } catch (error) {
    console.error('âŒ Error durante el cierre:', error);
    process.exit(1);
  }
};

process.on('uncaughtException', (err) => {
  console.error('âŒ Uncaught Exception:', err);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('âŒ Unhandled Rejection at:', promise, 'reason:', reason);
  process.exit(1);
});

start();

export default fastify;
/* Fin backend\src\index.ts */

/* Inicio backend\src\middleware\auth.ts */
import { FastifyReply, FastifyRequest } from 'fastify';
import AuthService from '../services/auth.service';
import { AuthenticationError, AuthorizationError, JWTPayload, UserRole } from '../types';

export interface AuthenticatedRequest extends FastifyRequest {
  user?: JWTPayload;
}

export const authenticate = async (request: AuthenticatedRequest, reply: FastifyReply) => {
  try {
    const authHeader = request.headers.authorization;
    console.log(`ðŸ”‘ Iniciando autenticaciÃ³n - Header: ${authHeader ? 'presente' : 'ausente'}`);

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      console.log('âŒ Header de autorizaciÃ³n faltante o malformado');
      throw new AuthenticationError('Token de autenticaciÃ³n requerido');
    }

    const token = authHeader.substring(7)
    console.log(`ðŸ”‘ Token extraÃ­do: ${token.substring(0, 20)}...`);

    if (!token) {
      console.log('âŒ Token vacÃ­o');
      throw new AuthenticationError('Token de autenticaciÃ³n requerido');
    }

    const decoded = await AuthService.verifyToken(token);
    request.user = decoded;
    console.log(`âœ… AutenticaciÃ³n exitosa - Usuario: ${decoded.email}, Rol: ${decoded.rol}`);

  } catch (error) {
    console.log(`ðŸ’¥ Error en middleware de autenticaciÃ³n: ${(error as Error).message}`);
    if (error instanceof AuthenticationError) {
      return reply.code(error.statusCode).send({
        success: false,
        error: error.message,
        code: error.code,
      });
    }

    if (error instanceof Error && (error.message.includes('invÃ¡lido') || error.message.includes('expirado'))) {
      return reply.code(401).send({
        success: false,
        error: 'Token de autenticaciÃ³n invÃ¡lido',
        code: 'AUTHENTICATION_ERROR',
      });
    }
    throw error;
  }
};

export const authorize = (allowedRoles: UserRole[]) => {
  return async (request: AuthenticatedRequest, reply: FastifyReply) => {
    try {
      console.log(`ðŸ” Verificando autorizaciÃ³n - Usuario: ${request.user?.rol}, Roles permitidos: ${allowedRoles.join(', ')}`);

      if (!request.user) {
        console.log('âŒ Usuario no autenticado en middleware de autorizaciÃ³n');
        throw new AuthenticationError('Usuario no autenticado');
      }

      if (!allowedRoles.includes(request.user.rol)) {
        console.log(`âŒ Acceso denegado: rol '${request.user.rol}' no estÃ¡ en ${allowedRoles.join(', ')}`);
        throw new AuthorizationError('Acceso denegado: rol insuficiente');
      }

      console.log(`âœ… AutorizaciÃ³n exitosa para rol '${request.user.rol}'`);
    } catch (error) {
      console.log(`ðŸ’¥ Error en middleware de autorizaciÃ³n: ${(error as Error).message}`);
      if (error instanceof AuthenticationError || error instanceof AuthorizationError) {
        return reply.code(error.statusCode).send({
          success: false,
          error: error.message,
          code: error.code,
        });
      }
      throw error;
    }
  };
};

export const optionalAuthenticate = async (request: AuthenticatedRequest, reply: FastifyReply) => {
  try {
    const authHeader = request.headers.authorization;

    if (authHeader && authHeader.startsWith('Bearer ')) {
      const token = authHeader.substring(7);
      if (token) {
        const decoded = await AuthService.verifyToken(token);
        request.user = decoded;
      }
    }
  } catch (error) {

    console.warn('Error en autenticaciÃ³n opcional:', error);
  }
};

export default {
  authenticate,
  authorize,
  optionalAuthenticate,
};
/* Fin backend\src\middleware\auth.ts */

/* Inicio backend\src\middleware\errorHandler.ts */
import { FastifyInstance } from 'fastify';
import { AppError, DatabaseError } from '../types';

export const setupErrorHandler = (fastify: FastifyInstance) => {
  fastify.setErrorHandler((error: Error | AppError | DatabaseError, request, reply) => {

    fastify.log.error(error);

    if (error instanceof AppError) {
      return reply.code(error.statusCode).send({
        success: false,
        error: error.message,
        code: error.code,
      });
    }

    if ('validation' in error && error.validation) {
      return reply.code(400).send({
        success: false,
        error: 'Datos de entrada invÃ¡lidos',
        code: 'VALIDATION_ERROR',
        details: error.validation,
      });
    }

    if (error instanceof Error && 'code' in error && typeof (error as { code?: unknown }).code === 'string') {
      const prismaError = error as DatabaseError;

      if ('code' in prismaError) {

        if (prismaError.code === 'P2003') {
          return reply.code(400).send({
            success: false,
            error: 'Datos de referencia invÃ¡lidos',
            code: 'FOREIGN_KEY_ERROR',
          });
        }

        if (prismaError.code === 'P2002') {
          return reply.code(409).send({
            success: false,
            error: 'El registro ya existe',
            code: 'UNIQUE_CONSTRAINT_ERROR',
          });
        }

        if (prismaError.code === 'P2025') {
          return reply.code(404).send({
            success: false,
            error: 'Registro no encontrado',
            code: 'NOT_FOUND_ERROR',
          });
        }

        if (prismaError.code === 'P2000' || prismaError.code === 'P2001') {
          return reply.code(400).send({
            success: false,
            error: 'Datos invÃ¡lidos',
            code: 'VALIDATION_ERROR',
          });
        }
      }
    }

    if (error.message) {
      let statusCode = 500;
      let code = 'INTERNAL_ERROR';

      if (error.message.includes('Credenciales invÃ¡lidas') || error.message.includes('Usuario inactivo')) {
        statusCode = 401;
        code = 'AUTHENTICATION_ERROR';
      } else if (error.message.includes('Refresh token') || error.message.includes('Token invÃ¡lido')) {
        statusCode = 401;
        code = 'AUTHENTICATION_ERROR';
      } else if (error.message.includes('Acceso denegado')) {
        statusCode = 403;
        code = 'AUTHORIZATION_ERROR';
      } else if (error.message.includes('no encontrado')) {
        statusCode = 404;
        code = 'NOT_FOUND_ERROR';
      }

      return reply.code(statusCode).send({
        success: false,
        error: error.message,
        code,
      });
    }

    return reply.code(500).send({
      success: false,
      error: 'Error interno del servidor',
      code: 'INTERNAL_ERROR',
    });
  });

  fastify.setNotFoundHandler((request, reply) => {
    return reply.code(404).send({
      success: false,
      error: 'Ruta no encontrada',
      code: 'NOT_FOUND_ERROR',
    });
  });
};

export default setupErrorHandler;
/* Fin backend\src\middleware\errorHandler.ts */

/* Inicio backend\src\routes\admin-institucion.routes.ts */
import { FastifyInstance } from 'fastify';
import AdminInstitucionController from '../controllers/admin-institucion.controller';
import { authenticate, authorize } from '../middleware/auth';

export default async function adminInstitucionRoutes(fastify: FastifyInstance) {

  fastify.register(async function (adminInstitucionRoutes) {

    adminInstitucionRoutes.addHook('preHandler', authenticate);
    adminInstitucionRoutes.addHook('preHandler', authorize(['super_admin']));

    adminInstitucionRoutes.get('/', {
      handler: AdminInstitucionController.getAll,
    });

    adminInstitucionRoutes.get('/:id', {
      handler: AdminInstitucionController.getById,
    });

    adminInstitucionRoutes.post('/', {
      handler: AdminInstitucionController.create,
    });

    adminInstitucionRoutes.put('/:id', {
      handler: AdminInstitucionController.update,
    });

    adminInstitucionRoutes.delete('/:id', {
      handler: AdminInstitucionController.delete,
    });
  });
}
/* Fin backend\src\routes\admin-institucion.routes.ts */

/* Inicio backend\src\routes\auth.routes.ts */
import { FastifyInstance } from 'fastify';
import AuthController from '../controllers/auth.controller';
import { authenticate } from '../middleware/auth';

export default async function authRoutes(fastify: FastifyInstance) {
  fastify.register(async function (authRoutes) {
    authRoutes.post('/login', {
      handler: AuthController.login,
    });
    authRoutes.post('/login-test', {
      handler: AuthController.login,
    });
    authRoutes.get('/verify', {
      preHandler: authenticate,
      handler: AuthController.verify,
    });

    authRoutes.get('/instituciones', {
      preHandler: authenticate,
      handler: AuthController.getUserInstitutions,
    });

    authRoutes.post('/logout', {
      preHandler: authenticate,
      handler: AuthController.logout,
    });
    authRoutes.post('/refresh', {
      config: {
        rateLimit: {
          max: 10,
          timeWindow: '15 minutes',
        },
      },
      handler: AuthController.refreshToken,
    });
  });
}
/* Fin backend\src\routes\auth.routes.ts */

/* Inicio backend\src\routes\estudiante.routes.ts */
import { FastifyInstance } from 'fastify';
import { EstudianteController } from '../controllers/estudiante.controller';
import { authenticate, authorize } from '../middleware/auth';

export default async function estudianteRoutes(fastify: FastifyInstance) {

  fastify.register(async function (estudianteRoutes) {

    estudianteRoutes.addHook('preHandler', authenticate);
    estudianteRoutes.addHook('preHandler', authorize(['estudiante']));

    estudianteRoutes.get('/dashboard/clases-hoy', {
      handler: EstudianteController.getClasesHoy as any,
      schema: {
        description: 'Obtiene las clases que el estudiante tiene hoy',
        tags: ['Estudiantes - Dashboard'],
        summary: 'Clases del dÃ­a',
        security: [{ bearerAuth: [] }],
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: {
                type: 'array',
                items: {
                  type: 'object',
                  properties: {
                    id: { type: 'string' },
                    diaSemana: { type: 'number' },
                    horaInicio: { type: 'string' },
                    horaFin: { type: 'string' },
                    materia: {
                      type: 'object',
                      properties: {
                        id: { type: 'string' },
                        nombre: { type: 'string' },
                        codigo: { type: 'string' }
                      }
                    },
                    profesor: {
                      type: 'object',
                      properties: {
                        id: { type: 'string' },
                        nombres: { type: 'string' },
                        apellidos: { type: 'string' }
                      }
                    },
                    grupo: {
                      type: 'object',
                      properties: {
                        id: { type: 'string' },
                        nombre: { type: 'string' },
                        grado: { type: 'string' },
                        seccion: { type: 'string' }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    });

    estudianteRoutes.get('/dashboard/horario-semanal', {
      handler: EstudianteController.getHorarioSemanal as any,
      schema: {
        description: 'Obtiene el horario semanal completo del estudiante',
        tags: ['Estudiantes - Dashboard'],
        summary: 'Horario semanal',
        security: [{ bearerAuth: [] }],
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: {
                type: 'object',
                patternProperties: {
                  '^[1-7]$': {
                    type: 'array',
                    items: {
                      type: 'object',
                      properties: {
                        id: { type: 'string' },
                        diaSemana: { type: 'number' },
                        horaInicio: { type: 'string' },
                        horaFin: { type: 'string' },
                        materia: { type: 'object' },
                        profesor: { type: 'object' },
                        grupo: { type: 'object' }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    });

    estudianteRoutes.get('/dashboard/clases/:diaSemana', {
      handler: EstudianteController.getClasesPorDia as any,
      schema: {
        description: 'Obtiene las clases de un dÃ­a especÃ­fico para el estudiante',
        tags: ['Estudiantes - Dashboard'],
        summary: 'Clases por dÃ­a',
        security: [{ bearerAuth: [] }],
        params: {
          type: 'object',
          properties: {
            diaSemana: {
              type: 'string',
              pattern: '^[1-7]$',
              description: 'DÃ­a de la semana (1=Lunes, 7=Domingo)'
            }
          },
          required: ['diaSemana']
        },
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: { type: 'array' }
            }
          }
        }
      }
    });
    estudianteRoutes.get('/perfil', {
      handler: EstudianteController.getPerfil as any,
      schema: {
        description: 'Obtiene el perfil del estudiante',
        tags: ['Estudiantes'],
        summary: 'Perfil del estudiante',
        security: [{ bearerAuth: [] }],
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: { type: 'object' }
            }
          }
        }
      }
    });

    estudianteRoutes.get('/grupos', {
      handler: EstudianteController.getGrupos as any,
      schema: {
        description: 'Obtiene los grupos del estudiante',
        tags: ['Estudiantes'],
        summary: 'Grupos del estudiante',
        security: [{ bearerAuth: [] }],
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: { type: 'array' }
            }
          }
        }
      }
    });

  });

  console.log('âœ… Rutas del estudiante registradas exitosamente');
}
/* Fin backend\src\routes\estudiante.routes.ts */

/* Inicio backend\src\routes\grupo.routes.ts */
import { FastifyInstance } from 'fastify';
import GrupoController from '../controllers/grupo.controller';
import { authenticate, authorize } from '../middleware/auth';

export default async function grupoRoutes(fastify: FastifyInstance) {

  fastify.register(async function (grupoRoutes) {

    grupoRoutes.addHook('preHandler', authenticate);
    grupoRoutes.addHook('preHandler', authorize(['admin_institucion']));

    grupoRoutes.get('/', {
      handler: GrupoController.getAll as any,
      schema: {
        description: 'Obtener todos los grupos de la instituciÃ³n',
        tags: ['Grupos'],
        querystring: {
          type: 'object',
          properties: {
            page: { type: 'string', description: 'NÃºmero de pÃ¡gina' },
            limit: { type: 'string', description: 'Elementos por pÃ¡gina' },
            periodoId: { type: 'string', description: 'Filtrar por periodo acadÃ©mico' },
            grado: { type: 'string', description: 'Filtrar por grado' },
            seccion: { type: 'string', description: 'Filtrar por secciÃ³n' },
            search: { type: 'string', description: 'Buscar por nombre' },
          },
        },
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: {
                type: 'array',
                items: {
                  type: 'object',
                  properties: {
                    id: { type: 'string' },
                    nombre: { type: 'string' },
                    grado: { type: 'string' },
                    seccion: { type: 'string', nullable: true },
                    periodoId: { type: 'string' },
                    institucionId: { type: 'string' },
                    createdAt: { type: 'string' },
                    periodoAcademico: {
                      type: 'object',
                      properties: {
                        id: { type: 'string' },
                        nombre: { type: 'string' },
                        fechaInicio: { type: 'string' },
                        fechaFin: { type: 'string' },
                        activo: { type: 'boolean' },
                      },
                    },
                    _count: {
                      type: 'object',
                      properties: {
                        estudiantesGrupos: { type: 'number' },
                        horarios: { type: 'number' },
                      },
                    },
                  },
                },
              },
              pagination: {
                type: 'object',
                properties: {
                  page: { type: 'number' },
                  limit: { type: 'number' },
                  total: { type: 'number' },
                  totalPages: { type: 'number' },
                  hasNext: { type: 'boolean' },
                  hasPrev: { type: 'boolean' },
                },
              },
            },
          },
        },
      },
    });

    grupoRoutes.get('/disponibles', {
      handler: GrupoController.getGruposDisponibles as any,
      schema: {
        description: 'Obtener grupos disponibles para asignar estudiantes',
        tags: ['Grupos'],
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: {
                type: 'array',
                items: {
                  type: 'object',
                  properties: {
                    id: { type: 'string' },
                    nombre: { type: 'string' },
                    grado: { type: 'string' },
                    seccion: { type: 'string', nullable: true },
                    periodoId: { type: 'string' },
                    institucionId: { type: 'string' },
                    createdAt: { type: 'string' },
                    periodoAcademico: {
                      type: 'object',
                      properties: {
                        id: { type: 'string' },
                        nombre: { type: 'string' },
                        fechaInicio: { type: 'string' },
                        fechaFin: { type: 'string' },
                        activo: { type: 'boolean' },
                      },
                    },
                    _count: {
                      type: 'object',
                      properties: {
                        estudiantesGrupos: { type: 'number' },
                      },
                    },
                  },
                },
              },
            },
          },
        },
      },
    });

    grupoRoutes.get('/:id', {
      handler: GrupoController.getById as any,
      schema: {
        description: 'Obtener un grupo por ID',
        tags: ['Grupos'],
        params: {
          type: 'object',
          properties: {
            id: { type: 'string', description: 'ID del grupo' },
          },
          required: ['id'],
        },
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: {
                type: 'object',
                properties: {
                  id: { type: 'string' },
                  nombre: { type: 'string' },
                  grado: { type: 'string' },
                  seccion: { type: 'string', nullable: true },
                  periodoId: { type: 'string' },
                  institucionId: { type: 'string' },
                  createdAt: { type: 'string' },
                  periodoAcademico: {
                    type: 'object',
                    properties: {
                      id: { type: 'string' },
                      nombre: { type: 'string' },
                      fechaInicio: { type: 'string' },
                      fechaFin: { type: 'string' },
                      activo: { type: 'boolean' },
                    },
                  },
                  _count: {
                    type: 'object',
                    properties: {
                      estudiantesGrupos: { type: 'number' },
                      horarios: { type: 'number' },
                    },
                  },
                },
              },
            },
          },
        },
      },
    });

    grupoRoutes.post('/', {
      handler: GrupoController.create as any,
      schema: {
        description: 'Crear un nuevo grupo',
        tags: ['Grupos'],
        body: {
          type: 'object',
          properties: {
            nombre: { type: 'string', description: 'Nombre del grupo' },
            grado: { type: 'string', description: 'Grado del grupo' },
            seccion: { type: 'string', description: 'SecciÃ³n del grupo (opcional)' },
            periodoId: { type: 'string', description: 'ID del periodo acadÃ©mico' },
          },
          required: ['nombre', 'grado', 'periodoId'],
        },
        response: {
          201: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: {
                type: 'object',
                properties: {
                  id: { type: 'string' },
                  nombre: { type: 'string' },
                  grado: { type: 'string' },
                  seccion: { type: 'string', nullable: true },
                  periodoId: { type: 'string' },
                  institucionId: { type: 'string' },
                  createdAt: { type: 'string' },
                  periodoAcademico: {
                    type: 'object',
                    properties: {
                      id: { type: 'string' },
                      nombre: { type: 'string' },
                      fechaInicio: { type: 'string' },
                      fechaFin: { type: 'string' },
                      activo: { type: 'boolean' },
                    },
                  },
                  _count: {
                    type: 'object',
                    properties: {
                      estudiantesGrupos: { type: 'number' },
                      horarios: { type: 'number' },
                    },
                  },
                },
              },
              message: { type: 'string' },
            },
          },
        },
      },
    });

    grupoRoutes.put('/:id', {
      handler: GrupoController.update as any,
      schema: {
        description: 'Actualizar un grupo',
        tags: ['Grupos'],
        params: {
          type: 'object',
          properties: {
            id: { type: 'string', description: 'ID del grupo' },
          },
          required: ['id'],
        },
        body: {
          type: 'object',
          properties: {
            nombre: { type: 'string', description: 'Nombre del grupo' },
            grado: { type: 'string', description: 'Grado del grupo' },
            seccion: { type: 'string', description: 'SecciÃ³n del grupo (opcional)' },
            periodoId: { type: 'string', description: 'ID del periodo acadÃ©mico' },
          },
        },
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: {
                type: 'object',
                properties: {
                  id: { type: 'string' },
                  nombre: { type: 'string' },
                  grado: { type: 'string' },
                  seccion: { type: 'string', nullable: true },
                  periodoId: { type: 'string' },
                  institucionId: { type: 'string' },
                  createdAt: { type: 'string' },
                  periodoAcademico: {
                    type: 'object',
                    properties: {
                      id: { type: 'string' },
                      nombre: { type: 'string' },
                      fechaInicio: { type: 'string' },
                      fechaFin: { type: 'string' },
                      activo: { type: 'boolean' },
                    },
                  },
                  _count: {
                    type: 'object',
                    properties: {
                      estudiantesGrupos: { type: 'number' },
                      horarios: { type: 'number' },
                    },
                  },
                },
              },
              message: { type: 'string' },
            },
          },
        },
      },
    });

    grupoRoutes.delete('/:id', {
      handler: GrupoController.delete as any,
      schema: {
        description: 'Eliminar un grupo',
        tags: ['Grupos'],
        params: {
          type: 'object',
          properties: {
            id: { type: 'string', description: 'ID del grupo' },
          },
          required: ['id'],
        },
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              message: { type: 'string' },
            },
          },
        },
      },
    });
  });
}
/* Fin backend\src\routes\grupo.routes.ts */

/* Inicio backend\src\routes\horario.routes.ts */
import { FastifyInstance } from 'fastify';
import HorarioController from '../controllers/horario.controller';
import { authenticate, authorize } from '../middleware/auth';

export default async function horarioRoutes(fastify: FastifyInstance) {

  fastify.register(async function (horarioRoutes) {

    horarioRoutes.addHook('preHandler', authenticate);
    horarioRoutes.addHook('preHandler', authorize(['admin_institucion']));

    horarioRoutes.get('/', {
      handler: HorarioController.getAll as any,
      schema: {
        description: 'Obtener todos los horarios de la instituciÃ³n',
        tags: ['Horarios'],
        querystring: {
          type: 'object',
          properties: {
            page: { type: 'string', description: 'NÃºmero de pÃ¡gina' },
            limit: { type: 'string', description: 'Elementos por pÃ¡gina' },
            grupoId: { type: 'string', description: 'Filtrar por grupo' },
            materiaId: { type: 'string', description: 'Filtrar por materia' },
            profesorId: { type: 'string', description: 'Filtrar por profesor' },
            diaSemana: { type: 'string', description: 'Filtrar por dÃ­a de la semana (1-7)' },
          },
        },
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: {
                type: 'array',
                items: {
                  type: 'object',
                  properties: {
                    id: { type: 'string' },
                    periodoId: { type: 'string' },
                    grupoId: { type: 'string' },
                    materiaId: { type: 'string' },
                    profesorId: { type: 'string', nullable: true },
                    diaSemana: { type: 'number' },
                    horaInicio: { type: 'string' },
                    horaFin: { type: 'string' },
                    institucionId: { type: 'string' },
                    createdAt: { type: 'string' },
                    periodoAcademico: {
                      type: 'object',
                      properties: {
                        id: { type: 'string' },
                        nombre: { type: 'string' },
                        fechaInicio: { type: 'string' },
                        fechaFin: { type: 'string' },
                        activo: { type: 'boolean' },
                      },
                    },
                    grupo: {
                      type: 'object',
                      properties: {
                        id: { type: 'string' },
                        nombre: { type: 'string' },
                        grado: { type: 'string' },
                        seccion: { type: 'string', nullable: true },
                      },
                    },
                    materia: {
                      type: 'object',
                      properties: {
                        id: { type: 'string' },
                        nombre: { type: 'string' },
                        codigo: { type: 'string', nullable: true },
                      },
                    },
                    profesor: {
                      type: 'object',
                      nullable: true,
                      properties: {
                        id: { type: 'string' },
                        nombres: { type: 'string' },
                        apellidos: { type: 'string' },
                      },
                    },
                    _count: {
                      type: 'object',
                      properties: {
                        asistencias: { type: 'number' },
                      },
                    },
                  },
                },
              },
              pagination: {
                type: 'object',
                properties: {
                  page: { type: 'number' },
                  limit: { type: 'number' },
                  total: { type: 'number' },
                  totalPages: { type: 'number' },
                  hasNext: { type: 'boolean' },
                  hasPrev: { type: 'boolean' },
                },
              },
            },
          },
        },
      },
    });

    horarioRoutes.get('/grupo/:grupoId', {
      handler: HorarioController.getByGrupo as any,
      schema: {
        description: 'Obtener todos los horarios de un grupo especÃ­fico',
        tags: ['Horarios'],
        params: {
          type: 'object',
          properties: {
            grupoId: { type: 'string', description: 'ID del grupo' },
          },
          required: ['grupoId'],
        },
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: {
                type: 'array',
                items: {
                  type: 'object',
                  properties: {
                    id: { type: 'string' },
                    periodoId: { type: 'string' },
                    grupoId: { type: 'string' },
                    materiaId: { type: 'string' },
                    profesorId: { type: 'string', nullable: true },
                    diaSemana: { type: 'number' },
                    horaInicio: { type: 'string' },
                    horaFin: { type: 'string' },
                    institucionId: { type: 'string' },
                    createdAt: { type: 'string' },
                    periodoAcademico: {
                      type: 'object',
                      properties: {
                        id: { type: 'string' },
                        nombre: { type: 'string' },
                        fechaInicio: { type: 'string' },
                        fechaFin: { type: 'string' },
                        activo: { type: 'boolean' },
                      },
                    },
                    grupo: {
                      type: 'object',
                      properties: {
                        id: { type: 'string' },
                        nombre: { type: 'string' },
                        grado: { type: 'string' },
                        seccion: { type: 'string', nullable: true },
                      },
                    },
                    materia: {
                      type: 'object',
                      properties: {
                        id: { type: 'string' },
                        nombre: { type: 'string' },
                        codigo: { type: 'string', nullable: true },
                      },
                    },
                    profesor: {
                      type: 'object',
                      nullable: true,
                      properties: {
                        id: { type: 'string' },
                        nombres: { type: 'string' },
                        apellidos: { type: 'string' },
                      },
                    },
                    _count: {
                      type: 'object',
                      properties: {
                        asistencias: { type: 'number' },
                      },
                    },
                  },
                },
              },
            },
          },
        },
      },
    });

    horarioRoutes.get('/:id', {
      handler: HorarioController.getById as any,
      schema: {
        description: 'Obtener un horario por ID',
        tags: ['Horarios'],
        params: {
          type: 'object',
          properties: {
            id: { type: 'string', description: 'ID del horario' },
          },
          required: ['id'],
        },
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: {
                type: 'object',
                properties: {
                  id: { type: 'string' },
                  periodoId: { type: 'string' },
                  grupoId: { type: 'string' },
                  materiaId: { type: 'string' },
                  profesorId: { type: 'string', nullable: true },
                  diaSemana: { type: 'number' },
                  horaInicio: { type: 'string' },
                  horaFin: { type: 'string' },
                  institucionId: { type: 'string' },
                  createdAt: { type: 'string' },
                  periodoAcademico: {
                    type: 'object',
                    properties: {
                      id: { type: 'string' },
                      nombre: { type: 'string' },
                      fechaInicio: { type: 'string' },
                      fechaFin: { type: 'string' },
                      activo: { type: 'boolean' },
                    },
                  },
                  grupo: {
                    type: 'object',
                    properties: {
                      id: { type: 'string' },
                      nombre: { type: 'string' },
                      grado: { type: 'string' },
                      seccion: { type: 'string', nullable: true },
                    },
                  },
                  materia: {
                    type: 'object',
                    properties: {
                      id: { type: 'string' },
                      nombre: { type: 'string' },
                      codigo: { type: 'string', nullable: true },
                    },
                  },
                  profesor: {
                    type: 'object',
                    nullable: true,
                    properties: {
                      id: { type: 'string' },
                      nombres: { type: 'string' },
                      apellidos: { type: 'string' },
                    },
                  },
                  _count: {
                    type: 'object',
                    properties: {
                      asistencias: { type: 'number' },
                    },
                  },
                },
              },
            },
          },
        },
      },
    });

    horarioRoutes.post('/', {
      handler: HorarioController.create as any,
      schema: {
        description: 'Crear un nuevo horario',
        tags: ['Horarios'],
        body: {
          type: 'object',
          properties: {
            periodoId: { type: 'string', description: 'ID del periodo acadÃ©mico' },
            grupoId: { type: 'string', description: 'ID del grupo' },
            materiaId: { type: 'string', description: 'ID de la materia' },
            profesorId: { type: 'string', description: 'ID del profesor (opcional)' },
            diaSemana: { type: 'number', description: 'DÃ­a de la semana (1=Lunes, 7=Domingo)' },
            horaInicio: { type: 'string', description: 'Hora de inicio (HH:MM)' },
            horaFin: { type: 'string', description: 'Hora de fin (HH:MM)' },
          },
          required: ['periodoId', 'grupoId', 'materiaId', 'diaSemana', 'horaInicio', 'horaFin'],
        },
        response: {
          201: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: {
                type: 'object',
                properties: {
                  id: { type: 'string' },
                  periodoId: { type: 'string' },
                  grupoId: { type: 'string' },
                  materiaId: { type: 'string' },
                  profesorId: { type: 'string', nullable: true },
                  diaSemana: { type: 'number' },
                  horaInicio: { type: 'string' },
                  horaFin: { type: 'string' },
                  institucionId: { type: 'string' },
                  createdAt: { type: 'string' },
                  periodoAcademico: {
                    type: 'object',
                    properties: {
                      id: { type: 'string' },
                      nombre: { type: 'string' },
                      fechaInicio: { type: 'string' },
                      fechaFin: { type: 'string' },
                      activo: { type: 'boolean' },
                    },
                  },
                  grupo: {
                    type: 'object',
                    properties: {
                      id: { type: 'string' },
                      nombre: { type: 'string' },
                      grado: { type: 'string' },
                      seccion: { type: 'string', nullable: true },
                    },
                  },
                  materia: {
                    type: 'object',
                    properties: {
                      id: { type: 'string' },
                      nombre: { type: 'string' },
                      codigo: { type: 'string', nullable: true },
                    },
                  },
                  profesor: {
                    type: 'object',
                    nullable: true,
                    properties: {
                      id: { type: 'string' },
                      nombres: { type: 'string' },
                      apellidos: { type: 'string' },
                    },
                  },
                  _count: {
                    type: 'object',
                    properties: {
                      asistencias: { type: 'number' },
                    },
                  },
                },
              },
              message: { type: 'string' },
            },
          },
        },
      },
    });

    horarioRoutes.put('/:id', {
      handler: HorarioController.update as any,
      schema: {
        description: 'Actualizar un horario',
        tags: ['Horarios'],
        params: {
          type: 'object',
          properties: {
            id: { type: 'string', description: 'ID del horario' },
          },
          required: ['id'],
        },
        body: {
          type: 'object',
          properties: {
            grupoId: { type: 'string', description: 'ID del grupo' },
            materiaId: { type: 'string', description: 'ID de la materia' },
            profesorId: { type: 'string', description: 'ID del profesor (opcional)' },
            diaSemana: { type: 'number', description: 'DÃ­a de la semana (1=Lunes, 7=Domingo)' },
            horaInicio: { type: 'string', description: 'Hora de inicio (HH:MM)' },
            horaFin: { type: 'string', description: 'Hora de fin (HH:MM)' },
          },
        },
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: {
                type: 'object',
                properties: {
                  id: { type: 'string' },
                  periodoId: { type: 'string' },
                  grupoId: { type: 'string' },
                  materiaId: { type: 'string' },
                  profesorId: { type: 'string', nullable: true },
                  diaSemana: { type: 'number' },
                  horaInicio: { type: 'string' },
                  horaFin: { type: 'string' },
                  institucionId: { type: 'string' },
                  createdAt: { type: 'string' },
                  periodoAcademico: {
                    type: 'object',
                    properties: {
                      id: { type: 'string' },
                      nombre: { type: 'string' },
                      fechaInicio: { type: 'string' },
                      fechaFin: { type: 'string' },
                      activo: { type: 'boolean' },
                    },
                  },
                  grupo: {
                    type: 'object',
                    properties: {
                      id: { type: 'string' },
                      nombre: { type: 'string' },
                      grado: { type: 'string' },
                      seccion: { type: 'string', nullable: true },
                    },
                  },
                  materia: {
                    type: 'object',
                    properties: {
                      id: { type: 'string' },
                      nombre: { type: 'string' },
                      codigo: { type: 'string', nullable: true },
                    },
                  },
                  profesor: {
                    type: 'object',
                    nullable: true,
                    properties: {
                      id: { type: 'string' },
                      nombres: { type: 'string' },
                      apellidos: { type: 'string' },
                    },
                  },
                  _count: {
                    type: 'object',
                    properties: {
                      asistencias: { type: 'number' },
                    },
                  },
                },
              },
              message: { type: 'string' },
            },
          },
        },
      },
    });

    horarioRoutes.delete('/:id', {
      handler: HorarioController.delete as any,
      schema: {
        description: 'Eliminar un horario',
        tags: ['Horarios'],
        params: {
          type: 'object',
          properties: {
            id: { type: 'string', description: 'ID del horario' },
          },
          required: ['id'],
        },
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              message: { type: 'string' },
            },
          },
        },
      },
    });
  });
}
/* Fin backend\src\routes\horario.routes.ts */

/* Inicio backend\src\routes\index.ts */
import { FastifyInstance } from 'fastify';
import adminInstitucionRoutes from './admin-institucion.routes';
import authRoutes from './auth.routes';
import estudianteRoutes from './estudiante.routes';
import grupoRoutes from './grupo.routes';
import horarioRoutes from './horario.routes';
import institucionRoutes from './institucion.routes';
import institutionAdminRoutes from './institution-admin.routes';
import materiaRoutes from './materia.routes';
import profesorRoutes from './profesor.routes';
import userRoutes from './user.routes';

console.log('ðŸ”„ Iniciando registro de rutas...');

export default async function routes(fastify: FastifyInstance) {
  console.log('ðŸ“‹ Registrando rutas bÃ¡sicas...');

  fastify.get('/', async (request, reply) => {
    return {
      success: true,
      message: 'Hola Mundo desde AsistApp Backend v2.0!',
      timestamp: new Date().toISOString(),
    };
  });

  fastify.get('/health', async (request, reply) => {
    return reply.code(200).send({
      success: true,
      status: 'healthy',
      timestamp: new Date().toISOString(),
      services: {
        server: 'running'
      },
      uptime: process.uptime()
    });
  });

  await fastify.register(authRoutes, { prefix: '/auth' });
  await fastify.register(userRoutes, { prefix: '/usuarios' });
  await fastify.register(adminInstitucionRoutes, { prefix: '/admin-institucion' });
  await fastify.register(institutionAdminRoutes, { prefix: '/institution-admin' });
  await fastify.register(institucionRoutes, { prefix: '/instituciones' });
  await fastify.register(grupoRoutes, { prefix: '/grupos' });
  await fastify.register(materiaRoutes, { prefix: '/materias' });
  await fastify.register(horarioRoutes, { prefix: '/horarios' });
  await fastify.register(profesorRoutes, { prefix: '/profesores' });

  console.log('ðŸŽ“ Registrando rutas del estudiante...');
  await fastify.register(estudianteRoutes, { prefix: '/estudiantes' });
  console.log('âœ… Rutas del estudiante registradas');

  console.log('ðŸŽ‰ Todas las rutas registradas exitosamente');
}
/* Fin backend\src\routes\index.ts */

/* Inicio backend\src\routes\institucion.routes.ts */
import { FastifyInstance } from 'fastify';
import InstitucionController from '../controllers/institucion.controller';
import { authenticate, authorize } from '../middleware/auth';

export default async function institucionRoutes(fastify: FastifyInstance) {

  fastify.register(async function (institucionRoutes) {

    institucionRoutes.addHook('preHandler', authenticate);
    institucionRoutes.addHook('preHandler', authorize(['super_admin']));

    institucionRoutes.get('/', {
      handler: InstitucionController.getAll,
    });

    institucionRoutes.get('/:id', {
      handler: InstitucionController.getById as any,
    });
    institucionRoutes.get('/:id/admins', {
      handler: InstitucionController.getAdminsByInstitution as any,
    });

    institucionRoutes.post('/:id/admins', {
      handler: InstitucionController.assignAdminToInstitution as any,
    });

    institucionRoutes.delete('/:id/admins/:userId', {
      handler: InstitucionController.removeAdminFromInstitution as any,
    });

    institucionRoutes.post('/', {
      handler: InstitucionController.create as any,
    });

    institucionRoutes.put('/:id', {
      handler: InstitucionController.update as any,
    });

    institucionRoutes.delete('/:id', {
      handler: InstitucionController.delete as any,
    });
  });
}
/* Fin backend\src\routes\institucion.routes.ts */

/* Inicio backend\src\routes\institution-admin.routes.ts */
import { FastifyInstance } from 'fastify';
import InstitutionAdminController from '../controllers/institution-admin.controller';
import { authenticate, authorize } from '../middleware/auth';

export default async function institutionAdminRoutes(fastify: FastifyInstance) {
  fastify.addHook('preHandler', authenticate);
  fastify.addHook('preHandler', authorize(['admin_institucion']));

  fastify.get('/profesores', InstitutionAdminController.getAllProfesores);

  fastify.get('/profesores/:id', InstitutionAdminController.getProfesorById);

  fastify.post('/profesores', InstitutionAdminController.createProfesor);

  fastify.put('/profesores/:id', InstitutionAdminController.updateProfesor);

  fastify.delete('/profesores/:id', InstitutionAdminController.deleteProfesor);

  fastify.patch('/profesores/:id/toggle-status', InstitutionAdminController.toggleProfesorStatus);
}
/* Fin backend\src\routes\institution-admin.routes.ts */

/* Inicio backend\src\routes\materia.routes.ts */
import { FastifyInstance } from 'fastify';
import MateriaController from '../controllers/materia.controller';
import { authenticate, authorize } from '../middleware/auth';

export default async function materiaRoutes(fastify: FastifyInstance) {

  fastify.register(async function (materiaRoutes) {

    materiaRoutes.addHook('preHandler', authenticate);
    materiaRoutes.addHook('preHandler', authorize(['admin_institucion']));

    materiaRoutes.get('/', {
      handler: MateriaController.getAll as any,
      schema: {
        description: 'Obtener todas las materias de la instituciÃ³n',
        tags: ['Materias'],
        querystring: {
          type: 'object',
          properties: {
            page: { type: 'string', description: 'NÃºmero de pÃ¡gina' },
            limit: { type: 'string', description: 'Elementos por pÃ¡gina' },
            search: { type: 'string', description: 'Buscar por nombre o cÃ³digo' },
          },
        },
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: {
                type: 'array',
                items: {
                  type: 'object',
                  properties: {
                    id: { type: 'string' },
                    nombre: { type: 'string' },
                    codigo: { type: 'string', nullable: true },
                    institucionId: { type: 'string' },
                    createdAt: { type: 'string' },
                    _count: {
                      type: 'object',
                      properties: {
                        horarios: { type: 'number' },
                      },
                    },
                  },
                },
              },
              pagination: {
                type: 'object',
                properties: {
                  page: { type: 'number' },
                  limit: { type: 'number' },
                  total: { type: 'number' },
                  totalPages: { type: 'number' },
                  hasNext: { type: 'boolean' },
                  hasPrev: { type: 'boolean' },
                },
              },
            },
          },
        },
      },
    });

    materiaRoutes.get('/disponibles', {
      handler: MateriaController.getMateriasDisponibles as any,
      schema: {
        description: 'Obtener materias disponibles para crear horarios',
        tags: ['Materias'],
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: {
                type: 'array',
                items: {
                  type: 'object',
                  properties: {
                    id: { type: 'string' },
                    nombre: { type: 'string' },
                    codigo: { type: 'string', nullable: true },
                    institucionId: { type: 'string' },
                    createdAt: { type: 'string' },
                    _count: {
                      type: 'object',
                      properties: {
                        horarios: { type: 'number' },
                      },
                    },
                  },
                },
              },
            },
          },
        },
      },
    });

    materiaRoutes.get('/:id', {
      handler: MateriaController.getById as any,
      schema: {
        description: 'Obtener una materia por ID',
        tags: ['Materias'],
        params: {
          type: 'object',
          properties: {
            id: { type: 'string', description: 'ID de la materia' },
          },
          required: ['id'],
        },
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: {
                type: 'object',
                properties: {
                  id: { type: 'string' },
                  nombre: { type: 'string' },
                  codigo: { type: 'string', nullable: true },
                  institucionId: { type: 'string' },
                  createdAt: { type: 'string' },
                  _count: {
                    type: 'object',
                    properties: {
                      horarios: { type: 'number' },
                    },
                  },
                },
              },
            },
          },
        },
      },
    });

    materiaRoutes.post('/', {
      handler: MateriaController.create as any,
      schema: {
        description: 'Crear una nueva materia',
        tags: ['Materias'],
        body: {
          type: 'object',
          properties: {
            nombre: { type: 'string', description: 'Nombre de la materia' },
            codigo: { type: 'string', description: 'CÃ³digo de la materia (opcional)' },
          },
          required: ['nombre'],
        },
        response: {
          201: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: {
                type: 'object',
                properties: {
                  id: { type: 'string' },
                  nombre: { type: 'string' },
                  codigo: { type: 'string', nullable: true },
                  institucionId: { type: 'string' },
                  createdAt: { type: 'string' },
                  _count: {
                    type: 'object',
                    properties: {
                      horarios: { type: 'number' },
                    },
                  },
                },
              },
              message: { type: 'string' },
            },
          },
        },
      },
    });

    materiaRoutes.put('/:id', {
      handler: MateriaController.update as any,
      schema: {
        description: 'Actualizar una materia',
        tags: ['Materias'],
        params: {
          type: 'object',
          properties: {
            id: { type: 'string', description: 'ID de la materia' },
          },
          required: ['id'],
        },
        body: {
          type: 'object',
          properties: {
            nombre: { type: 'string', description: 'Nombre de la materia' },
            codigo: { type: 'string', description: 'CÃ³digo de la materia (opcional)' },
          },
        },
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: {
                type: 'object',
                properties: {
                  id: { type: 'string' },
                  nombre: { type: 'string' },
                  codigo: { type: 'string', nullable: true },
                  institucionId: { type: 'string' },
                  createdAt: { type: 'string' },
                  _count: {
                    type: 'object',
                    properties: {
                      horarios: { type: 'number' },
                    },
                  },
                },
              },
              message: { type: 'string' },
            },
          },
        },
      },
    });

    materiaRoutes.delete('/:id', {
      handler: MateriaController.delete as any,
      schema: {
        description: 'Eliminar una materia',
        tags: ['Materias'],
        params: {
          type: 'object',
          properties: {
            id: { type: 'string', description: 'ID de la materia' },
          },
          required: ['id'],
        },
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              message: { type: 'string' },
            },
          },
        },
      },
    });
  });
}
/* Fin backend\src\routes\materia.routes.ts */

/* Inicio backend\src\routes\profesor.routes.ts */
import { FastifyInstance } from 'fastify';
import { ProfesorController } from '../controllers/profesor.controller';
import { authenticate, authorize } from '../middleware/auth';

export default async function profesorRoutes(fastify: FastifyInstance) {

  fastify.register(async function (profesorRoutes) {

    profesorRoutes.addHook('preHandler', authenticate);
    profesorRoutes.addHook('preHandler', authorize(['profesor']));

    profesorRoutes.get('/dashboard/clases-hoy', {
      handler: ProfesorController.getClasesDelDia as any,
      schema: {
        description: 'Obtiene las clases que el profesor tiene hoy',
        tags: ['Profesores - Dashboard'],
        summary: 'Clases del dÃ­a',
        security: [{ bearerAuth: [] }],
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: {
                type: 'array',
                items: {
                  type: 'object',
                  properties: {
                    id: { type: 'string' },
                    diaSemana: { type: 'number', minimum: 1, maximum: 7 },
                    horaInicio: { type: 'string', format: 'time' },
                    horaFin: { type: 'string', format: 'time' },
                    grupo: {
                      type: 'object',
                      properties: {
                        id: { type: 'string' },
                        nombre: { type: 'string' },
                        grado: { type: 'string' },
                        seccion: { type: 'string', nullable: true },
                      },
                    },
                    materia: {
                      type: 'object',
                      properties: {
                        id: { type: 'string' },
                        nombre: { type: 'string' },
                        codigo: { type: 'string', nullable: true },
                      },
                    },
                    periodoAcademico: {
                      type: 'object',
                      properties: {
                        id: { type: 'string' },
                        nombre: { type: 'string' },
                        activo: { type: 'boolean' },
                      },
                    },
                    institucion: {
                      type: 'object',
                      properties: {
                        id: { type: 'string' },
                        nombre: { type: 'string' },
                      },
                    },
                  },
                },
              },
              message: { type: 'string' },
            },
          },
          401: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              message: { type: 'string' },
            },
          },
          403: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              message: { type: 'string' },
            },
          },
          500: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              message: { type: 'string' },
            },
          },
        },
      },
    });

    profesorRoutes.get('/dashboard/clases/:diaSemana', {
      handler: ProfesorController.getClasesPorDia as any,
      schema: {
        description: 'Obtiene las clases que el profesor tiene en un dÃ­a especÃ­fico de la semana',
        tags: ['Profesores - Dashboard'],
        summary: 'Clases por dÃ­a de la semana',
        security: [{ bearerAuth: [] }],
        params: {
          type: 'object',
          properties: {
            diaSemana: {
              type: 'string',
              pattern: '^[1-7]$',
              description: 'DÃ­a de la semana (1=Lunes, 2=Martes, ..., 7=Domingo)',
            },
          },
          required: ['diaSemana'],
        },
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: {
                type: 'array',
                items: {
                  type: 'object',
                  properties: {
                    id: { type: 'string' },
                    diaSemana: { type: 'number', minimum: 1, maximum: 7 },
                    horaInicio: { type: 'string', format: 'time' },
                    horaFin: { type: 'string', format: 'time' },
                    grupo: {
                      type: 'object',
                      properties: {
                        id: { type: 'string' },
                        nombre: { type: 'string' },
                        grado: { type: 'string' },
                        seccion: { type: 'string', nullable: true },
                      },
                    },
                    materia: {
                      type: 'object',
                      properties: {
                        id: { type: 'string' },
                        nombre: { type: 'string' },
                        codigo: { type: 'string', nullable: true },
                      },
                    },
                    periodoAcademico: {
                      type: 'object',
                      properties: {
                        id: { type: 'string' },
                        nombre: { type: 'string' },
                        activo: { type: 'boolean' },
                      },
                    },
                    institucion: {
                      type: 'object',
                      properties: {
                        id: { type: 'string' },
                        nombre: { type: 'string' },
                      },
                    },
                  },
                },
              },
              message: { type: 'string' },
            },
          },
          400: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              message: { type: 'string' },
            },
          },
          401: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              message: { type: 'string' },
            },
          },
          403: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              message: { type: 'string' },
            },
          },
          500: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              message: { type: 'string' },
            },
          },
        },
      },
    });

    profesorRoutes.get('/dashboard/horario-semanal', {
      handler: ProfesorController.getHorarioSemanal as any,
      schema: {
        description: 'Obtiene el horario semanal completo del profesor',
        tags: ['Profesores - Dashboard'],
        summary: 'Horario semanal completo',
        security: [{ bearerAuth: [] }],
        response: {
          200: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              data: {
                type: 'object',
                patternProperties: {
                  '^[1-7]$': {
                    type: 'array',
                    items: {
                      type: 'object',
                      properties: {
                        id: { type: 'string' },
                        diaSemana: { type: 'number', minimum: 1, maximum: 7 },
                        horaInicio: { type: 'string', format: 'time' },
                        horaFin: { type: 'string', format: 'time' },
                        grupo: {
                          type: 'object',
                          properties: {
                            id: { type: 'string' },
                            nombre: { type: 'string' },
                            grado: { type: 'string' },
                            seccion: { type: 'string', nullable: true },
                          },
                        },
                        materia: {
                          type: 'object',
                          properties: {
                            id: { type: 'string' },
                            nombre: { type: 'string' },
                            codigo: { type: 'string', nullable: true },
                          },
                        },
                        periodoAcademico: {
                          type: 'object',
                          properties: {
                            id: { type: 'string' },
                            nombre: { type: 'string' },
                            activo: { type: 'boolean' },
                          },
                        },
                        institucion: {
                          type: 'object',
                          properties: {
                            id: { type: 'string' },
                            nombre: { type: 'string' },
                          },
                        },
                      },
                    },
                  },
                },
              },
              message: { type: 'string' },
            },
          },
          401: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              message: { type: 'string' },
            },
          },
          403: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              message: { type: 'string' },
            },
          },
          500: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              message: { type: 'string' },
            },
          },
        },
      },
    });
  });
}
/* Fin backend\src\routes\profesor.routes.ts */

/* Inicio backend\src\routes\user.routes.ts */
import { FastifyInstance } from 'fastify';
import UserController from '../controllers/user.controller';
import { authenticate, authorize } from '../middleware/auth';

export default async function userRoutes(fastify: FastifyInstance) {
  fastify.addHook('preHandler', authenticate);

  fastify.get('/', {
    preHandler: authorize(['super_admin']),
    handler: UserController.getAllUsers,
  });

  fastify.get('/:id', UserController.getUserById);

  fastify.get('/rol/:role', UserController.getUsersByRole);

  fastify.get('/institucion/:institucionId', UserController.getUsersByInstitution);

  fastify.post('/', {
    preHandler: authorize(['super_admin', 'admin_institucion']),
    handler: UserController.createUser,
  });

  fastify.put('/:id', {
    preHandler: authorize(['super_admin', 'admin_institucion']),
    handler: UserController.updateUser,
  });

  fastify.delete('/:id', {
    preHandler: authorize(['super_admin', 'admin_institucion']),
    handler: UserController.deleteUser,
  });

  fastify.patch('/:id/change-password', {
    preHandler: authorize(['super_admin', 'admin_institucion']),
    handler: UserController.changePassword,
  });
}
/* Fin backend\src\routes\user.routes.ts */

/* Inicio backend\src\scripts\cleanup-tokens.ts */
import { databaseService } from '../config/database';

async function cleanupExpiredRefreshTokens() {
  try {
    console.log('ðŸ§¹ Iniciando limpieza de refresh tokens expirados...');

    const prisma = databaseService.getClient();
    const result = await prisma.refreshToken.deleteMany({
      where: {
        OR: [
          { expiresAt: { lt: new Date() } }, // Expirados
          { revoked: true }, // Revocados
        ],
      },
    });

    console.log(`âœ… Eliminados ${result.count} refresh tokens expirados/revocados`);
    const remainingTokens = await prisma.refreshToken.count();
    console.log(`ðŸ“Š Tokens restantes en DB: ${remainingTokens}`);

  } catch (error) {
    console.error('âŒ Error durante la limpieza:', error);
    process.exit(1);
  } finally {
    await databaseService.disconnect();
  }
}
if (require.main === module) {
  cleanupExpiredRefreshTokens();
}

export default cleanupExpiredRefreshTokens;
/* Fin backend\src\scripts\cleanup-tokens.ts */

/* Inicio backend\src\services\admin-institucion.service.ts */
import bcrypt from 'bcryptjs';
import { prisma } from '../config/database';
import { ConflictError, PaginatedResponse, PaginationParams, ValidationError } from '../types';

export interface CreateAdminInstitucionRequest {
  email: string;
  password: string;
  nombres: string;
  apellidos: string;
  telefono?: string;
  institucionId: string;
}

export interface UpdateAdminInstitucionRequest {
  email?: string;
  nombres?: string;
  apellidos?: string;
  telefono?: string;
  activo?: boolean;
}

export interface AdminInstitucionResponse {
  id: string;
  email: string;
  nombres: string;
  apellidos: string;
  telefono: string | null;
  activo: boolean;
  institucion: {
    id: string;
    nombre: string;
  };
  createdAt: string;
  updatedAt: string;
}

export class AdminInstitucionService {

  public static async getAll(pagination?: PaginationParams): Promise<PaginatedResponse<AdminInstitucionResponse>> {
    try {
      const page = pagination?.page || 1;
      const limit = pagination?.limit || 20;
      const skip = (page - 1) * limit;
      const total = await prisma.usuario.count({
        where: { rol: 'admin_institucion' },
      });
      const admins = await prisma.usuario.findMany({
        where: { rol: 'admin_institucion' },
        include: {
          usuarioInstituciones: {
            where: { activo: true },
            include: {
              institucion: true,
            },
          },
        },
        orderBy: {
          createdAt: 'desc',
        },
        skip,
        take: limit,
      });

      const totalPages = Math.ceil(total / limit);

      const data: AdminInstitucionResponse[] = admins.map((admin: any) => ({
        id: admin.id,
        email: admin.email,
        nombres: admin.nombres,
        apellidos: admin.apellidos,
        telefono: admin.telefono,
        activo: admin.activo,
        institucion: admin.usuarioInstituciones[0] ? {
          id: admin.usuarioInstituciones[0].institucion.id,
          nombre: admin.usuarioInstituciones[0].institucion.nombre,
        } : { id: '', nombre: '' },
        createdAt: admin.createdAt.toISOString(),
        updatedAt: admin.updatedAt.toISOString(),
      }));

      return {
        data,
        pagination: {
          page,
          limit,
          total,
          totalPages,
          hasNext: page < totalPages,
          hasPrev: page > 1,
        },
      };
    } catch (error) {
      console.error('Error al obtener admins de instituciÃ³n:', error);
      throw error;
    }
  }

  public static async getById(id: string): Promise<AdminInstitucionResponse | null> {
    try {
      const admin = await prisma.usuario.findFirst({
        where: {
          id,
          rol: 'admin_institucion',
        },
        include: {
          usuarioInstituciones: {
            where: { activo: true },
            include: {
              institucion: true,
            },
          },
        },
      });

      if (!admin) {
        return null;
      }

      return {
        id: admin.id,
        email: admin.email,
        nombres: admin.nombres,
        apellidos: admin.apellidos,
        telefono: admin.telefono,
        activo: admin.activo,
        institucion: admin.usuarioInstituciones[0] ? {
          id: admin.usuarioInstituciones[0].institucion.id,
          nombre: admin.usuarioInstituciones[0].institucion.nombre,
        } : { id: '', nombre: '' },
        createdAt: admin.createdAt.toISOString(),
        updatedAt: admin.updatedAt.toISOString(),
      };
    } catch (error) {
      console.error(`Error al obtener admin de instituciÃ³n ${id}:`, error);
      throw error;
    }
  }

  public static async create(data: CreateAdminInstitucionRequest): Promise<AdminInstitucionResponse> {
    try {
      if (!data.email || !data.password || !data.nombres || !data.apellidos || !data.institucionId) {
        throw new ValidationError('Campos requeridos faltantes');
      }
      const institucion = await prisma.institucion.findUnique({
        where: { id: data.institucionId },
      });

      if (!institucion) {
        throw new ValidationError('InstituciÃ³n no encontrada');
      }
      const existingAdmin = await prisma.usuarioInstitucion.findFirst({
        where: {
          institucionId: data.institucionId,
          rolEnInstitucion: 'admin',
          activo: true,
        },
      });

      if (existingAdmin) {
        throw new ConflictError('Ya existe un admin para esta instituciÃ³n');
      }
      const emailExists = await prisma.usuario.findUnique({
        where: { email: data.email.toLowerCase() },
      });

      if (emailExists) {
        throw new ConflictError('El email ya estÃ¡ registrado');
      }
      const hashedPassword = await bcrypt.hash(data.password, 10);
      const result = await prisma.$transaction(async (tx: any) => {
        const admin = await tx.usuario.create({
          data: {
            email: data.email.toLowerCase(),
            passwordHash: hashedPassword,
            nombres: data.nombres,
            apellidos: data.apellidos,
            rol: 'admin_institucion',
            telefono: data.telefono,
          },
        });

        await tx.usuarioInstitucion.create({
          data: {
            usuarioId: admin.id,
            institucionId: data.institucionId,
            rolEnInstitucion: 'admin',
          },
        });

        return admin;
      });
      return await this.getById(result.id) as AdminInstitucionResponse;
    } catch (error) {
      console.error('Error al crear admin de instituciÃ³n:', error);
      throw error;
    }
  }

  public static async update(id: string, data: UpdateAdminInstitucionRequest): Promise<AdminInstitucionResponse | null> {
    try {
      const existingAdmin = await this.getById(id);
      if (!existingAdmin) {
        throw new ValidationError('Admin de instituciÃ³n no encontrado');
      }
      if (data.email && data.email !== existingAdmin.email) {
        const emailExists = await prisma.usuario.findUnique({
          where: { email: data.email.toLowerCase() },
        });

        if (emailExists) {
          throw new ConflictError('El email ya estÃ¡ registrado');
        }
      }
      await prisma.usuario.update({
        where: { id },
        data: {
          email: data.email?.toLowerCase(),
          nombres: data.nombres,
          apellidos: data.apellidos,
          telefono: data.telefono,
          activo: data.activo,
        },
      });

      return await this.getById(id);
    } catch (error) {
      console.error(`Error al actualizar admin de instituciÃ³n ${id}:`, error);
      throw error;
    }
  }

  public static async delete(id: string): Promise<boolean> {
    try {
      const existingAdmin = await this.getById(id);
      if (!existingAdmin) {
        throw new ValidationError('Admin de instituciÃ³n no encontrado');
      }

      await prisma.usuario.update({
        where: { id },
        data: { activo: false },
      });

      return true;
    } catch (error) {
      console.error(`Error al eliminar admin de instituciÃ³n ${id}:`, error);
      throw error;
    }
  }

  public static async isAdminOfInstitution(userId: string, institucionId: string): Promise<boolean> {
    try {
      const relacion = await prisma.usuarioInstitucion.findFirst({
        where: {
          usuarioId: userId,
          institucionId,
          rolEnInstitucion: 'admin',
          activo: true,
        },
      });

      return !!relacion;
    } catch (error) {
      console.error(`Error al verificar admin de instituciÃ³n ${userId}:`, error);
      return false;
    }
  }
}

export default AdminInstitucionService;
/* Fin backend\src\services\admin-institucion.service.ts */

/* Inicio backend\src\services\auth.service.ts */
import bcrypt from 'bcryptjs';
import crypto from 'crypto';
import { prisma } from '../config/database';
import JWTService from '../config/jwt';
import { AuthenticationError, JWTPayload, LoginRequest, LoginResponse, RefreshTokenResponse, UserRole } from '../types';

export class AuthService {

  public static async login(credentials: LoginRequest): Promise<LoginResponse> {
    const { email, password } = credentials;

    const usuario = await prisma.usuario.findUnique({
      where: { email },
      include: {
        usuarioInstituciones: {
          include: {
            institucion: true,
          },
        },
      },
    });

    if (!usuario) {
      throw new AuthenticationError('Credenciales invÃ¡lidas');
    }

    if (!usuario.activo) {
      throw new AuthenticationError('Tu cuenta de usuario estÃ¡ inactiva. Contacta al administrador.');
    }

    const passwordMatch = await bcrypt.compare(password, usuario.passwordHash);
    if (!passwordMatch) {
      throw new AuthenticationError('Credenciales invÃ¡lidas');
    }
    const institucionesActivas = (usuario.usuarioInstituciones || []).filter((ui: any) => ui.activo && ui.institucion?.activa);
    if (usuario.rol !== 'super_admin' && institucionesActivas.length === 0) {
      throw new AuthenticationError('No tienes acceso a ninguna instituciÃ³n activa. Contacta al administrador.');
    }

    const accessToken = JWTService.signAccessToken({
      id: usuario.id,
      rol: usuario.rol as UserRole,
      email: usuario.email,
      tokenVersion: usuario.tokenVersion,
    });

    const refreshToken = JWTService.signRefreshToken({
      id: usuario.id,
      rol: usuario.rol as UserRole,
      email: usuario.email,
      tokenVersion: usuario.tokenVersion,
    });

    try {
      const decodedRefresh = JWTService.decode(refreshToken) as JWTPayload & { exp?: number };
      const exp = decodedRefresh?.exp
      const expiresAt = exp ? new Date(exp * 1000) : new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);

      const hashed = crypto.createHash('sha256').update(refreshToken).digest('hex');

      await prisma.refreshToken.create({
        data: {
          usuarioId: usuario.id,
          token: hashed,
          expiresAt,
        },
      });
    } catch (err) {

      console.warn('No se pudo guardar refresh token en DB:', err);
    }

    const expiresIn = 24 * 60 * 60

    return {
      accessToken,
      refreshToken,
      usuario: {
        id: usuario.id,
        nombres: usuario.nombres,
        apellidos: usuario.apellidos,
        rol: usuario.rol as UserRole,
        instituciones: institucionesActivas.map((ui: any) => ({
          id: ui.institucion.id,
          nombre: ui.institucion.nombre,
          rolEnInstitucion: ui.rolEnInstitucion,
        })),
      },
      expiresIn,
    };
  }

  public static async verifyToken(token: string) {
    const decoded = JWTService.verify(token);

    const usuario = await prisma.usuario.findUnique({
      where: { id: decoded.id },
      select: { tokenVersion: true, activo: true },
    });

    if (!usuario || !usuario.activo) {
      throw new AuthenticationError('Usuario no encontrado o inactivo');
    }

    if (usuario.tokenVersion !== decoded.tokenVersion) {
      throw new AuthenticationError('Token revocado por cambio de versiÃ³n');
    }

    return decoded;
  }

  public static async refreshToken(refreshToken: string): Promise<RefreshTokenResponse> {
    try {

      const decoded = JWTService.verifyRefreshToken(refreshToken);

      const hashed = crypto.createHash('sha256').update(refreshToken).digest('hex');

      const tokenRecord = await prisma.refreshToken.findFirst({
        where: {
          usuarioId: decoded.id,
          token: hashed,
          revoked: false,
        },
      });

      if (!tokenRecord) {
        throw new AuthenticationError('Refresh token invÃ¡lido o revocado');
      }

      if (tokenRecord.expiresAt <= new Date()) {

        await prisma.refreshToken.update({ where: { id: tokenRecord.id }, data: { revoked: true } });
        throw new AuthenticationError('Refresh token expirado');
      }

      const usuario = await prisma.usuario.findUnique({
        where: { id: decoded.id },
        include: {
          usuarioInstituciones: {
            include: {
              institucion: true,
            },
          },
        },
      });

      if (!usuario || !usuario.activo) {
        throw new AuthenticationError('Usuario no encontrado o inactivo');
      }

      if (usuario.tokenVersion !== decoded.tokenVersion) {
        throw new AuthenticationError('Refresh token revocado por cambio de versiÃ³n');
      }

      await prisma.refreshToken.update({ where: { id: tokenRecord.id }, data: { revoked: true } });
      const institucionesActivas = (usuario.usuarioInstituciones || []).filter((ui: any) => ui.activo && ui.institucion?.activa);

      const newAccessToken = JWTService.signAccessToken({
        id: usuario.id,
        rol: usuario.rol as UserRole,
        email: usuario.email,
        tokenVersion: usuario.tokenVersion,
      });

      const newRefreshToken = JWTService.signRefreshToken({
        id: usuario.id,
        rol: usuario.rol as UserRole,
        email: usuario.email,
        tokenVersion: usuario.tokenVersion,
      });

      try {
        const decodedNew = JWTService.decode(newRefreshToken) as JWTPayload & { exp?: number };
        const exp = decodedNew?.exp;
        const expiresAt = exp ? new Date(exp * 1000) : new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);
        const hashedNew = crypto.createHash('sha256').update(newRefreshToken).digest('hex');

        await prisma.refreshToken.create({
          data: {
            usuarioId: usuario.id,
            token: hashedNew,
            expiresAt,
          },
        });
      } catch (err) {
        console.warn('No se pudo guardar nuevo refresh token en DB:', err);
      }

      const expiresIn = 24 * 60 * 60

      return {
        accessToken: newAccessToken,
        refreshToken: newRefreshToken,
        expiresIn,
      };
    } catch (error) {
      if (error instanceof AuthenticationError) {
        throw error;
      }
      throw new AuthenticationError(error instanceof Error ? error.message : 'Refresh token invÃ¡lido');
    }
  }

  public static async revokeRefreshTokens(usuarioId: string, refreshToken?: string): Promise<void> {
    if (refreshToken) {
      const hashed = crypto.createHash('sha256').update(refreshToken).digest('hex');
      await prisma.refreshToken.updateMany({ where: { usuarioId, token: hashed }, data: { revoked: true } });
      return;
    }

    await prisma.refreshToken.updateMany({ where: { usuarioId, revoked: false }, data: { revoked: true } });
  }

  public static async revokeAllUserTokens(usuarioId: string): Promise<void> {
    await prisma.usuario.update({
      where: { id: usuarioId },
      data: { tokenVersion: { increment: 1 } },
    });
  }

  public static async hashPassword(password: string): Promise<string> {
    const saltRounds = 10;
    return bcrypt.hash(password, saltRounds);
  }

  public static async ensureAdminUser(): Promise<void> {
    try {
      console.log('ðŸ” Verificando usuario administrador...');

      const adminExists = await prisma.usuario.findUnique({
        where: { email: 'admin@asistapp.com' }
      });

      if (!adminExists) {
        console.log('âš ï¸ No se encontrÃ³ usuario administrador. Creando usuario por defecto...');

        const adminPassword = await this.hashPassword('pollo');

        const admin = await prisma.usuario.create({
          data: {
            email: 'admin@asistapp.com',
            passwordHash: adminPassword,
            nombres: 'Administrador',
            apellidos: 'Sistema',
            rol: 'super_admin',
            activo: true,
          },
        });

        console.log('âœ… Usuario administrador creado exitosamente:', admin.email);
      } else {
        console.log('âœ… Usuario administrador ya existe:', adminExists.email);
      }
    } catch (error) {
      console.error('âŒ Error al verificar/crear usuario administrador:', error);
      throw error;
    }
  }
}

export default AuthService;
/* Fin backend\src\services\auth.service.ts */

/* Inicio backend\src\services\grupo.service.ts */
import { prisma } from '../config/database';
import { ConflictError, NotFoundError, PaginatedResponse, PaginationParams, ValidationError } from '../types';

export interface GrupoFilters {
  periodoId?: string;
  grado?: string;
  seccion?: string;
  search?: string;
}

export interface CreateGrupoRequest {
  nombre: string;
  grado: string;
  seccion?: string;
  periodoId: string;
  institucionId: string;
}

export interface UpdateGrupoRequest {
  nombre?: string;
  grado?: string;
  seccion?: string;
  periodoId?: string;
}

export interface GrupoResponse {
  id: string;
  nombre: string;
  grado: string;
  seccion: string | null;
  periodoId: string;
  institucionId: string;
  createdAt: string;
  periodoAcademico: {
    id: string;
    nombre: string;
    fechaInicio: string;
    fechaFin: string;
    activo: boolean;
  };
  _count?: {
    estudiantesGrupos: number;
    horarios: number;
  };
}

export class GrupoService {

  public static async getAllGruposByInstitucion(
    institucionId: string,
    pagination?: PaginationParams,
    filters?: GrupoFilters
  ): Promise<PaginatedResponse<GrupoResponse>> {
    try {
      const page = pagination?.page || 1;
      const limit = pagination?.limit || 10;

      if (page < 1 || limit < 1 || limit > 100) {
        throw new ValidationError('Los parÃ¡metros de paginaciÃ³n deben ser mayores a 0. El lÃ­mite mÃ¡ximo es 100.');
      }

      const skip = (page - 1) * limit;
      const where: any = {
        institucionId: institucionId,
      };

      if (filters?.periodoId) {
        where.periodoId = filters.periodoId;
      }
      if (filters?.grado) {
        where.grado = filters.grado;
      }
      if (filters?.seccion) {
        where.seccion = filters.seccion;
      }
      if (filters?.search) {
        where.nombre = {
          contains: filters.search,
          mode: 'insensitive',
        };
      }
      const total = await prisma.grupo.count({ where });
      const grupos = await prisma.grupo.findMany({
        where,
        skip,
        take: limit,
        orderBy: [
          { grado: 'asc' },
          { seccion: 'asc' },
          { nombre: 'asc' },
        ],
        include: {
          periodoAcademico: {
            select: {
              id: true,
              nombre: true,
              fechaInicio: true,
              fechaFin: true,
              activo: true,
            },
          },
          _count: {
            select: {
              estudiantesGrupos: true,
              horarios: true,
            },
          },
        },
      });

      const totalPages = Math.ceil(total / limit);

      return {
        data: grupos.map((grupo: any) => ({
          id: grupo.id,
          nombre: grupo.nombre,
          grado: grupo.grado,
          seccion: grupo.seccion,
          periodoId: grupo.periodoId,
          institucionId: grupo.institucionId,
          createdAt: grupo.createdAt.toISOString(),
          periodoAcademico: {
            id: grupo.periodoAcademico.id,
            nombre: grupo.periodoAcademico.nombre,
            fechaInicio: grupo.periodoAcademico.fechaInicio.toISOString(),
            fechaFin: grupo.periodoAcademico.fechaFin.toISOString(),
            activo: grupo.periodoAcademico.activo,
          },
          _count: grupo._count,
        })),
        pagination: {
          page,
          limit,
          total,
          totalPages,
          hasNext: page < totalPages,
          hasPrev: page > 1,
        },
      };
    } catch (error) {
      console.error('Error al obtener grupos:', error);
      if (error instanceof ValidationError) {
        throw error;
      }
      throw new Error('Error al obtener los grupos');
    }
  }

  public static async getGrupoById(id: string): Promise<GrupoResponse | null> {
    try {
      const grupo = await prisma.grupo.findUnique({
        where: { id },
        include: {
          periodoAcademico: {
            select: {
              id: true,
              nombre: true,
              fechaInicio: true,
              fechaFin: true,
              activo: true,
            },
          },
          _count: {
            select: {
              estudiantesGrupos: true,
              horarios: true,
            },
          },
        },
      });

      if (!grupo) {
        return null;
      }

      return {
        id: grupo.id,
        nombre: grupo.nombre,
        grado: grupo.grado,
        seccion: grupo.seccion,
        periodoId: grupo.periodoId,
        institucionId: grupo.institucionId,
        createdAt: grupo.createdAt.toISOString(),
        periodoAcademico: {
          id: grupo.periodoAcademico.id,
          nombre: grupo.periodoAcademico.nombre,
          fechaInicio: grupo.periodoAcademico.fechaInicio.toISOString(),
          fechaFin: grupo.periodoAcademico.fechaFin.toISOString(),
          activo: grupo.periodoAcademico.activo,
        },
        _count: grupo._count,
      };
    } catch (error) {
      console.error('Error al obtener grupo:', error);
      throw new Error('Error al obtener el grupo');
    }
  }

  public static async createGrupo(data: CreateGrupoRequest): Promise<GrupoResponse> {
    try {
      if (!data.nombre || data.nombre.trim() === '') {
        throw new ValidationError('El nombre del grupo es requerido');
      }
      if (!data.grado || data.grado.trim() === '') {
        throw new ValidationError('El grado del grupo es requerido');
      }
      const periodo = await prisma.periodoAcademico.findFirst({
        where: {
          id: data.periodoId,
          institucionId: data.institucionId,
        },
      });

      if (!periodo) {
        throw new ValidationError('El periodo acadÃ©mico no existe o no pertenece a esta instituciÃ³n');
      }
      const existingGrupo = await prisma.grupo.findFirst({
        where: {
          nombre: data.nombre.trim(),
          periodoId: data.periodoId,
          institucionId: data.institucionId,
        },
      });

      if (existingGrupo) {
        throw new ConflictError('Ya existe un grupo con este nombre en el periodo acadÃ©mico seleccionado');
      }

      const grupo = await prisma.grupo.create({
        data: {
          nombre: data.nombre.trim(),
          grado: data.grado.trim(),
          seccion: data.seccion?.trim() || null,
          periodoId: data.periodoId,
          institucionId: data.institucionId,
        },
        include: {
          periodoAcademico: {
            select: {
              id: true,
              nombre: true,
              fechaInicio: true,
              fechaFin: true,
              activo: true,
            },
          },
          _count: {
            select: {
              estudiantesGrupos: true,
              horarios: true,
            },
          },
        },
      });

      return {
        id: grupo.id,
        nombre: grupo.nombre,
        grado: grupo.grado,
        seccion: grupo.seccion,
        periodoId: grupo.periodoId,
        institucionId: grupo.institucionId,
        createdAt: grupo.createdAt.toISOString(),
        periodoAcademico: {
          id: grupo.periodoAcademico.id,
          nombre: grupo.periodoAcademico.nombre,
          fechaInicio: grupo.periodoAcademico.fechaInicio.toISOString(),
          fechaFin: grupo.periodoAcademico.fechaFin.toISOString(),
          activo: grupo.periodoAcademico.activo,
        },
        _count: grupo._count,
      };
    } catch (error) {
      console.error('Error al crear grupo:', error);
      if (error instanceof ValidationError || error instanceof ConflictError) {
        throw error;
      }
      throw new Error('Error al crear el grupo');
    }
  }

  public static async updateGrupo(id: string, data: UpdateGrupoRequest): Promise<GrupoResponse | null> {
    try {
      const existingGrupo = await prisma.grupo.findUnique({
        where: { id },
      });

      if (!existingGrupo) {
        throw new NotFoundError('Grupo');
      }
      if (data.periodoId && data.periodoId !== existingGrupo.periodoId) {
        const periodo = await prisma.periodoAcademico.findFirst({
          where: {
            id: data.periodoId,
            institucionId: existingGrupo.institucionId,
          },
        });

        if (!periodo) {
          throw new ValidationError('El periodo acadÃ©mico no existe o no pertenece a esta instituciÃ³n');
        }
      }
      if (data.nombre && data.nombre !== existingGrupo.nombre) {
        const periodoId = data.periodoId || existingGrupo.periodoId;
        const existingGrupoWithName = await prisma.grupo.findFirst({
          where: {
            nombre: data.nombre,
            periodoId: periodoId,
            institucionId: existingGrupo.institucionId,
            id: { not: id },
          },
        });

        if (existingGrupoWithName) {
          throw new ConflictError('Ya existe un grupo con este nombre en el periodo acadÃ©mico seleccionado');
        }
      }

      const grupo = await prisma.grupo.update({
        where: { id },
        data: {
          nombre: data.nombre,
          grado: data.grado,
          seccion: data.seccion,
          periodoId: data.periodoId,
        },
        include: {
          periodoAcademico: {
            select: {
              id: true,
              nombre: true,
              fechaInicio: true,
              fechaFin: true,
              activo: true,
            },
          },
          _count: {
            select: {
              estudiantesGrupos: true,
              horarios: true,
            },
          },
        },
      });

      return {
        id: grupo.id,
        nombre: grupo.nombre,
        grado: grupo.grado,
        seccion: grupo.seccion,
        periodoId: grupo.periodoId,
        institucionId: grupo.institucionId,
        createdAt: grupo.createdAt.toISOString(),
        periodoAcademico: {
          id: grupo.periodoAcademico.id,
          nombre: grupo.periodoAcademico.nombre,
          fechaInicio: grupo.periodoAcademico.fechaInicio.toISOString(),
          fechaFin: grupo.periodoAcademico.fechaFin.toISOString(),
          activo: grupo.periodoAcademico.activo,
        },
        _count: grupo._count,
      };
    } catch (error) {
      console.error('Error al actualizar grupo:', error);
      if (error instanceof NotFoundError || error instanceof ValidationError || error instanceof ConflictError) {
        throw error;
      }
      throw new Error('Error al actualizar el grupo');
    }
  }

  public static async deleteGrupo(id: string): Promise<boolean> {
    try {
      const existingGrupo = await prisma.grupo.findUnique({
        where: { id },
        include: {
          _count: {
            select: {
              estudiantesGrupos: true,
              horarios: true,
              asistencias: true,
            },
          },
        },
      });

      if (!existingGrupo) {
        throw new NotFoundError('Grupo');
      }
      if (existingGrupo._count.estudiantesGrupos > 0) {
        throw new ValidationError('No se puede eliminar el grupo porque tiene estudiantes asignados');
      }
      if (existingGrupo._count.horarios > 0) {
        throw new ValidationError('No se puede eliminar el grupo porque tiene horarios asignados');
      }
      if (existingGrupo._count.asistencias > 0) {
        throw new ValidationError('No se puede eliminar el grupo porque tiene asistencias registradas');
      }

      await prisma.grupo.delete({
        where: { id },
      });

      return true;
    } catch (error) {
      console.error('Error al eliminar grupo:', error);
      if (error instanceof NotFoundError || error instanceof ValidationError) {
        throw error;
      }
      throw new Error('Error al eliminar el grupo');
    }
  }

  public static async getGruposDisponibles(institucionId: string): Promise<GrupoResponse[]> {
    try {
      const grupos = await prisma.grupo.findMany({
        where: {
          institucionId: institucionId,
          periodoAcademico: {
            activo: true,
          },
        },
        orderBy: [
          { grado: 'asc' },
          { seccion: 'asc' },
          { nombre: 'asc' },
        ],
        include: {
          periodoAcademico: {
            select: {
              id: true,
              nombre: true,
              fechaInicio: true,
              fechaFin: true,
              activo: true,
            },
          },
          _count: {
            select: {
              estudiantesGrupos: true,
              horarios: true,
            },
          },
        },
      });

      return grupos.map((grupo: any) => ({
        id: grupo.id,
        nombre: grupo.nombre,
        grado: grupo.grado,
        seccion: grupo.seccion,
        periodoId: grupo.periodoId,
        institucionId: grupo.institucionId,
        createdAt: grupo.createdAt.toISOString(),
        periodoAcademico: {
          id: grupo.periodoAcademico.id,
          nombre: grupo.periodoAcademico.nombre,
          fechaInicio: grupo.periodoAcademico.fechaInicio.toISOString(),
          fechaFin: grupo.periodoAcademico.fechaFin.toISOString(),
          activo: grupo.periodoAcademico.activo,
        },
        _count: grupo._count,
      }));
    } catch (error) {
      console.error('Error al obtener grupos disponibles:', error);
      throw new Error('Error al obtener los grupos disponibles');
    }
  }
}

export default GrupoService;
/* Fin backend\src\services\grupo.service.ts */

/* Inicio backend\src\services\horario.service.ts */
import { prisma } from '../config/database';
import { ConflictError, NotFoundError, PaginatedResponse, PaginationParams, ValidationError } from '../types';

export interface HorarioFilters {
  grupoId?: string;
  materiaId?: string;
  profesorId?: string;
  diaSemana?: number;
}

export interface CreateHorarioRequest {
  periodoId: string;
  grupoId: string;
  materiaId: string;
  profesorId?: string;
  diaSemana: number;
  horaInicio: string;
  horaFin: string;
  institucionId: string;
}

export interface UpdateHorarioRequest {
  grupoId?: string;
  materiaId?: string;
  profesorId?: string;
  diaSemana?: number;
  horaInicio?: string;
  horaFin?: string;
}

export interface HorarioResponse {
  id: string;
  periodoId: string;
  grupoId: string;
  materiaId: string;
  profesorId: string | null;
  diaSemana: number;
  horaInicio: string;
  horaFin: string;
  institucionId: string;
  createdAt: string;
  periodoAcademico: {
    id: string;
    nombre: string;
    fechaInicio: string;
    fechaFin: string;
    activo: boolean;
  };
  grupo: {
    id: string;
    nombre: string;
    grado: string;
    seccion: string | null;
  };
  materia: {
    id: string;
    nombre: string;
    codigo: string | null;
  };
  profesor?: {
    id: string;
    nombres: string;
    apellidos: string;
  } | null;
  _count?: {
    asistencias: number;
  };
}

export class HorarioService {

  public static async getAllHorariosByInstitucion(
    institucionId: string,
    pagination?: PaginationParams,
    filters?: HorarioFilters
  ): Promise<PaginatedResponse<HorarioResponse>> {
    try {
      const page = pagination?.page || 1;
      const limit = pagination?.limit || 10;

      if (page < 1 || limit < 1 || limit > 100) {
        throw new ValidationError('Los parÃ¡metros de paginaciÃ³n deben ser mayores a 0. El lÃ­mite mÃ¡ximo es 100.');
      }

      const skip = (page - 1) * limit;
      const where: any = {
        institucionId: institucionId,
      };

      if (filters?.grupoId) {
        where.grupoId = filters.grupoId;
      }
      if (filters?.materiaId) {
        where.materiaId = filters.materiaId;
      }
      if (filters?.profesorId) {
        where.profesorId = filters.profesorId;
      }
      if (filters?.diaSemana !== undefined) {
        where.diaSemana = filters.diaSemana;
      }
      const total = await prisma.horario.count({ where });
      const horarios = await prisma.horario.findMany({
        where,
        skip,
        take: limit,
        orderBy: [
          { diaSemana: 'asc' },
          { horaInicio: 'asc' },
          { grupo: { nombre: 'asc' } },
        ],
        include: {
          periodoAcademico: {
            select: {
              id: true,
              nombre: true,
              fechaInicio: true,
              fechaFin: true,
              activo: true,
            },
          },
          grupo: {
            select: {
              id: true,
              nombre: true,
              grado: true,
              seccion: true,
            },
          },
          materia: {
            select: {
              id: true,
              nombre: true,
              codigo: true,
            },
          },
          profesor: {
            select: {
              id: true,
              nombres: true,
              apellidos: true,
            },
          },
          _count: {
            select: {
              asistencias: true,
            },
          },
        },
      });

      const totalPages = Math.ceil(total / limit);

      return {
        data: horarios.map((horario: any) => ({
          id: horario.id,
          periodoId: horario.periodoId,
          grupoId: horario.grupoId,
          materiaId: horario.materiaId,
          profesorId: horario.profesorId,
          diaSemana: horario.diaSemana,
          horaInicio: horario.horaInicio,
          horaFin: horario.horaFin,
          institucionId: horario.institucionId,
          createdAt: horario.createdAt.toISOString(),
          periodoAcademico: {
            id: horario.periodoAcademico.id,
            nombre: horario.periodoAcademico.nombre,
            fechaInicio: horario.periodoAcademico.fechaInicio.toISOString(),
            fechaFin: horario.periodoAcademico.fechaFin.toISOString(),
            activo: horario.periodoAcademico.activo,
          },
          grupo: {
            id: horario.grupo.id,
            nombre: horario.grupo.nombre,
            grado: horario.grupo.grado,
            seccion: horario.grupo.seccion,
          },
          materia: {
            id: horario.materia.id,
            nombre: horario.materia.nombre,
            codigo: horario.materia.codigo,
          },
          profesor: horario.profesor ? {
            id: horario.profesor.id,
            nombres: horario.profesor.nombres,
            apellidos: horario.profesor.apellidos,
          } : null,
          _count: horario._count,
        })),
        pagination: {
          page,
          limit,
          total,
          totalPages,
          hasNext: page < totalPages,
          hasPrev: page > 1,
        },
      };
    } catch (error) {
      console.error('Error al obtener horarios:', error);
      if (error instanceof ValidationError) {
        throw error;
      }
      throw new Error('Error al obtener los horarios');
    }
  }

  public static async getHorariosByGrupo(grupoId: string): Promise<HorarioResponse[]> {
    try {
      const horarios = await prisma.horario.findMany({
        where: { grupoId },
        orderBy: [
          { diaSemana: 'asc' },
          { horaInicio: 'asc' },
        ],
        include: {
          periodoAcademico: {
            select: {
              id: true,
              nombre: true,
              fechaInicio: true,
              fechaFin: true,
              activo: true,
            },
          },
          grupo: {
            select: {
              id: true,
              nombre: true,
              grado: true,
              seccion: true,
            },
          },
          materia: {
            select: {
              id: true,
              nombre: true,
              codigo: true,
            },
          },
          profesor: {
            select: {
              id: true,
              nombres: true,
              apellidos: true,
            },
          },
          _count: {
            select: {
              asistencias: true,
            },
          },
        },
      });

      return horarios.map((horario: any) => ({
        id: horario.id,
        periodoId: horario.periodoId,
        grupoId: horario.grupoId,
        materiaId: horario.materiaId,
        profesorId: horario.profesorId,
        diaSemana: horario.diaSemana,
        horaInicio: horario.horaInicio,
        horaFin: horario.horaFin,
        institucionId: horario.institucionId,
        createdAt: horario.createdAt.toISOString(),
        periodoAcademico: {
          id: horario.periodoAcademico.id,
          nombre: horario.periodoAcademico.nombre,
          fechaInicio: horario.periodoAcademico.fechaInicio.toISOString(),
          fechaFin: horario.periodoAcademico.fechaFin.toISOString(),
          activo: horario.periodoAcademico.activo,
        },
        grupo: {
          id: horario.grupo.id,
          nombre: horario.grupo.nombre,
          grado: horario.grupo.grado,
          seccion: horario.grupo.seccion,
        },
        materia: {
          id: horario.materia.id,
          nombre: horario.materia.nombre,
          codigo: horario.materia.codigo,
        },
        profesor: horario.profesor ? {
          id: horario.profesor.id,
          nombres: horario.profesor.nombres,
          apellidos: horario.profesor.apellidos,
        } : null,
        _count: horario._count,
      }));
    } catch (error) {
      console.error('Error al obtener horarios del grupo:', error);
      throw new Error('Error al obtener los horarios del grupo');
    }
  }

  public static async getHorarioById(id: string): Promise<HorarioResponse | null> {
    try {
      const horario = await prisma.horario.findUnique({
        where: { id },
        include: {
          periodoAcademico: {
            select: {
              id: true,
              nombre: true,
              fechaInicio: true,
              fechaFin: true,
              activo: true,
            },
          },
          grupo: {
            select: {
              id: true,
              nombre: true,
              grado: true,
              seccion: true,
            },
          },
          materia: {
            select: {
              id: true,
              nombre: true,
              codigo: true,
            },
          },
          profesor: {
            select: {
              id: true,
              nombres: true,
              apellidos: true,
            },
          },
          _count: {
            select: {
              asistencias: true,
            },
          },
        },
      });

      if (!horario) {
        return null;
      }

      return {
        id: horario.id,
        periodoId: horario.periodoId,
        grupoId: horario.grupoId,
        materiaId: horario.materiaId,
        profesorId: horario.profesorId,
        diaSemana: horario.diaSemana,
        horaInicio: horario.horaInicio,
        horaFin: horario.horaFin,
        institucionId: horario.institucionId,
        createdAt: horario.createdAt.toISOString(),
        periodoAcademico: {
          id: horario.periodoAcademico.id,
          nombre: horario.periodoAcademico.nombre,
          fechaInicio: horario.periodoAcademico.fechaInicio.toISOString(),
          fechaFin: horario.periodoAcademico.fechaFin.toISOString(),
          activo: horario.periodoAcademico.activo,
        },
        grupo: {
          id: horario.grupo.id,
          nombre: horario.grupo.nombre,
          grado: horario.grupo.grado,
          seccion: horario.grupo.seccion,
        },
        materia: {
          id: horario.materia.id,
          nombre: horario.materia.nombre,
          codigo: horario.materia.codigo,
        },
        profesor: horario.profesor ? {
          id: horario.profesor.id,
          nombres: horario.profesor.nombres,
          apellidos: horario.profesor.apellidos,
        } : null,
        _count: horario._count,
      };
    } catch (error) {
      console.error('Error al obtener horario:', error);
      throw new Error('Error al obtener el horario');
    }
  }

  private static async validateHorarioConflict(
    grupoId: string,
    profesorId: string | null,
    diaSemana: number,
    horaInicio: string,
    horaFin: string,
    excludeId?: string
  ): Promise<void> {
    const timeRegex = /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/;
    if (!timeRegex.test(horaInicio) || !timeRegex.test(horaFin)) {
      throw new ValidationError('El formato de hora debe ser HH:MM');
    }
    if (horaInicio >= horaFin) {
      throw new ValidationError('La hora de inicio debe ser anterior a la hora de fin');
    }
    if (diaSemana < 1 || diaSemana > 7) {
      throw new ValidationError('El dÃ­a de la semana debe estar entre 1 (Lunes) y 7 (Domingo)');
    }
    const grupoConflicts = await prisma.horario.findMany({
      where: {
        grupoId: grupoId,
        diaSemana: diaSemana,
        OR: [
          {
            AND: [
              { horaInicio: { lte: horaInicio } },
              { horaFin: { gt: horaInicio } }
            ]
          },
          {
            AND: [
              { horaInicio: { lt: horaFin } },
              { horaFin: { gte: horaFin } }
            ]
          },
          {
            AND: [
              { horaInicio: { gte: horaInicio } },
              { horaFin: { lte: horaFin } }
            ]
          }
        ],
        ...(excludeId && { id: { not: excludeId } })
      },
    });

    if (grupoConflicts.length > 0) {
      throw new ConflictError('El grupo ya tiene una clase programada en este horario');
    }
    if (profesorId) {
      const profesorConflicts = await prisma.horario.findMany({
        where: {
          profesorId: profesorId,
          diaSemana: diaSemana,
          OR: [
            {
              AND: [
                { horaInicio: { lte: horaInicio } },
                { horaFin: { gt: horaInicio } }
              ]
            },
            {
              AND: [
                { horaInicio: { lt: horaFin } },
                { horaFin: { gte: horaFin } }
              ]
            },
            {
              AND: [
                { horaInicio: { gte: horaInicio } },
                { horaFin: { lte: horaFin } }
              ]
            }
          ],
          ...(excludeId && { id: { not: excludeId } })
        },
      });

      if (profesorConflicts.length > 0) {
        throw new ConflictError('El profesor ya tiene una clase programada en este horario');
      }
    }
  }

  public static async createHorario(data: CreateHorarioRequest): Promise<HorarioResponse> {
    try {
      const periodo = await prisma.periodoAcademico.findFirst({
        where: {
          id: data.periodoId,
          institucionId: data.institucionId,
        },
      });

      if (!periodo) {
        throw new ValidationError('El periodo acadÃ©mico no existe o no pertenece a esta instituciÃ³n');
      }
      const grupo = await prisma.grupo.findFirst({
        where: {
          id: data.grupoId,
          institucionId: data.institucionId,
          periodoId: data.periodoId,
        },
      });

      if (!grupo) {
        throw new ValidationError('El grupo no existe o no pertenece a esta instituciÃ³n y periodo');
      }
      const materia = await prisma.materia.findFirst({
        where: {
          id: data.materiaId,
          institucionId: data.institucionId,
        },
      });

      if (!materia) {
        throw new ValidationError('La materia no existe o no pertenece a esta instituciÃ³n');
      }
      if (data.profesorId) {
        const profesor = await prisma.usuario.findFirst({
          where: {
            id: data.profesorId,
            rol: 'profesor',
            usuarioInstituciones: {
              some: {
                institucionId: data.institucionId,
                activo: true,
              },
            },
          },
        });

        if (!profesor) {
          throw new ValidationError('El profesor no existe o no pertenece a esta instituciÃ³n');
        }
      }
      await this.validateHorarioConflict(
        data.grupoId,
        data.profesorId || null,
        data.diaSemana,
        data.horaInicio,
        data.horaFin
      );

      const horario = await prisma.horario.create({
        data: {
          periodoId: data.periodoId,
          grupoId: data.grupoId,
          materiaId: data.materiaId,
          profesorId: data.profesorId,
          diaSemana: data.diaSemana,
          horaInicio: data.horaInicio,
          horaFin: data.horaFin,
          institucionId: data.institucionId,
        },
        include: {
          periodoAcademico: {
            select: {
              id: true,
              nombre: true,
              fechaInicio: true,
              fechaFin: true,
              activo: true,
            },
          },
          grupo: {
            select: {
              id: true,
              nombre: true,
              grado: true,
              seccion: true,
            },
          },
          materia: {
            select: {
              id: true,
              nombre: true,
              codigo: true,
            },
          },
          profesor: {
            select: {
              id: true,
              nombres: true,
              apellidos: true,
            },
          },
          _count: {
            select: {
              asistencias: true,
            },
          },
        },
      });

      return {
        id: horario.id,
        periodoId: horario.periodoId,
        grupoId: horario.grupoId,
        materiaId: horario.materiaId,
        profesorId: horario.profesorId,
        diaSemana: horario.diaSemana,
        horaInicio: horario.horaInicio,
        horaFin: horario.horaFin,
        institucionId: horario.institucionId,
        createdAt: horario.createdAt.toISOString(),
        periodoAcademico: {
          id: horario.periodoAcademico.id,
          nombre: horario.periodoAcademico.nombre,
          fechaInicio: horario.periodoAcademico.fechaInicio.toISOString(),
          fechaFin: horario.periodoAcademico.fechaFin.toISOString(),
          activo: horario.periodoAcademico.activo,
        },
        grupo: {
          id: horario.grupo.id,
          nombre: horario.grupo.nombre,
          grado: horario.grupo.grado,
          seccion: horario.grupo.seccion,
        },
        materia: {
          id: horario.materia.id,
          nombre: horario.materia.nombre,
          codigo: horario.materia.codigo,
        },
        profesor: horario.profesor ? {
          id: horario.profesor.id,
          nombres: horario.profesor.nombres,
          apellidos: horario.profesor.apellidos,
        } : null,
        _count: horario._count,
      };
    } catch (error) {
      console.error('Error al crear horario:', error);
      if (error instanceof ValidationError || error instanceof ConflictError) {
        throw error;
      }
      throw new Error('Error al crear el horario');
    }
  }

  public static async updateHorario(id: string, data: UpdateHorarioRequest): Promise<HorarioResponse | null> {
    try {
      const existingHorario = await prisma.horario.findUnique({
        where: { id },
      });

      if (!existingHorario) {
        throw new NotFoundError('Horario');
      }
      const grupoId = data.grupoId || existingHorario.grupoId;
      const profesorId = data.profesorId !== undefined ? data.profesorId : existingHorario.profesorId;
      const diaSemana = data.diaSemana !== undefined ? data.diaSemana : existingHorario.diaSemana;
      const horaInicio = data.horaInicio || existingHorario.horaInicio;
      const horaFin = data.horaFin || existingHorario.horaFin;
      if (data.grupoId && data.grupoId !== existingHorario.grupoId) {
        const grupo = await prisma.grupo.findFirst({
          where: {
            id: data.grupoId,
            institucionId: existingHorario.institucionId,
            periodoId: existingHorario.periodoId,
          },
        });

        if (!grupo) {
          throw new ValidationError('El grupo no existe o no pertenece a esta instituciÃ³n y periodo');
        }
      }
      if (data.materiaId && data.materiaId !== existingHorario.materiaId) {
        const materia = await prisma.materia.findFirst({
          where: {
            id: data.materiaId,
            institucionId: existingHorario.institucionId,
          },
        });

        if (!materia) {
          throw new ValidationError('La materia no existe o no pertenece a esta instituciÃ³n');
        }
      }
      if (data.profesorId !== undefined && data.profesorId !== existingHorario.profesorId) {
        if (data.profesorId) {
          const profesor = await prisma.usuario.findFirst({
            where: {
              id: data.profesorId,
              rol: 'profesor',
              usuarioInstituciones: {
                some: {
                  institucionId: existingHorario.institucionId,
                  activo: true,
                },
              },
            },
          });

          if (!profesor) {
            throw new ValidationError('El profesor no existe o no pertenece a esta instituciÃ³n');
          }
        }
      }
      await this.validateHorarioConflict(
        grupoId,
        profesorId,
        diaSemana,
        horaInicio,
        horaFin,
        id
      );

      const horario = await prisma.horario.update({
        where: { id },
        data: {
          grupoId: data.grupoId,
          materiaId: data.materiaId,
          profesorId: data.profesorId,
          diaSemana: data.diaSemana,
          horaInicio: data.horaInicio,
          horaFin: data.horaFin,
        },
        include: {
          periodoAcademico: {
            select: {
              id: true,
              nombre: true,
              fechaInicio: true,
              fechaFin: true,
              activo: true,
            },
          },
          grupo: {
            select: {
              id: true,
              nombre: true,
              grado: true,
              seccion: true,
            },
          },
          materia: {
            select: {
              id: true,
              nombre: true,
              codigo: true,
            },
          },
          profesor: {
            select: {
              id: true,
              nombres: true,
              apellidos: true,
            },
          },
          _count: {
            select: {
              asistencias: true,
            },
          },
        },
      });

      return {
        id: horario.id,
        periodoId: horario.periodoId,
        grupoId: horario.grupoId,
        materiaId: horario.materiaId,
        profesorId: horario.profesorId,
        diaSemana: horario.diaSemana,
        horaInicio: horario.horaInicio,
        horaFin: horario.horaFin,
        institucionId: horario.institucionId,
        createdAt: horario.createdAt.toISOString(),
        periodoAcademico: {
          id: horario.periodoAcademico.id,
          nombre: horario.periodoAcademico.nombre,
          fechaInicio: horario.periodoAcademico.fechaInicio.toISOString(),
          fechaFin: horario.periodoAcademico.fechaFin.toISOString(),
          activo: horario.periodoAcademico.activo,
        },
        grupo: {
          id: horario.grupo.id,
          nombre: horario.grupo.nombre,
          grado: horario.grupo.grado,
          seccion: horario.grupo.seccion,
        },
        materia: {
          id: horario.materia.id,
          nombre: horario.materia.nombre,
          codigo: horario.materia.codigo,
        },
        profesor: horario.profesor ? {
          id: horario.profesor.id,
          nombres: horario.profesor.nombres,
          apellidos: horario.profesor.apellidos,
        } : null,
        _count: horario._count,
      };
    } catch (error) {
      console.error('Error al actualizar horario:', error);
      if (error instanceof NotFoundError || error instanceof ValidationError || error instanceof ConflictError) {
        throw error;
      }
      throw new Error('Error al actualizar el horario');
    }
  }

  public static async deleteHorario(id: string): Promise<boolean> {
    try {
      const existingHorario = await prisma.horario.findUnique({
        where: { id },
        include: {
          _count: {
            select: {
              asistencias: true,
            },
          },
        },
      });

      if (!existingHorario) {
        throw new NotFoundError('Horario');
      }
      if (existingHorario._count.asistencias > 0) {
        throw new ValidationError('No se puede eliminar el horario porque tiene asistencias registradas');
      }

      await prisma.horario.delete({
        where: { id },
      });

      return true;
    } catch (error) {
      console.error('Error al eliminar horario:', error);
      if (error instanceof NotFoundError || error instanceof ValidationError) {
        throw error;
      }
      throw new Error('Error al eliminar el horario');
    }
  }
}

export default HorarioService;
/* Fin backend\src\services\horario.service.ts */

/* Inicio backend\src\services\institucion.service.ts */
import { prisma } from '../config/database';
import { ConflictError, PaginatedResponse, PaginationParams, ValidationError } from '../types';

export interface InstitutionFilters {
  activa?: boolean;
  search?: string;
}

export interface CreateInstitutionRequest {
  nombre: string;
  direccion?: string;
  telefono?: string;
  email?: string;
}

export interface UpdateInstitutionRequest {
  nombre?: string;
  direccion?: string;
  telefono?: string;
  email?: string;
  activa?: boolean;
}

export interface InstitutionResponse {
  id: string;
  nombre: string;
  direccion: string | null;
  telefono: string | null;
  email: string | null;
  activa: boolean;
  createdAt: string;
  updatedAt: string;
}

export class InstitucionService {

  public static async getAllInstitutions(pagination?: PaginationParams, filters?: InstitutionFilters): Promise<PaginatedResponse<InstitutionResponse>> {
    try {
      const page = pagination?.page || 1;
      const limit = pagination?.limit || 10;

      if (page < 1 || limit < 1 || limit > 100) {
        throw new ValidationError('Los parÃ¡metros de paginaciÃ³n deben ser mayores a 0. El lÃ­mite mÃ¡ximo es 100.');
      }

      const skip = (page - 1) * limit;
      const where: any = {};

      if (filters?.activa !== undefined) {
        where.activa = filters.activa;
      }
      if (filters?.search) {
        where.OR = [
          { nombre: { contains: filters.search, mode: 'insensitive' } },
          { email: { contains: filters.search, mode: 'insensitive' } },
        ];
      }
      const total = await prisma.institucion.count({ where });
      const institutions = await prisma.institucion.findMany({
        orderBy: {
          createdAt: 'desc',
        },
        skip,
        take: limit,
        where,
      });

      const totalPages = Math.ceil(total / limit);

      const data: InstitutionResponse[] = institutions.map((inst: any) => ({
        id: inst.id,
        nombre: inst.nombre,
        direccion: inst.direccion,
        telefono: inst.telefono,
        email: inst.email,
        activa: inst.activa,
        createdAt: inst.createdAt.toISOString(),
        updatedAt: inst.updatedAt.toISOString(),
      }));

      const result = {
        data,
        pagination: {
          page,
          limit,
          total,
          totalPages,
          hasNext: page < totalPages,
          hasPrev: page > 1,
        },
      };

      return result;
    } catch (error) {
      console.error('Error al obtener todas las instituciones:', error);
      if (error instanceof ValidationError) {
        throw error;
      }
      throw new Error('Error al obtener las instituciones');
    }
  }

  public static async getAdminsByInstitution(institutionId: string) {
    try {
      if (!institutionId) throw new ValidationError('ID de instituciÃ³n invÃ¡lido');

      const relations = await prisma.usuarioInstitucion.findMany({
        where: {
          institucionId: institutionId,
          rolEnInstitucion: 'admin',
          activo: true,
        },
        include: {
          usuario: true,
        },
      });
      const admins = relations.map((rel: any) => ({
        usuarioId: rel.usuario.id,
        email: rel.usuario.email,
        nombres: rel.usuario.nombres,
        apellidos: rel.usuario.apellidos,
        telefono: rel.usuario.telefono,
        activo: rel.usuario.activo,
        institucionId: rel.institucionId,
        rolEnInstitucion: rel.rolEnInstitucion,
      }));

      return admins;
    } catch (error) {
      console.error(`Error al obtener admins de la instituciÃ³n ${institutionId}:`, error);
      throw error;
    }
  }

  public static async assignAdminToInstitution(institutionId: string, userId: string) {
    try {
      if (!institutionId || !userId) throw new ValidationError('ParÃ¡metros invÃ¡lidos');
      const institucion = await prisma.institucion.findUnique({ where: { id: institutionId } });
      if (!institucion) throw new ValidationError('InstituciÃ³n no encontrada');
      const usuario = await prisma.usuario.findUnique({ where: { id: userId } });
      if (!usuario) throw new ValidationError('Usuario no encontrado');
      if (usuario.rol !== 'admin_institucion') {
        await prisma.usuario.update({ where: { id: userId }, data: { rol: 'admin_institucion' } });
      }
      const existingRel = await prisma.usuarioInstitucion.findUnique({
        where: { usuarioId_institucionId: { usuarioId: userId, institucionId: institutionId } },
      });

      if (existingRel) {
        await prisma.usuarioInstitucion.update({
          where: { usuarioId_institucionId: { usuarioId: userId, institucionId: institutionId } },
          data: { rolEnInstitucion: 'admin', activo: true },
        });
      } else {
        await prisma.usuarioInstitucion.create({
          data: { usuarioId: userId, institucionId: institutionId, rolEnInstitucion: 'admin', activo: true },
        });
      }
      const updatedUser = await prisma.usuario.findUnique({ where: { id: userId } });
      return updatedUser;
    } catch (error) {
      console.error(`Error al asignar admin ${userId} a instituciÃ³n ${institutionId}:`, error);
      throw error;
    }
  }

  public static async removeAdminFromInstitution(institutionId: string, userId: string) {
    try {
      if (!institutionId || !userId) throw new ValidationError('ParÃ¡metros invÃ¡lidos');

      const rel = await prisma.usuarioInstitucion.findUnique({
        where: { usuarioId_institucionId: { usuarioId: userId, institucionId: institutionId } },
      });

      if (!rel) {
        throw new ValidationError('RelaciÃ³n usuario-instituciÃ³n no encontrada');
      }
      await prisma.usuarioInstitucion.update({
        where: { usuarioId_institucionId: { usuarioId: userId, institucionId: institutionId } },
        data: { activo: false },
      });
      const otherActiveAdmin = await prisma.usuarioInstitucion.findFirst({
        where: { usuarioId: userId, rolEnInstitucion: 'admin', activo: true },
      });

      if (!otherActiveAdmin) {
        const usuario = await prisma.usuario.findUnique({ where: { id: userId } });
        if (usuario && usuario.rol === 'admin_institucion') {
          await prisma.usuario.update({ where: { id: userId }, data: { rol: 'user' } });
        }
      }

  return { usuarioId: userId, institutionId, removed: true };
    } catch (error) {
      console.error(`Error al remover admin ${userId} de instituciÃ³n ${institutionId}:`, error);
      throw error;
    }
  }

  public static async getInstitutionById(id: string): Promise<InstitutionResponse | null> {
    try {
      if (!id || typeof id !== 'string') {
        throw new ValidationError('ID de instituciÃ³n invÃ¡lido');
      }

      const institution = await prisma.institucion.findUnique({
        where: { id },
      });

      if (!institution) {
        return null;
      }

      return {
        id: institution.id,
        nombre: institution.nombre,
        direccion: institution.direccion,
        telefono: institution.telefono,
        email: institution.email,
        activa: institution.activa,
        createdAt: institution.createdAt.toISOString(),
        updatedAt: institution.updatedAt.toISOString(),
      };
    } catch (error) {
      console.error(`Error al obtener instituciÃ³n con ID ${id}:`, error);
      throw error;
    }
  }

  public static async createInstitution(data: CreateInstitutionRequest): Promise<InstitutionResponse> {
    try {
      if (!data.nombre) {
        throw new ValidationError('Nombre es requerido');
      }

      const institution = await prisma.institucion.create({
        data: {
          nombre: data.nombre,
          direccion: data.direccion,
          telefono: data.telefono,
          email: data.email,
        },
      });

      return {
        id: institution.id,
        nombre: institution.nombre,
        direccion: institution.direccion,
        telefono: institution.telefono,
        email: institution.email,
        activa: institution.activa,
        createdAt: institution.createdAt.toISOString(),
        updatedAt: institution.updatedAt.toISOString(),
      };
    } catch (error) {
      console.error('Error al crear instituciÃ³n:', error);
      throw error;
    }
  }

  public static async updateInstitution(id: string, data: UpdateInstitutionRequest): Promise<InstitutionResponse | null> {
    try {
      if (!id || typeof id !== 'string') {
        throw new ValidationError('ID de instituciÃ³n invÃ¡lido');
      }
      const existingInstitution = await this.getInstitutionById(id);
      if (!existingInstitution) {
        throw new ValidationError('InstituciÃ³n no encontrada');
      }

      const institution = await prisma.institucion.update({
        where: { id },
        data: {
          nombre: data.nombre,
          direccion: data.direccion,
          telefono: data.telefono,
          email: data.email,
          activa: data.activa,
        },
      });

      return {
        id: institution.id,
        nombre: institution.nombre,
        direccion: institution.direccion,
        telefono: institution.telefono,
        email: institution.email,
        activa: institution.activa,
        createdAt: institution.createdAt.toISOString(),
        updatedAt: institution.updatedAt.toISOString(),
      };
    } catch (error) {
      console.error(`Error al actualizar instituciÃ³n con ID ${id}:`, error);
      throw error;
    }
  }

  public static async deleteInstitution(id: string): Promise<boolean> {
    try {
      if (!id || typeof id !== 'string') {
        throw new ValidationError('ID de instituciÃ³n invÃ¡lido');
      }
      const existingInstitution = await this.getInstitutionById(id);
      if (!existingInstitution) {
        throw new ValidationError('InstituciÃ³n no encontrada');
      }
      const usuariosCount = await prisma.usuarioInstitucion.count({
        where: { institucionId: id, activo: true },
      });

      if (usuariosCount > 0) {
        throw new ConflictError('No se puede eliminar la instituciÃ³n porque tiene usuarios activos asociados');
      }

      await prisma.institucion.delete({
        where: { id },
      });

      return true;
    } catch (error) {
      console.error(`Error al eliminar instituciÃ³n con ID ${id}:`, error);
      throw error;
    }
  }
}

export default InstitucionService;
/* Fin backend\src\services\institucion.service.ts */

/* Inicio backend\src\services\materia.service.ts */
import { prisma } from '../config/database';
import { ConflictError, NotFoundError, PaginatedResponse, PaginationParams, ValidationError } from '../types';

export interface MateriaFilters {
  search?: string;
}

export interface CreateMateriaRequest {
  nombre: string;
  codigo?: string;
  institucionId: string;
}

export interface UpdateMateriaRequest {
  nombre?: string;
  codigo?: string;
}

export interface MateriaResponse {
  id: string;
  nombre: string;
  codigo: string | null;
  institucionId: string;
  createdAt: string;
  _count?: {
    horarios: number;
  };
}

export class MateriaService {

  public static async getAllMateriasByInstitucion(
    institucionId: string,
    pagination?: PaginationParams,
    filters?: MateriaFilters
  ): Promise<PaginatedResponse<MateriaResponse>> {
    try {
      const page = pagination?.page || 1;
      const limit = pagination?.limit || 10;

      if (page < 1 || limit < 1 || limit > 100) {
        throw new ValidationError('Los parÃ¡metros de paginaciÃ³n deben ser mayores a 0. El lÃ­mite mÃ¡ximo es 100.');
      }

      const skip = (page - 1) * limit;
      const where: any = {
        institucionId: institucionId,
      };

      if (filters?.search) {
        where.OR = [
          { nombre: { contains: filters.search, mode: 'insensitive' } },
          { codigo: { contains: filters.search, mode: 'insensitive' } },
        ];
      }
      const total = await prisma.materia.count({ where });
      const materias = await prisma.materia.findMany({
        where,
        skip,
        take: limit,
        orderBy: [
          { nombre: 'asc' },
        ],
        include: {
          _count: {
            select: {
              horarios: true,
            },
          },
        },
      });

      const totalPages = Math.ceil(total / limit);

      return {
        data: materias.map((materia: any) => ({
          id: materia.id,
          nombre: materia.nombre,
          codigo: materia.codigo,
          institucionId: materia.institucionId,
          createdAt: materia.createdAt.toISOString(),
          _count: materia._count,
        })),
        pagination: {
          page,
          limit,
          total,
          totalPages,
          hasNext: page < totalPages,
          hasPrev: page > 1,
        },
      };
    } catch (error) {
      console.error('Error al obtener materias:', error);
      if (error instanceof ValidationError) {
        throw error;
      }
      throw new Error('Error al obtener las materias');
    }
  }

  public static async getMateriaById(id: string): Promise<MateriaResponse | null> {
    try {
      const materia = await prisma.materia.findUnique({
        where: { id },
        include: {
          _count: {
            select: {
              horarios: true,
            },
          },
        },
      });

      if (!materia) {
        return null;
      }

      return {
        id: materia.id,
        nombre: materia.nombre,
        codigo: materia.codigo,
        institucionId: materia.institucionId,
        createdAt: materia.createdAt.toISOString(),
        _count: materia._count,
      };
    } catch (error) {
      console.error('Error al obtener materia:', error);
      throw new Error('Error al obtener la materia');
    }
  }

  public static async createMateria(data: CreateMateriaRequest): Promise<MateriaResponse> {
    try {
      if (!data.nombre || data.nombre.trim() === '') {
        throw new ValidationError('El nombre de la materia es requerido');
      }
      const existingMateria = await prisma.materia.findFirst({
        where: {
          nombre: data.nombre.trim(),
          institucionId: data.institucionId,
        },
      });

      if (existingMateria) {
        throw new ConflictError('Ya existe una materia con este nombre en la instituciÃ³n');
      }
      if (data.codigo && data.codigo.trim() !== '') {
        const existingCodigo = await prisma.materia.findFirst({
          where: {
            codigo: data.codigo.trim(),
            institucionId: data.institucionId,
          },
        });

        if (existingCodigo) {
          throw new ConflictError('Ya existe una materia con este cÃ³digo en la instituciÃ³n');
        }
      }

      const materia = await prisma.materia.create({
        data: {
          nombre: data.nombre.trim(),
          codigo: data.codigo?.trim() || null,
          institucionId: data.institucionId,
        },
        include: {
          _count: {
            select: {
              horarios: true,
            },
          },
        },
      });

      return {
        id: materia.id,
        nombre: materia.nombre,
        codigo: materia.codigo,
        institucionId: materia.institucionId,
        createdAt: materia.createdAt.toISOString(),
        _count: materia._count,
      };
    } catch (error) {
      console.error('Error al crear materia:', error);
      if (error instanceof ValidationError || error instanceof ConflictError) {
        throw error;
      }
      throw new Error('Error al crear la materia');
    }
  }

  public static async updateMateria(id: string, data: UpdateMateriaRequest): Promise<MateriaResponse | null> {
    try {
      const existingMateria = await prisma.materia.findUnique({
        where: { id },
      });

      if (!existingMateria) {
        throw new NotFoundError('Materia');
      }
      if (data.nombre && data.nombre !== existingMateria.nombre) {
        const existingMateriaWithName = await prisma.materia.findFirst({
          where: {
            nombre: data.nombre,
            institucionId: existingMateria.institucionId,
            id: { not: id },
          },
        });

        if (existingMateriaWithName) {
          throw new ConflictError('Ya existe una materia con este nombre en la instituciÃ³n');
        }
      }
      if (data.codigo && data.codigo !== existingMateria.codigo) {
        const existingMateriaWithCodigo = await prisma.materia.findFirst({
          where: {
            codigo: data.codigo,
            institucionId: existingMateria.institucionId,
            id: { not: id },
          },
        });

        if (existingMateriaWithCodigo) {
          throw new ConflictError('Ya existe una materia con este cÃ³digo en la instituciÃ³n');
        }
      }

      const materia = await prisma.materia.update({
        where: { id },
        data: {
          nombre: data.nombre,
          codigo: data.codigo,
        },
        include: {
          _count: {
            select: {
              horarios: true,
            },
          },
        },
      });

      return {
        id: materia.id,
        nombre: materia.nombre,
        codigo: materia.codigo,
        institucionId: materia.institucionId,
        createdAt: materia.createdAt.toISOString(),
        _count: materia._count,
      };
    } catch (error) {
      console.error('Error al actualizar materia:', error);
      if (error instanceof NotFoundError || error instanceof ValidationError || error instanceof ConflictError) {
        throw error;
      }
      throw new Error('Error al actualizar la materia');
    }
  }

  public static async deleteMateria(id: string): Promise<boolean> {
    try {
      const existingMateria = await prisma.materia.findUnique({
        where: { id },
        include: {
          _count: {
            select: {
              horarios: true,
            },
          },
        },
      });

      if (!existingMateria) {
        throw new NotFoundError('Materia');
      }
      if (existingMateria._count.horarios > 0) {
        throw new ValidationError('No se puede eliminar la materia porque tiene horarios asignados');
      }

      await prisma.materia.delete({
        where: { id },
      });

      return true;
    } catch (error) {
      console.error('Error al eliminar materia:', error);
      if (error instanceof NotFoundError || error instanceof ValidationError) {
        throw error;
      }
      throw new Error('Error al eliminar la materia');
    }
  }

  public static async getMateriasDisponibles(institucionId: string): Promise<MateriaResponse[]> {
    try {
      const materias = await prisma.materia.findMany({
        where: {
          institucionId: institucionId,
        },
        orderBy: [
          { nombre: 'asc' },
        ],
        include: {
          _count: {
            select: {
              horarios: true,
            },
          },
        },
      });

      return materias.map((materia: any) => ({
        id: materia.id,
        nombre: materia.nombre,
        codigo: materia.codigo,
        institucionId: materia.institucionId,
        createdAt: materia.createdAt.toISOString(),
        _count: materia._count,
      }));
    } catch (error) {
      console.error('Error al obtener materias disponibles:', error);
      throw new Error('Error al obtener las materias disponibles');
    }
  }
}

export default MateriaService;
/* Fin backend\src\services\materia.service.ts */

/* Inicio backend\src\services\profesor.service.ts */
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';
import { NotFoundError, ValidationError } from '../types';

const prisma = new PrismaClient();

export interface CreateProfesorRequest {
  nombres: string;
  apellidos: string;
  email: string;
  password: string;
  institucionId: string;
  grupoId?: string;
}

export interface UpdateProfesorRequest {
  nombres?: string;
  apellidos?: string;
  email?: string;
  grupoId?: string;
  activo?: boolean;
}

export interface ProfesorFilters {
  institucionId: string;
  activo?: boolean;
  search?: string;
}

export interface ClaseDelDiaResponse {
  id: string;
  diaSemana: number;
  horaInicio: string;
  horaFin: string;
  grupo: {
    id: string;
    nombre: string;
    grado: string;
    seccion: string | null;
  };
  materia: {
    id: string;
    nombre: string;
    codigo: string | null;
  };
  periodoAcademico: {
    id: string;
    nombre: string;
    activo: boolean;
  };
  institucion: {
    id: string;
    nombre: string;
  };
}

export class ProfesorService {

  public static async getAll(
    institucionId: string,
    pagination?: { page?: number; limit?: number },
    filters?: ProfesorFilters
  ) {
    try {
      const page = pagination?.page || 1;
      const limit = pagination?.limit || 10;

      if (page < 1 || limit < 1 || limit > 100) {
        throw new ValidationError('Los parÃ¡metros de paginaciÃ³n deben ser mayores a 0. El lÃ­mite mÃ¡ximo es 100.');
      }

      const skip = (page - 1) * limit;
      const where: any = {
        rol: 'profesor',
        usuarioInstituciones: {
          some: {
            institucionId,
            activo: true,
          },
        },
      };

      if (filters?.activo !== undefined) {
        where.activo = filters.activo;
      }

      if (filters?.search) {
        where.OR = [
          { nombres: { contains: filters.search, mode: 'insensitive' } },
          { apellidos: { contains: filters.search, mode: 'insensitive' } },
          { email: { contains: filters.search, mode: 'insensitive' } },
        ];
      }
      const total = await prisma.usuario.count({ where });
      const profesores = await prisma.usuario.findMany({
        where,
        skip,
        take: limit,
        include: {
          usuarioInstituciones: {
            where: {
              institucionId,
              activo: true,
            },
            include: {
              institucion: {
                select: {
                  id: true,
                  nombre: true,
                },
              },
            },
          },
        },
        orderBy: {
          apellidos: 'asc',
        },
      });
      const formattedProfesores = profesores.map((profesor: any) => ({
        id: profesor.id,
        nombres: profesor.nombres,
        apellidos: profesor.apellidos,
        email: profesor.email,
        telefono: profesor.telefono,
        activo: profesor.activo,
        institucion: profesor.usuarioInstituciones[0]?.institucion,
        createdAt: profesor.createdAt,
      }));

      return {
        data: formattedProfesores,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
        },
      };
    } catch (error) {
      console.error('Error al obtener profesores:', error);
      if (error instanceof ValidationError) {
        throw error;
      }
      throw new Error('Error al obtener los profesores');
    }
  }

  public static async getById(id: string, institucionId: string) {
    const profesor = await prisma.usuario.findFirst({
      where: {
        id,
        rol: 'profesor',
        usuarioInstituciones: {
          some: {
            institucionId,
            activo: true,
          },
        },
      },
      include: {
        usuarioInstituciones: {
          where: {
            institucionId,
            activo: true,
          },
          include: {
            institucion: {
              select: {
                id: true,
                nombre: true,
              },
            },
          },
        },
      },
    });

    if (!profesor) return null;

    return {
      id: profesor.id,
      nombres: profesor.nombres,
      apellidos: profesor.apellidos,
      email: profesor.email,
      telefono: profesor.telefono,
      activo: profesor.activo,
      institucion: profesor.usuarioInstituciones[0]?.institucion,
      createdAt: profesor.createdAt,
    };
  }

  public static async create(data: CreateProfesorRequest, createdBy: string) {
    const existingUser = await prisma.usuario.findUnique({
      where: { email: data.email },
    });

    if (existingUser) {
      throw new ValidationError('El email ya estÃ¡ registrado');
    }
    const institucion = await prisma.institucion.findUnique({
      where: { id: data.institucionId },
    });

    if (!institucion) {
      throw new NotFoundError('InstituciÃ³n');
    }
    const hashedPassword = await bcrypt.hash(data.password, 10);
    const newProfesor = await prisma.usuario.create({
      data: {
        email: data.email,
        passwordHash: hashedPassword,
        nombres: data.nombres,
        apellidos: data.apellidos,
        rol: 'profesor',
        activo: true,
      },
    });
    await prisma.usuarioInstitucion.create({
      data: {
        usuarioId: newProfesor.id,
        institucionId: data.institucionId,
        activo: true,
      },
    });
    const profesorWithInstitucion = await this.getById(newProfesor.id, data.institucionId);

    return profesorWithInstitucion;
  }

  public static async update(id: string, institucionId: string, data: UpdateProfesorRequest) {
    const existingProfesor = await prisma.usuario.findFirst({
      where: {
        id,
        rol: 'profesor',
        usuarioInstituciones: {
          some: {
            institucionId,
            activo: true,
          },
        },
      },
    });

    if (!existingProfesor) {
      throw new NotFoundError('Profesor');
    }
    if (data.email && data.email !== existingProfesor.email) {
      const emailExists = await prisma.usuario.findUnique({
        where: { email: data.email },
      });

      if (emailExists) {
        throw new ValidationError('El email ya estÃ¡ registrado para otro usuario');
      }
    }

    const updatedProfesor = await prisma.usuario.update({
      where: { id },
      data: {
        nombres: data.nombres,
        apellidos: data.apellidos,
        email: data.email,
        activo: data.activo,
      },
      include: {
        usuarioInstituciones: {
          where: {
            institucionId,
            activo: true,
          },
          include: {
            institucion: {
              select: {
                id: true,
                nombre: true,
              },
            },
          },
        },
      },
    });

    return {
      id: updatedProfesor.id,
      nombres: updatedProfesor.nombres,
      apellidos: updatedProfesor.apellidos,
      email: updatedProfesor.email,
      telefono: updatedProfesor.telefono,
      activo: updatedProfesor.activo,
      institucion: updatedProfesor.usuarioInstituciones[0]?.institucion,
      createdAt: updatedProfesor.createdAt,
    };
  }

  public static async delete(id: string, institucionId: string) {
    const existingProfesor = await prisma.usuario.findFirst({
      where: {
        id,
        rol: 'profesor',
        usuarioInstituciones: {
          some: {
            institucionId,
            activo: true,
          },
        },
      },
    });

    if (!existingProfesor) {
      return false;
    }
    await prisma.usuario.update({
      where: { id },
      data: { activo: false },
    });

    return true;
  }

  public static async toggleStatus(id: string, institucionId: string) {
    const existingProfesor = await prisma.usuario.findFirst({
      where: {
        id,
        rol: 'profesor',
        usuarioInstituciones: {
          some: {
            institucionId,
            activo: true,
          },
        },
      },
    });

    if (!existingProfesor) {
      throw new NotFoundError('Profesor');
    }

    const updatedProfesor = await prisma.usuario.update({
      where: { id },
      data: { activo: !existingProfesor.activo },
      include: {
        usuarioInstituciones: {
          where: {
            institucionId,
            activo: true,
          },
          include: {
            institucion: {
              select: {
                id: true,
                nombre: true,
              },
            },
          },
        },
      },
    });

    return {
      id: updatedProfesor.id,
      nombres: updatedProfesor.nombres,
      apellidos: updatedProfesor.apellidos,
      email: updatedProfesor.email,
      telefono: updatedProfesor.telefono,
      activo: updatedProfesor.activo,
      institucion: updatedProfesor.usuarioInstituciones[0]?.institucion,
      createdAt: updatedProfesor.createdAt,
    };
  }

  public static async getClasesDelDia(profesorId: string): Promise<ClaseDelDiaResponse[]> {
    try {
      const hoy = new Date();
      const diaSemana = hoy.getDay() === 0 ? 7 : hoy.getDay()
      const clases = await prisma.horario.findMany({
        where: {
          profesorId: profesorId,
          diaSemana: diaSemana,
          periodoAcademico: {
            activo: true, // Solo periodos activos
          },
        },
        orderBy: [
          { horaInicio: 'asc' },
        ],
        include: {
          grupo: {
            select: {
              id: true,
              nombre: true,
              grado: true,
              seccion: true,
            },
          },
          materia: {
            select: {
              id: true,
              nombre: true,
              codigo: true,
            },
          },
          periodoAcademico: {
            select: {
              id: true,
              nombre: true,
              activo: true,
            },
          },
          institucion: {
            select: {
              id: true,
              nombre: true,
            },
          },
        },
      });

      return clases.map((clase: any) => ({
        id: clase.id,
        diaSemana: clase.diaSemana,
        horaInicio: clase.horaInicio,
        horaFin: clase.horaFin,
        grupo: {
          id: clase.grupo.id,
          nombre: clase.grupo.nombre,
          grado: clase.grupo.grado,
          seccion: clase.grupo.seccion,
        },
        materia: {
          id: clase.materia.id,
          nombre: clase.materia.nombre,
          codigo: clase.materia.codigo,
        },
        periodoAcademico: {
          id: clase.periodoAcademico.id,
          nombre: clase.periodoAcademico.nombre,
          activo: clase.periodoAcademico.activo,
        },
        institucion: {
          id: clase.institucion.id,
          nombre: clase.institucion.nombre,
        },
      }));
    } catch (error) {
      console.error('Error al obtener clases del dÃ­a:', error);
      throw new Error('Error al obtener las clases del dÃ­a');
    }
  }

  public static async getClasesPorDia(profesorId: string, diaSemana: number): Promise<ClaseDelDiaResponse[]> {
    try {
      if (diaSemana < 1 || diaSemana > 7) {
        throw new Error('El dÃ­a de la semana debe estar entre 1 (Lunes) y 7 (Domingo)');
      }

      const clases = await prisma.horario.findMany({
        where: {
          profesorId: profesorId,
          diaSemana: diaSemana,
          periodoAcademico: {
            activo: true, // Solo periodos activos
          },
        },
        orderBy: [
          { horaInicio: 'asc' },
        ],
        include: {
          grupo: {
            select: {
              id: true,
              nombre: true,
              grado: true,
              seccion: true,
            },
          },
          materia: {
            select: {
              id: true,
              nombre: true,
              codigo: true,
            },
          },
          periodoAcademico: {
            select: {
              id: true,
              nombre: true,
              activo: true,
            },
          },
          institucion: {
            select: {
              id: true,
              nombre: true,
            },
          },
        },
      });

      return clases.map((clase: any) => ({
        id: clase.id,
        diaSemana: clase.diaSemana,
        horaInicio: clase.horaInicio,
        horaFin: clase.horaFin,
        grupo: {
          id: clase.grupo.id,
          nombre: clase.grupo.nombre,
          grado: clase.grupo.grado,
          seccion: clase.grupo.seccion,
        },
        materia: {
          id: clase.materia.id,
          nombre: clase.materia.nombre,
          codigo: clase.materia.codigo,
        },
        periodoAcademico: {
          id: clase.periodoAcademico.id,
          nombre: clase.periodoAcademico.nombre,
          activo: clase.periodoAcademico.activo,
        },
        institucion: {
          id: clase.institucion.id,
          nombre: clase.institucion.nombre,
        },
      }));
    } catch (error) {
      console.error('Error al obtener clases por dÃ­a:', error);
      throw new Error('Error al obtener las clases por dÃ­a');
    }
  }

  public static async getHorarioSemanal(profesorId: string): Promise<{
    [key: number]: ClaseDelDiaResponse[];
  }> {
    try {
      const horarioSemanal: { [key: number]: ClaseDelDiaResponse[] } = {};
      for (let dia = 1; dia <= 7; dia++) {
        horarioSemanal[dia] = await this.getClasesPorDia(profesorId, dia);
      }

      return horarioSemanal;
    } catch (error) {
      console.error('Error al obtener horario semanal:', error);
      throw new Error('Error al obtener el horario semanal');
    }
  }
}

export default ProfesorService;
/* Fin backend\src\services\profesor.service.ts */

/* Inicio backend\src\services\user.service.ts */
import bcrypt from 'bcryptjs';
import { randomBytes } from 'crypto';
import { prisma } from '../config/database';
import { AuthorizationError, ConflictError, CreateUserRequest, CreateUserResponse, NotFoundError, PaginatedResponse, PaginationParams, UpdateUserRequest, UserFilters, UserRole, UsuarioExtendido, ValidationError } from '../types';

export class UserService {

  public static async getAllUsers(pagination?: PaginationParams, filters?: UserFilters): Promise<PaginatedResponse<UsuarioExtendido>> {
    try {
      const page = pagination?.page || 1;
      const limit = pagination?.limit || 50;

      if (page < 1 || limit < 1 || limit > 100) {
        throw new ValidationError('Los parÃ¡metros de paginaciÃ³n deben ser mayores a 0. El lÃ­mite mÃ¡ximo es 100.');
      }

      const skip = (page - 1) * limit;
      const where: any = {};

      if (filters?.activo !== undefined) {
        where.activo = filters.activo;
      }
      if (filters?.rol) {
        const rolFilter: any = filters.rol as any;
        if (Array.isArray(rolFilter)) {
          where.rol = { in: rolFilter };
        } else if (typeof rolFilter === 'string' && rolFilter.includes(',')) {
          where.rol = { in: rolFilter.split(',').map(r => r.trim()) };
        } else {
          where.rol = rolFilter;
        }
      }
      if (filters?.institucionId) {
        where.usuarioInstituciones = {
          some: { institucionId: filters.institucionId, activo: true },
        };
      }
      if (filters?.search) {
        where.OR = [
          { nombres: { contains: filters.search, mode: 'insensitive' } },
          { apellidos: { contains: filters.search, mode: 'insensitive' } },
          { email: { contains: filters.search, mode: 'insensitive' } },
        ];
      }
      const total = await prisma.usuario.count({ where });
      const users = await prisma.usuario.findMany({
        include: {
          usuarioInstituciones: {
            where: { activo: true },
            include: {
              institucion: true,
            },
          },
        },
        orderBy: {
          createdAt: 'desc',
        },
        skip,
        take: limit,
        where,
      });

      const totalPages = Math.ceil(total / limit);

      return {
        data: users,
        pagination: {
          page,
          limit,
          total,
          totalPages,
          hasNext: page < totalPages,
          hasPrev: page > 1,
        },
      };
    } catch (error) {
      console.error('Error al obtener todos los usuarios:', error);
      if (error instanceof ValidationError) {
        throw error;
      }
      throw new Error('Error al obtener los usuarios');
    }
  }

  public static async getUserById(id: string): Promise<UsuarioExtendido | null> {
    try {
      if (!id || typeof id !== 'string') {
        throw new ValidationError('ID de usuario invÃ¡lido');
      }

      const user = await prisma.usuario.findUnique({
        where: { id },
        include: {
          usuarioInstituciones: {
            where: { activo: true },
            include: {
              institucion: true,
            },
          },
          estudiante: true,
        },
      });

      return user;
    } catch (error) {
      console.error(`Error al obtener usuario con ID ${id}:`, error);
      throw error;
    }
  }

  public static async getUserByEmail(email: string): Promise<UsuarioExtendido | null> {
    try {
      if (!email || typeof email !== 'string' || !email.includes('@')) {
        throw new ValidationError('Email invÃ¡lido');
      }

      const user = await prisma.usuario.findUnique({
        where: { email: email.toLowerCase() },
        include: {
          usuarioInstituciones: {
            where: { activo: true },
            include: {
              institucion: true,
            },
          },
        },
      });

      return user;
    } catch (error) {
      console.error(`Error al obtener usuario con email ${email}:`, error);
      throw error;
    }
  }

  public static async getUsersByRole(role: string, pagination?: PaginationParams, filters?: UserFilters): Promise<PaginatedResponse<UsuarioExtendido>> {
    const combinedFilters = { ...filters, rol: role as UserRole };
    return this.getAllUsers(pagination, combinedFilters);
  }

  public static async getUsersByInstitution(institucionId: string, pagination?: PaginationParams, filters?: UserFilters): Promise<PaginatedResponse<UsuarioExtendido>> {
    const combinedFilters = { ...filters, institucionId };
    return this.getAllUsers(pagination, combinedFilters);
  }

  public static async createUser(userData: CreateUserRequest, invokerRole: UserRole): Promise<CreateUserResponse> {
    try {
      if (invokerRole === 'super_admin' && userData.rol !== 'admin_institucion' && userData.rol !== 'super_admin') {
        throw new AuthorizationError('Un Super Admin solo puede crear usuarios de tipo Administrador de InstituciÃ³n o Super Admin.');
      }
      if (invokerRole === 'super_admin' && userData.rol === 'admin_institucion' && !userData.institucionId) {
        throw new ValidationError('Se requiere un institucionId para crear un Administrador de InstituciÃ³n.');
      }
      if (invokerRole === 'admin_institucion' && (userData.rol !== 'profesor' && userData.rol !== 'estudiante')) {
        throw new AuthorizationError('Un Administrador de InstituciÃ³n solo puede crear profesores o estudiantes.');
      }
      if (!userData.email || !userData.password || !userData.nombres || !userData.apellidos || !userData.rol) {
        throw new ValidationError('Campos requeridos faltantes');
      }

      const validRoles: UserRole[] = ['super_admin', 'admin_institucion', 'profesor', 'estudiante'];
      if (!validRoles.includes(userData.rol)) {
        throw new ValidationError('Rol invÃ¡lido');
      }
      const emailAvailable = await this.isEmailAvailable(userData.email);
      if (!emailAvailable) {
        throw new ConflictError('El email ya estÃ¡ registrado');
      }
      const hashedPassword = await bcrypt.hash(userData.password, 10);
      let codigoQr: string | undefined;
      if (userData.rol === 'estudiante') {
        if (!userData.identificacion) {
          throw new ValidationError('La identificaciÃ³n es requerida para estudiantes');
        }
        codigoQr = this.generateUniqueQRCode();
      }
      const result = await prisma.$transaction(async (tx: any) => {
        const newUser = await tx.usuario.create({
          data: {
            email: userData.email.toLowerCase(),
            passwordHash: hashedPassword,
            nombres: userData.nombres,
            apellidos: userData.apellidos,
            rol: userData.rol,
            telefono: userData.telefono,
          },
        });
        if (userData.institucionId) {
          await tx.usuarioInstitucion.create({
            data: {
              usuarioId: newUser.id,
              institucionId: userData.institucionId,
              rolEnInstitucion: userData.rolEnInstitucion,
            },
          });
        }
        let estudianteData: {
          id: string;
          usuarioId: string;
          identificacion: string;
          codigoQr: string;
          nombreResponsable: string | null;
          telefonoResponsable: string | null;
        } | null = null;
        if (userData.rol === 'estudiante' && userData.identificacion) {
          estudianteData = await tx.estudiante.create({
            data: {
              usuarioId: newUser.id,
              identificacion: userData.identificacion,
              codigoQr: codigoQr!,
              nombreResponsable: userData.nombreResponsable,
              telefonoResponsable: userData.telefonoResponsable,
            },
          });
        }

        return { newUser, estudianteData };
      });
      const userWithRelations = await this.getUserById(result.newUser.id);
      if (!userWithRelations) {
        throw new Error('Error al obtener usuario creado');
      }
      const response: CreateUserResponse = {
        id: userWithRelations.id,
        email: userWithRelations.email,
        nombres: userWithRelations.nombres,
        apellidos: userWithRelations.apellidos,
        rol: userWithRelations.rol as UserRole,
        telefono: userWithRelations.telefono,
        activo: userWithRelations.activo,
        instituciones: userWithRelations.usuarioInstituciones?.map(ui => ({
          id: ui.institucion.id,
          nombre: ui.institucion.nombre,
          rolEnInstitucion: ui.rolEnInstitucion,
          activo: ui.activo,
        })) || [],
      };

      if (result.estudianteData) {
        response.estudiante = {
          id: result.estudianteData.id,
          identificacion: result.estudianteData.identificacion,
          codigoQr: result.estudianteData.codigoQr,
          nombreResponsable: result.estudianteData.nombreResponsable,
          telefonoResponsable: result.estudianteData.telefonoResponsable,
        };
      }

      return response;

    } catch (error) {
      console.error('Error al crear usuario:', error);
      throw error;
    }
  }

  public static async updateUser(id: string, userData: UpdateUserRequest): Promise<UsuarioExtendido | null> {
    try {
      if (!id || typeof id !== 'string') {
        throw new ValidationError('ID de usuario invÃ¡lido');
      }
      const existingUser = await this.getUserById(id);
      if (!existingUser) {
        throw new ValidationError('Usuario no encontrado');
      }
      if (userData.email && userData.email !== existingUser.email) {
        const emailAvailable = await this.isEmailAvailable(userData.email, id);
        if (!emailAvailable) {
          throw new ConflictError('El email ya estÃ¡ registrado');
        }
      }
      const result = await prisma.$transaction(async (tx: any) => {
        const updateData: {
          email?: string;
          nombres?: string;
          apellidos?: string;
          telefono?: string | null;
          activo?: boolean;
        } = {};
        if (userData.email !== undefined) updateData.email = userData.email.toLowerCase();
        if (userData.nombres !== undefined) updateData.nombres = userData.nombres;
        if (userData.apellidos !== undefined) updateData.apellidos = userData.apellidos;
        if (userData.telefono !== undefined) updateData.telefono = userData.telefono;
        if (userData.activo !== undefined) updateData.activo = userData.activo;

        const updatedUser = await tx.usuario.update({
          where: { id },
          data: updateData,
        });
        if (existingUser.rol === 'estudiante' && (userData.identificacion || userData.nombreResponsable || userData.telefonoResponsable)) {
          const estudianteUpdateData: {
            identificacion?: string;
            nombreResponsable?: string | null;
            telefonoResponsable?: string | null;
          } = {};
          if (userData.identificacion !== undefined) estudianteUpdateData.identificacion = userData.identificacion;
          if (userData.nombreResponsable !== undefined) estudianteUpdateData.nombreResponsable = userData.nombreResponsable;
          if (userData.telefonoResponsable !== undefined) estudianteUpdateData.telefonoResponsable = userData.telefonoResponsable;

          await tx.estudiante.update({
            where: { usuarioId: id },
            data: estudianteUpdateData,
          });
        }

        return updatedUser;
      });
      return await this.getUserById(id);

    } catch (error) {
      console.error(`Error al actualizar usuario con ID ${id}:`, error);
      throw error;
    }
  }

  public static async changeUserPassword(userId: string, newPassword: string): Promise<boolean> {
    try {
      if (!userId || typeof userId !== 'string') {
        throw new ValidationError('ID de usuario invÃ¡lido');
      }
      if (!newPassword || typeof newPassword !== 'string' || newPassword.length < 8) {
        throw new ValidationError('La nueva contraseÃ±a debe tener al menos 8 caracteres');
      }

      const user = await prisma.usuario.findUnique({ where: { id: userId } });
      if (!user) {
        throw new NotFoundError('Usuario');
      }

      const hashed = await bcrypt.hash(newPassword, 10);

      await prisma.usuario.update({
        where: { id: userId },
        data: {
          passwordHash: hashed,
          tokenVersion: (user.tokenVersion ?? 0) + 1,
        },
      });

      return true;
    } catch (error) {
      console.error(`Error changing password for user ${userId}:`, error);
      throw error;
    }
  }

  public static async deleteUser(id: string): Promise<boolean> {
    try {
      if (!id || typeof id !== 'string') {
        throw new ValidationError('ID de usuario invÃ¡lido');
      }
      const existingUser = await this.getUserById(id);
      if (!existingUser) {
        throw new ValidationError('Usuario no encontrado');
      }
      await prisma.usuario.update({
        where: { id },
        data: { activo: false },
      });

      return true;

    } catch (error) {
      console.error(`Error al eliminar usuario con ID ${id}:`, error);
      throw error;
    }
  }

  private static generateUniqueQRCode(): string {
    return randomBytes(16).toString('hex').toUpperCase();
  }

  public static async userExists(id: string): Promise<boolean> {
    try {
      if (!id || typeof id !== 'string') {
        return false;
      }

      const count = await prisma.usuario.count({
        where: { id },
      });

      return count > 0;
    } catch (error) {
      console.error(`Error al verificar existencia de usuario ${id}:`, error);
      return false;
    }
  }

  public static async isEmailAvailable(email: string, excludeUserId?: string): Promise<boolean> {
    try {
      if (!email || typeof email !== 'string' || !email.includes('@')) {
        return false;
      }

      const whereClause: {
        email: string;
        id?: { not: string };
      } = { email: email.toLowerCase() };
      if (excludeUserId) {
        whereClause.id = { not: excludeUserId };
      }

      const count = await prisma.usuario.count({
        where: whereClause,
      });

      return count === 0;
    } catch (error) {
      console.error(`Error al verificar disponibilidad de email ${email}:`, error);
      return false;
    }
  }
}

export default UserService;
/* Fin backend\src\services\user.service.ts */

/* Inicio backend\src\types\index.ts */

import { PrismaClientKnownRequestError, PrismaClientValidationError } from '@prisma/client/runtime/library';
import { FastifyRequest } from 'fastify';
export type Institucion = any;
export type Usuario = any;

export type UserRole = 'super_admin' | 'admin_institucion' | 'profesor' | 'estudiante';

export interface LoginRequest {
  email: string;
  password: string;
}

export interface LoginResponse {
  accessToken: string;
  refreshToken: string;
  usuario: {
    id: string;
    nombres: string;
    apellidos: string;
    rol: UserRole;
    instituciones: {
      id: string;
      nombre: string;
      rolEnInstitucion?: string | null;
    }[];
  };
  expiresIn: number
}

export interface RefreshTokenRequest {
  refreshToken: string;
}

export interface RefreshTokenResponse {
  accessToken: string;
  refreshToken: string;
  expiresIn: number;
}

export interface LogoutRequest {
  refreshToken?: string;
}

export interface VerifyTokenResponse {
  usuario: JWTPayload;
  valid: boolean;
}

export interface GetUserByIdRequest {
  id: string;
}

export interface GetUsersByRoleRequest {
  role: UserRole;
}

export interface GetUsersByInstitutionRequest {
  institucionId: string;
}

export interface UserResponse {
  id: string;
  email: string;
  nombres: string;
  apellidos: string;
  rol: UserRole;
  telefono?: string | null;
  activo: boolean;
  instituciones: {
    id: string;
    nombre: string;
    rolEnInstitucion?: string | null;
    activo: boolean;
  }[];
}

export interface UsuarioExtendido extends Omit<Usuario, 'institucionId'> {
  usuarioInstituciones?: {
    institucion: Institucion;
    rolEnInstitucion?: string | null;
    activo: boolean;
  }[];
}

export interface UsuarioConInstituciones extends Usuario {
  usuarioInstituciones: {
    institucion: Institucion;
    rolEnInstitucion?: string | null;
    activo: boolean;
  }[];
}

export interface ApiResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

export class AppError extends Error {
  public readonly statusCode: number;
  public readonly code: string;
  public readonly isOperational: boolean;

  constructor(message: string, statusCode: number = 500, code: string = 'INTERNAL_ERROR') {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }
}

export class ValidationError extends AppError {
  constructor(message: string) {
    super(message, 400, 'VALIDATION_ERROR');
  }
}

export class AuthenticationError extends AppError {
  constructor(message: string = 'No autorizado') {
    super(message, 401, 'AUTHENTICATION_ERROR');
  }
}

export class AuthorizationError extends AppError {
  constructor(message: string = 'Acceso denegado') {
    super(message, 403, 'AUTHORIZATION_ERROR');
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string = 'Recurso') {
    super(`${resource} no encontrado`, 404, 'NOT_FOUND_ERROR');
  }
}

export class ConflictError extends AppError {
  constructor(message: string) {
    super(message, 409, 'CONFLICT_ERROR');
  }
}

export type DatabaseError = PrismaClientKnownRequestError | PrismaClientValidationError;

export interface JWTPayload {
  id: string;
  rol: UserRole;
  email: string;
  tokenVersion: number;
  jti?: string
  iat?: number;
  exp?: number;
}

export interface AuthenticatedRequest extends FastifyRequest {
  user: JWTPayload;
}

export interface AppConfig {
  port: number;
  host: string;
  jwtSecret: string;
  jwtExpiresIn: string;
  nodeEnv: string;
  logLevel: string;
}

export interface CreateInstitucionRequest {
  nombre: string;
  direccion?: string;
  telefono?: string;
  email?: string;
}

export interface UpdateInstitucionRequest {
  nombre?: string;
  direccion?: string;
  telefono?: string;
  email?: string;
  activa?: boolean;
}

export interface InstitucionResponse {
  id: string;
  nombre: string;
  direccion?: string | null;
  telefono?: string | null;
  email?: string | null;
  activa: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface CreateUserRequest {
  email: string;
  password: string;
  nombres: string;
  apellidos: string;
  rol: UserRole;
  telefono?: string;
  institucionId?: string
  rolEnInstitucion?: string
  identificacion?: string
  nombreResponsable?: string
  telefonoResponsable?: string
}

export interface UpdateUserRequest {
  email?: string;
  nombres?: string;
  apellidos?: string;
  telefono?: string;
  activo?: boolean;
  identificacion?: string;
  nombreResponsable?: string;
  telefonoResponsable?: string;
}

export interface CreateUserResponse extends UserResponse {
  estudiante?: {
    id: string;
    identificacion: string;
    codigoQr: string;
    nombreResponsable?: string | null;
    telefonoResponsable?: string | null;
  };
}
export interface PaginationParams {
  page?: number;
  limit?: number;
}

export interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}

export interface UserFilters {
  activo?: boolean;
  rol?: UserRole;
  institucionId?: string;
  search?: string;
}
/* Fin backend\src\types\index.ts */

/* Inicio backend\src\utils\index.ts */
import { ApiResponse } from '../types';

export class ResponseUtil {

  public static success<T>(data: T, message?: string): ApiResponse<T> {
    return {
      success: true,
      data,
      message,
    };
  }

  public static error(message: string, code?: string): ApiResponse {
    return {
      success: false,
      error: message,
      message: code,
    };
  }

  public static paginated<T>(
    data: T[],
    total: number,
    page: number,
    limit: number,
    message?: string
  ): ApiResponse<{
    items: T[];
    pagination: {
      total: number;
      page: number;
      limit: number;
      totalPages: number;
    };
  }> {
    return {
      success: true,
      data: {
        items: data,
        pagination: {
          total,
          page,
          limit,
          totalPages: Math.ceil(total / limit),
        },
      },
      message,
    };
  }
}

export class ValidationUtil {

  public static isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  public static isNotEmpty(value: string | undefined | null): boolean {
    return Boolean(value && value.trim().length > 0);
  }

  public static hasMinLength(value: string | undefined | null, minLength: number): boolean {
    return Boolean(value && value.length >= minLength);
  }
}

export class FormatUtil {

  public static capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
  }

  public static snakeToCamel(str: string): string {
    return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
  }

  public static camelToSnake(str: string): string {
    return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
  }
}

export default {
  ResponseUtil,
  ValidationUtil,
  FormatUtil,
};
/* Fin backend\src\utils\index.ts */

/* Inicio backend\test-api-complete.ts */
#!/usr/bin/env ts-node

import axios, { AxiosResponse } from 'axios';
const BASE_URL = 'http://localhost:3001';
interface AuthResponse {
  success: boolean;
  data: {
    accessToken: string;
    refreshToken: string;
    expiresIn: number;
    usuario: {
      id: string;
      nombres: string;
      apellidos: string;
      rol: string;
      institucionId: string | null;
    };
  };
}

interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  message?: string;
  pagination?: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

interface Usuario {
  id: string;
  nombres: string;
  apellidos: string;
  email: string;
  rol: string;
  activo: boolean;
  institucionId: string | null;
  createdAt: string;
}

interface Grupo {
  id: string;
  nombre: string;
  grado: string;
  seccion: string | null;
  periodoId: string;
  institucionId: string;
  createdAt: string;
  periodoAcademico: {
    id: string;
    nombre: string;
    fechaInicio: string;
    fechaFin: string;
    activo: boolean;
  };
  _count: {
    estudiantesGrupos: number;
    horarios: number;
  };
}

interface Materia {
  id: string;
  nombre: string;
  codigo: string | null;
  institucionId: string;
  createdAt: string;
}

interface Horario {
  id: string;
  periodoId: string;
  grupoId: string;
  materiaId: string;
  profesorId: string | null;
  diaSemana: number;
  horaInicio: string;
  horaFin: string;
  institucionId: string;
  createdAt: string;
  grupo: {
    id: string;
    nombre: string;
    grado: string;
    seccion: string | null;
  };
  materia: {
    id: string;
    nombre: string;
    codigo: string | null;
  };
  periodoAcademico: {
    id: string;
    nombre: string;
    activo: boolean;
  };
}

interface ClaseDelDia {
  id: string;
  diaSemana: number;
  horaInicio: string;
  horaFin: string;
  grupo: {
    id: string;
    nombre: string;
    grado: string;
    seccion: string | null;
  };
  materia: {
    id: string;
    nombre: string;
    codigo: string | null;
  };
  periodoAcademico: {
    id: string;
    nombre: string;
    activo: boolean;
  };
  institucion: {
    id: string;
    nombre: string;
  };
}
class CompleteFlowTester {
  private tokens: { [key: string]: string } = {};
  private createdEntities: { [key: string]: string[] } = {};
  private currentPeriodoId: string = '';

  constructor() {
    axios.defaults.baseURL = BASE_URL;
    axios.defaults.timeout = 15000;
  }
  async login(email: string, password: string, roleName: string): Promise<boolean> {
    try {
      console.log(`ðŸ” Iniciando sesiÃ³n como ${roleName} (${email})...`);

      const response: AxiosResponse<AuthResponse> = await axios.post('/auth/login', {
        email,
        password,
      });

      if (response.data.success && response.data.data.accessToken) {
        this.tokens[roleName] = response.data.data.accessToken;
        console.log(`âœ… SesiÃ³n iniciada para ${roleName}`);
        console.log(`   ðŸ‘¤ Usuario: ${response.data.data.usuario.nombres} ${response.data.data.usuario.apellidos}`);
        console.log(`   ðŸ« InstituciÃ³n ID: ${response.data.data.usuario.institucionId}`);
        return true;
      } else {
        console.log(`âŒ Error iniciando sesiÃ³n para ${roleName}`);
        console.log('Respuesta:', response.data);
        return false;
      }
    } catch (error: any) {
      console.log(`âŒ Error iniciando sesiÃ³n para ${roleName}:`, error.response?.data || error.message);
      return false;
    }
  }
  async verifyToken(roleName: string): Promise<boolean> {
    try {
      const response = await axios.get('/auth/verify', {
        headers: { 'Authorization': `Bearer ${this.tokens[roleName]}` }
      });
      return response.data.success;
    } catch (error) {
      return false;
    }
  }
  async testEndpoint(
    method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH',
    url: string,
    tokenRole: string,
    data?: any,
    expectedStatus: number = 200,
    description: string = '',
    showResponse: boolean = false
  ): Promise<boolean> {
    try {
      console.log(`\nðŸ§ª ${description}`);
      console.log(`   ${method} ${url}`);

      const config = {
        headers: {
          'Authorization': `Bearer ${this.tokens[tokenRole]}`,
          'Content-Type': 'application/json',
        },
      };

      let response: AxiosResponse;

      switch (method) {
        case 'GET':
          response = await axios.get(url, config);
          break;
        case 'POST':
          response = await axios.post(url, data, config);
          break;
        case 'PUT':
          response = await axios.put(url, data, config);
          break;
        case 'PATCH':
          response = await axios.patch(url, data, config);
          break;
        case 'DELETE':
          response = await axios.delete(url, config);
          break;
        default:
          throw new Error(`MÃ©todo HTTP no soportado: ${method}`);
      }

      if (response.status === expectedStatus) {
        console.log(`âœ… Status: ${response.status} (esperado: ${expectedStatus})`);
        if (response.data.success) {
          console.log(`   âœ… Respuesta exitosa`);
          if (showResponse && response.data.data) {
            console.log(`   ðŸ“„ Datos:`, typeof response.data.data === 'object' && response.data.data.length > 3
              ? `${response.data.data.length} elementos`
              : response.data.data);
          }
        } else {
          console.log(`   âš ï¸  Respuesta con mensaje: ${response.data.message}`);
        }
        return true;
      } else {
        console.log(`âŒ Status: ${response.status} (esperado: ${expectedStatus})`);
        console.log(`   Respuesta:`, response.data);
        return false;
      }
    } catch (error: any) {
      const status = error.response?.status || 'ERROR';
      const responseData = error.response?.data;

      if (status === expectedStatus) {
        console.log(`âœ… Status: ${status} (esperado: ${expectedStatus})`);
        if (responseData?.success === false) {
          console.log(`   âš ï¸  Respuesta esperada con error: ${responseData.message}`);
        }
        return true;
      } else {
        console.log(`âŒ Status: ${status} (esperado: ${expectedStatus})`);
        console.log(`   Error:`, responseData || error.message);
        return false;
      }
    }
  }
  async testEndpointNoAuth(
    method: 'GET' | 'POST' | 'PUT' | 'DELETE',
    url: string,
    expectedStatus: number = 401,
    description: string = ''
  ): Promise<boolean> {
    try {
      console.log(`\nðŸ§ª ${description} (Sin autenticaciÃ³n)`);
      console.log(`   ${method} ${url}`);

      const config = {
        headers: {
          'Content-Type': 'application/json',
        },
      };

      let response: AxiosResponse;

      switch (method) {
        case 'GET':
          response = await axios.get(url, config);
          break;
        case 'POST':
          response = await axios.post(url, {}, config);
          break;
        case 'PUT':
          response = await axios.put(url, {}, config);
          break;
        case 'DELETE':
          response = await axios.delete(url, config);
          break;
        default:
          throw new Error(`MÃ©todo HTTP no soportado: ${method}`);
      }

      if (response.status === expectedStatus) {
        console.log(`âœ… Status: ${response.status} (esperado: ${expectedStatus})`);
        return true;
      } else {
        console.log(`âŒ Status: ${response.status} (esperado: ${expectedStatus})`);
        console.log(`   Respuesta:`, response.data);
        return false;
      }
    } catch (error: any) {
      const status = error.response?.status || 'ERROR';
      const responseData = error.response?.data;

      if (status === expectedStatus) {
        console.log(`âœ… Status: ${status} (esperado: ${expectedStatus})`);
        return true;
      } else {
        console.log(`âŒ Status: ${status} (esperado: ${expectedStatus})`);
        console.log(`   Error:`, responseData || error.message);
        return false;
      }
    }
  }
  async getActivePeriodo(roleName: string): Promise<string> {
    try {
      const response = await axios.get('/grupos?page=1&limit=1', {
        headers: { 'Authorization': `Bearer ${this.tokens[roleName]}` }
      });

      if (response.data.success && response.data.data && response.data.data.length > 0) {
        const periodoId = response.data.data[0].periodoId;
        console.log(`ðŸ“… Periodo acadÃ©mico obtenido de grupo existente: ${periodoId}`);
        this.currentPeriodoId = periodoId;
        return periodoId;
      }
      console.log('âš ï¸  No se encontraron grupos existentes, usando periodo por defecto');
      this.currentPeriodoId = '550e8400-e29b-41d4-a716-446655440000'
      return '550e8400-e29b-41d4-a716-446655440000';

    } catch (error: any) {
      console.log('âŒ Error obteniendo periodo acadÃ©mico:', error.response?.data || error.message);
      this.currentPeriodoId = '550e8400-e29b-41d4-a716-446655440000';
      return '550e8400-e29b-41d4-a716-446655440000';
    }
  }
  async testAuthenticationFlows(): Promise<{ passed: number, total: number }> {
    console.log('\nðŸ” ===== FLUJO 1: AUTENTICACIÃ“N Y SESIONES =====');
    let passed = 0, total = 0;

    const countTest = (result: boolean) => { total++; if (result) passed++; };
    console.log('\nðŸ“± 1.1 LOGIN - Simulando login desde Flutter');

    countTest(await this.login('admin@sanjose.edu', 'SanJose123!', 'ADMIN_INSTITUCION'));
    countTest(await this.login('maria.garcia@sanjose.edu', 'Prof123!', 'PROFESOR'));
    countTest(await this.login('santiago.gomez@sanjose.edu', 'Est123!', 'ESTUDIANTE'));
    console.log('\nðŸ“± 1.2 VERIFICACIÃ“N DE SESIÃ“N - App verifica token guardado');

    countTest(await this.testEndpoint('GET', '/auth/verify', 'ADMIN_INSTITUCION', undefined, 200, 'Verificar token Admin InstituciÃ³n'));
    countTest(await this.testEndpoint('GET', '/auth/verify', 'PROFESOR', undefined, 200, 'Verificar token Profesor'));
    countTest(await this.testEndpoint('GET', '/auth/verify', 'ESTUDIANTE', undefined, 200, 'Verificar token Estudiante'));
    console.log('\nðŸ“± 1.3 ACCESO SIN AUTENTICACIÃ“N - Usuario sin login');

    countTest(await this.testEndpointNoAuth('GET', '/auth/verify', 401, 'Verificar token sin autenticaciÃ³n'));
    countTest(await this.testEndpointNoAuth('GET', '/grupos', 401, 'Acceder a datos sin token'));
    console.log('\nðŸ“± 1.4 LOGOUT - Usuario cierra sesiÃ³n');
    console.log('   ðŸ”„ Simulando logout - removiendo tokens...');

    return { passed, total };
  }
  async testProfesorManagementFlows(): Promise<{ passed: number, total: number }> {
    console.log('\nðŸ‘¨â€ðŸ« ===== FLUJO 2: GESTIÃ“N DE PROFESORES =====');
    let passed = 0, total = 0;

    const countTest = (result: boolean) => { total++; if (result) passed++; };

    console.log('\nðŸ“± 2.1 LISTADO DE PROFESORES - Admin ve lista de profesores');
    countTest(await this.testEndpoint('GET', '/institution-admin/profesores', 'ADMIN_INSTITUCION', undefined, 200,
      'Listar todos los profesores', true));
    countTest(await this.testEndpoint('GET', '/institution-admin/profesores?page=1&limit=5', 'ADMIN_INSTITUCION', undefined, 200,
      'Listar profesores con paginaciÃ³n', true));
    countTest(await this.testEndpoint('GET', '/institution-admin/profesores?activo=true', 'ADMIN_INSTITUCION', undefined, 200,
      'Filtrar profesores activos', true));

    countTest(await this.testEndpoint('GET', '/institution-admin/profesores?search=Juan', 'ADMIN_INSTITUCION', undefined, 200,
      'Buscar profesores por nombre', true));

    console.log('\nðŸ“± 2.2 CREAR PROFESOR - Admin crea nuevo profesor');

    const nuevoProfesor = {
      nombres: 'MarÃ­a',
      apellidos: `GonzÃ¡lez ${Date.now()}`,
      email: `maria.gonzalez${Date.now()}@sanjose.edu`,
      password: 'Prof123!'
    };

    const createResult = await this.testEndpoint('POST', '/institution-admin/profesores', 'ADMIN_INSTITUCION',
      nuevoProfesor, 201, 'Crear nuevo profesor', true);

    countTest(createResult);
    let profesorId = '';
    if (createResult) {
      try {
        const response = await axios.post('/institution-admin/profesores', nuevoProfesor, {
          headers: { 'Authorization': `Bearer ${this.tokens.ADMIN_INSTITUCION}` }
        });
        profesorId = response.data.data.id;
        if (!this.createdEntities.profesores) this.createdEntities.profesores = [];
        this.createdEntities.profesores.push(profesorId);
        console.log(`   ðŸ“ Profesor creado con ID: ${profesorId}`);
      } catch (error) {
        console.log('   âŒ Error obteniendo ID del profesor creado');
      }
    }

    if (profesorId) {
      console.log('\nðŸ“± 2.3 DETALLES DEL PROFESOR - Admin ve detalles especÃ­ficos');

      countTest(await this.testEndpoint('GET', `/institution-admin/profesores/${profesorId}`, 'ADMIN_INSTITUCION',
        undefined, 200, `Ver detalles del profesor ${profesorId}`, true));

      console.log('\nðŸ“± 2.4 EDITAR PROFESOR - Admin modifica datos del profesor');

      const datosActualizados = {
        nombres: 'MarÃ­a JosÃ©',
        apellidos: `GonzÃ¡lez RamÃ­rez ${Date.now()}`
      };

      countTest(await this.testEndpoint('PUT', `/institution-admin/profesores/${profesorId}`, 'ADMIN_INSTITUCION',
        datosActualizados, 200, 'Actualizar datos del profesor', true));

      console.log('\nðŸ“± 2.5 CAMBIAR ESTADO PROFESOR - Admin desactiva profesor');

      countTest(await this.testEndpoint('PATCH', `/institution-admin/profesores/${profesorId}/toggle-status`, 'ADMIN_INSTITUCION',
        {}, 200, 'Desactivar profesor', true));
      countTest(await this.testEndpoint('GET', `/institution-admin/profesores?activo=false`, 'ADMIN_INSTITUCION',
        undefined, 200, 'Verificar profesor inactivo en lista', true));

      console.log('\nðŸ“± 2.6 REACTIVAR PROFESOR - Admin vuelve a activar profesor');

      countTest(await this.testEndpoint('PATCH', `/institution-admin/profesores/${profesorId}/toggle-status`, 'ADMIN_INSTITUCION',
        {}, 200, 'Reactivar profesor', true));

      console.log('\nðŸ“± 2.7 ELIMINAR PROFESOR - Admin elimina profesor');

      countTest(await this.testEndpoint('DELETE', `/institution-admin/profesores/${profesorId}`, 'ADMIN_INSTITUCION',
        undefined, 200, 'Eliminar profesor', true));
      countTest(await this.testEndpoint('GET', `/institution-admin/profesores/${profesorId}`, 'ADMIN_INSTITUCION',
        undefined, 404, 'Verificar profesor eliminado (debe fallar)', false));
    }

    console.log('\nðŸ“± 2.8 ACCESO DENEGADO - Otros roles intentan gestionar profesores');

    countTest(await this.testEndpoint('GET', '/institution-admin/profesores', 'PROFESOR', undefined, 403,
      'Profesor intenta ver lista de profesores (debe fallar)'));

    countTest(await this.testEndpoint('GET', '/institution-admin/profesores', 'ESTUDIANTE', undefined, 403,
      'Estudiante intenta ver lista de profesores (debe fallar)'));

    return { passed, total };
  }
  async testGrupoManagementFlows(): Promise<{ passed: number, total: number }> {
    console.log('\nðŸ« ===== FLUJO 3: GESTIÃ“N DE GRUPOS =====');
    let passed = 0, total = 0;

    const countTest = (result: boolean) => { total++; if (result) passed++; };
    await this.getActivePeriodo('ADMIN_INSTITUCION');

    console.log('\nðŸ“± 3.1 LISTADO DE GRUPOS - Admin ve todos los grupos');

    countTest(await this.testEndpoint('GET', '/grupos', 'ADMIN_INSTITUCION', undefined, 200,
      'Listar todos los grupos', true));

    countTest(await this.testEndpoint('GET', '/grupos?page=1&limit=10', 'ADMIN_INSTITUCION', undefined, 200,
      'Listar grupos con paginaciÃ³n', true));

    console.log('\nðŸ“± 3.2 CREAR GRUPO - Admin crea nuevo grupo');

    const timestamp = Date.now();
    const nuevoGrupo = {
      nombre: `Grupo Test ${timestamp}`,
      grado: '2do',
      seccion: 'B',
      periodoId: this.currentPeriodoId
    };

    const createResult = await this.testEndpoint('POST', '/grupos', 'ADMIN_INSTITUCION',
      nuevoGrupo, 201, 'Crear nuevo grupo', true);

    countTest(createResult);
    let grupoId = '';
    if (createResult) {
      try {
        const response = await axios.post('/grupos', nuevoGrupo, {
          headers: { 'Authorization': `Bearer ${this.tokens.ADMIN_INSTITUCION}` }
        });
        grupoId = response.data.data.id;
        if (!this.createdEntities.grupos) this.createdEntities.grupos = [];
        this.createdEntities.grupos.push(grupoId);
        console.log(`   ðŸ“ Grupo creado con ID: ${grupoId}`);
      } catch (error) {
        console.log('   âŒ Error obteniendo ID del grupo creado');
      }
    }

    if (grupoId) {
      console.log('\nðŸ“± 3.3 DETALLES DEL GRUPO - Admin ve detalles especÃ­ficos');

      countTest(await this.testEndpoint('GET', `/grupos/${grupoId}`, 'ADMIN_INSTITUCION',
        undefined, 200, `Ver detalles del grupo ${grupoId}`, true));

      console.log('\nðŸ“± 3.4 EDITAR GRUPO - Admin modifica datos del grupo');

      const datosActualizados = {
        nombre: 'Grupo B Modificado',
        grado: '3ro',
        seccion: 'C'
      };

      countTest(await this.testEndpoint('PUT', `/grupos/${grupoId}`, 'ADMIN_INSTITUCION',
        datosActualizados, 200, 'Actualizar datos del grupo', true));

      console.log('\nðŸ“± 3.5 ELIMINAR GRUPO - Admin elimina grupo');

      countTest(await this.testEndpoint('DELETE', `/grupos/${grupoId}`, 'ADMIN_INSTITUCION',
        undefined, 200, 'Eliminar grupo', true));
      countTest(await this.testEndpoint('GET', `/grupos/${grupoId}`, 'ADMIN_INSTITUCION',
        undefined, 404, 'Verificar grupo eliminado (debe fallar)', false));
    }

    console.log('\nðŸ“± 3.6 VALIDACIONES - Crear grupo con datos invÃ¡lidos');

    countTest(await this.testEndpoint('POST', '/grupos', 'ADMIN_INSTITUCION', {
      nombre: '',
      grado: '1ro',
      periodoId: this.currentPeriodoId
    }, 400, 'Crear grupo sin nombre (debe fallar)'));

    countTest(await this.testEndpoint('POST', '/grupos', 'ADMIN_INSTITUCION', {
      nombre: 'Grupo Test',
      grado: '',
      periodoId: this.currentPeriodoId
    }, 400, 'Crear grupo sin grado (debe fallar)'));

    countTest(await this.testEndpoint('POST', '/grupos', 'ADMIN_INSTITUCION', {
      nombre: 'Grupo Test',
      grado: '1ro'
    }, 400, 'Crear grupo sin periodoId (debe fallar)'));

    console.log('\nðŸ“± 3.7 ACCESO DENEGADO - Otros roles intentan gestionar grupos');

    countTest(await this.testEndpoint('GET', '/grupos', 'PROFESOR', undefined, 403,
      'Profesor intenta ver grupos (debe fallar)'));

    countTest(await this.testEndpoint('GET', '/grupos', 'ESTUDIANTE', undefined, 403,
      'Estudiante intenta ver grupos (debe fallar)'));

    return { passed, total };
  }
  async testMateriaManagementFlows(): Promise<{ passed: number, total: number }> {
    console.log('\nðŸ“š ===== FLUJO 4: GESTIÃ“N DE MATERIAS =====');
    let passed = 0, total = 0;

    const countTest = (result: boolean) => { total++; if (result) passed++; };

    console.log('\nðŸ“± 4.1 LISTADO DE MATERIAS - Admin ve todas las materias');

    countTest(await this.testEndpoint('GET', '/materias', 'ADMIN_INSTITUCION', undefined, 200,
      'Listar todas las materias', true));

    countTest(await this.testEndpoint('GET', '/materias?page=1&limit=10', 'ADMIN_INSTITUCION', undefined, 200,
      'Listar materias con paginaciÃ³n', true));

    console.log('\nðŸ“± 4.2 CREAR MATERIA - Admin crea nueva materia');

    const timestamp = Date.now();
    const nuevaMateria = {
      nombre: `Materia Test ${timestamp}`,
      codigo: `TEST${timestamp}`
    };

    const createResult = await this.testEndpoint('POST', '/materias', 'ADMIN_INSTITUCION',
      nuevaMateria, 201, 'Crear nueva materia', true);

    countTest(createResult);
    let materiaId = '';
    if (createResult) {
      try {
        const response = await axios.post('/materias', nuevaMateria, {
          headers: { 'Authorization': `Bearer ${this.tokens.ADMIN_INSTITUCION}` }
        });
        materiaId = response.data.data.id;
        if (!this.createdEntities.materias) this.createdEntities.materias = [];
        this.createdEntities.materias.push(materiaId);
        console.log(`   ðŸ“ Materia creada con ID: ${materiaId}`);
      } catch (error) {
        console.log('   âŒ Error obteniendo ID de la materia creada');
      }
    }

    if (materiaId) {
      console.log('\nðŸ“± 4.3 DETALLES DE LA MATERIA - Admin ve detalles especÃ­ficos');

      countTest(await this.testEndpoint('GET', `/materias/${materiaId}`, 'ADMIN_INSTITUCION',
        undefined, 200, `Ver detalles de la materia ${materiaId}`, true));

      console.log('\nðŸ“± 4.4 EDITAR MATERIA - Admin modifica datos de la materia');

      const datosActualizados = {
        nombre: 'FÃ­sica Avanzada',
        codigo: 'FIS201'
      };

      countTest(await this.testEndpoint('PUT', `/materias/${materiaId}`, 'ADMIN_INSTITUCION',
        datosActualizados, 200, 'Actualizar datos de la materia', true));

      console.log('\nðŸ“± 4.5 ELIMINAR MATERIA - Admin elimina materia');

      countTest(await this.testEndpoint('DELETE', `/materias/${materiaId}`, 'ADMIN_INSTITUCION',
        undefined, 200, 'Eliminar materia', true));
      countTest(await this.testEndpoint('GET', `/materias/${materiaId}`, 'ADMIN_INSTITUCION',
        undefined, 404, 'Verificar materia eliminada (debe fallar)', false));
    }

    console.log('\nðŸ“± 4.6 VALIDACIONES - Crear materia con datos invÃ¡lidos');

    countTest(await this.testEndpoint('POST', '/materias', 'ADMIN_INSTITUCION', {
      nombre: '',
      codigo: 'TEST101'
    }, 400, 'Crear materia sin nombre (debe fallar)'));

    console.log('\nðŸ“± 4.7 ACCESO DENEGADO - Otros roles intentan gestionar materias');

    countTest(await this.testEndpoint('GET', '/materias', 'PROFESOR', undefined, 403,
      'Profesor intenta ver materias (debe fallar)'));

    countTest(await this.testEndpoint('GET', '/materias', 'ESTUDIANTE', undefined, 403,
      'Estudiante intenta ver materias (debe fallar)'));

    return { passed, total };
  }
  async testHorarioManagementFlows(): Promise<{ passed: number, total: number }> {
    console.log('\nðŸ“… ===== FLUJO 5: GESTIÃ“N DE HORARIOS =====');
    let passed = 0, total = 0;

    const countTest = (result: boolean) => { total++; if (result) passed++; };

    console.log('\nðŸ“± 5.1 LISTADO DE HORARIOS - Admin ve todos los horarios');

    countTest(await this.testEndpoint('GET', '/horarios', 'ADMIN_INSTITUCION', undefined, 200,
      'Listar todos los horarios', true));

    countTest(await this.testEndpoint('GET', '/horarios?page=1&limit=10', 'ADMIN_INSTITUCION', undefined, 200,
      'Listar horarios con paginaciÃ³n', true));
    let grupoId = '', materiaId = '', profesorId = '';
    try {
      const gruposResponse = await axios.get('/grupos?page=1&limit=1', {
        headers: { 'Authorization': `Bearer ${this.tokens.ADMIN_INSTITUCION}` }
      });
      if (gruposResponse.data.data && gruposResponse.data.data.length > 0) {
        grupoId = gruposResponse.data.data[0].id;
      }
      const materiasResponse = await axios.get('/materias?page=1&limit=1', {
        headers: { 'Authorization': `Bearer ${this.tokens.ADMIN_INSTITUCION}` }
      });
      if (materiasResponse.data.data && materiasResponse.data.data.length > 0) {
        materiaId = materiasResponse.data.data[0].id;
      }
      const profesoresResponse = await axios.get('/institution-admin/profesores?page=1&limit=1', {
        headers: { 'Authorization': `Bearer ${this.tokens.ADMIN_INSTITUCION}` }
      });
      if (profesoresResponse.data.data && profesoresResponse.data.data.length > 0) {
        profesorId = profesoresResponse.data.data[0].id;
      }
    } catch (error) {
      console.log('   âš ï¸  Error obteniendo entidades existentes para horario');
    }

    if (grupoId && materiaId && profesorId) {
      console.log('\nðŸ“± 5.2 CREAR HORARIO - Admin crea nuevo horario');

      const nuevoHorario = {
        periodoId: this.currentPeriodoId,
        grupoId: grupoId,
        materiaId: materiaId,
        profesorId: profesorId,
        diaSemana: 7, // Domingo (dÃ­a sin horarios existentes)
        horaInicio: '18:00', // Hora tardÃ­a sin conflictos
        horaFin: '19:00'
      };

      const createResult = await this.testEndpoint('POST', '/horarios', 'ADMIN_INSTITUCION',
        nuevoHorario, 201, 'Crear nuevo horario', true);

      countTest(createResult);
      let horarioId = '';
      if (createResult) {
        try {
          const response = await axios.post('/horarios', nuevoHorario, {
            headers: { 'Authorization': `Bearer ${this.tokens.ADMIN_INSTITUCION}` }
          });
          horarioId = response.data.data.id;
          if (!this.createdEntities.horarios) this.createdEntities.horarios = [];
          this.createdEntities.horarios.push(horarioId);
          console.log(`   ðŸ“ Horario creado con ID: ${horarioId}`);
        } catch (error) {
          console.log('   âŒ Error obteniendo ID del horario creado');
        }
      }

      if (horarioId) {
        console.log('\nðŸ“± 5.3 DETALLES DEL HORARIO - Admin ve detalles especÃ­ficos');

        countTest(await this.testEndpoint('GET', `/horarios/${horarioId}`, 'ADMIN_INSTITUCION',
          undefined, 200, `Ver detalles del horario ${horarioId}`, true));

        console.log('\nðŸ“± 5.4 EDITAR HORARIO - Admin modifica datos del horario');

        const datosActualizados = {
          diaSemana: 2, // Martes
          horaInicio: '09:00',
          horaFin: '10:00'
        };

        countTest(await this.testEndpoint('PUT', `/horarios/${horarioId}`, 'ADMIN_INSTITUCION',
          datosActualizados, 200, 'Actualizar datos del horario', true));

        console.log('\nðŸ“± 5.5 ELIMINAR HORARIO - Admin elimina horario');

        countTest(await this.testEndpoint('DELETE', `/horarios/${horarioId}`, 'ADMIN_INSTITUCION',
          undefined, 200, 'Eliminar horario', true));
        countTest(await this.testEndpoint('GET', `/horarios/${horarioId}`, 'ADMIN_INSTITUCION',
          undefined, 404, 'Verificar horario eliminado (debe fallar)', false));
      }
    }

    console.log('\nðŸ“± 5.6 VALIDACIONES - Crear horario con datos invÃ¡lidos');

    countTest(await this.testEndpoint('POST', '/horarios', 'ADMIN_INSTITUCION', {
      periodoId: this.currentPeriodoId,
      grupoId: 'invalid-id',
      materiaId: materiaId || 'invalid-id',
      profesorId: profesorId || 'invalid-id',
      diaSemana: 1,
      horaInicio: '08:00',
      horaFin: '09:00'
    }, 400, 'Crear horario con IDs invÃ¡lidos (debe fallar)'));

    countTest(await this.testEndpoint('POST', '/horarios', 'ADMIN_INSTITUCION', {
      periodoId: this.currentPeriodoId,
      grupoId: grupoId || 'invalid-id',
      materiaId: materiaId || 'invalid-id',
      profesorId: profesorId || 'invalid-id',
      diaSemana: 8, // DÃ­a invÃ¡lido
      horaInicio: '08:00',
      horaFin: '09:00'
    }, 400, 'Crear horario con dÃ­a de semana invÃ¡lido (debe fallar)'));

    console.log('\nðŸ“± 5.7 ACCESO DENEGADO - Otros roles intentan gestionar horarios');

    countTest(await this.testEndpoint('GET', '/horarios', 'PROFESOR', undefined, 403,
      'Profesor intenta ver horarios (debe fallar)'));

    countTest(await this.testEndpoint('GET', '/horarios', 'ESTUDIANTE', undefined, 403,
      'Estudiante intenta ver horarios (debe fallar)'));

    return { passed, total };
  }
  async testProfesorDashboardFlows(): Promise<{ passed: number, total: number }> {
    console.log('\nðŸ‘¨â€ðŸ« ===== FLUJO 6: DASHBOARD DEL PROFESOR =====');
    let passed = 0, total = 0;

    const countTest = (result: boolean) => { total++; if (result) passed++; };

    console.log('\nðŸ“± 6.1 CLASES DEL DÃA - Profesor ve sus clases de hoy');
    const today = new Date().getDay() || 7

    countTest(await this.testEndpoint('GET', '/profesores/dashboard/clases-hoy', 'PROFESOR',
      undefined, 200, `Ver clases del dÃ­a actual (dÃ­a ${today})`, true));

    console.log('\nðŸ“± 6.2 CLASES POR DÃA ESPECÃFICO - Profesor consulta diferentes dÃ­as');

    for (let dia = 1; dia <= 7; dia++) {
      const diaNombre = ['Lunes', 'Martes', 'MiÃ©rcoles', 'Jueves', 'Viernes', 'SÃ¡bado', 'Domingo'][dia - 1];
      countTest(await this.testEndpoint('GET', `/profesores/dashboard/clases/${dia}`, 'PROFESOR',
        undefined, 200, `Ver clases del ${diaNombre} (dÃ­a ${dia})`, false));
    }

    console.log('\nðŸ“± 6.3 HORARIO SEMANAL COMPLETO - Profesor ve todo su horario');

    countTest(await this.testEndpoint('GET', '/profesores/dashboard/horario-semanal', 'PROFESOR',
      undefined, 200, 'Ver horario semanal completo', true));

    console.log('\nðŸ“± 6.4 ACCESO DENEGADO - Otros roles intentan ver dashboard del profesor');

    countTest(await this.testEndpoint('GET', '/profesores/dashboard/clases-hoy', 'ADMIN_INSTITUCION',
      undefined, 403, 'Admin instituciÃ³n intenta ver dashboard profesor (debe fallar)'));

    countTest(await this.testEndpoint('GET', '/profesores/dashboard/clases-hoy', 'ESTUDIANTE',
      undefined, 403, 'Estudiante intenta ver dashboard profesor (debe fallar)'));

    console.log('\nðŸ“± 6.5 ACCESO SIN AUTENTICACIÃ“N - Usuario no logueado');

    countTest(await this.testEndpointNoAuth('GET', '/profesores/dashboard/clases-hoy', 401,
      'Acceder a dashboard sin autenticaciÃ³n (debe fallar)'));

    return { passed, total };
  }
  async testEstudianteDashboardFlows(): Promise<{ passed: number, total: number }> {
    console.log('\nðŸŽ“ ===== FLUJO 7: DASHBOARD DEL ESTUDIANTE =====');
    let passed = 0, total = 0;

    const countTest = (result: boolean) => { total++; if (result) passed++; };

    console.log('\nðŸ“± 7.1 INTENTANDO ACCEDER A DASHBOARD ESTUDIANTE');
    try {
      countTest(await this.testEndpoint('GET', '/estudiantes/dashboard/clases-hoy', 'ESTUDIANTE',
        undefined, 200, 'Ver clases del dÃ­a - Estudiante', true));
    } catch (error) {
      console.log('   âš ï¸  Dashboard de estudiante no implementado aÃºn (esperado)');
      countTest(true)
    }

    console.log('\nðŸ“± 7.2 ACCESO DENEGADO - Otros roles intentan ver dashboard estudiante');

    countTest(await this.testEndpoint('GET', '/estudiantes/dashboard/clases-hoy', 'ADMIN_INSTITUCION',
      undefined, 403, 'Admin instituciÃ³n intenta ver dashboard estudiante (debe fallar)'));

    countTest(await this.testEndpoint('GET', '/estudiantes/dashboard/clases-hoy', 'PROFESOR',
      undefined, 403, 'Profesor intenta ver dashboard estudiante (debe fallar)'));

    return { passed, total };
  }
  async testValidationAndErrorFlows(): Promise<{ passed: number, total: number }> {
    console.log('\nâš ï¸ ===== FLUJO 8: VALIDACIONES Y MANEJO DE ERRORES =====');
    let passed = 0, total = 0;

    const countTest = (result: boolean) => { total++; if (result) passed++; };

    console.log('\nðŸ“± 8.1 TOKENS EXPIRADOS O INVÃLIDOS');
    const invalidToken = 'invalid.jwt.token';
    try {
      await axios.get('/auth/verify', {
        headers: { 'Authorization': `Bearer ${invalidToken}` }
      });
      countTest(false)
    } catch (error: any) {
      if (error.response?.status === 401) {
        countTest(true)
        console.log('   âœ… Token invÃ¡lido correctamente rechazado');
      } else {
        countTest(false);
      }
    }

    console.log('\nðŸ“± 8.2 PARÃMETROS INVÃLIDOS EN QUERIES');
    countTest(await this.testEndpoint('GET', '/grupos?page=-1&limit=10', 'ADMIN_INSTITUCION',
      undefined, 400, 'PaginaciÃ³n con pÃ¡gina negativa (debe fallar)'));

    countTest(await this.testEndpoint('GET', '/grupos?page=1&limit=0', 'ADMIN_INSTITUCION',
      undefined, 400, 'PaginaciÃ³n con lÃ­mite cero (debe fallar)'));
    countTest(await this.testEndpoint('GET', '/profesores/dashboard/clases/0', 'PROFESOR',
      undefined, 400, 'DÃ­a de semana 0 invÃ¡lido (debe fallar)'));

    countTest(await this.testEndpoint('GET', '/profesores/dashboard/clases/8', 'PROFESOR',
      undefined, 400, 'DÃ­a de semana 8 invÃ¡lido (debe fallar)'));

    console.log('\nðŸ“± 8.3 IDs INEXISTENTES');

    countTest(await this.testEndpoint('GET', '/grupos/00000000-0000-0000-0000-000000000000', 'ADMIN_INSTITUCION',
      undefined, 404, 'Buscar grupo con ID inexistente (debe fallar)'));

    countTest(await this.testEndpoint('GET', '/materias/00000000-0000-0000-0000-000000000000', 'ADMIN_INSTITUCION',
      undefined, 404, 'Buscar materia con ID inexistente (debe fallar)'));

    countTest(await this.testEndpoint('GET', '/horarios/00000000-0000-0000-0000-000000000000', 'ADMIN_INSTITUCION',
      undefined, 404, 'Buscar horario con ID inexistente (debe fallar)'));

    console.log('\nðŸ“± 8.4 MÃ‰TODOS HTTP INCORRECTOS');
    try {
      await axios.post('/grupos', {}, {
        headers: { 'Authorization': `Bearer ${this.tokens.ADMIN_INSTITUCION}` }
      });
      countTest(false)
    } catch (error: any) {
      if (error.response?.status === 400) {
        countTest(true);
        console.log('   âœ… POST sin datos requeridos correctamente rechazado');
      } else {
        countTest(false);
      }
    }

    return { passed, total };
  }
  async runAllTests(): Promise<void> {
    console.log('ðŸš€ INICIANDO PRUEBAS EXHAUSTIVAS DE FLUJOS COMPLETOS - AsistApp Backend');
    console.log('========================================================================\n');

    let totalPassed = 0;
    let totalTests = 0;
    const accumulateResults = (result: { passed: number, total: number }) => {
      totalPassed += result.passed;
      totalTests += result.total;
    };
    accumulateResults(await this.testAuthenticationFlows());
    accumulateResults(await this.testProfesorManagementFlows());
    accumulateResults(await this.testGrupoManagementFlows());
    accumulateResults(await this.testMateriaManagementFlows());
    accumulateResults(await this.testHorarioManagementFlows());
    accumulateResults(await this.testProfesorDashboardFlows());
    accumulateResults(await this.testEstudianteDashboardFlows());
    accumulateResults(await this.testValidationAndErrorFlows());

    console.log('\nðŸŽ¯ ===== RESULTADOS FINALES =====');
    console.log(`Total de pruebas ejecutadas: ${totalTests}`);
    console.log(`Pruebas exitosas: ${totalPassed}`);
    console.log(`Pruebas fallidas: ${totalTests - totalPassed}`);
    console.log(`Tasa de Ã©xito: ${((totalPassed / totalTests) * 100).toFixed(1)}%\n`);

    console.log('ðŸ“‹ RESUMEN DE FLUJOS PROBADOS:');
    console.log('â€¢ ðŸ” AutenticaciÃ³n completa y gestiÃ³n de sesiones');
    console.log('â€¢ ðŸ‘¨â€ðŸ« GestiÃ³n completa de Profesores (CRUD + toggle status)');
    console.log('â€¢ ðŸ« GestiÃ³n completa de Grupos (CRUD)');
    console.log('â€¢ ðŸ“š GestiÃ³n completa de Materias (CRUD)');
    console.log('â€¢ ðŸ“… GestiÃ³n completa de Horarios (CRUD)');
    console.log('â€¢ ðŸ‘¨â€ðŸ« Dashboard del Profesor (clases del dÃ­a, semanal)');
    console.log('â€¢ ðŸŽ“ Dashboard del Estudiante (bÃ¡sico)');
    console.log('â€¢ âš ï¸ Validaciones exhaustivas y manejo de errores');
    console.log('â€¢ ðŸš« Control de acceso basado en roles');
    console.log('â€¢ ðŸ“± SimulaciÃ³n completa de flujos de Flutter\n');

    if (totalPassed === totalTests) {
      console.log('ðŸŽ‰ Â¡TODAS LAS PRUEBAS PASARON EXITOSAMENTE!');
      console.log('âœ… La API estÃ¡ lista para producciÃ³n con todos los flujos funcionales.');
    } else {
      console.log(`âš ï¸ ${totalTests - totalPassed} pruebas fallaron. Revisa los logs anteriores para detalles.`);
      console.log('ðŸ”§ Algunos flujos pueden necesitar ajustes o pueden no estar implementados aÃºn.');
    }

    console.log('\nðŸ“Š ENTIDADES CREADAS DURANTE LAS PRUEBAS:');
    Object.keys(this.createdEntities).forEach(entityType => {
      console.log(`â€¢ ${entityType}: ${this.createdEntities[entityType].length} elementos`);
    });

    console.log('\nðŸ’¡ RECOMENDACIONES:');
    console.log('â€¢ Implementar endpoints faltantes si algunas pruebas fallaron');
    console.log('â€¢ Agregar mÃ¡s validaciones de negocio segÃºn requerimientos');
    console.log('â€¢ Considerar implementar rate limiting para producciÃ³n');
    console.log('â€¢ Agregar logging detallado para debugging');
    console.log('â€¢ Implementar tests de carga para endpoints crÃ­ticos');
  }
}
async function main() {
  try {
    console.log('ðŸ” Verificando conexiÃ³n con el servidor...');
    await axios.get(`${BASE_URL}/`, { timeout: 5000 });
    console.log('âœ… Servidor conectado\n');

    const tester = new CompleteFlowTester();
    await tester.runAllTests();
  } catch (error: any) {
    console.error('âŒ Error de conexiÃ³n con el servidor:');
    console.error(`   ${error.message}`);
    console.log('\nðŸ’¡ AsegÃºrate de que:');
    console.log('   1. El servidor estÃ© corriendo en localhost:3001');
    console.log('   2. La base de datos estÃ© disponible');
    console.log('   3. Las variables de entorno estÃ©n configuradas');
    console.log('   4. Los contenedores Docker estÃ©n ejecutÃ¡ndose');
    process.exit(1);
  }
}
if (require.main === module) {
  main();
}

export default CompleteFlowTester;
/* Fin backend\test-api-complete.ts */

/* Inicio backend\test-auth-simple.ts */
#!/usr/bin/env ts-node

import axios from 'axios';

const BASE_URL = 'http://localhost:3001';
const tokens = {
  profesor: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImE5ZjM5ZjM4LWMwZjEtNGQ4ZS1hZjM5LWE5ZjM5ZjM4YzBmMSIsInJvbCI6InByb2Zlc29yIiwiZW1haWwiOiJhbmEubG9wZXpAc2FuanVzZS5lZHUiLCJ0b2tlblZlcnNpb24iOjEsImp0aSI6ImE5ZjM5ZjM4LWMwZjEtNGQ4ZS1hZjM5LWE5ZjM5ZjM4YzBmMSJ9.invalid',
  estudiante: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6Imp1YW4ucGVyZXpAc2FuanVzZS5lZHUiLCJyb2wiOiJlc3R1ZGlhbnRlIiwiZW1haWwiOiJqdWFuLnBlcmV6QHNhbmp1c2UuZWR1IiwidG9rZW5WZXJzaW9uIjoxLCJqdGkiOiJqdWFuLnBlcmV6QHNhbmp1c2UuZWR1In0.invalid'
};

async function testRoute(url: string, token: string, description: string) {
  try {
    console.log(`\nðŸ§ª Probando: ${description}`);
    console.log(`ðŸ“¡ URL: ${url}`);
    console.log(`ðŸ”‘ Token: ${token.substring(0, 20)}...`);

    const response = await axios.get(url, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      timeout: 5000
    });

    console.log(`âœ… Status: ${response.status}`);
    console.log(`ðŸ“„ Respuesta:`, response.data);

  } catch (error: any) {
    console.log(`âŒ Error: ${error.response?.status || 'Network error'}`);
    if (error.response?.data) {
      console.log(`ðŸ“„ Error response:`, error.response.data);
    } else {
      console.log(`ðŸ’¥ Error: ${error.message}`);
    }
  }
}

async function main() {
  console.log('ðŸš€ Iniciando tests de autenticaciÃ³n para rutas del estudiante\n');
  await testRoute(
    `${BASE_URL}/estudiantes/dashboard/clases-hoy`,
    tokens.profesor,
    'Estudiante con token de PROFESOR (debe fallar con 403)'
  );
  await testRoute(
    `${BASE_URL}/estudiantes/dashboard/clases-hoy`,
    tokens.estudiante,
    'Estudiante con token de ESTUDIANTE (debe funcionar)'
  );
  try {
    console.log(`\nðŸ§ª Probando: Estudiante sin token (debe fallar con 401)`);
    const response = await axios.get(`${BASE_URL}/estudiantes/dashboard/clases-hoy`);
    console.log(`âŒ Status: ${response.status} (esperado 401)`);
  } catch (error: any) {
    console.log(`âœ… Status: ${error.response?.status} (esperado 401)`);
  }

  console.log('\nðŸŽ¯ Tests completados');
}

main().catch(console.error);
/* Fin backend\test-auth-simple.ts */

/* Inicio backend\test-server.ts */
import Fastify from 'fastify';
const fastify = Fastify({ logger: true });

fastify.get('/', async (request, reply) => {
  return { message: 'Hola Mundo desde AsistApp Backend refactorizado!' };
});

fastify.get('/usuarios', async (request, reply) => {
  return { message: 'Endpoint de usuarios funcionando' };
});

fastify.post('/login', async (request, reply) => {
  return { message: 'Endpoint de login funcionando' };
});
const start = async () => {
  try {
    await fastify.listen({ port: 3000, host: '0.0.0.0' });
    console.log('âœ… Servidor de prueba corriendo en http://localhost:3000');
  } catch (err) {
    fastify.log.error(err);
    process.exit(1);
  }
};

start();
/* Fin backend\test-server.ts */

/* Inicio backend\tests\auth.integration.test.js */
"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fastify_1 = __importDefault(require("fastify"));
const database_1 = require("../src/config/database");
const errorHandler_1 = __importDefault(require("../src/middleware/errorHandler"));
const routes_1 = __importDefault(require("../src/routes"));
const auth_service_1 = __importDefault(require("../src/services/auth.service"));
describe('Auth Integration Tests', () => {
    let fastify;
    beforeAll(async () => {

        fastify = (0, fastify_1.default)({ logger: false });

        (0, errorHandler_1.default)(fastify);
        fastify.register(routes_1.default);

        await database_1.databaseService.connect();
        await auth_service_1.default.ensureAdminUser();
        await fastify.ready();
    });
    afterAll(async () => {
        await fastify.close();
        await database_1.databaseService.disconnect();
    });
    beforeEach(async () => {

        const client = database_1.databaseService.getClient();
        await client.refreshToken.deleteMany();
        await client.usuarioInstitucion.deleteMany();
        await client.usuario.deleteMany({
            where: {
                email: { not: 'admin@asistapp.com' }
            }
        });
        await client.institucion.deleteMany({
            where: {
                codigo: { not: 'DEFAULT' }
            }
        });
    });
    it('should complete full auth flow: login -> get institutions -> refresh -> logout', async () => {

        const institucion = await database_1.databaseService.getClient().institucion.create({
            data: {
                nombre: 'InstituciÃ³n Integration',
                codigo: 'INT001',
                activa: true,
            },
        });

        const hashedPassword = await auth_service_1.default.hashPassword('integrationpass');
        const user = await database_1.databaseService.getClient().usuario.create({
            data: {
                email: 'integration@example.com',
                passwordHash: hashedPassword,
                nombres: 'Integration',
                apellidos: 'Test',
                rol: 'estudiante',
                activo: true,
            },
        });

        await database_1.databaseService.getClient().usuarioInstitucion.create({
            data: {
                usuarioId: user.id,
                institucionId: institucion.id,
                rolEnInstitucion: 'estudiante',
                activo: true,
            },
        });

        const loginResponse = await fastify.inject({
            method: 'POST',
            url: '/auth/login',
            payload: {
                email: 'integration@example.com',
                password: 'integrationpass',
            },
        });
        expect(loginResponse.statusCode).toBe(200);
        const loginBody = JSON.parse(loginResponse.body);
        expect(loginBody.success).toBe(true);
        expect(loginBody.data).toHaveProperty('accessToken');
        expect(loginBody.data).toHaveProperty('refreshToken');
        expect(loginBody.data.usuario).toHaveProperty('instituciones');
        expect(loginBody.data.usuario.instituciones).toHaveLength(1);
        const accessToken = loginBody.data.accessToken;
        const refreshToken = loginBody.data.refreshToken;

        const institutionsResponse = await fastify.inject({
            method: 'GET',
            url: '/auth/instituciones',
            headers: {
                authorization: `Bearer ${accessToken}`,
            },
        });
        expect(institutionsResponse.statusCode).toBe(200);
        const institutionsBody = JSON.parse(institutionsResponse.body);
        expect(institutionsBody.success).toBe(true);
        expect(institutionsBody.data).toHaveLength(1);
        expect(institutionsBody.data[0].id).toBe(institucion.id);

        const verifyResponse = await fastify.inject({
            method: 'GET',
            url: '/auth/verify',
            headers: {
                authorization: `Bearer ${accessToken}`,
            },
        });
        expect(verifyResponse.statusCode).toBe(200);
        const verifyBody = JSON.parse(verifyResponse.body);
        expect(verifyBody.success).toBe(true);
        expect(verifyBody.data.valid).toBe(true);

        const refreshResponse = await fastify.inject({
            method: 'POST',
            url: '/auth/refresh',
            payload: {
                refreshToken: refreshToken,
            },
        });
        expect(refreshResponse.statusCode).toBe(200);
        const refreshBody = JSON.parse(refreshResponse.body);
        expect(refreshBody.success).toBe(true);
        expect(refreshBody.data).toHaveProperty('accessToken');
        expect(refreshBody.data).toHaveProperty('refreshToken');

        expect(refreshBody.data.refreshToken).not.toBe(refreshToken);
        const newAccessToken = refreshBody.data.accessToken;
        const newRefreshToken = refreshBody.data.refreshToken;

        const logoutResponse = await fastify.inject({
            method: 'POST',
            url: '/auth/logout',
            headers: {
                authorization: `Bearer ${newAccessToken}`,
            },
            payload: {
                refreshToken: newRefreshToken,
            },
        });
        expect(logoutResponse.statusCode).toBe(200);
        const logoutBody = JSON.parse(logoutResponse.body);
        expect(logoutBody.success).toBe(true);

        const refreshAfterLogoutResponse = await fastify.inject({
            method: 'POST',
            url: '/auth/refresh',
            payload: {
                refreshToken: newRefreshToken, // Token revocado
            },
        });
        expect(refreshAfterLogoutResponse.statusCode).toBe(401);
    });
});

/* Fin backend\tests\auth.integration.test.js */

/* Inicio backend\tests\auth.integration.test.ts */


import { afterAll, beforeAll, beforeEach, describe, expect, it } from '@jest/globals';
import Fastify from 'fastify';
import { databaseService } from '../src/config/database';
import setupErrorHandler from '../src/middleware/errorHandler';
import routes from '../src/routes';
import AuthService from '../src/services/auth.service';

describe('Auth Integration Tests', () => {
  let fastify: any;

  beforeAll(async () => {

    fastify = Fastify({ logger: false });

    setupErrorHandler(fastify);
    fastify.register(routes);

    await databaseService.connect();
    await AuthService.ensureAdminUser();

    await fastify.ready();
  });

  afterAll(async () => {
    await fastify.close();
    await databaseService.disconnect();
  });

  beforeEach(async () => {

    const client = databaseService.getClient();
    await client.refreshToken.deleteMany();
    await client.usuarioInstitucion.deleteMany();
    await client.usuario.deleteMany({
      where: {
        email: { not: 'admin@asistapp.com' }
      }
    });
    await client.institucion.deleteMany();
  });

  it('should complete full auth flow: login -> get institutions -> refresh -> logout', async () => {

    const institucion = await databaseService.getClient().institucion.create({
      data: {
        nombre: 'InstituciÃ³n Integration',
        activa: true,
      },
    });

    const hashedPassword = await AuthService.hashPassword('integrationpass');
    const user = await databaseService.getClient().usuario.create({
      data: {
        email: 'integration@example.com',
        passwordHash: hashedPassword,
        nombres: 'Integration',
        apellidos: 'Test',
        rol: 'estudiante',
        activo: true,
      },
    });

    await databaseService.getClient().usuarioInstitucion.create({
      data: {
        usuarioId: user.id,
        institucionId: institucion.id,
        rolEnInstitucion: 'estudiante',
        activo: true,
      },
    });

    const loginResponse = await fastify.inject({
      method: 'POST',
      url: '/auth/login',
      payload: {
        email: 'integration@example.com',
        password: 'integrationpass',
      },
    });

    expect(loginResponse.statusCode).toBe(200);
    const loginBody = JSON.parse(loginResponse.body);
    expect(loginBody.success).toBe(true);
    expect(loginBody.data).toHaveProperty('accessToken');
    expect(loginBody.data).toHaveProperty('refreshToken');
    expect(loginBody.data.usuario).toHaveProperty('instituciones');
    expect(loginBody.data.usuario.instituciones).toHaveLength(1);

    const accessToken = loginBody.data.accessToken;
    const refreshToken = loginBody.data.refreshToken;

    const institutionsResponse = await fastify.inject({
      method: 'GET',
      url: '/auth/instituciones',
      headers: {
        authorization: `Bearer ${accessToken}`,
      },
    });

    expect(institutionsResponse.statusCode).toBe(200);
    const institutionsBody = JSON.parse(institutionsResponse.body);
    expect(institutionsBody.success).toBe(true);
    expect(institutionsBody.data).toHaveLength(1);
    expect(institutionsBody.data[0].id).toBe(institucion.id);

    const verifyResponse = await fastify.inject({
      method: 'GET',
      url: '/auth/verify',
      headers: {
        authorization: `Bearer ${accessToken}`,
      },
    });

    expect(verifyResponse.statusCode).toBe(200);
    const verifyBody = JSON.parse(verifyResponse.body);
    expect(verifyBody.success).toBe(true);
    expect(verifyBody.data.valid).toBe(true);

    const refreshResponse = await fastify.inject({
      method: 'POST',
      url: '/auth/refresh',
      payload: {
        refreshToken: refreshToken,
      },
    });

    expect(refreshResponse.statusCode).toBe(200);
    const refreshBody = JSON.parse(refreshResponse.body);
    expect(refreshBody.success).toBe(true);
    expect(refreshBody.data).toHaveProperty('accessToken');
    expect(refreshBody.data).toHaveProperty('refreshToken');

    expect(refreshBody.data.refreshToken).not.toBe(refreshToken);

    const newAccessToken = refreshBody.data.accessToken;
    const newRefreshToken = refreshBody.data.refreshToken;

    const logoutResponse = await fastify.inject({
      method: 'POST',
      url: '/auth/logout',
      headers: {
        authorization: `Bearer ${newAccessToken}`,
      },
      payload: {
        refreshToken: newRefreshToken,
      },
    });

    expect(logoutResponse.statusCode).toBe(200);
    const logoutBody = JSON.parse(logoutResponse.body);
    expect(logoutBody.success).toBe(true);

    const refreshAfterLogoutResponse = await fastify.inject({
      method: 'POST',
      url: '/auth/refresh',
      payload: {
        refreshToken: newRefreshToken, // Token revocado
      },
    });

    expect(refreshAfterLogoutResponse.statusCode).toBe(401);
  });

  it('should handle login with invalid credentials', async () => {
    const response = await fastify.inject({
      method: 'POST',
      url: '/auth/login',
      payload: {
        email: 'nonexistent@example.com',
        password: 'wrongpassword',
      },
    });

    expect(response.statusCode).toBe(401);
    const body = JSON.parse(response.body);
    expect(body.success).toBe(false);
    expect(body.code).toBe('AUTHENTICATION_ERROR');
  });

  it('should handle missing authorization header', async () => {
    const response = await fastify.inject({
      method: 'GET',
      url: '/auth/instituciones',
    });

    expect(response.statusCode).toBe(401);
    const body = JSON.parse(response.body);
    expect(body.success).toBe(false);
    expect(body.code).toBe('AUTHENTICATION_ERROR');
  });

  it('should handle invalid JWT token', async () => {
    const response = await fastify.inject({
      method: 'GET',
      url: '/auth/instituciones',
      headers: {
        authorization: 'Bearer invalid.jwt.token',
      },
    });

    expect(response.statusCode).toBe(401);
    const body = JSON.parse(response.body);
    expect(body.success).toBe(false);
    expect(body.code).toBe('AUTHENTICATION_ERROR');
  });

  it('should handle expired refresh token', async () => {

    const institucion = await databaseService.getClient().institucion.create({
      data: {
        nombre: 'InstituciÃ³n Integration',
        activa: true,
      },
    });

    const hashedPassword = await AuthService.hashPassword('integrationpass');
    const user = await databaseService.getClient().usuario.create({
      data: {
        email: 'integration@example.com',
        passwordHash: hashedPassword,
        nombres: 'Integration',
        apellidos: 'Test',
        rol: 'estudiante',
        activo: true,
      },
    });

    await databaseService.getClient().usuarioInstitucion.create({
      data: {
        usuarioId: user.id,
        institucionId: institucion.id,
        rolEnInstitucion: 'estudiante',
        activo: true,
      },
    });

    const expiredToken = await databaseService.getClient().refreshToken.create({
      data: {
        usuarioId: user.id,
        token: 'expired_token_hash',
        expiresAt: new Date(Date.now() - 1000), // Expirado
        revoked: false,
      },
    });

    const response = await fastify.inject({
      method: 'POST',
      url: '/auth/refresh',
      payload: {
        refreshToken: 'expired_token_hash',
      },
    });

    expect(response.statusCode).toBe(401);
    const body = JSON.parse(response.body);
    expect(body.success).toBe(false);
    expect(body.code).toBe('AUTHENTICATION_ERROR');
  });

  it('should handle revoked refresh token', async () => {

    const institucion = await databaseService.getClient().institucion.create({
      data: {
        nombre: 'InstituciÃ³n Integration',
        activa: true,
      },
    });

    const hashedPassword = await AuthService.hashPassword('integrationpass');
    const user = await databaseService.getClient().usuario.create({
      data: {
        email: 'integration@example.com',
        passwordHash: hashedPassword,
        nombres: 'Integration',
        apellidos: 'Test',
        rol: 'estudiante',
        activo: true,
      },
    });

    await databaseService.getClient().usuarioInstitucion.create({
      data: {
        usuarioId: user.id,
        institucionId: institucion.id,
        rolEnInstitucion: 'estudiante',
        activo: true,
      },
    });

    const revokedToken = await databaseService.getClient().refreshToken.create({
      data: {
        usuarioId: user.id,
        token: 'revoked_token_hash',
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // VÃ¡lido
        revoked: true,
      },
    });

    const response = await fastify.inject({
      method: 'POST',
      url: '/auth/refresh',
      payload: {
        refreshToken: 'revoked_token_hash',
      },
    });

    expect(response.statusCode).toBe(401);
    const body = JSON.parse(response.body);
    expect(body.success).toBe(false);
    expect(body.code).toBe('AUTHENTICATION_ERROR');
  });

  it('should handle login with inactive user', async () => {

    const institucion = await databaseService.getClient().institucion.create({
      data: {
        nombre: 'InstituciÃ³n Integration',
        activa: true,
      },
    });

    const hashedPassword = await AuthService.hashPassword('inactivepass');
    const user = await databaseService.getClient().usuario.create({
      data: {
        email: 'inactive@example.com',
        passwordHash: hashedPassword,
        nombres: 'Inactive',
        apellidos: 'User',
        rol: 'estudiante',
        activo: false, // Usuario inactivo
      },
    });

    await databaseService.getClient().usuarioInstitucion.create({
      data: {
        usuarioId: user.id,
        institucionId: institucion.id,
        rolEnInstitucion: 'estudiante',
        activo: true,
      },
    });

    const response = await fastify.inject({
      method: 'POST',
      url: '/auth/login',
      payload: {
        email: 'inactive@example.com',
        password: 'inactivepass',
      },
    });

    expect(response.statusCode).toBe(401);
    const body = JSON.parse(response.body);
    expect(body.success).toBe(false);
    expect(body.code).toBe('AUTHENTICATION_ERROR');
  });

  it('should handle missing required fields in login', async () => {

    const response1 = await fastify.inject({
      method: 'POST',
      url: '/auth/login',
      payload: {
        password: 'somepassword',
      },
    });

    expect(response1.statusCode).toBe(400);
    const body1 = JSON.parse(response1.body);
    expect(body1.success).toBe(false);
    expect(body1.code).toBe('VALIDATION_ERROR');

    const response2 = await fastify.inject({
      method: 'POST',
      url: '/auth/login',
      payload: {
        email: 'test@example.com',
      },
    });

    expect(response2.statusCode).toBe(400);
    const body2 = JSON.parse(response2.body);
    expect(body2.success).toBe(false);
    expect(body2.code).toBe('VALIDATION_ERROR');
  });

  it('should handle malformed refresh token request', async () => {

    const response = await fastify.inject({
      method: 'POST',
      url: '/auth/refresh',
      payload: {},
    });

    expect(response.statusCode).toBe(400);
    const body = JSON.parse(response.body);
    expect(body.success).toBe(false);
    expect(body.code).toBe('VALIDATION_ERROR');
  });
});
/* Fin backend\tests\auth.integration.test.ts */

/* Inicio backend\tests\auth.service.test.js */
"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const client_1 = require("@prisma/client");
const auth_service_1 = __importDefault(require("../src/services/auth.service"));
const prisma = new client_1.PrismaClient();
describe('AuthService', () => {
    beforeAll(async () => {

        await prisma.$connect();
    });
    afterAll(async () => {
        await prisma.$disconnect();
    });
    beforeEach(async () => {

        await prisma.refreshToken.deleteMany();
        await prisma.usuarioInstitucion.deleteMany();
        await prisma.usuario.deleteMany({
            where: {
                email: { not: 'admin@asistapp.com' }
            }
        });
        await prisma.institucion.deleteMany({
            where: {
                codigo: { not: 'DEFAULT' }
            }
        });
    });
    describe('login', () => {
        it('should login valid user and return tokens with user institutions', async () => {

            const institucion = await prisma.institucion.create({
                data: {
                    nombre: 'InstituciÃ³n Test',
                    codigo: 'TEST001',
                    direccion: 'DirecciÃ³n Test',
                    telefono: '123456789',
                    email: 'test@institucion.com',
                    activa: true,
                },
            });

            const hashedPassword = await auth_service_1.default.hashPassword('testpass');
            const user = await prisma.usuario.create({
                data: {
                    email: 'test@example.com',
                    passwordHash: hashedPassword,
                    nombres: 'Test',
                    apellidos: 'User',
                    rol: 'estudiante',
                    activo: true,
                },
            });

            await prisma.usuarioInstitucion.create({
                data: {
                    usuarioId: user.id,
                    institucionId: institucion.id,
                    rolEnInstitucion: 'estudiante',
                    activo: true,
                },
            });
            const result = await auth_service_1.default.login({ email: 'test@example.com', password: 'testpass' });
            expect(result).toHaveProperty('accessToken');
            expect(result).toHaveProperty('refreshToken');
            expect(result.usuario.id).toBe(user.id);
            expect(result.usuario.instituciones).toBeDefined();
            expect(result.usuario.instituciones).toHaveLength(1);
            expect(result.usuario.instituciones[0].id).toBe(institucion.id);
            expect(result.expiresIn).toBe(24 * 60 * 60);

            const tokens = await prisma.refreshToken.findMany({ where: { usuarioId: user.id } });
            expect(tokens.length).toBe(1);
        });
        it('should throw error for invalid credentials', async () => {
            await expect(auth_service_1.default.login({ email: 'invalid@example.com', password: 'wrong' })).rejects.toThrow('Credenciales invÃ¡lidas');
        });
        it('should throw error for inactive user', async () => {

            const institucion = await prisma.institucion.create({
                data: {
                    nombre: 'InstituciÃ³n Test',
                    codigo: 'TEST002',
                    activa: true,
                },
            });
            const hashedPassword = await auth_service_1.default.hashPassword('testpass');
            const user = await prisma.usuario.create({
                data: {
                    email: 'inactive@example.com',
                    passwordHash: hashedPassword,
                    nombres: 'Inactive',
                    apellidos: 'User',
                    rol: 'estudiante',
                    activo: false,
                },
            });

            await prisma.usuarioInstitucion.create({
                data: {
                    usuarioId: user.id,
                    institucionId: institucion.id,
                    rolEnInstitucion: 'estudiante',
                    activo: true,
                },
            });
            await expect(auth_service_1.default.login({ email: 'inactive@example.com', password: 'testpass' })).rejects.toThrow('Usuario inactivo');
        });
    });
    describe('refreshToken', () => {
        it('should refresh token and rotate it', async () => {

            const hashedPassword = await auth_service_1.default.hashPassword('testpass');
            const user = await prisma.usuario.create({
                data: {
                    email: 'refresh@example.com',
                    passwordHash: hashedPassword,
                    nombres: 'Refresh',
                    apellidos: 'User',
                    rol: 'estudiante',
                    activo: true,
                },
            });
            const loginResult = await auth_service_1.default.login({ email: 'refresh@example.com', password: 'testpass' });
            const oldRefreshToken = loginResult.refreshToken;

            const refreshResult = await auth_service_1.default.refreshToken(oldRefreshToken);
            expect(refreshResult).toHaveProperty('accessToken');
            expect(refreshResult).toHaveProperty('refreshToken');
            expect(refreshResult.refreshToken).not.toBe(oldRefreshToken);

            const oldTokenRecord = await prisma.refreshToken.findFirst({
                where: { usuarioId: user.id, revoked: true },
            });
            expect(oldTokenRecord).toBeTruthy();

            const newTokens = await prisma.refreshToken.findMany({
                where: { usuarioId: user.id, revoked: false },
            });
            expect(newTokens.length).toBe(1);
        });
        it('should throw error for invalid refresh token', async () => {
            await expect(auth_service_1.default.refreshToken('invalid-token')).rejects.toThrow('Refresh token invÃ¡lido');
        });
        it('should throw error for revoked token', async () => {
            const hashedPassword = await auth_service_1.default.hashPassword('testpass');
            const user = await prisma.usuario.create({
                data: {
                    email: 'revoked@example.com',
                    passwordHash: hashedPassword,
                    nombres: 'Revoked',
                    apellidos: 'User',
                    rol: 'estudiante',
                    activo: true,
                },
            });
            const loginResult = await auth_service_1.default.login({ email: 'revoked@example.com', password: 'testpass' });
            const refreshToken = loginResult.refreshToken;

            await auth_service_1.default.revokeRefreshTokens(user.id, refreshToken);

            await expect(auth_service_1.default.refreshToken(refreshToken)).rejects.toThrow('Refresh token invÃ¡lido o revocado');
        });
    });
    describe('revokeRefreshTokens', () => {
        it('should revoke specific token', async () => {
            const hashedPassword = await auth_service_1.default.hashPassword('testpass');
            const user = await prisma.usuario.create({
                data: {
                    email: 'revoke@example.com',
                    passwordHash: hashedPassword,
                    nombres: 'Revoke',
                    apellidos: 'User',
                    rol: 'estudiante',
                    activo: true,
                },
            });
            const loginResult = await auth_service_1.default.login({ email: 'revoke@example.com', password: 'testpass' });
            const refreshToken = loginResult.refreshToken;
            await auth_service_1.default.revokeRefreshTokens(user.id, refreshToken);
            const tokenRecord = await prisma.refreshToken.findFirst({
                where: { usuarioId: user.id },
            });
            expect(tokenRecord?.revoked).toBe(true);
        });
        it('should revoke all tokens for user', async () => {
            const hashedPassword = await auth_service_1.default.hashPassword('testpass');
            const user = await prisma.usuario.create({
                data: {
                    email: 'revokeall@example.com',
                    passwordHash: hashedPassword,
                    nombres: 'Revoke All',
                    apellidos: 'User',
                    rol: 'estudiante',
                    activo: true,
                },
            });

            await auth_service_1.default.login({ email: 'revokeall@example.com', password: 'testpass' });
            await auth_service_1.default.login({ email: 'revokeall@example.com', password: 'testpass' });
            await auth_service_1.default.revokeRefreshTokens(user.id);
            const tokens = await prisma.refreshToken.findMany({
                where: { usuarioId: user.id },
            });
            expect(tokens.every(t => t.revoked)).toBe(true);
        });
    });
});

/* Fin backend\tests\auth.service.test.js */

/* Inicio backend\tests\auth.service.test.ts */


import { afterAll, beforeAll, beforeEach, describe, expect, it } from '@jest/globals';
import AuthService from '../src/services/auth.service';
import { testPrisma } from './test-database';

describe('AuthService', () => {
  beforeAll(async () => {
    await testPrisma.$connect();
  });

  afterAll(async () => {
    await testPrisma.$disconnect();
  });

  beforeEach(async () => {
    await testPrisma.refreshToken.deleteMany();
    await testPrisma.usuarioInstitucion.deleteMany();
    await testPrisma.usuario.deleteMany({
      where: {
        email: { not: 'admin@asistapp.com' }
      }
    });
    await testPrisma.institucion.deleteMany({
      where: {
        codigo: { not: 'DEFAULT' }
      }
    });
  });

  describe('login', () => {
    it('should login valid user and return tokens with user institutions', async () => {
      const institucion = await testPrisma.institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          codigo: 'TEST001',
          direccion: 'DirecciÃ³n Test',
          telefono: '123456789',
          email: 'test@institucion.com',
          activa: true,
        },
      });
      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'test@example.com',
          passwordHash: hashedPassword,
          nombres: 'Test',
          apellidos: 'User',
          rol: 'estudiante',
          activo: true,
        },
      });
      await testPrisma.usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          rolEnInstitucion: 'estudiante',
          activo: true,
        },
      });

      const result = await AuthService.login({ email: 'test@example.com', password: 'testpass' });

      expect(result).toHaveProperty('accessToken');
      expect(result).toHaveProperty('refreshToken');
      expect(result.usuario.id).toBe(user.id);
      expect(result.usuario.instituciones).toBeDefined();
      expect(result.usuario.instituciones).toHaveLength(1);
      expect(result.usuario.instituciones[0].id).toBe(institucion.id);
      expect(result.expiresIn).toBe(24 * 60 * 60);
      const tokens = await testPrisma.refreshToken.findMany({ where: { usuarioId: user.id } });
      expect(tokens.length).toBe(1);
    });

    it('should login valid user without institutions', async () => {
      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'noinst@example.com',
          passwordHash: hashedPassword,
          nombres: 'No Institution',
          apellidos: 'User',
          rol: 'super_admin',
          activo: true,
        },
      });

      const result = await AuthService.login({ email: 'noinst@example.com', password: 'testpass' });

      expect(result).toHaveProperty('accessToken');
      expect(result).toHaveProperty('refreshToken');
      expect(result.usuario.id).toBe(user.id);
      expect(result.usuario.instituciones).toBeDefined();
      expect(result.usuario.instituciones).toHaveLength(0);
      expect(result.expiresIn).toBe(24 * 60 * 60);
    });

    it('should throw error for invalid credentials', async () => {
      await expect(AuthService.login({ email: 'invalid@example.com', password: 'wrong' })).rejects.toThrow('Credenciales invÃ¡lidas');
    });

    it('should throw error for wrong password', async () => {
      const institucion = await testPrisma.institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          codigo: 'TEST002',
          activa: true,
        },
      });

      const hashedPassword = await AuthService.hashPassword('correctpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'wrongpass@example.com',
          passwordHash: hashedPassword,
          nombres: 'Wrong',
          apellidos: 'Password',
          rol: 'estudiante',
          activo: true,
        },
      });
      await testPrisma.usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          rolEnInstitucion: 'estudiante',
          activo: true,
        },
      });

      await expect(AuthService.login({ email: 'wrongpass@example.com', password: 'wrongpass' })).rejects.toThrow('Credenciales invÃ¡lidas');
    });

    it('should throw error for inactive user', async () => {
      const institucion = await testPrisma.institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          codigo: 'TEST003',
          activa: true,
        },
      });

      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'inactive@example.com',
          passwordHash: hashedPassword,
          nombres: 'Inactive',
          apellidos: 'User',
          rol: 'estudiante',
          activo: false,
        },
      });
      await testPrisma.usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          rolEnInstitucion: 'estudiante',
          activo: true,
        },
      });

      await expect(AuthService.login({ email: 'inactive@example.com', password: 'testpass' })).rejects.toThrow('Usuario inactivo');
    });

    it('should throw error for missing email', async () => {
      await expect(AuthService.login({ email: '', password: 'testpass' })).rejects.toThrow('Credenciales invÃ¡lidas');
    });

    it('should throw error for missing password', async () => {
      await expect(AuthService.login({ email: 'test@example.com', password: '' })).rejects.toThrow('Credenciales invÃ¡lidas');
    });
  });

  describe('refreshToken', () => {
    it('should refresh token and rotate it', async () => {
      const institucion = await testPrisma.institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          codigo: 'TEST004',
          activa: true,
        },
      });
      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'refresh@example.com',
          passwordHash: hashedPassword,
          nombres: 'Refresh',
          apellidos: 'User',
          rol: 'estudiante',
          activo: true,
        },
      });
      await testPrisma.usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          rolEnInstitucion: 'estudiante',
          activo: true,
        },
      });

      const loginResult = await AuthService.login({ email: 'refresh@example.com', password: 'testpass' });
      const oldRefreshToken = loginResult.refreshToken;
      const refreshResult = await AuthService.refreshToken(oldRefreshToken);

      expect(refreshResult).toHaveProperty('accessToken');
      expect(refreshResult).toHaveProperty('refreshToken');
      expect(refreshResult.refreshToken).not.toBe(oldRefreshToken);
      const oldTokenRecord = await testPrisma.refreshToken.findFirst({
        where: { usuarioId: user.id, revoked: true },
      });
      expect(oldTokenRecord).toBeTruthy();
      const newTokens = await testPrisma.refreshToken.findMany({
        where: { usuarioId: user.id, revoked: false },
      });
      expect(newTokens.length).toBe(1);
    });

    it('should throw error for invalid refresh token', async () => {
      await expect(AuthService.refreshToken('invalid-token')).rejects.toThrow('Refresh token invÃ¡lido');
    });

    it('should throw error for malformed JWT', async () => {
      await expect(AuthService.refreshToken('not-a-jwt')).rejects.toThrow('Refresh token invÃ¡lido');
    });

    it('should throw error for revoked token', async () => {
      const institucion = await testPrisma.institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          codigo: 'TEST005',
          activa: true,
        },
      });
      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'revoked@example.com',
          passwordHash: hashedPassword,
          nombres: 'Revoked',
          apellidos: 'User',
          rol: 'estudiante',
          activo: true,
        },
      });
      await testPrisma.usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          rolEnInstitucion: 'estudiante',
          activo: true,
        },
      });

      const loginResult = await AuthService.login({ email: 'revoked@example.com', password: 'testpass' });
      const refreshToken = loginResult.refreshToken;
      await AuthService.revokeRefreshTokens(user.id, refreshToken);
      await expect(AuthService.refreshToken(refreshToken)).rejects.toThrow('Refresh token invÃ¡lido o revocado');
    });

    it('should throw error for expired token', async () => {
      const institucion = await testPrisma.institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          codigo: 'TEST006',
          activa: true,
        },
      });
      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'expired@example.com',
          passwordHash: hashedPassword,
          nombres: 'Expired',
          apellidos: 'User',
          rol: 'estudiante',
          activo: true,
        },
      });
      await testPrisma.usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          rolEnInstitucion: 'estudiante',
          activo: true,
        },
      });
      const loginResult = await AuthService.login({ email: 'expired@example.com', password: 'testpass' });
      const refreshToken = loginResult.refreshToken;
      await testPrisma.refreshToken.updateMany({
        where: { usuarioId: user.id },
        data: { expiresAt: new Date(Date.now() - 1000)
      });
      await expect(AuthService.refreshToken(refreshToken)).rejects.toThrow('Refresh token expirado');
    });

    it('should throw error for missing refresh token', async () => {
      await expect(AuthService.refreshToken('')).rejects.toThrow('Refresh token invÃ¡lido');
    });
  });

  describe('revokeRefreshTokens', () => {
    it('should revoke specific token', async () => {
      const institucion = await testPrisma.institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          codigo: 'TEST007',
          activa: true,
        },
      });
      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'revoke@example.com',
          passwordHash: hashedPassword,
          nombres: 'Revoke',
          apellidos: 'User',
          rol: 'estudiante',
          activo: true,
        },
      });
      await testPrisma.usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          rolEnInstitucion: 'estudiante',
          activo: true,
        },
      });

      const loginResult = await AuthService.login({ email: 'revoke@example.com', password: 'testpass' });
      const refreshToken = loginResult.refreshToken;

      await AuthService.revokeRefreshTokens(user.id, refreshToken);

      const tokenRecord = await testPrisma.refreshToken.findFirst({
        where: { usuarioId: user.id },
      });
      expect(tokenRecord?.revoked).toBe(true);
    });

    it('should revoke all tokens for user', async () => {
      const institucion = await testPrisma.institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          codigo: 'TEST008',
          activa: true,
        },
      });
      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'revokeall@example.com',
          passwordHash: hashedPassword,
          nombres: 'Revoke All',
          apellidos: 'User',
          rol: 'estudiante',
          activo: true,
        },
      });
      await testPrisma.usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          rolEnInstitucion: 'estudiante',
          activo: true,
        },
      });
      await AuthService.login({ email: 'revokeall@example.com', password: 'testpass' });
      await AuthService.login({ email: 'revokeall@example.com', password: 'testpass' });

      await AuthService.revokeRefreshTokens(user.id);

      const tokens = await testPrisma.refreshToken.findMany({
        where: { usuarioId: user.id },
      });
      expect(tokens.every(t => t.revoked)).toBe(true);
    });

    it('should handle non-existent token gracefully', async () => {
      const institucion = await testPrisma.institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          codigo: 'TEST009',
          activa: true,
        },
      });
      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'nonexist@example.com',
          passwordHash: hashedPassword,
          nombres: 'Non Exist',
          apellidos: 'User',
          rol: 'estudiante',
          activo: true,
        },
      });
      await testPrisma.usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          rolEnInstitucion: 'estudiante',
          activo: true,
        },
      });
      await expect(AuthService.revokeRefreshTokens(user.id, 'non-existent-token')).resolves.not.toThrow();
    });
  });

  describe('hashPassword', () => {
    it('should hash password correctly', async () => {
      const password = 'testpassword';
      const hashed = await AuthService.hashPassword(password);

      expect(hashed).toBeDefined();
      expect(typeof hashed).toBe('string');
      expect(hashed.length).toBeGreaterThan(0);
      expect(hashed).not.toBe(password)
    });

    it('should generate different hashes for same password', async () => {
      const password = 'testpassword';
      const hash1 = await AuthService.hashPassword(password);
      const hash2 = await AuthService.hashPassword(password);

      expect(hash1).not.toBe(hash2)
    });
  });

  describe('verifyToken', () => {
    it('should verify valid token', async () => {
      const institucion = await testPrisma.institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          codigo: 'TEST010',
          activa: true,
        },
      });
      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'verify@example.com',
          passwordHash: hashedPassword,
          nombres: 'Verify',
          apellidos: 'User',
          rol: 'estudiante',
          activo: true,
        },
      });
      await testPrisma.usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          rolEnInstitucion: 'estudiante',
          activo: true,
        },
      });

      const loginResult = await AuthService.login({ email: 'verify@example.com', password: 'testpass' });
      const accessToken = loginResult.accessToken;

      const decoded = await AuthService.verifyToken(accessToken);

      expect(decoded.id).toBe(user.id);
      expect(decoded.rol).toBe('estudiante');
      expect(decoded.email).toBe('verify@example.com');
    });

    it('should throw error for invalid token', async () => {
      await expect(AuthService.verifyToken('invalid-token')).rejects.toThrow('Access token invÃ¡lido');
    });

    it('should throw error for inactive user', async () => {
      const institucion = await testPrisma.institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          codigo: 'TEST011',
          activa: true,
        },
      });
      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await testPrisma.usuario.create({
        data: {
          email: 'inactive-verify@example.com',
          passwordHash: hashedPassword,
          nombres: 'Inactive Verify',
          apellidos: 'User',
          rol: 'estudiante',
          activo: true, // Usuario activo inicialmente
        },
      });
      await testPrisma.usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          rolEnInstitucion: 'estudiante',
          activo: true,
        },
      });
      const loginResult = await AuthService.login({ email: 'inactive-verify@example.com', password: 'testpass' });
      const accessToken = loginResult.accessToken;
      await testPrisma.usuario.update({
        where: { id: user.id },
        data: { activo: false },
      });
      await expect(AuthService.verifyToken(accessToken)).rejects.toThrow('Usuario no encontrado o inactivo');
    });
  });
});

/* Fin backend\tests\auth.service.test.ts */

/* Inicio backend\tests\institucion.integration.test.ts */


import { beforeAll, beforeEach, describe, expect, it } from '@jest/globals';
import Fastify from 'fastify';
import { databaseService } from '../src/config/database';
import setupErrorHandler from '../src/middleware/errorHandler';
import routes from '../src/routes';
import AuthService from '../src/services/auth.service';

describe('Institucion Integration Tests', () => {
  let fastify: any;
  let adminToken: string;

  beforeAll(async () => {

    fastify = Fastify({ logger: false });

    setupErrorHandler(fastify);
    fastify.register(routes);

    await databaseService.connect();

    await fastify.ready();
  });

  beforeEach(async () => {

    const client = databaseService.getClient();
    await client.asistencia.deleteMany();
    await client.logNotificacion.deleteMany();
    await client.estudianteGrupo.deleteMany();
    await client.horario.deleteMany();
    await client.grupo.deleteMany();
    await client.materia.deleteMany();
    await client.periodoAcademico.deleteMany();
    await client.configuracion.deleteMany();
    await client.refreshToken.deleteMany();
    await client.usuarioInstitucion.deleteMany();
    await client.estudiante.deleteMany();
    await client.usuario.deleteMany({
      where: {
        email: { not: 'admin@asistapp.com' }
      }
    });
    await client.institucion.deleteMany({
      where: {
        nombre: { not: 'InstituciÃ³n por Defecto' }
      }
    });

    await AuthService.ensureAdminUser();
    const existingDefault = await databaseService.getClient().institucion.findFirst({
      where: { nombre: 'InstituciÃ³n por Defecto' }
    });

    if (!existingDefault) {
      await databaseService.getClient().institucion.create({
        data: {
          nombre: 'InstituciÃ³n por Defecto',
          activa: true,
        },
      });
    }

    const loginResponse = await fastify.inject({
      method: 'POST',
      url: '/auth/login',
      payload: {
        email: 'admin@asistapp.com',
        password: 'pollo',
      },
    });

    const loginBody = JSON.parse(loginResponse.body);
    if (loginBody.success) {
      adminToken = loginBody.data.accessToken;
    } else {
      throw new Error('Could not obtain admin token');
    }
  });

  describe('Token verification', () => {
    it('should verify admin token works', async () => {
      console.log('Testing token:', adminToken.substring(0, 50) + '...');

      const response = await fastify.inject({
        method: 'GET',
        url: '/auth/verify',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      console.log('Verify response status:', response.statusCode);
      console.log('Verify response body:', response.body);

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data.valid).toBe(true);
      expect(body.data.usuario.rol).toBe('super_admin');
    });
  });

  describe('GET /instituciones', () => {
    it('should get all instituciones for super_admin', async () => {

      await databaseService.getClient().institucion.create({
        data: {
          nombre: 'InstituciÃ³n 1',
          activa: true,
        },
      });

      await databaseService.getClient().institucion.create({
        data: {
          nombre: 'InstituciÃ³n 2',
          activa: false,
        },
      });

      const response = await fastify.inject({
        method: 'GET',
        url: '/instituciones',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data).toHaveLength(3)
      expect(body.data[0]).toHaveProperty('id');
      expect(body.data[0]).toHaveProperty('nombre');
      expect(body.data[0]).toHaveProperty('activa');
    });

    it('should deny access to non-super-admin', async () => {

      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await databaseService.getClient().usuario.create({
        data: {
          email: 'test@example.com',
          passwordHash: hashedPassword,
          nombres: 'Test',
          apellidos: 'User',
          rol: 'admin_institucion',
          activo: true,
        },
      });

      const loginResponse = await fastify.inject({
        method: 'POST',
        url: '/auth/login',
        payload: {
          email: 'test@example.com',
          password: 'testpass',
        },
      });

      const loginBody = JSON.parse(loginResponse.body);
      const userToken = loginBody.data.accessToken;

      const response = await fastify.inject({
        method: 'GET',
        url: '/instituciones',
        headers: {
          authorization: `Bearer ${userToken}`,
        },
      });

      expect(response.statusCode).toBe(403);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHORIZATION_ERROR');
    });

    it('should deny access without authentication', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: '/instituciones',
      });

      expect(response.statusCode).toBe(401);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHENTICATION_ERROR');
    });
  });

  describe('GET /instituciones/:id', () => {
    it('should get institucion by id for super_admin', async () => {
      const institucion = await databaseService.getClient().institucion.create({
        data: {
          nombre: 'InstituciÃ³n Test',
          direccion: 'DirecciÃ³n Test',
          telefono: '123456789',
          email: 'test@institucion.com',
          activa: true,
        },
      });

      const response = await fastify.inject({
        method: 'GET',
        url: `/instituciones/${institucion.id}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data.id).toBe(institucion.id);
      expect(body.data.nombre).toBe('InstituciÃ³n Test');
      expect(body.data.direccion).toBe('DirecciÃ³n Test');
      expect(body.data.telefono).toBe('123456789');
      expect(body.data.email).toBe('test@institucion.com');
      expect(body.data.activa).toBe(true);
    });

    it('should return 404 for non-existent institucion', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: '/instituciones/non-existent-id',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(404);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('NOT_FOUND_ERROR');
    });
  });

  describe('POST /instituciones', () => {
    it('should create new institucion for super_admin', async () => {
      const institucionData = {
        nombre: 'Nueva InstituciÃ³n',
        direccion: 'Nueva DirecciÃ³n',
        telefono: '987654321',
        email: 'nueva@institucion.com',
      };

      const response = await fastify.inject({
        method: 'POST',
        url: '/instituciones',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: institucionData,
      });

      expect(response.statusCode).toBe(201);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data.nombre).toBe('Nueva InstituciÃ³n');
      expect(body.data.activa).toBe(true)
      expect(body.message).toBe('InstituciÃ³n creada exitosamente');

      const created = await databaseService.getClient().institucion.findUnique({
        where: { id: body.data.id },
      });
      expect(created).toBeTruthy();
      expect(created?.nombre).toBe('Nueva InstituciÃ³n');
    });

    it('should return 400 for missing required fields', async () => {
      const response = await fastify.inject({
        method: 'POST',
        url: '/instituciones',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: {
        },
      });

      expect(response.statusCode).toBe(400);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('VALIDATION_ERROR');
    });
  });

  describe('PUT /instituciones/:id', () => {
    it('should update institucion for super_admin', async () => {
      const institucion = await databaseService.getClient().institucion.create({
        data: {
          nombre: 'InstituciÃ³n Original',
          activa: true,
        },
      });

      const updateData = {
        nombre: 'InstituciÃ³n Actualizada',
        direccion: 'DirecciÃ³n Actualizada',
        telefono: '111111111',
        email: 'updated@institucion.com',
        activa: false,
      };

      const response = await fastify.inject({
        method: 'PUT',
        url: `/instituciones/${institucion.id}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: updateData,
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data.nombre).toBe('InstituciÃ³n Actualizada');
      expect(body.data.activa).toBe(false);
      expect(body.message).toBe('InstituciÃ³n actualizada exitosamente');

      const updated = await databaseService.getClient().institucion.findUnique({
        where: { id: institucion.id },
      });
      expect(updated?.nombre).toBe('InstituciÃ³n Actualizada');
    });

    it('should return 404 for non-existent institucion', async () => {
      const response = await fastify.inject({
        method: 'PUT',
        url: '/instituciones/non-existent-id',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: {
          nombre: 'ActualizaciÃ³n',
        },
      });

      expect(response.statusCode).toBe(404);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('NOT_FOUND_ERROR');
    });
  });

  describe('DELETE /instituciones/:id', () => {
    it('should delete institucion for super_admin', async () => {
      const institucion = await databaseService.getClient().institucion.create({
        data: {
          nombre: 'InstituciÃ³n a Eliminar',
          activa: true,
        },
      });

      const response = await fastify.inject({
        method: 'DELETE',
        url: `/instituciones/${institucion.id}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.message).toBe('InstituciÃ³n eliminada exitosamente');

      const deleted = await databaseService.getClient().institucion.findUnique({
        where: { id: institucion.id },
      });
      expect(deleted).toBeNull();
    });

    it('should return 404 for non-existent institucion', async () => {
      const response = await fastify.inject({
        method: 'DELETE',
        url: '/instituciones/non-existent-id',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(404);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('NOT_FOUND_ERROR');
    });

    it('should return 409 when trying to delete institucion with active users', async () => {
      const institucion = await databaseService.getClient().institucion.create({
        data: {
          nombre: 'InstituciÃ³n con Usuarios',
          activa: true,
        },
      });

      const hashedPassword = await AuthService.hashPassword('testpass');
      const user = await databaseService.getClient().usuario.create({
        data: {
          email: 'user@institucion.com',
          passwordHash: hashedPassword,
          nombres: 'Test',
          apellidos: 'User',
          rol: 'estudiante',
          activo: true,
        },
      });

      await databaseService.getClient().usuarioInstitucion.create({
        data: {
          usuarioId: user.id,
          institucionId: institucion.id,
          activo: true,
        },
      });

      const response = await fastify.inject({
        method: 'DELETE',
        url: `/instituciones/${institucion.id}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(409);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('CONFLICT_ERROR');
    });
  });
});
/* Fin backend\tests\institucion.integration.test.ts */

/* Inicio backend\tests\setup.js */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("jest");
const database_1 = require("../src/config/database");

beforeAll(async () => {

    process.env.NODE_ENV = 'test';
    process.env.DATABASE_URL = process.env.DATABASE_URL_TEST || 'postgresql://arroz:pollo@localhost:5432/asistapp_test?schema=public';
    await database_1.databaseService.connect();
});
afterAll(async () => {
    await database_1.databaseService.disconnect();
});

/* Fin backend\tests\setup.js */

/* Inicio backend\tests\setup.ts */
import { afterAll, beforeAll } from '@jest/globals';
import { testDatabaseService } from './test-database';

beforeAll(async () => {

  process.env.NODE_ENV = 'test';
  process.env.DATABASE_URL = 'postgresql://postgres:postgres@localhost:5433/asistapp_test?schema=public';

  await testDatabaseService.connect();
});

afterAll(async () => {
  await testDatabaseService.disconnect();
});


/* Fin backend\tests\setup.ts */

/* Inicio backend\tests\simple-validation.test.js */
#!/usr/bin/env node

const assert = require('assert');
const validateUserData = (data) => {
  if (!data.rol || typeof data.rol !== 'string') {
    throw new Error('Rol invÃ¡lido');
  }

  const validRoles = ['super_admin', 'admin_institucion', 'profesor', 'estudiante'];
  if (!validRoles.includes(data.rol)) {
    throw new Error('Rol invÃ¡lido');
  }
  if (!data.email || !data.password || !data.nombres || !data.apellidos) {
    throw new Error('Campos requeridos faltantes');
  }
  if (data.rol === 'estudiante' && !data.identificacion) {
    throw new Error('La identificaciÃ³n es requerida para estudiantes');
  }
};

const validateEmail = (email) => {
  if (!email || typeof email !== 'string' || !email.includes('@')) {
    throw new Error('Email invÃ¡lido');
  }
};

const validateUserId = (id) => {
  if (!id || typeof id !== 'string') {
    throw new Error('ID de usuario invÃ¡lido');
  }
};

const generateQRCode = () => {
  return 'ABC123DEF456'
};

const hashPassword = async (password) => {
  return `hashed_${password}`;
};
const runTests = async () => {
  const results = {
    passed: 0,
    failed: 0,
    errors: []
  };

  const test = (name, fn) => {
    try {
      fn();
      results.passed++;
      console.log(`âœ“ ${name}`);
    } catch (error) {
      results.failed++;
      results.errors.push({ name, error: error.message });
      console.log(`âœ— ${name}: ${error.message}`);
    }
  };

  console.log('Ejecutando pruebas de validaciÃ³n de usuario...\n');
  test('validateUserData - profesor vÃ¡lido', () => {
    const validData = {
      email: 'profesor@test.com',
      password: 'password123',
      nombres: 'Juan',
      apellidos: 'PÃ©rez',
      rol: 'profesor',
      telefono: '+1234567890',
    };
    validateUserData(validData);
  });

  test('validateUserData - estudiante vÃ¡lido', () => {
    const validData = {
      email: 'estudiante@test.com',
      password: 'password123',
      nombres: 'MarÃ­a',
      apellidos: 'GarcÃ­a',
      rol: 'estudiante',
      identificacion: '123456789',
      nombreResponsable: 'Padre de MarÃ­a',
    };
    validateUserData(validData);
  });

  test('validateUserData - campos requeridos faltantes', () => {
    const invalidData = {
      email: 'test@test.com',
      rol: 'profesor',
    };
    try {
      validateUserData(invalidData);
      throw new Error('DeberÃ­a haber fallado');
    } catch (error) {
      if (error.message !== 'Campos requeridos faltantes') {
        throw new Error(`Error inesperado: ${error.message}`);
      }
    }
  });

  test('validateUserData - rol invÃ¡lido', () => {
    const invalidData = {
      email: 'test@test.com',
      password: 'password123',
      nombres: 'Juan',
      apellidos: 'PÃ©rez',
      rol: 'invalid_role',
    };
    try {
      validateUserData(invalidData);
      throw new Error('DeberÃ­a haber fallado');
    } catch (error) {
      if (error.message !== 'Rol invÃ¡lido') {
        throw new Error(`Error inesperado: ${error.message}`);
      }
    }
  });

  test('validateUserData - estudiante sin identificaciÃ³n', () => {
    const invalidData = {
      email: 'estudiante@test.com',
      password: 'password123',
      nombres: 'MarÃ­a',
      apellidos: 'GarcÃ­a',
      rol: 'estudiante',
    };
    try {
      validateUserData(invalidData);
      throw new Error('DeberÃ­a haber fallado');
    } catch (error) {
      if (error.message !== 'La identificaciÃ³n es requerida para estudiantes') {
        throw new Error(`Error inesperado: ${error.message}`);
      }
    }
  });
  test('validateEmail - email vÃ¡lido', () => {
    validateEmail('test@example.com');
  });

  test('validateEmail - email invÃ¡lido', () => {
    try {
      validateEmail('invalid-email');
      throw new Error('DeberÃ­a haber fallado');
    } catch (error) {
      if (error.message !== 'Email invÃ¡lido') {
        throw new Error(`Error inesperado: ${error.message}`);
      }
    }
  });

  test('validateEmail - email null', () => {
    try {
      validateEmail(null);
      throw new Error('DeberÃ­a haber fallado');
    } catch (error) {
      if (error.message !== 'Email invÃ¡lido') {
        throw new Error(`Error inesperado: ${error.message}`);
      }
    }
  });
  test('validateUserId - ID vÃ¡lido', () => {
    validateUserId('user-123');
  });

  test('validateUserId - ID invÃ¡lido', () => {
    try {
      validateUserId('');
      throw new Error('DeberÃ­a haber fallado');
    } catch (error) {
      if (error.message !== 'ID de usuario invÃ¡lido') {
        throw new Error(`Error inesperado: ${error.message}`);
      }
    }
  });
  test('generateQRCode - genera cÃ³digo QR', () => {
    const qrCode = generateQRCode();
    assert.strictEqual(typeof qrCode, 'string');
    assert(qrCode.length > 0);
    assert.strictEqual(qrCode, 'ABC123DEF456');
  });
  test('hashPassword - hashea contraseÃ±a', async () => {
    const password = 'mypassword123';
    const hashed = await hashPassword(password);
    assert.strictEqual(hashed, `hashed_${password}`);
    assert(hashed.startsWith('hashed_'));
  });
  test('roles vÃ¡lidos - acepta todos los roles', () => {
    const validRoles = ['super_admin', 'admin_institucion', 'profesor', 'estudiante'];

    validRoles.forEach(role => {
      const data = {
        email: 'test@test.com',
        password: 'password123',
        nombres: 'Test',
        apellidos: 'User',
        rol: role,
      };

      if (role === 'estudiante') {
        data.identificacion = '123456789';
      }

      validateUserData(data);
    });
  });

  test('roles invÃ¡lidos - rechaza roles invÃ¡lidos', () => {
    const invalidRoles = ['admin', 'teacher', 'student', 'superuser'];

    invalidRoles.forEach(role => {
      const data = {
        email: 'test@test.com',
        password: 'password123',
        nombres: 'Test',
        apellidos: 'User',
        rol: role,
      };

      try {
        validateUserData(data);
        throw new Error('DeberÃ­a haber fallado');
      } catch (error) {
        if (error.message !== 'Rol invÃ¡lido') {
          throw new Error(`Error inesperado: ${error.message}`);
        }
      }
    });
    const dataWithEmptyRole = {
      email: 'test@test.com',
      password: 'password123',
      nombres: 'Test',
      apellidos: 'User',
      rol: '',
    };

    try {
      validateUserData(dataWithEmptyRole);
      throw new Error('DeberÃ­a haber fallado');
    } catch (error) {
      if (error.message !== 'Rol invÃ¡lido') {
        throw new Error(`Error inesperado: ${error.message}`);
      }
    }
  });
  test('email case sensitivity - maneja mayÃºsculas/minÃºsculas', () => {
    const emails = ['Test@Example.COM', 'TEST@EXAMPLE.COM', 'test@example.com'];

    emails.forEach(email => {
      validateEmail(email);
    });
  });
  test('data sanitization - maneja espacios en blanco', () => {
    const dataWithWhitespace = {
      email: '  test@example.com  ',
      password: 'password123',
      nombres: '  Juan  ',
      apellidos: '  PÃ©rez  ',
      rol: 'profesor',
    };
    validateUserData(dataWithWhitespace);
  });

  console.log(`\nResultados: ${results.passed} pasaron, ${results.failed} fallaron`);

  if (results.failed > 0) {
    console.log('\nErrores:');
    results.errors.forEach(error => {
      console.log(`- ${error.name}: ${error.error}`);
    });
    process.exit(1);
  } else {
    console.log('\nÂ¡Todas las pruebas pasaron! âœ“');
  }
};
runTests().catch(error => {
  console.error('Error ejecutando pruebas:', error);
  process.exit(1);
});
/* Fin backend\tests\simple-validation.test.js */

/* Inicio backend\tests\test-database.ts */
import { PrismaClient } from '@prisma/client';

class TestDatabaseService {
  private static instance: TestDatabaseService;
  private prisma: PrismaClient | null = null;

  private constructor() {}

  public static getInstance(): TestDatabaseService {
    if (!TestDatabaseService.instance) {
      TestDatabaseService.instance = new TestDatabaseService();
    }
    return TestDatabaseService.instance;
  }

  public getClient(): PrismaClient {
    if (!this.prisma) {
      this.prisma = new PrismaClient({
        datasourceUrl: 'file:./test.db',
      });
    }
    return this.prisma;
  }

  public async disconnect(): Promise<void> {
    if (this.prisma) {
      await this.prisma.$disconnect();
      this.prisma = null;
    }
  }

  public async connect(): Promise<void> {
    const client = this.getClient();
    await client.$connect();
  }

  public async reset(): Promise<void> {
    const client = this.getClient();
    await client.logNotificacion.deleteMany();
    await client.asistencia.deleteMany();
    await client.estudianteGrupo.deleteMany();
    await client.horario.deleteMany();
    await client.materia.deleteMany();
    await client.grupo.deleteMany();
    await client.periodoAcademico.deleteMany();
    await client.configuracion.deleteMany();
    await client.usuarioInstitucion.deleteMany();
    await client.refreshToken.deleteMany();
    await client.estudiante.deleteMany();
    await client.usuario.deleteMany();
    await client.institucion.deleteMany();
  }
}

export const testDatabaseService = TestDatabaseService.getInstance();
export const testPrisma = testDatabaseService.getClient();
/* Fin backend\tests\test-database.ts */

/* Inicio backend\tests\user.controller.test.ts */


import { afterEach, beforeEach, describe, expect, it, jest } from '@jest/globals';
import UserController from '../../src/controllers/user.controller';
import UserService from '../../src/services/user.service';
import { ConflictError, CreateUserRequest, UpdateUserRequest, ValidationError } from '../../src/types';
jest.mock('../../src/services/user.service');
const mockRequest = (body?: any, params?: any) => ({
  body,
  params: params || {},
});

const mockReply = () => {
  const res: any = {};
  res.code = jest.fn().mockReturnValue(res);
  res.send = jest.fn().mockReturnValue(res);
  return res;
};

describe('UserController Unit Tests', () => {
  const mockUserService = UserService as jest.Mocked<typeof UserService>;

  beforeEach(() => {
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('createUser', () => {
    const validUserData: CreateUserRequest = {
      email: 'test@example.com',
      password: 'password123',
      nombres: 'Juan',
      apellidos: 'PÃ©rez',
      rol: 'profesor',
      telefono: '+1234567890',
      institucionId: 'inst-123',
      rolEnInstitucion: 'profesor',
    };

    const mockResponse = {
      id: 'user-123',
      email: validUserData.email,
      nombres: validUserData.nombres,
      apellidos: validUserData.apellidos,
      rol: validUserData.rol,
      telefono: validUserData.telefono,
      activo: true,
      instituciones: [{
        id: validUserData.institucionId,
        nombre: 'InstituciÃ³n Test',
        rolEnInstitucion: validUserData.rolEnInstitucion,
        activo: true,
      }],
    };

    it('should create user and return success response', async () => {
      mockUserService.createUser.mockResolvedValue(mockResponse);

      const request = mockRequest(validUserData);
      const reply = mockReply();

      const result = await UserController.createUser(request as any, reply as any);

      expect(mockUserService.createUser).toHaveBeenCalledWith(validUserData);
      expect(reply.code).toHaveBeenCalledWith(201);
      expect(reply.send).toHaveBeenCalledWith({
        success: true,
        data: mockResponse,
        message: 'Usuario creado exitosamente',
      });
    });

    it('should handle ValidationError and throw it', async () => {
      const validationError = new ValidationError('Campos requeridos faltantes');
      mockUserService.createUser.mockRejectedValue(validationError);

      const request = mockRequest({ email: 'test@example.com' });
      const reply = mockReply();

      await expect(UserController.createUser(request as any, reply as any)).rejects.toThrow(ValidationError);
      expect(mockUserService.createUser).toHaveBeenCalled();
    });

    it('should handle ConflictError and throw it', async () => {
      const conflictError = new ConflictError('El email ya estÃ¡ registrado');
      mockUserService.createUser.mockRejectedValue(conflictError);

      const request = mockRequest(validUserData);
      const reply = mockReply();

      await expect(UserController.createUser(request as any, reply as any)).rejects.toThrow(ConflictError);
      expect(mockUserService.createUser).toHaveBeenCalled();
    });
  });

  describe('updateUser', () => {
    const userId = 'user-123';
    const updateData: UpdateUserRequest = {
      nombres: 'Juan Carlos',
      telefono: '+9876543210',
    };

    const mockResponse = {
      id: userId,
      email: 'test@example.com',
      nombres: updateData.nombres,
      apellidos: 'PÃ©rez',
      rol: 'profesor',
      telefono: updateData.telefono,
      activo: true,
      usuarioInstituciones: [],
    };

    it('should update user and return success response', async () => {
      mockUserService.updateUser.mockResolvedValue(mockResponse);

      const request = mockRequest(updateData, { id: userId });
      const reply = mockReply();

      const result = await UserController.updateUser(request as any, reply as any);

      expect(mockUserService.updateUser).toHaveBeenCalledWith(userId, updateData);
      expect(reply.code).toHaveBeenCalledWith(200);
      expect(reply.send).toHaveBeenCalledWith({
        success: true,
        data: mockResponse,
        message: 'Usuario actualizado exitosamente',
      });
    });

    it('should handle ValidationError for invalid user id', async () => {
      const validationError = new ValidationError('ID de usuario invÃ¡lido');
      mockUserService.updateUser.mockRejectedValue(validationError);

      const request = mockRequest(updateData, { id: '' });
      const reply = mockReply();

      await expect(UserController.updateUser(request as any, reply as any)).rejects.toThrow(ValidationError);
      expect(mockUserService.updateUser).toHaveBeenCalledWith('', updateData);
    });

    it('should handle ValidationError for non-existent user', async () => {
      const validationError = new ValidationError('Usuario no encontrado');
      mockUserService.updateUser.mockRejectedValue(validationError);

      const request = mockRequest(updateData, { id: 'non-existent' });
      const reply = mockReply();

      await expect(UserController.updateUser(request as any, reply as any)).rejects.toThrow(ValidationError);
      expect(mockUserService.updateUser).toHaveBeenCalledWith('non-existent', updateData);
    });

    it('should handle ConflictError for duplicate email', async () => {
      const conflictError = new ConflictError('El email ya estÃ¡ registrado');
      mockUserService.updateUser.mockRejectedValue(conflictError);

      const emailUpdate = { email: 'existing@example.com' };
      const request = mockRequest(emailUpdate, { id: userId });
      const reply = mockReply();

      await expect(UserController.updateUser(request as any, reply as any)).rejects.toThrow(ConflictError);
      expect(mockUserService.updateUser).toHaveBeenCalledWith(userId, emailUpdate);
    });
  });

  describe('deleteUser', () => {
    const userId = 'user-123';

    it('should delete user and return success response', async () => {
      mockUserService.deleteUser.mockResolvedValue(true);

      const request = mockRequest(undefined, { id: userId });
      const reply = mockReply();

      const result = await UserController.deleteUser(request as any, reply as any);

      expect(mockUserService.deleteUser).toHaveBeenCalledWith(userId);
      expect(reply.code).toHaveBeenCalledWith(200);
      expect(reply.send).toHaveBeenCalledWith({
        success: true,
        data: null,
        message: 'Usuario eliminado exitosamente',
      });
    });

    it('should handle ValidationError for invalid user id', async () => {
      const validationError = new ValidationError('ID de usuario invÃ¡lido');
      mockUserService.deleteUser.mockRejectedValue(validationError);

      const request = mockRequest(undefined, { id: '' });
      const reply = mockReply();

      await expect(UserController.deleteUser(request as any, reply as any)).rejects.toThrow(ValidationError);
      expect(mockUserService.deleteUser).toHaveBeenCalledWith('');
    });

    it('should handle ValidationError for non-existent user', async () => {
      const validationError = new ValidationError('Usuario no encontrado');
      mockUserService.deleteUser.mockRejectedValue(validationError);

      const request = mockRequest(undefined, { id: 'non-existent' });
      const reply = mockReply();

      await expect(UserController.deleteUser(request as any, reply as any)).rejects.toThrow(ValidationError);
      expect(mockUserService.deleteUser).toHaveBeenCalledWith('non-existent');
    });
  });

  describe('getUserById', () => {
    const userId = 'user-123';
    const mockUser = {
      id: userId,
      email: 'test@example.com',
      nombres: 'Juan',
      apellidos: 'PÃ©rez',
      rol: 'profesor',
      telefono: '+1234567890',
      activo: true,
      usuarioInstituciones: [],
    };

    it('should get user by id and return success response', async () => {
      mockUserService.getUserById.mockResolvedValue(mockUser);

      const request = mockRequest(undefined, { id: userId });
      const reply = mockReply();

      const result = await UserController.getUserById(request as any, reply as any);

      expect(mockUserService.getUserById).toHaveBeenCalledWith(userId);
      expect(reply.code).toHaveBeenCalledWith(200);
      expect(reply.send).toHaveBeenCalledWith({
        success: true,
        data: mockUser,
      });
    });

    it('should handle ValidationError for invalid id', async () => {
      const validationError = new ValidationError('ID de usuario invÃ¡lido');
      mockUserService.getUserById.mockRejectedValue(validationError);

      const request = mockRequest(undefined, { id: '' });
      const reply = mockReply();

      await expect(UserController.getUserById(request as any, reply as any)).rejects.toThrow(ValidationError);
      expect(mockUserService.getUserById).toHaveBeenCalledWith('');
    });

    it('should handle NotFoundError for non-existent user', async () => {
      const notFoundError = new (class NotFoundError extends Error {
        constructor(message: string) {
          super(message);
          this.name = 'NotFoundError';
        }
      })('Usuario no encontrado');
      mockUserService.getUserById.mockRejectedValue(notFoundError);

      const request = mockRequest(undefined, { id: 'non-existent' });
      const reply = mockReply();

      await expect(UserController.getUserById(request as any, reply as any)).rejects.toThrow();
      expect(mockUserService.getUserById).toHaveBeenCalledWith('non-existent');
    });
  });

  describe('getAllUsers', () => {
    const mockUsers = [
      {
        id: 'user-1',
        email: 'user1@example.com',
        nombres: 'Juan',
        apellidos: 'PÃ©rez',
        rol: 'profesor',
        activo: true,
        usuarioInstituciones: [],
      },
      {
        id: 'user-2',
        email: 'user2@example.com',
        nombres: 'MarÃ­a',
        apellidos: 'GarcÃ­a',
        rol: 'estudiante',
        activo: true,
        usuarioInstituciones: [],
        estudiante: {
          id: 'student-1',
          identificacion: '123456789',
          codigoQr: 'QR123',
        },
      },
    ];

    it('should get all users and return success response', async () => {
      mockUserService.getAllUsers.mockResolvedValue(mockUsers);

      const request = mockRequest();
      const reply = mockReply();

      const result = await UserController.getAllUsers(request as any, reply as any);

      expect(mockUserService.getAllUsers).toHaveBeenCalled();
      expect(reply.code).toHaveBeenCalledWith(200);
      expect(reply.send).toHaveBeenCalledWith({
        success: true,
        data: mockUsers,
      });
    });

    it('should handle service errors', async () => {
      const serviceError = new Error('Database connection failed');
      mockUserService.getAllUsers.mockRejectedValue(serviceError);

      const request = mockRequest();
      const reply = mockReply();

      await expect(UserController.getAllUsers(request as any, reply as any)).rejects.toThrow('Database connection failed');
      expect(mockUserService.getAllUsers).toHaveBeenCalled();
    });
  });

  describe('getUsersByRole', () => {
    const role = 'profesor';
    const mockUsers = [
      {
        id: 'user-1',
        email: 'prof1@example.com',
        nombres: 'Juan',
        apellidos: 'PÃ©rez',
        rol: 'profesor',
        activo: true,
        usuarioInstituciones: [],
      },
    ];

    it('should get users by role and return success response', async () => {
      mockUserService.getUsersByRole.mockResolvedValue(mockUsers);

      const request = mockRequest(undefined, { role });
      const reply = mockReply();

      const result = await UserController.getUsersByRole(request as any, reply as any);

      expect(mockUserService.getUsersByRole).toHaveBeenCalledWith(role);
      expect(reply.code).toHaveBeenCalledWith(200);
      expect(reply.send).toHaveBeenCalledWith({
        success: true,
        data: mockUsers,
      });
    });

    it('should handle ValidationError for invalid role', async () => {
      const validationError = new ValidationError('Rol invÃ¡lido');
      mockUserService.getUsersByRole.mockRejectedValue(validationError);

      const request = mockRequest(undefined, { role: 'invalid_role' });
      const reply = mockReply();

      await expect(UserController.getUsersByRole(request as any, reply as any)).rejects.toThrow(ValidationError);
      expect(mockUserService.getUsersByRole).toHaveBeenCalledWith('invalid_role');
    });
  });

  describe('getUsersByInstitution', () => {
    const institucionId = 'inst-123';
    const mockUsers = [
      {
        id: 'user-1',
        email: 'user1@example.com',
        nombres: 'Juan',
        apellidos: 'PÃ©rez',
        rol: 'profesor',
        activo: true,
        usuarioInstituciones: [{
          institucion: { id: institucionId, nombre: 'InstituciÃ³n Test' },
          rolEnInstitucion: 'profesor',
          activo: true,
        }],
      },
    ];

    it('should get users by institution and return success response', async () => {
      mockUserService.getUsersByInstitution.mockResolvedValue(mockUsers);

      const request = mockRequest(undefined, { institucionId });
      const reply = mockReply();

      const result = await UserController.getUsersByInstitution(request as any, reply as any);

      expect(mockUserService.getUsersByInstitution).toHaveBeenCalledWith(institucionId);
      expect(reply.code).toHaveBeenCalledWith(200);
      expect(reply.send).toHaveBeenCalledWith({
        success: true,
        data: mockUsers,
      });
    });

    it('should handle ValidationError for invalid institution id', async () => {
      const validationError = new ValidationError('ID de instituciÃ³n invÃ¡lido');
      mockUserService.getUsersByInstitution.mockRejectedValue(validationError);

      const request = mockRequest(undefined, { institucionId: '' });
      const reply = mockReply();

      await expect(UserController.getUsersByInstitution(request as any, reply as any)).rejects.toThrow(ValidationError);
      expect(mockUserService.getUsersByInstitution).toHaveBeenCalledWith('');
    });
  });
});
/* Fin backend\tests\user.controller.test.ts */

/* Inicio backend\tests\user.integration.test.ts */


import { afterAll, beforeAll, beforeEach, describe, expect, it } from '@jest/globals';
import Fastify, { FastifyInstance } from 'fastify';
import { databaseService } from '../src/config/database';
import setupErrorHandler from '../src/middleware/errorHandler';
import routes from '../src/routes';
import AuthService from '../src/services/auth.service';

describe('User Integration Tests', () => {
  let fastify: FastifyInstance;
  let adminToken: string;
  let institucionId: string;
  let studentUserId: string;

  beforeAll(async () => {

    fastify = Fastify({ logger: false });

    setupErrorHandler(fastify);
    fastify.register(routes);

    await databaseService.connect();
    await AuthService.ensureAdminUser();

    await fastify.ready();
  });

  afterAll(async () => {
    await fastify.close();
    await databaseService.disconnect();
  });

  beforeEach(async () => {

    const client = databaseService.getClient();
    await client.refreshToken.deleteMany();
    await client.usuarioInstitucion.deleteMany();
    await client.usuario.deleteMany({
      where: {
        email: { not: 'admin@asistapp.com' }
      }
    });
    await client.institucion.deleteMany();

    const institucion = await client.institucion.create({
      data: {
        nombre: 'InstituciÃ³n Test',
        activa: true,
      },
    });
    institucionId = institucion.id;

    const hashedPassword = await AuthService.hashPassword('studentpass');
    const student = await client.usuario.create({
      data: {
        email: 'student@test.com',
        passwordHash: hashedPassword,
        nombres: 'Estudiante',
        apellidos: 'Test',
        rol: 'estudiante',
        activo: true,
      },
    });
    studentUserId = student.id;

    await client.usuarioInstitucion.create({
      data: {
        usuarioId: student.id,
        institucionId: institucion.id,
        rolEnInstitucion: 'estudiante',
        activo: true,
      },
    });

    const loginResponse = await fastify.inject({
      method: 'POST',
      url: '/auth/login',
      payload: {
        email: 'admin@asistapp.com',
        password: 'pollo',
      },
    });

    const loginBody = JSON.parse(loginResponse.body);
    adminToken = loginBody.data.accessToken;
  });

  describe('GET /usuarios', () => {
    it('should get all users with admin token', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: '/usuarios',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(Array.isArray(body.data)).toBe(true);
      expect(body.data.length).toBeGreaterThan(0);
    });

    it('should fail without authentication token', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: '/usuarios',
      });

      expect(response.statusCode).toBe(401);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHENTICATION_ERROR');
    });

    it('should fail with student token (insufficient permissions)', async () => {

      const loginResponse = await fastify.inject({
        method: 'POST',
        url: '/auth/login',
        payload: {
          email: 'student@test.com',
          password: 'studentpass',
        },
      });

      const loginBody = JSON.parse(loginResponse.body);
      const studentToken = loginBody.data.accessToken;

      const response = await fastify.inject({
        method: 'GET',
        url: '/usuarios',
        headers: {
          authorization: `Bearer ${studentToken}`,
        },
      });

      expect(response.statusCode).toBe(403);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHORIZATION_ERROR');
    });
  });

  describe('GET /usuarios/:id', () => {
    it('should get user by id with valid token', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: `/usuarios/${studentUserId}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data).toHaveProperty('id', studentUserId);
      expect(body.data).toHaveProperty('email', 'student@test.com');
    });

    it('should fail with invalid user id', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: '/usuarios/invalid-id-123',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(404);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('NOT_FOUND_ERROR');
    });

    it('should fail without authentication token', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: `/usuarios/${studentUserId}`,
      });

      expect(response.statusCode).toBe(401);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHENTICATION_ERROR');
    });
  });

  describe('GET /usuarios/rol/:role', () => {
    it('should get users by role with admin token', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: '/usuarios/rol/estudiante',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(Array.isArray(body.data)).toBe(true);
      expect(body.data.length).toBeGreaterThan(0);
      expect(body.data[0]).toHaveProperty('rol', 'estudiante');
    });

    it('should return empty array for role with no users', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: '/usuarios/rol/profesor',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(Array.isArray(body.data)).toBe(true);
      expect(body.data.length).toBe(0);
    });

    it('should fail without authentication token', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: '/usuarios/rol/estudiante',
      });

      expect(response.statusCode).toBe(401);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHENTICATION_ERROR');
    });

    it('should fail with student token (insufficient permissions)', async () => {

      const loginResponse = await fastify.inject({
        method: 'POST',
        url: '/auth/login',
        payload: {
          email: 'student@test.com',
          password: 'studentpass',
        },
      });

      const loginBody = JSON.parse(loginResponse.body);
      const studentToken = loginBody.data.accessToken;

      const response = await fastify.inject({
        method: 'GET',
        url: '/usuarios/rol/estudiante',
        headers: {
          authorization: `Bearer ${studentToken}`,
        },
      });

      expect(response.statusCode).toBe(403);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHORIZATION_ERROR');
    });
  });

  describe('GET /usuarios/institucion/:institucionId', () => {
    it('should get users by institution with valid token', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: `/usuarios/institucion/${institucionId}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(Array.isArray(body.data)).toBe(true);
      expect(body.data.length).toBeGreaterThan(0);
    });

    it('should return empty array for institution with no users', async () => {

      const emptyInstitution = await databaseService.getClient().institucion.create({
        data: {
          nombre: 'InstituciÃ³n VacÃ­a',
          activa: true,
        },
      });

      const response = await fastify.inject({
        method: 'GET',
        url: `/usuarios/institucion/${emptyInstitution.id}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(Array.isArray(body.data)).toBe(true);
      expect(body.data.length).toBe(0);
    });

    it('should fail without authentication token', async () => {
      const response = await fastify.inject({
        method: 'GET',
        url: `/usuarios/institucion/${institucionId}`,
      });

      expect(response.statusCode).toBe(401);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHENTICATION_ERROR');
    });
  });

  describe('POST /usuarios/admin/cleanup-tokens', () => {
    it('should cleanup expired tokens with super_admin token', async () => {
      const response = await fastify.inject({
        method: 'POST',
        url: '/usuarios/admin/cleanup-tokens',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data).toHaveProperty('message');
    });

    it('should fail without authentication token', async () => {
      const response = await fastify.inject({
        method: 'POST',
        url: '/usuarios/admin/cleanup-tokens',
      });

      expect(response.statusCode).toBe(401);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHENTICATION_ERROR');
    });

    it('should fail with student token (insufficient permissions)', async () => {

      const loginResponse = await fastify.inject({
        method: 'POST',
        url: '/auth/login',
        payload: {
          email: 'student@test.com',
          password: 'studentpass',
        },
      });

      const loginBody = JSON.parse(loginResponse.body);
      const studentToken = loginBody.data.accessToken;

      const response = await fastify.inject({
        method: 'POST',
        url: '/usuarios/admin/cleanup-tokens',
        headers: {
          authorization: `Bearer ${studentToken}`,
        },
      });

      expect(response.statusCode).toBe(403);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHORIZATION_ERROR');
    });
  });

  describe('POST /usuarios', () => {
    it('should create a new profesor user with admin token', async () => {
      const newUser = {
        email: 'profesor@test.com',
        password: 'password123',
        nombres: 'Juan',
        apellidos: 'PÃ©rez',
        rol: 'profesor',
        telefono: '+1234567890',
        institucionId: institucionId,
        rolEnInstitucion: 'profesor',
      };

      const response = await fastify.inject({
        method: 'POST',
        url: '/usuarios',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: newUser,
      });

      expect(response.statusCode).toBe(201);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data).toHaveProperty('id');
      expect(body.data.email).toBe(newUser.email);
      expect(body.data.nombres).toBe(newUser.nombres);
      expect(body.data.rol).toBe(newUser.rol);
      expect(body.data.instituciones).toHaveLength(1);
    });

    it('should create a new estudiante user with admin token', async () => {
      const newUser = {
        email: 'estudiante2@test.com',
        password: 'password123',
        nombres: 'MarÃ­a',
        apellidos: 'GarcÃ­a',
        rol: 'estudiante',
        telefono: '+0987654321',
        institucionId: institucionId,
        rolEnInstitucion: 'estudiante',
        identificacion: '123456789',
        nombreResponsable: 'Padre de MarÃ­a',
        telefonoResponsable: '+111111111',
      };

      const response = await fastify.inject({
        method: 'POST',
        url: '/usuarios',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: newUser,
      });

      expect(response.statusCode).toBe(201);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data).toHaveProperty('id');
      expect(body.data.email).toBe(newUser.email);
      expect(body.data.estudiante).toBeDefined();
      expect(body.data.estudiante.identificacion).toBe(newUser.identificacion);
      expect(body.data.estudiante.nombreResponsable).toBe(newUser.nombreResponsable);
    });

    it('should fail to create user with duplicate email', async () => {
      const newUser = {
        email: 'student@test.com', // Email ya existente
        password: 'password123',
        nombres: 'Duplicado',
        apellidos: 'Usuario',
        rol: 'profesor',
      };

      const response = await fastify.inject({
        method: 'POST',
        url: '/usuarios',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: newUser,
      });

      expect(response.statusCode).toBe(409);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('CONFLICT_ERROR');
    });

    it('should fail to create estudiante without identificacion', async () => {
      const newUser = {
        email: 'estudiante3@test.com',
        password: 'password123',
        nombres: 'Pedro',
        apellidos: 'LÃ³pez',
        rol: 'estudiante',
      };

      const response = await fastify.inject({
        method: 'POST',
        url: '/usuarios',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: newUser,
      });

      expect(response.statusCode).toBe(400);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('VALIDATION_ERROR');
    });

    it('should fail without authentication token', async () => {
      const newUser = {
        email: 'test@test.com',
        password: 'password123',
        nombres: 'Test',
        apellidos: 'User',
        rol: 'profesor',
      };

      const response = await fastify.inject({
        method: 'POST',
        url: '/usuarios',
        payload: newUser,
      });

      expect(response.statusCode).toBe(401);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHENTICATION_ERROR');
    });
  });

  describe('PUT /usuarios/:id', () => {
    it('should update user with admin token', async () => {
      const updateData = {
        nombres: 'Estudiante Actualizado',
        telefono: '+555555555',
      };

      const response = await fastify.inject({
        method: 'PUT',
        url: `/usuarios/${studentUserId}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: updateData,
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data.nombres).toBe(updateData.nombres);
      expect(body.data.telefono).toBe(updateData.telefono);
    });

    it('should update estudiante data', async () => {
      const updateData = {
        nombreResponsable: 'Madre Actualizada',
        telefonoResponsable: '+999999999',
      };

      const response = await fastify.inject({
        method: 'PUT',
        url: `/usuarios/${studentUserId}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: updateData,
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data.estudiante.nombreResponsable).toBe(updateData.nombreResponsable);
      expect(body.data.estudiante.telefonoResponsable).toBe(updateData.telefonoResponsable);
    });

    it('should fail to update with duplicate email', async () => {
      const otherUser = await databaseService.getClient().usuario.create({
        data: {
          email: 'other@test.com',
          passwordHash: await AuthService.hashPassword('password'),
          nombres: 'Otro',
          apellidos: 'Usuario',
          rol: 'profesor',
          activo: true,
        },
      });

      const updateData = {
        email: 'student@test.com', // Email ya existente
      };

      const response = await fastify.inject({
        method: 'PUT',
        url: `/usuarios/${otherUser.id}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: updateData,
      });

      expect(response.statusCode).toBe(409);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('CONFLICT_ERROR');
    });

    it('should fail with invalid user id', async () => {
      const updateData = {
        nombres: 'Nombre Actualizado',
      };

      const response = await fastify.inject({
        method: 'PUT',
        url: '/usuarios/invalid-id-123',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
        payload: updateData,
      });

      expect(response.statusCode).toBe(404);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('NOT_FOUND_ERROR');
    });

    it('should fail without authentication token', async () => {
      const updateData = {
        nombres: 'Nombre Actualizado',
      };

      const response = await fastify.inject({
        method: 'PUT',
        url: `/usuarios/${studentUserId}`,
        payload: updateData,
      });

      expect(response.statusCode).toBe(401);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHENTICATION_ERROR');
    });
  });

  describe('DELETE /usuarios/:id', () => {
    it('should delete user with super_admin token', async () => {
      const response = await fastify.inject({
        method: 'DELETE',
        url: `/usuarios/${studentUserId}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.message).toBe('Usuario eliminado exitosamente');
      const checkResponse = await fastify.inject({
        method: 'GET',
        url: `/usuarios/${studentUserId}`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(checkResponse.statusCode).toBe(200);
      const checkBody = JSON.parse(checkResponse.body);
      expect(checkBody.data.activo).toBe(false);
    });

    it('should fail with invalid user id', async () => {
      const response = await fastify.inject({
        method: 'DELETE',
        url: '/usuarios/invalid-id-123',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(404);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('NOT_FOUND_ERROR');
    });

    it('should fail without authentication token', async () => {
      const response = await fastify.inject({
        method: 'DELETE',
        url: `/usuarios/${studentUserId}`,
      });

      expect(response.statusCode).toBe(401);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.code).toBe('AUTHENTICATION_ERROR');
    });
  });
});

/* Fin backend\tests\user.integration.test.ts */

/* Inicio backend\tests\user.logic.test.ts */


import { describe, expect, it } from '@jest/globals';
const validateUserData = (data: any) => {
  if (!data.email || !data.password || !data.nombres || !data.apellidos || !data.rol) {
    throw new Error('Campos requeridos faltantes');
  }

  const validRoles = ['super_admin', 'admin_institucion', 'profesor', 'estudiante'];
  if (!validRoles.includes(data.rol)) {
    throw new Error('Rol invÃ¡lido');
  }

  if (data.rol === 'estudiante' && !data.identificacion) {
    throw new Error('La identificaciÃ³n es requerida para estudiantes');
  }
};

const validateEmail = (email: string) => {
  if (!email || typeof email !== 'string' || !email.includes('@')) {
    throw new Error('Email invÃ¡lido');
  }
};

const validateUserId = (id: string) => {
  if (!id || typeof id !== 'string') {
    throw new Error('ID de usuario invÃ¡lido');
  }
};

const generateQRCode = () => {
  return 'ABC123DEF456'
};

const hashPassword = async (password: string) => {
  return `hashed_${password}`;
};

describe('User Service Validation Logic (Standalone)', () => {
  describe('validateUserData', () => {
    it('should pass validation for valid profesor data', () => {
      const validData = {
        email: 'profesor@test.com',
        password: 'password123',
        nombres: 'Juan',
        apellidos: 'PÃ©rez',
        rol: 'profesor',
        telefono: '+1234567890',
      };

      expect(() => validateUserData(validData)).not.toThrow();
    });

    it('should pass validation for valid estudiante data', () => {
      const validData = {
        email: 'estudiante@test.com',
        password: 'password123',
        nombres: 'MarÃ­a',
        apellidos: 'GarcÃ­a',
        rol: 'estudiante',
        identificacion: '123456789',
        nombreResponsable: 'Padre de MarÃ­a',
      };

      expect(() => validateUserData(validData)).not.toThrow();
    });

    it('should throw error for missing required fields', () => {
      const invalidData = {
        email: 'test@test.com',
      };

      expect(() => validateUserData(invalidData)).toThrow('Campos requeridos faltantes');
    });

    it('should throw error for invalid role', () => {
      const invalidData = {
        email: 'test@test.com',
        password: 'password123',
        nombres: 'Juan',
        apellidos: 'PÃ©rez',
        rol: 'invalid_role',
      };

      expect(() => validateUserData(invalidData)).toThrow('Rol invÃ¡lido');
    });

    it('should throw error for estudiante without identificacion', () => {
      const invalidData = {
        email: 'estudiante@test.com',
        password: 'password123',
        nombres: 'MarÃ­a',
        apellidos: 'GarcÃ­a',
        rol: 'estudiante',
      };

      expect(() => validateUserData(invalidData)).toThrow('La identificaciÃ³n es requerida para estudiantes');
    });
  });

  describe('validateEmail', () => {
    it('should pass validation for valid email', () => {
      const validEmail = 'test@example.com';

      expect(() => validateEmail(validEmail)).not.toThrow();
    });

    it('should throw error for invalid email', () => {
      const invalidEmails = ['', 'invalid-email', 'test@', '@example.com'];

      invalidEmails.forEach(email => {
        expect(() => validateEmail(email)).toThrow('Email invÃ¡lido');
      });
    });

    it('should throw error for null or undefined email', () => {
      expect(() => validateEmail(null as any)).toThrow('Email invÃ¡lido');
      expect(() => validateEmail(undefined as any)).toThrow('Email invÃ¡lido');
    });
  });

  describe('validateUserId', () => {
    it('should pass validation for valid user id', () => {
      const validId = 'user-123';

      expect(() => validateUserId(validId)).not.toThrow();
    });

    it('should throw error for invalid user id', () => {
      const invalidIds = ['', null, undefined, 123];

      invalidIds.forEach(id => {
        expect(() => validateUserId(id as any)).toThrow('ID de usuario invÃ¡lido');
      });
    });
  });

  describe('generateQRCode', () => {
    it('should generate a QR code string', () => {
      const qrCode = generateQRCode();

      expect(typeof qrCode).toBe('string');
      expect(qrCode.length).toBeGreaterThan(0);
      expect(qrCode).toBe('ABC123DEF456');
    });
  });

  describe('hashPassword', () => {
    it('should hash password', async () => {
      const password = 'mypassword123';
      const hashed = await hashPassword(password);

      expect(hashed).toBe(`hashed_${password}`);
      expect(typeof hashed).toBe('string');
      expect(hashed.startsWith('hashed_')).toBe(true);
    });
  });

  describe('User Role Validation', () => {
    const validRoles = ['super_admin', 'admin_institucion', 'profesor', 'estudiante'];

    it('should accept all valid roles', () => {
      validRoles.forEach(role => {
        const data: any = {
          email: 'test@test.com',
          password: 'password123',
          nombres: 'Test',
          apellidos: 'User',
          rol: role,
        };

        if (role === 'estudiante') {
          data.identificacion = '123456789';
        }

        expect(() => validateUserData(data)).not.toThrow();
      });
    });

    it('should reject invalid roles', () => {
      const invalidRoles = ['admin', 'teacher', 'student', 'superuser', ''];

      invalidRoles.forEach(role => {
        const data = {
          email: 'test@test.com',
          password: 'password123',
          nombres: 'Test',
          apellidos: 'User',
          rol: role,
        };

        expect(() => validateUserData(data)).toThrow('Rol invÃ¡lido');
      });
    });
  });

  describe('Email Normalization', () => {
    it('should handle email case sensitivity', () => {
      const emails = ['Test@Example.COM', 'TEST@EXAMPLE.COM', 'test@example.com'];

      emails.forEach(email => {
        expect(() => validateEmail(email)).not.toThrow();
      });
    });
  });

  describe('Password Requirements', () => {
    it('should accept various password formats', () => {
      const passwords = ['password123', 'Password123!', '123456', 'abc'];

      passwords.forEach(async (password) => {
        const hashed = await hashPassword(password);
        expect(hashed).toBe(`hashed_${password}`);
      });
    });
  });

  describe('Data Sanitization', () => {
    it('should handle whitespace in input data', () => {
      const dataWithWhitespace = {
        email: '  test@example.com  ',
        password: 'password123',
        nombres: '  Juan  ',
        apellidos: '  PÃ©rez  ',
        rol: 'profesor',
      };
      expect(() => validateUserData(dataWithWhitespace)).not.toThrow();
    });
  });
});
/* Fin backend\tests\user.logic.test.ts */

/* Inicio backend\tests\user.service.test.ts */


import { afterEach, beforeEach, describe, expect, it, jest } from '@jest/globals';
import { prisma } from '../../src/config/database';
import UserService from '../../src/services/user.service';
import { ConflictError, ValidationError } from '../../src/types';
jest.mock('../../src/config/database', () => ({
  prisma: {
    usuario: {
      create: jest.fn(),
      update: jest.fn(),
      findUnique: jest.fn(),
      findMany: jest.fn(),
      count: jest.fn(),
    },
    estudiante: {
      create: jest.fn(),
      update: jest.fn(),
    },
    usuarioInstitucion: {
      create: jest.fn(),
    },
    $transaction: jest.fn(),
  },
}));
jest.mock('bcryptjs', () => ({
  hash: jest.fn(),
}));
jest.mock('crypto', () => ({
  randomBytes: jest.fn(),
}));

describe('UserService Unit Tests', () => {
  const mockPrisma = prisma as jest.Mocked<typeof prisma>;
  const mockBcrypt = require('bcryptjs');
  const mockCrypto = require('crypto');

  beforeEach(() => {
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.resetAllMocks();
    jest.restoreAllMocks();
  });

  describe('createUser', () => {
    const validUserData = {
      email: 'test@example.com',
      password: 'password123',
      nombres: 'Juan',
      apellidos: 'PÃ©rez',
      rol: 'profesor' as const,
      telefono: '+1234567890',
      institucionId: 'inst-123',
      rolEnInstitucion: 'profesor',
    };

    const validStudentData = {
      email: 'student@example.com',
      password: 'password123',
      nombres: 'MarÃ­a',
      apellidos: 'GarcÃ­a',
      rol: 'estudiante' as const,
      identificacion: '123456789',
      nombreResponsable: 'Padre de MarÃ­a',
      telefonoResponsable: '+0987654321',
      institucionId: 'inst-123',
    };

    it('should create a profesor user successfully', async () => {
      const hashedPassword = 'hashedPassword123';
      const userId = 'user-123';

      mockBcrypt.hash.mockResolvedValue(hashedPassword);
      mockPrisma.$transaction.mockImplementation(async (callback: any) => {
        return callback(mockPrisma);
      });

      mockPrisma.usuario.create.mockResolvedValue({
        id: userId,
        email: validUserData.email,
        passwordHash: hashedPassword,
        nombres: validUserData.nombres,
        apellidos: validUserData.apellidos,
        rol: validUserData.rol,
        telefono: validUserData.telefono,
        activo: true,
        tokenVersion: 1,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      const result = await UserService.createUser(validUserData);

      expect(mockBcrypt.hash).toHaveBeenCalledWith(validUserData.password, 10);
      expect(mockPrisma.usuario.create).toHaveBeenCalledWith({
        data: {
          email: validUserData.email.toLowerCase(),
          passwordHash: hashedPassword,
          nombres: validUserData.nombres,
          apellidos: validUserData.apellidos,
          rol: validUserData.rol,
          telefono: validUserData.telefono,
        },
      });
      expect(mockPrisma.usuarioInstitucion.create).toHaveBeenCalledWith({
        data: {
          usuarioId: userId,
          institucionId: validUserData.institucionId,
          rolEnInstitucion: validUserData.rolEnInstitucion,
        },
      });
      expect(result).toHaveProperty('id', userId);
      expect(result).toHaveProperty('email', validUserData.email);
      expect(result).toHaveProperty('rol', validUserData.rol);
    });

    it('should create a estudiante user successfully', async () => {
      const hashedPassword = 'hashedPassword123';
      const userId = 'user-456';
      const studentId = 'student-456';
      const qrCode = 'ABC123DEF456';

      mockBcrypt.hash.mockResolvedValue(hashedPassword);
      mockCrypto.randomBytes.mockReturnValue({
        toString: jest.fn().mockReturnValue(qrCode),
      });
      mockPrisma.$transaction.mockImplementation(async (callback: any) => {
        return callback(mockPrisma);
      });

      mockPrisma.usuario.create.mockResolvedValue({
        id: userId,
        email: validStudentData.email,
        passwordHash: hashedPassword,
        nombres: validStudentData.nombres,
        apellidos: validStudentData.apellidos,
        rol: validStudentData.rol,
        telefono: null,
        activo: true,
        tokenVersion: 1,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      mockPrisma.estudiante.create.mockResolvedValue({
        id: studentId,
        usuarioId: userId,
        identificacion: validStudentData.identificacion!,
        codigoQr: qrCode,
        nombreResponsable: validStudentData.nombreResponsable,
        telefonoResponsable: validStudentData.telefonoResponsable,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      const result = await UserService.createUser(validStudentData);

      expect(mockCrypto.randomBytes).toHaveBeenCalledWith(16);
      expect(mockPrisma.estudiante.create).toHaveBeenCalledWith({
        data: {
          usuarioId: userId,
          identificacion: validStudentData.identificacion,
          codigoQr: qrCode,
          nombreResponsable: validStudentData.nombreResponsable,
          telefonoResponsable: validStudentData.telefonoResponsable,
        },
      });
      expect(result.estudiante).toBeDefined();
      expect(result.estudiante?.identificacion).toBe(validStudentData.identificacion);
      expect(result.estudiante?.codigoQr).toBe(qrCode);
    });

    it('should throw ValidationError for missing required fields', async () => {
      const invalidData = {
        email: 'test@example.com',
      };

      await expect(UserService.createUser(invalidData as any)).rejects.toThrow(ValidationError);
    });

    it('should throw ValidationError for invalid role', async () => {
      const invalidData = {
        ...validUserData,
        rol: 'invalid_role' as any,
      };

      await expect(UserService.createUser(invalidData)).rejects.toThrow(ValidationError);
    });

    it('should throw ValidationError for estudiante without identificacion', async () => {
      const invalidStudentData = {
        ...validStudentData,
        identificacion: undefined,
      };

      await expect(UserService.createUser(invalidStudentData as any)).rejects.toThrow(ValidationError);
    });

    it('should throw ConflictError for duplicate email', async () => {
      const existingUser = {
        id: 'existing-user',
        email: validUserData.email,
      };

      mockPrisma.usuario.findUnique.mockResolvedValue(existingUser as any);
      jest.spyOn(UserService, 'isEmailAvailable').mockResolvedValue(false);

      await expect(UserService.createUser(validUserData)).rejects.toThrow(ConflictError);
    });
  });

  describe('updateUser', () => {
    const userId = 'user-123';
    const updateData = {
      nombres: 'Juan Carlos',
      telefono: '+9876543210',
    };

    it('should update user successfully', async () => {
      const existingUser = {
        id: userId,
        email: 'test@example.com',
        nombres: 'Juan',
        apellidos: 'PÃ©rez',
        rol: 'profesor',
        activo: true,
      };

      const updatedUser = {
        ...existingUser,
        nombres: updateData.nombres,
        telefono: updateData.telefono,
      };

      mockPrisma.usuario.findUnique
        .mockResolvedValueOnce(existingUser as any
        .mockResolvedValueOnce(updatedUser as any)

      mockPrisma.$transaction.mockImplementation(async (callback: any) => {
        return callback(mockPrisma);
      });

      mockPrisma.usuario.update.mockResolvedValue(updatedUser as any);

      const result = await UserService.updateUser(userId, updateData);

      expect(mockPrisma.usuario.update).toHaveBeenCalledWith({
        where: { id: userId },
        data: updateData,
      });
      expect(result).toHaveProperty('nombres', updateData.nombres);
      expect(result).toHaveProperty('telefono', updateData.telefono);
    });

    it('should update estudiante data', async () => {
      const existingUser = {
        id: userId,
        email: 'student@example.com',
        nombres: 'MarÃ­a',
        apellidos: 'GarcÃ­a',
        rol: 'estudiante',
        activo: true,
      };

      const estudianteUpdateData = {
        nombreResponsable: 'Madre de MarÃ­a',
        telefonoResponsable: '+111111111',
      };

      mockPrisma.usuario.findUnique.mockResolvedValue(existingUser as any);
      mockPrisma.$transaction.mockImplementation(async (callback: any) => {
        return callback(mockPrisma);
      });

      mockPrisma.usuario.update.mockResolvedValue(existingUser as any);
      mockPrisma.estudiante.update.mockResolvedValue({
        id: 'student-123',
        usuarioId: userId,
        ...estudianteUpdateData,
      } as any);

      const result = await UserService.updateUser(userId, estudianteUpdateData);

      expect(mockPrisma.estudiante.update).toHaveBeenCalledWith({
        where: { usuarioId: userId },
        data: estudianteUpdateData,
      });
    });

    it('should throw ValidationError for invalid user id', async () => {
      await expect(UserService.updateUser('', updateData)).rejects.toThrow(ValidationError);
    });

    it('should throw ValidationError for non-existent user', async () => {
      mockPrisma.usuario.findUnique.mockResolvedValue(null);

      await expect(UserService.updateUser(userId, updateData)).rejects.toThrow(ValidationError);
    });

    it('should throw ConflictError for duplicate email', async () => {
      const existingUser = {
        id: userId,
        email: 'test@example.com',
        nombres: 'Juan',
        apellidos: 'PÃ©rez',
        rol: 'profesor',
        activo: true,
      };

      mockPrisma.usuario.findUnique.mockResolvedValue(existingUser as any);
      jest.spyOn(UserService, 'isEmailAvailable').mockResolvedValue(false);

      const emailUpdate = { email: 'existing@example.com' };

      await expect(UserService.updateUser(userId, emailUpdate)).rejects.toThrow(ConflictError);
    });
  });

  describe('deleteUser', () => {
    const userId = 'user-123';

    it('should delete user successfully', async () => {
      const existingUser = {
        id: userId,
        email: 'test@example.com',
        activo: true,
      };

      mockPrisma.usuario.findUnique.mockResolvedValue(existingUser as any);
      mockPrisma.usuario.update.mockResolvedValue({
        ...existingUser,
        activo: false,
      } as any);

      const result = await UserService.deleteUser(userId);

      expect(mockPrisma.usuario.update).toHaveBeenCalledWith({
        where: { id: userId },
        data: { activo: false },
      });
      expect(result).toBe(true);
    });

    it('should throw ValidationError for invalid user id', async () => {
      await expect(UserService.deleteUser('')).rejects.toThrow(ValidationError);
    });

    it('should throw ValidationError for non-existent user', async () => {
      mockPrisma.usuario.findUnique.mockResolvedValue(null);

      await expect(UserService.deleteUser(userId)).rejects.toThrow(ValidationError);
    });
  });

  describe('getUserById', () => {
    it('should return user with estudiante data', async () => {
      const userId = 'user-123';
      const userData = {
        id: userId,
        email: 'student@example.com',
        nombres: 'MarÃ­a',
        apellidos: 'GarcÃ­a',
        rol: 'estudiante',
        activo: true,
        estudiante: {
          id: 'student-123',
          identificacion: '123456789',
          codigoQr: 'QR123',
        },
      };

      mockPrisma.usuario.findUnique.mockResolvedValue(userData as any);

      const result = await UserService.getUserById(userId);

      expect(mockPrisma.usuario.findUnique).toHaveBeenCalledWith({
        where: { id: userId },
        include: {
          usuarioInstituciones: {
            where: { activo: true },
            include: { institucion: true },
          },
          estudiante: true,
        },
      });
      expect(result).toEqual(userData);
    });

    it('should throw ValidationError for invalid id', async () => {
      await expect(UserService.getUserById('')).rejects.toThrow(ValidationError);
    });
  });

  describe('isEmailAvailable', () => {
    it('should return true for available email', async () => {
      mockPrisma.usuario.count.mockResolvedValue(0);

      const result = await UserService.isEmailAvailable('new@example.com');

      expect(mockPrisma.usuario.count).toHaveBeenCalledWith({
        where: { email: 'new@example.com' },
      });
      expect(result).toBe(true);
    });

    it('should return false for taken email', async () => {
      mockPrisma.usuario.count.mockResolvedValue(1);

      const result = await UserService.isEmailAvailable('taken@example.com');

      expect(result).toBe(false);
    });

    it('should exclude user when updating', async () => {
      mockPrisma.usuario.count.mockResolvedValue(0);

      const result = await UserService.isEmailAvailable('test@example.com', 'user-123');

      expect(mockPrisma.usuario.count).toHaveBeenCalledWith({
        where: {
          email: 'test@example.com',
          id: { not: 'user-123' },
        },
      });
      expect(result).toBe(true);
    });

    it('should return false for invalid email', async () => {
      const result = await UserService.isEmailAvailable('invalid-email');

      expect(result).toBe(false);
    });
  });

  describe('userExists', () => {
    it('should return true for existing user', async () => {
      mockPrisma.usuario.count.mockResolvedValue(1);

      const result = await UserService.userExists('user-123');

      expect(mockPrisma.usuario.count).toHaveBeenCalledWith({
        where: { id: 'user-123' },
      });
      expect(result).toBe(true);
    });

    it('should return false for non-existing user', async () => {
      mockPrisma.usuario.count.mockResolvedValue(0);

      const result = await UserService.userExists('non-existent');

      expect(result).toBe(false);
    });

    it('should return false for invalid id', async () => {
      const result = await UserService.userExists('');

      expect(result).toBe(false);
    });
  });
});
/* Fin backend\tests\user.service.test.ts */

/* Inicio backend\tests\user.validation.test.ts */


import { describe, expect, it } from '@jest/globals';
const validateUserData = (data: unknown) => {
  const userData = data as Record<string, unknown>;
  if (!userData.rol || typeof userData.rol !== 'string') {
    throw new Error('Rol invÃ¡lido');
  }

  const validRoles = ['super_admin', 'admin_institucion', 'profesor', 'estudiante'];
  if (!validRoles.includes(userData.rol as string)) {
    throw new Error('Rol invÃ¡lido');
  }
  if (!userData.email || !userData.password || !userData.nombres || !userData.apellidos) {
    throw new Error('Campos requeridos faltantes');
  }
  if (userData.rol === 'estudiante' && !userData.identificacion) {
    throw new Error('La identificaciÃ³n es requerida para estudiantes');
  }
};

const validateEmail = (email: string) => {
  if (!email || typeof email !== 'string' || !email.includes('@') || !email.includes('.')) {
    throw new Error('Email invÃ¡lido');
  }
};

const validateUserId = (id: string) => {
  if (!id || typeof id !== 'string') {
    throw new Error('ID de usuario invÃ¡lido');
  }
};

const generateQRCode = () => {
  return 'ABC123DEF456'
};

const hashPassword = async (password: string) => {
  return `hashed_${password}`;
};

describe('User Service Validation Logic', () => {
  describe('validateUserData', () => {
    it('should pass validation for valid profesor data', () => {
      const validData = {
        email: 'profesor@test.com',
        password: 'password123',
        nombres: 'Juan',
        apellidos: 'PÃ©rez',
        rol: 'profesor',
        telefono: '+1234567890',
      };

      expect(() => validateUserData(validData)).not.toThrow();
    });

    it('should pass validation for valid estudiante data', () => {
      const validData = {
        email: 'estudiante@test.com',
        password: 'password123',
        nombres: 'MarÃ­a',
        apellidos: 'GarcÃ­a',
        rol: 'estudiante',
        identificacion: '123456789',
        nombreResponsable: 'Padre de MarÃ­a',
      };

      expect(() => validateUserData(validData)).not.toThrow();
    });

    it('should throw error for missing required fields', () => {
      const invalidData: Record<string, unknown> = {
        email: 'test@example.com',
        rol: 'profesor',
      };

      expect(() => validateUserData(invalidData)).toThrow('Campos requeridos faltantes');
    });

    it('should throw error for invalid role', () => {
      const invalidData = {
        email: 'test@test.com',
        password: 'password123',
        nombres: 'Juan',
        apellidos: 'PÃ©rez',
        rol: 'invalid_role',
      };

      expect(() => validateUserData(invalidData)).toThrow('Rol invÃ¡lido');
    });

    it('should throw error for estudiante without identificacion', () => {
      const invalidData = {
        email: 'estudiante@test.com',
        password: 'password123',
        nombres: 'MarÃ­a',
        apellidos: 'GarcÃ­a',
        rol: 'estudiante',
      };

      expect(() => validateUserData(invalidData)).toThrow('La identificaciÃ³n es requerida para estudiantes');
    });
  });

  describe('validateEmail', () => {
    it('should pass validation for valid email', () => {
      const validEmail = 'test@example.com';

      expect(() => validateEmail(validEmail)).not.toThrow();
    });

    it('should throw error for invalid email', () => {
      expect(() => validateEmail('invalid-email')).toThrow('Email invÃ¡lido');
      expect(() => validateEmail('test@')).toThrow('Email invÃ¡lido');
      expect(() => validateEmail('test@domain')).toThrow('Email invÃ¡lido');
    });

    it('should throw error for null or undefined email', () => {
      expect(() => validateEmail(null as unknown as string)).toThrow('Email invÃ¡lido');
      expect(() => validateEmail(undefined as unknown as string)).toThrow('Email invÃ¡lido');
    });
  });

  describe('validateUserId', () => {
    it('should pass validation for valid user id', () => {
      const validId = 'user-123';

      expect(() => validateUserId(validId)).not.toThrow();
    });

    it('should throw error for invalid user id', () => {
      const invalidIds: unknown[] = ['', null, undefined, 123];

      invalidIds.forEach(id => {
        expect(() => validateUserId(id as string)).toThrow('ID de usuario invÃ¡lido');
      });
    });
  });

  describe('generateQRCode', () => {
    it('should generate a QR code string', () => {
      const qrCode = generateQRCode();

      expect(typeof qrCode).toBe('string');
      expect(qrCode.length).toBeGreaterThan(0);
      expect(qrCode).toBe('ABC123DEF456');
    });
  });

  describe('hashPassword', () => {
    it('should hash password', async () => {
      const password = 'mypassword123';
      const hashed = await hashPassword(password);

      expect(hashed).toBe(`hashed_${password}`);
      expect(typeof hashed).toBe('string');
      expect(hashed.startsWith('hashed_')).toBe(true);
    });
  });

  describe('User Role Validation', () => {
    const validRoles = ['super_admin', 'admin_institucion', 'profesor', 'estudiante'];

    it('should accept all valid roles', () => {
      validRoles.forEach(role => {
        const data: Record<string, unknown> = {
          email: 'test@test.com',
          password: 'password123',
          nombres: 'Test',
          apellidos: 'User',
          rol: role,
        };

        if (role === 'estudiante') {
          data.identificacion = '123456789';
        }

        expect(() => validateUserData(data)).not.toThrow();
      });
    });

    it('should reject invalid roles', () => {
      const invalidRoles = ['admin', 'teacher', 'student', 'superuser'];

      invalidRoles.forEach(role => {
        const data: Record<string, unknown> = {
          email: 'test@test.com',
          password: 'password123',
          nombres: 'Test',
          apellidos: 'User',
          rol: role,
        };

        expect(() => validateUserData(data)).toThrow('Rol invÃ¡lido');
      });
      const dataWithEmptyRole: Record<string, unknown> = {
        email: 'test@test.com',
        password: 'password123',
        nombres: 'Test',
        apellidos: 'User',
        rol: '',
      };

      expect(() => validateUserData(dataWithEmptyRole)).toThrow('Rol invÃ¡lido');
    });
  });

  describe('Email Normalization', () => {
    it('should handle email case sensitivity', () => {
      const emails = ['Test@Example.COM', 'TEST@EXAMPLE.COM', 'test@example.com'];

      emails.forEach(email => {
        expect(() => validateEmail(email)).not.toThrow();
      });
    });
  });
});
/* Fin backend\tests\user.validation.test.ts */

/* Inicio backend\verify-schema.js */

const { PrismaClient } = require('@prisma/client');

const prisma = new PrismaClient();

async function verifySchema() {
  console.log('ðŸ” Verificando estructura acadÃ©mica en la base de datos...\n');

  try {
    console.log('âœ“ Verificando tabla: periodos_academicos');
    const periodos = await prisma.periodoAcademico.findMany();
    console.log(`  â†’ ${periodos.length} periodos acadÃ©micos encontrados\n`);
    console.log('âœ“ Verificando tabla: grupos');
    const grupos = await prisma.grupo.findMany();
    console.log(`  â†’ ${grupos.length} grupos encontrados\n`);
    console.log('âœ“ Verificando tabla: materias');
    const materias = await prisma.materia.findMany();
    console.log(`  â†’ ${materias.length} materias encontradas\n`);
    console.log('âœ“ Verificando tabla: horarios');
    const horarios = await prisma.horario.findMany();
    console.log(`  â†’ ${horarios.length} horarios encontrados\n`);
    console.log('âœ“ Verificando tabla: instituciones');
    const instituciones = await prisma.institucion.findMany();
    console.log(`  â†’ ${instituciones.length} instituciones encontradas\n`);

    console.log('âœ… TODAS LAS TABLAS ACADÃ‰MICAS ESTÃN CORRECTAMENTE CREADAS\n');
    console.log('ðŸ“Š Resumen de la estructura:');
    console.log('   - PeriodoAcademico âœ“ (id, nombre, fechaInicio, fechaFin, activo, institucionId)');
    console.log('   - Grupo âœ“ (id, nombre, grado, seccion, institucionId, periodoId)');
    console.log('   - Materia âœ“ (id, nombre, codigo, institucionId)');
    console.log('   - Horario âœ“ (id, diaSemana, horaInicio, horaFin, periodoId, grupoId, materiaId, profesorId)');
    console.log('\nðŸŽ‰ Sub-fase 2.1 COMPLETADA con Ã©xito!\n');

  } catch (error) {
    console.error('âŒ Error al verificar la estructura:', error.message);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

verifySchema();

/* Fin backend\verify-schema.js */
