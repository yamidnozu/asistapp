
/* Directorio: \lib */
â”œâ”€â”€ ğŸ“‚ config
â”‚   â”œâ”€â”€ app_config.dart [77]
â”‚   â””â”€â”€ app_constants.dart [62]
â”œâ”€â”€ ğŸ“‚ constants
â”‚   â”œâ”€â”€ attendance.dart [61]
â”‚   â””â”€â”€ roles.dart [32]
â”œâ”€â”€ ğŸ“‚ dev_tools
â”‚   â””â”€â”€ test_runner_screen.dart [274]
â”œâ”€â”€ main.dart [134]
â”œâ”€â”€ ğŸ“‚ managers
â”‚   â””â”€â”€ app_lifecycle_manager.dart [110]
â”œâ”€â”€ ğŸ“‚ models
â”‚   â”œâ”€â”€ asistencia_estudiante.dart [65]
â”‚   â”œâ”€â”€ asistencia_estudiante.g.dart [32]
â”‚   â”œâ”€â”€ clase_del_dia.dart [110]
â”‚   â”œâ”€â”€ clase_del_dia.g.dart [85]
â”‚   â”œâ”€â”€ conflict_error.dart [99]
â”‚   â”œâ”€â”€ grupo.dart [76]
â”‚   â”œâ”€â”€ grupo.g.dart [58]
â”‚   â”œâ”€â”€ horario.dart [54]
â”‚   â”œâ”€â”€ horario.g.dart [41]
â”‚   â”œâ”€â”€ institution.dart [75]
â”‚   â”œâ”€â”€ institution.g.dart [35]
â”‚   â”œâ”€â”€ materia.dart [26]
â”‚   â”œâ”€â”€ materia.g.dart [20]
â”‚   â”œâ”€â”€ pagination_types.dart [7]
â”‚   â”œâ”€â”€ user.dart [249]
â”‚   â””â”€â”€ user.g.dart [92]
â”œâ”€â”€ ğŸ“‚ providers
â”‚   â”œâ”€â”€ asistencia_provider.dart [167]
â”‚   â”œâ”€â”€ auth_provider.dart [248]
â”‚   â”œâ”€â”€ common_types.dart [2]
â”‚   â”œâ”€â”€ estudiantes_by_grupo_paginated_provider.dart [53]
â”‚   â”œâ”€â”€ estudiantes_sin_asignar_paginated_provider.dart [35]
â”‚   â”œâ”€â”€ grupo_provider.dart [327]
â”‚   â”œâ”€â”€ horario_paginated_provider.dart [39]
â”‚   â”œâ”€â”€ horario_provider.dart [405]
â”‚   â”œâ”€â”€ institution_admins_paginated_provider.dart [43]
â”‚   â”œâ”€â”€ institution_provider.dart [217]
â”‚   â”œâ”€â”€ materia_provider.dart [184]
â”‚   â”œâ”€â”€ paginated_data_mixin.dart [175]
â”‚   â”œâ”€â”€ paginated_data_provider.dart [159]
â”‚   â”œâ”€â”€ periodo_academico_provider.dart [233]
â”‚   â””â”€â”€ user_provider.dart [381]
â”œâ”€â”€ ğŸ“‚ screens
â”‚   â”œâ”€â”€ ğŸ“‚ academic
â”‚   â”‚   â”œâ”€â”€ gestion_academica_screen.dart [153]
â”‚   â”‚   â”œâ”€â”€ grupos_screen.dart [54]
â”‚   â”‚   â”œâ”€â”€ grupo_detail_screen.dart [564]
â”‚   â”‚   â”œâ”€â”€ horarios_screen.dart [345]
â”‚   â”‚   â”œâ”€â”€ materias_screen.dart [320]
â”‚   â”‚   â”œâ”€â”€ materia_dialogs.dart [214]
â”‚   â”‚   â””â”€â”€ periodos_academicos_screen.dart [603]
â”‚   â”œâ”€â”€ admin_dashboard.dart [170]
â”‚   â”œâ”€â”€ app_shell.dart [323]
â”‚   â”œâ”€â”€ attendance_screen.dart [737]
â”‚   â”œâ”€â”€ ğŸ“‚ institutions
â”‚   â”‚   â”œâ”€â”€ create_institution_admin_screen.dart [20]
â”‚   â”‚   â”œâ”€â”€ ğŸ“‚ form_steps
â”‚   â”‚   â”‚   â”œâ”€â”€ index.dart [5]
â”‚   â”‚   â”‚   â”œâ”€â”€ institution_basic_info_step.dart [73]
â”‚   â”‚   â”‚   â”œâ”€â”€ institution_config_step.dart [127]
â”‚   â”‚   â”‚   â””â”€â”€ institution_contact_step.dart [92]
â”‚   â”‚   â”œâ”€â”€ institutions_list_screen.dart [498]
â”‚   â”‚   â”œâ”€â”€ institution_admins_screen.dart [633]
â”‚   â”‚   â””â”€â”€ institution_form_screen.dart [165]
â”‚   â”œâ”€â”€ institution_selection_screen.dart [173]
â”‚   â”œâ”€â”€ login_screen.dart [386]
â”‚   â”œâ”€â”€ my_qr_code_screen.dart [268]
â”‚   â”œâ”€â”€ qr_scanner_screen.dart [434]
â”‚   â”œâ”€â”€ student_attendance_screen.dart [412]
â”‚   â”œâ”€â”€ student_dashboard.dart [203]
â”‚   â”œâ”€â”€ student_notifications_screen.dart [388]
â”‚   â”œâ”€â”€ student_schedule_screen.dart [298]
â”‚   â”œâ”€â”€ super_admin_dashboard.dart [315]
â”‚   â”œâ”€â”€ teacher_dashboard.dart [660]
â”‚   â”œâ”€â”€ test_multi_hora_screen.dart [20]
â”‚   â”œâ”€â”€ test_runner_screen.dart [301]
â”‚   â””â”€â”€ ğŸ“‚ users
â”‚       â”œâ”€â”€ ğŸ“‚ form_steps
â”‚       â”‚   â”œâ”€â”€ index.dart [5]
â”‚       â”‚   â”œâ”€â”€ role_specific_details_step.dart [266]
â”‚       â”‚   â”œâ”€â”€ user_account_step.dart [314]
â”‚       â”‚   â””â”€â”€ user_personal_info_step.dart [263]
â”‚       â”œâ”€â”€ users_list_screen.dart [739]
â”‚       â”œâ”€â”€ user_detail_screen.dart [160]
â”‚       â””â”€â”€ user_form_screen.dart [685]
â”œâ”€â”€ ğŸ“‚ services
â”‚   â”œâ”€â”€ ğŸ“‚ academic
â”‚   â”‚   â”œâ”€â”€ grupo_service.dart [416]
â”‚   â”‚   â”œâ”€â”€ horario_service.dart [441]
â”‚   â”‚   â”œâ”€â”€ materia_service.dart [232]
â”‚   â”‚   â””â”€â”€ periodo_service.dart [307]
â”‚   â”œâ”€â”€ asistencia_service.dart [235]
â”‚   â”œâ”€â”€ auth_service.dart [193]
â”‚   â”œâ”€â”€ estudiante_service.dart [44]
â”‚   â”œâ”€â”€ form_validation_service.dart [173]
â”‚   â”œâ”€â”€ institution_service.dart [224]
â”‚   â”œâ”€â”€ profesor_service.dart [257]
â”‚   â”œâ”€â”€ user_form_service.dart [197]
â”‚   â””â”€â”€ user_service.dart [453]
â”œâ”€â”€ ğŸ“‚ theme
â”‚   â”œâ”€â”€ app_colors.dart [115]
â”‚   â”œâ”€â”€ app_spacing.dart [24]
â”‚   â”œâ”€â”€ app_text_styles.dart [203]
â”‚   â”œâ”€â”€ app_theme.dart [241]
â”‚   â”œâ”€â”€ index.dart [5]
â”‚   â””â”€â”€ theme_extensions.dart [42]
â”œâ”€â”€ ğŸ“‚ utils
â”‚   â”œâ”€â”€ app_router.dart [348]
â”‚   â”œâ”€â”€ http_client.dart [179]
â”‚   â”œâ”€â”€ responsive_utils.dart [166]
â”‚   â”œâ”€â”€ role_enum.dart [53]
â”‚   â””â”€â”€ test_flow_manager.dart [403]
â””â”€â”€ ğŸ“‚ widgets
    â”œâ”€â”€ ğŸ“‚ common
    â”‚   â”œâ”€â”€ dashboard_scaffold.dart [76]
    â”‚   â”œâ”€â”€ empty_state_widget.dart [47]
    â”‚   â”œâ”€â”€ index.dart [4]
    â”‚   â”œâ”€â”€ management_scaffold.dart [218]
    â”‚   â”œâ”€â”€ multi_step_form_scaffold.dart [95]
    â”‚   â””â”€â”€ shimmer_list_widget.dart [32]
    â”œâ”€â”€ ğŸ“‚ components
    â”‚   â”œâ”€â”€ clarity_components.dart [715]
    â”‚   â”œâ”€â”€ clarity_form_dialog.dart [80]
    â”‚   â”œâ”€â”€ clarity_management_page.dart [156]
    â”‚   â”œâ”€â”€ command_palette.dart [284]
    â”‚   â””â”€â”€ index.dart [5]
    â”œâ”€â”€ dashboard_widgets.dart [287]
    â”œâ”€â”€ form_widgets.dart [320]
    â”œâ”€â”€ ğŸ“‚ horarios
    â”‚   â”œâ”€â”€ create_class_dialog.dart [324]
    â”‚   â”œâ”€â”€ edit_class_dialog.dart [218]
    â”‚   â””â”€â”€ weekly_calendar.dart [305]
    â”œâ”€â”€ index.dart [11]
    â”œâ”€â”€ pagination_widget.dart [411]
    â”œâ”€â”€ role_guard.dart [39]
    â”œâ”€â”€ scroll_state_keeper.dart [31]
    â”œâ”€â”€ session_info_footer.dart [105]
    â”œâ”€â”€ test_multi_hora_widget.dart [156]
    â””â”€â”€ ğŸ“‚ ui
        â”œâ”€â”€ app_button.dart [196]
        â”œâ”€â”€ app_components.dart [216]
        â”œâ”€â”€ error_logger.dart [198]
        â””â”€â”€ index.dart [4]


/* Directorio: \backend */


Total de lÃ­neas resumidas: 25412
Total de archivos: 124
Promedio de lÃ­neas por archivo: 205
Archivo mÃ¡s grande: users_list_screen.dart (739 lÃ­neas)


/* Inicio lib\config\app_config.dart */
import 'package:flutter/foundation.dart';
import 'dart:io' show Platform;
import 'package:flutter_dotenv/flutter_dotenv.dart';
class AppConfig {
  static String? _baseUrl;
  static String? _environment;
  static Future<void> initialize() async {
    const dartDefineUrl = String.fromEnvironment('API_BASE_URL');
    const dartDefineEnv = String.fromEnvironment('ENVIRONMENT', defaultValue: 'development');

    if (dartDefineUrl.isNotEmpty) {
      _baseUrl = dartDefineUrl;
      _environment = dartDefineEnv;
      debugPrint('AppConfig: Usando configuraciÃ³n de --dart-define');
      debugPrint('  - API_BASE_URL: $_baseUrl');
      debugPrint('  - ENVIRONMENT: $_environment');
      return;
    }
    try {
      await dotenv.load(fileName: '.env');
      final envUrl = dotenv.env['API_BASE_URL'];
      final envEnvironment = dotenv.env['ENVIRONMENT'] ?? 'development';

      if (envUrl != null && envUrl.isNotEmpty) {
        _baseUrl = envUrl;
        _environment = envEnvironment;
        debugPrint('AppConfig: Usando configuraciÃ³n de .env');
        debugPrint('  - API_BASE_URL: $_baseUrl');
        debugPrint('  - ENVIRONMENT: $_environment');
        return;
      }
    } catch (e) {
      debugPrint('AppConfig: No se pudo cargar .env: $e');
    }
    _baseUrl = _getDefaultUrl();
    _environment = 'development';
    debugPrint('AppConfig: Usando configuraciÃ³n por defecto');
    debugPrint('  - API_BASE_URL: $_baseUrl');
    debugPrint('  - ENVIRONMENT: $_environment');
    debugPrint('  - Plataforma: ${Platform.operatingSystem}');
  }
  static String _getDefaultUrl() {

    if (kDebugMode) {
      if (Platform.isAndroid) {
        return 'http://10.0.2.2:3002';
      } else if (Platform.isIOS) {
        return 'http://localhost:3002';
      }
    }
    return 'http://192.168.20.22:3002';
  }
  static String get baseUrl {
    if (_baseUrl == null) {
      throw StateError(
        'AppConfig no ha sido inicializado. '
        'Llama a AppConfig.initialize() antes de usar baseUrl.'
      );
    }
    return _baseUrl!;
  }
  static String get environment {
    return _environment ?? 'development';
  }
  static bool get isDevelopment => environment == 'development';
  static bool get isStaging => environment == 'staging';
  static bool get isProduction => environment == 'production';
  static Duration get networkTimeout {
    if (isProduction) {
      return const Duration(seconds: 30);
    } else {
      return const Duration(seconds: 60)
    }
  }
  static bool get enableNetworkLogs => isDevelopment || isStaging;
}

/* Fin lib\config\app_config.dart */

/* Inicio lib\config\app_constants.dart */

class AppConstants {
  AppConstants._();

  static final AppConstants instance = AppConstants._();
  static const int itemsPerPage = 5;
  static const int httpTimeoutSeconds = 10;
  static const int maxRetries = 3;
  final double mobileSmall = 480;
  final double mobileLarge = 768;
  final double tablet = 1024;
  final double desktop = 1440;
  final double maxWidthMobile = 480;
  final double maxWidthTablet = 768;
  final double maxWidthDesktop = 1024;
  final double maxWidthLargeDesktop = 1400;

  final double logoSize = 80;
  final double spinnerSize = 20;
  final double buttonBorderRadius = 8;
  final double cardBorderRadius = 8;
  final double logoBorderRadius = 20;
  final double errorLoggerWidthCollapsed = 60;
  final double errorLoggerHeightCollapsed = 60;
  final double errorLoggerWidthExpanded = 300;
  final double errorLoggerHeightExpanded = 200;

  final double defaultFontSize = 14;
  final double logoFontSize = 48;
  final double shadowBlurRadius = 8;
  final double shadowOffsetY = 2;
  final double errorLoggerShadowBlur = 8;
  final double errorLoggerShadowOffsetY = 4;
  final double borderWidthThin = 0.5;
  final double borderWidthNormal = 1;
  final double borderWidthThick = 1.5;

  final double shadowOpacity = 0.1
  final double surfaceTintOpacity = 0.1;
  double getMaxWidth(double screenWidth) {
    if (screenWidth <= mobileSmall) return maxWidthMobile;
    if (screenWidth <= mobileLarge) return maxWidthTablet;
    if (screenWidth <= tablet) return maxWidthDesktop;
    return maxWidthLargeDesktop;
  }
  ScreenType getScreenType(double width) {
    if (width <= mobileSmall) return ScreenType.mobileSmall;
    if (width <= mobileLarge) return ScreenType.mobileLarge;
    if (width <= tablet) return ScreenType.tablet;
    if (width <= desktop) return ScreenType.desktop;
    return ScreenType.largeDesktop;
  }
}

enum ScreenType {
  mobileSmall,    // <= 480px
  mobileLarge,    // 481-768px
  tablet,         // 769-1024px
  desktop,        // 1025-1440px
  largeDesktop,   // > 1440px
}

/* Fin lib\config\app_constants.dart */

/* Inicio lib\constants\attendance.dart */


class AttendanceStatus {
  static const String presente = 'PRESENTE';
  static const String ausente = 'AUSENTE';
  static const String tardanza = 'TARDANZA';
  static const String justificado = 'JUSTIFICADO';
  static bool isValid(String status) {
    return [presente, ausente, tardanza, justificado].contains(status);
  }
  static String getName(String status) {
    switch (status) {
      case presente:
        return 'Presente';
      case ausente:
        return 'Ausente';
      case tardanza:
        return 'Tardanza';
      case justificado:
        return 'Justificado';
      default:
        return 'Desconocido';
    }
  }
  static String getColor(String status) {
    switch (status) {
      case presente:
        return '#4CAF50'
      case ausente:
        return '#F44336'
      case tardanza:
        return '#FF9800'
      case justificado:
        return '#2196F3'
      default:
        return '#9E9E9E'
    }
  }
}

class AttendanceType {
  static const String manual = 'MANUAL';
  static const String qr = 'QR';
  static const String automatico = 'AUTOMATICO';
  static bool isValid(String type) {
    return [manual, qr, automatico].contains(type);
  }
  static String getName(String type) {
    switch (type) {
      case manual:
        return 'Manual';
      case qr:
        return 'CÃ³digo QR';
      case automatico:
        return 'AutomÃ¡tico';
      default:
        return 'Desconocido';
    }
  }
}

/* Fin lib\constants\attendance.dart */

/* Inicio lib\constants\roles.dart */


class UserRoles {
  static const String superAdmin = 'super_admin';
  static const String adminInstitucion = 'admin_institucion';
  static const String profesor = 'profesor';
  static const String estudiante = 'estudiante';
  static bool isValidRole(String role) {
    return [superAdmin, adminInstitucion, profesor, estudiante].contains(role);
  }
  static bool isAdminRole(String role) {
    return role == superAdmin || role == adminInstitucion;
  }
  static bool canManageClasses(String role) {
    return isAdminRole(role) || role == profesor;
  }
  static String getRoleName(String role) {
    switch (role) {
      case superAdmin:
        return 'Super Administrador';
      case adminInstitucion:
        return 'Administrador de InstituciÃ³n';
      case profesor:
        return 'Profesor';
      case estudiante:
        return 'Estudiante';
      default:
        return 'Desconocido';
    }
  }
}

/* Fin lib\constants\roles.dart */

/* Inicio lib\dev_tools\test_runner_screen.dart */
import 'package:flutter/material.dart';

import '../theme/app_colors.dart';
import '../theme/app_spacing.dart';
import '../theme/app_text_styles.dart';
import '../utils/test_flow_manager.dart';

class TestRunnerScreen extends StatefulWidget {
  const TestRunnerScreen({super.key});

  @override
  State<TestRunnerScreen> createState() => _TestRunnerScreenState();
}

class _TestRunnerScreenState extends State<TestRunnerScreen> {
  bool _isRunning = false;
  String _currentStep = '';
  final List<String> _logs = [];
  final ScrollController _logController = ScrollController();

  static const List<_TestStep> _stepDefinitions = [
    _TestStep('1. Login Super Admin', TestFlowManager.step1LoginSuperAdmin),
    _TestStep('2. Crear InstituciÃ³n', TestFlowManager.step2CrearInstitucion),
    _TestStep('3. Crear Admin InstituciÃ³n', TestFlowManager.step3CrearAdminInstitucion),
    _TestStep('4. Crear Profesores', TestFlowManager.step4CrearProfesores),
    _TestStep('5. Crear Estudiantes', TestFlowManager.step5CrearEstudiantes),
    _TestStep('6. Crear Materias', TestFlowManager.step6CrearMaterias),
    _TestStep('7. Crear Grupos', TestFlowManager.step7CrearGrupos),
    _TestStep('8. Crear Horarios', TestFlowManager.step8CrearHorarios),
    _TestStep('9. Verificar Asistencias', TestFlowManager.step9VerificarAsistencias),
    _TestStep('10. Verificar Dashboards', TestFlowManager.step10VerificarDashboards),
  ];

  void _addLog(String message) {
    setState(() => _logs.add('[${DateTime.now().toIso8601String()}] $message'));

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_logController.hasClients) {
        _logController.animateTo(
          _logController.position.maxScrollExtent,
          duration: const Duration(milliseconds: 250),
          curve: Curves.easeOut,
        );
      }
    });
  }

  Future<void> _executeFlow(Future<void> Function(BuildContext) flow, String label) async {
    if (_isRunning) return;

    setState(() {
      _isRunning = true;
      _currentStep = label;
    });

  _addLog('Iniciando: $label');

    try {
      await flow(context);
      _addLog('âœ… $label completado');
    } catch (error, stack) {
      debugPrintStack(label: label, stackTrace: stack);
      _addLog('âŒ $label fallÃ³: $error');
    } finally {
      if (mounted) {
        setState(() {
          _isRunning = false;
          _currentStep = '';
        });
      }
    }
  }

  Future<void> _runFullFlow() => _executeFlow(TestFlowManager.ejecutarFlujoCompleto, 'Flujo completo');

  Future<void> _runUITests() => _executeFlow(TestFlowManager.ejecutarPruebasUI, 'Pruebas de UI');

  Future<void> _runStep(_TestStep step) => _executeFlow(step.handler, step.title);

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final textStyles = AppTextStyles.instance;
    final spacing = AppSpacing.instance;

    return Scaffold(
      backgroundColor: colors.background,
      appBar: AppBar(
        backgroundColor: colors.primary,
        foregroundColor: colors.white,
        elevation: 0,
        title: const Text('Flujo de Pruebas'),
      ),
      body: Padding(
        padding: EdgeInsets.all(spacing.screenPadding),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Herramientas de Testing',
              style: textStyles.displayMedium,
            ),
            SizedBox(height: spacing.sm),
            Text(
              'Ejecuta flujos completos de pruebas para validar todas las funcionalidades clave.',
              style: textStyles.bodyLarge,
            ),
            SizedBox(height: spacing.xl),
            if (_currentStep.isNotEmpty)
              Container(
                padding: EdgeInsets.all(spacing.md),
                decoration: BoxDecoration(
                  color: colors.primary.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(spacing.borderRadius),
                  border: Border.all(color: colors.primary.withValues(alpha: 0.3)),
                ),
                child: Row(
                  children: [
                    SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        valueColor: AlwaysStoppedAnimation<Color>(colors.primary),
                      ),
                    ),
                    SizedBox(width: spacing.md),
                    Expanded(
                      child: Text(
                        _currentStep,
                        style: textStyles.bodyMedium.copyWith(color: colors.primary),
                      ),
                    ),
                  ],
                ),
              ),
            if (_currentStep.isNotEmpty) SizedBox(height: spacing.lg),
            Text(
              'Flujos de prueba',
              style: textStyles.headlineSmall,
            ),
            SizedBox(height: spacing.md),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: _isRunning ? null : _runFullFlow,
                icon: Icon(_isRunning ? Icons.hourglass_top : Icons.play_arrow),
                label: Text(_isRunning ? 'Ejecutando...' : 'Ejecutar flujo completo'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: colors.primary,
                  foregroundColor: colors.white,
                  padding: EdgeInsets.symmetric(vertical: spacing.lg),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(spacing.borderRadius),
                  ),
                ),
              ),
            ),
            SizedBox(height: spacing.md),
            SizedBox(
              width: double.infinity,
              child: OutlinedButton.icon(
                onPressed: _isRunning ? null : _runUITests,
                icon: const Icon(Icons.visibility),
                label: const Text('Probar solo UI'),
                style: OutlinedButton.styleFrom(
                  side: BorderSide(color: colors.primary),
                  foregroundColor: colors.primary,
                  padding: EdgeInsets.symmetric(vertical: spacing.lg),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(spacing.borderRadius),
                  ),
                ),
              ),
            ),
            SizedBox(height: spacing.xl),
            Text(
              'Pasos individuales',
              style: textStyles.headlineSmall,
            ),
            SizedBox(height: spacing.md),
            Expanded(
              flex: 2,
              child: ListView.separated(
                itemCount: _stepDefinitions.length,
                separatorBuilder: (_, __) => SizedBox(height: spacing.sm),
                itemBuilder: (context, index) => _buildStepButton(
                  _stepDefinitions[index],
                  colors,
                  spacing,
                  textStyles,
                ),
              ),
            ),
            if (_logs.isNotEmpty) ...[
              SizedBox(height: spacing.xl),
              Text(
                'Logs de ejecuciÃ³n',
                style: textStyles.headlineSmall,
              ),
              SizedBox(height: spacing.md),
              Expanded(
                flex: 3,
                child: Container(
                  decoration: BoxDecoration(
                    color: colors.surface,
                    borderRadius: BorderRadius.circular(spacing.borderRadius),
                    border: Border.all(color: colors.borderLight),
                  ),
                  child: ListView.builder(
                    controller: _logController,
                    padding: EdgeInsets.all(spacing.md),
                    itemCount: _logs.length,
                    itemBuilder: (context, index) {
                      final log = _logs[index];
                      final color = log.contains('âœ…')
                          ? colors.success
                          : log.contains('âŒ')
                              ? colors.error
                              : colors.textPrimary;
                      return Padding(
                        padding: EdgeInsets.only(bottom: spacing.xs),
                        child: Text(
                          log,
                          style: textStyles.bodySmall.copyWith(
                            fontFamily: 'monospace',
                            color: color,
                          ),
                        ),
                      );
                    },
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildStepButton(_TestStep step, AppColors colors, AppSpacing spacing, AppTextStyles textStyles) {
    return Padding(
      padding: EdgeInsets.only(bottom: spacing.sm),
      child: SizedBox(
        width: double.infinity,
        child: TextButton(
          onPressed: _isRunning ? null : () => _runStep(step),
          style: TextButton.styleFrom(
            padding: EdgeInsets.symmetric(vertical: spacing.md, horizontal: spacing.lg),
            alignment: Alignment.centerLeft,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(spacing.borderRadius),
            ),
          ),
          child: Text(
            step.title,
            style: textStyles.bodyMedium.copyWith(
              color: _isRunning ? colors.textSecondary : colors.primary,
            ),
          ),
        ),
      ),
    );
  }
}

class _TestStep {
  final String title;
  final Future<void> Function(BuildContext) handler;

  const _TestStep(this.title, this.handler);
}

/* Fin lib\dev_tools\test_runner_screen.dart */

/* Inicio lib\main.dart */
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'config/app_config.dart';
import 'providers/auth_provider.dart';
import 'providers/institution_provider.dart';
import 'providers/user_provider.dart';
import 'providers/estudiantes_by_grupo_paginated_provider.dart';
import 'providers/estudiantes_sin_asignar_paginated_provider.dart';
import 'providers/institution_admins_paginated_provider.dart';
import 'providers/horario_provider.dart';
import 'providers/asistencia_provider.dart';
import 'providers/grupo_provider.dart';
import 'providers/materia_provider.dart';
import 'providers/periodo_academico_provider.dart';
import 'managers/app_lifecycle_manager.dart';
import 'theme/app_theme.dart';
import 'theme/app_colors.dart';
import 'utils/app_router.dart';
import 'services/auth_service.dart';
import 'services/asistencia_service.dart';
import 'services/institution_service.dart';
import 'services/academic/grupo_service.dart';
import 'services/academic/materia_service.dart';
import 'services/academic/horario_service.dart';
import 'services/academic/periodo_service.dart';
import 'services/user_service.dart' as user_service;

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await AppConfig.initialize();

  SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle(
    statusBarColor: AppColors.instance.transparent,
    statusBarIconBrightness: Brightness.light,
    systemNavigationBarColor: AppColors.instance.black,
    systemNavigationBarIconBrightness: Brightness.light,
  ));

  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> with WidgetsBindingObserver {

  late final AppLifecycleManager _lifecycleManager;
  late AppRouter _appRouter;
  late final AuthService _authService;
  late final InstitutionService _institutionService;
  late final GrupoService _grupoService;
  late final MateriaService _materiaService;
  late final HorarioService _horarioService;
  late final PeriodoService _periodoService;
  late final AsistenciaService _asistenciaService;
  late final user_service.UserService _userService;
  late final AuthProvider _authProvider;

  @override
  void initState() {
    super.initState();

    _lifecycleManager = AppLifecycleManager();
    _authService = AuthService();
    _institutionService = InstitutionService();
    _grupoService = GrupoService();
    _materiaService = MateriaService();
    _horarioService = HorarioService();
    _periodoService = PeriodoService();
    _asistenciaService = AsistenciaService();
    _userService = user_service.UserService();
    _authProvider = AuthProvider(authService: _authService);

    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _appRouter.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => _authProvider),
        ChangeNotifierProvider(create: (_) => InstitutionProvider(institutionService: _institutionService)),
        ChangeNotifierProvider(create: (_) => HorarioProvider(horarioService: _horarioService)),
        ChangeNotifierProvider(create: (_) => AsistenciaProvider(asistenciaService: _asistenciaService)),
        ChangeNotifierProvider(create: (_) => GrupoProvider(grupoService: _grupoService)),
        ChangeNotifierProvider(create: (_) => MateriaProvider(materiaService: _materiaService)),
        ChangeNotifierProvider(create: (_) => PeriodoAcademicoProvider(periodoService: _periodoService)),
        ChangeNotifierProvider(create: (_) => UserProvider(userService: _userService)),
        ChangeNotifierProvider(create: (_) => EstudiantesByGrupoPaginatedProvider(grupoService: _grupoService)),
        ChangeNotifierProvider(create: (_) => EstudiantesSinAsignarPaginatedProvider(grupoService: _grupoService)),
        ChangeNotifierProvider(create: (_) => InstitutionAdminsPaginatedProvider(userService: _userService)),
        ChangeNotifierProvider(create: (_) => _lifecycleManager),
      ],
      child: Builder(
        builder: (context) {

          _appRouter = AppRouter(
            authProvider: _authProvider,
          );

          return MaterialApp.router(
            title: 'AsistApp',
            debugShowCheckedModeBanner: false,
            theme: AppTheme.defaultTheme,
            routerConfig: _appRouter.router,
            builder: (context, child) {
              return DefaultTextStyle(
                style: TextStyle(
                  decoration: TextDecoration.none,
                  color: AppColors.instance.white,
                  fontSize: 14.0,
                  fontWeight: FontWeight.normal,
                ),
                child: child!,
              );
            },
          );
        },
      ),
    );
  }
}
/* Fin lib\main.dart */

/* Inicio lib\managers\app_lifecycle_manager.dart */
import 'package:flutter/widgets.dart';
enum AppState {
  resumed,
  paused,
  hidden,
  detached,
}
class AppLifecycleManager extends ChangeNotifier {
  AppState _currentState = AppState.resumed;
  DateTime? _lastPausedTime;
  bool _isFirstResume = true;

  AppState get currentState => _currentState;
  bool get isInForeground => _currentState == AppState.resumed;
  bool get isInBackground => _currentState == AppState.paused || _currentState == AppState.hidden;

  AppLifecycleManager() {
    WidgetsBinding.instance.addObserver(_AppLifecycleObserver(this));
  }

  void _onLifecycleChanged(AppState state) {
    final previousState = _currentState;
    _currentState = state;

    switch (state) {
      case AppState.paused:
        _handleAppPaused();
        break;
      case AppState.resumed:
        _handleAppResumed(previousState);
        break;
      case AppState.hidden:
        _handleAppHidden();
        break;
      case AppState.detached:
        _handleAppDetached();
        break;
    }

    notifyListeners();
  }

  void _handleAppPaused() {
    _lastPausedTime = DateTime.now();
    debugPrint('AppLifecycleManager: App paused at $_lastPausedTime');
  }

  void _handleAppResumed(AppState previousState) {
    final now = DateTime.now();
    final timeInBackground = _lastPausedTime != null ? now.difference(_lastPausedTime!) : Duration.zero;

    debugPrint('AppLifecycleManager: App resumed after ${timeInBackground.inSeconds}s in background');
    if (_isFirstResume) {
      _isFirstResume = false;
      return;
    }
    if (timeInBackground.inSeconds > 30) {
      debugPrint('AppLifecycleManager: Long background time, triggering data refresh');
      _triggerDataRefresh();
    } else {
      debugPrint('AppLifecycleManager: Quick resume, using cached data');
    }
  }

  void _handleAppHidden() {
    debugPrint('AppLifecycleManager: App hidden');
  }

  void _handleAppDetached() {
    debugPrint('AppLifecycleManager: App detached');
  }
  void _triggerDataRefresh() {
    debugPrint('AppLifecycleManager: Triggering data refresh...');
  }
  void addLifecycleCallback(String key, VoidCallback callback) {
  }

  void removeLifecycleCallback(String key) {
  }
}
class _AppLifecycleObserver extends WidgetsBindingObserver {
  final AppLifecycleManager _manager;

  _AppLifecycleObserver(this._manager);

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    AppState mappedState;

    switch (state) {
      case AppLifecycleState.resumed:
        mappedState = AppState.resumed;
        break;
      case AppLifecycleState.paused:
        mappedState = AppState.paused;
        break;
      case AppLifecycleState.hidden:
        mappedState = AppState.hidden;
        break;
      case AppLifecycleState.detached:
        mappedState = AppState.detached;
        break;
      case AppLifecycleState.inactive:
        mappedState = AppState.paused;
        break;
    }

    _manager._onLifecycleChanged(mappedState);
  }
}
/* Fin lib\managers\app_lifecycle_manager.dart */

/* Inicio lib\models\asistencia_estudiante.dart */
import 'package:json_annotation/json_annotation.dart';
import '../constants/attendance.dart';

part 'asistencia_estudiante.g.dart';
@JsonSerializable()
class AsistenciaEstudiante {
  final String? id
  final String estudianteId;
  final String nombres;
  final String apellidos;
  final String identificacion;
  final String? estado
  final String? observacion
  final DateTime? fechaRegistro;

  AsistenciaEstudiante({
    this.id,
    required this.estudianteId,
    required this.nombres,
    required this.apellidos,
    required this.identificacion,
    this.estado,
    this.observacion,
    this.fechaRegistro,
  });
  factory AsistenciaEstudiante.fromJson(Map<String, dynamic> json) => _$AsistenciaEstudianteFromJson(json);
  Map<String, dynamic> toJson() => _$AsistenciaEstudianteToJson(this);
  String get nombreCompleto => '$nombres $apellidos';
  String get inicial {
    if (nombres.isNotEmpty) {
      return nombres[0].toUpperCase();
    }
    if (nombreCompleto.isNotEmpty && nombreCompleto != ' ') {
      return nombreCompleto[0].toUpperCase();
    }
    return '?';
  }
  bool get estaPresente => estado == AttendanceStatus.presente;
  bool get estaAusente => estado == AttendanceStatus.ausente;
  bool get tieneTardanza => estado == AttendanceStatus.tardanza;
  bool get estaJustificado => estado == AttendanceStatus.justificado;
  bool get sinRegistrar => estado == null;
  String getEstadoColor() {
    if (estado == null) return '#9E9E9E'
    return AttendanceStatus.getColor(estado!);
  }
  String getEstadoTexto() {
    if (estado == null) return 'Sin registrar';
    return AttendanceStatus.getName(estado!);
  }

  @override
  String toString() {
    return 'AsistenciaEstudiante(estudianteId: $estudianteId, nombre: $nombreCompleto, estado: $estado)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is AsistenciaEstudiante && other.estudianteId == estudianteId;
  }

  @override
  int get hashCode => estudianteId.hashCode;
}
/* Fin lib\models\asistencia_estudiante.dart */

/* Inicio lib\models\asistencia_estudiante.g.dart */


part of 'asistencia_estudiante.dart';

AsistenciaEstudiante _$AsistenciaEstudianteFromJson(
        Map<String, dynamic> json) =>
    AsistenciaEstudiante(
      id: json['id'] as String?,
      estudianteId: json['estudianteId'] as String,
      nombres: json['nombres'] as String,
      apellidos: json['apellidos'] as String,
      identificacion: json['identificacion'] as String,
      estado: json['estado'] as String?,
      observacion: json['observacion'] as String?,
      fechaRegistro: json['fechaRegistro'] == null
          ? null
          : DateTime.parse(json['fechaRegistro'] as String),
    );

Map<String, dynamic> _$AsistenciaEstudianteToJson(
        AsistenciaEstudiante instance) =>
    <String, dynamic>{
      'id': instance.id,
      'estudianteId': instance.estudianteId,
      'nombres': instance.nombres,
      'apellidos': instance.apellidos,
      'identificacion': instance.identificacion,
      'estado': instance.estado,
      'observacion': instance.observacion,
      'fechaRegistro': instance.fechaRegistro?.toIso8601String(),
    };

/* Fin lib\models\asistencia_estudiante.g.dart */

/* Inicio lib\models\clase_del_dia.dart */
import 'package:json_annotation/json_annotation.dart';

part 'clase_del_dia.g.dart';

@JsonSerializable()
class ClaseDelDia {
  final String id;
  final int diaSemana;
  final String horaInicio;
  final String horaFin;
  final GrupoSimple grupo;
  final MateriaSimple materia;
  final PeriodoAcademicoSimple periodoAcademico;
  final Institucion institucion;

  ClaseDelDia({
    required this.id,
    required this.diaSemana,
    required this.horaInicio,
    required this.horaFin,
    required this.grupo,
    required this.materia,
    required this.periodoAcademico,
    required this.institucion,
  });

  factory ClaseDelDia.fromJson(Map<String, dynamic> json) => _$ClaseDelDiaFromJson(json);

  Map<String, dynamic> toJson() => _$ClaseDelDiaToJson(this);

  String get diaSemanaNombre {
    const dias = ['Lunes', 'Martes', 'MiÃ©rcoles', 'Jueves', 'Viernes', 'SÃ¡bado', 'Domingo'];
    return dias[diaSemana - 1];
  }

  String get horarioFormato => '$horaInicio - $horaFin';

  String get descripcion => '${materia.nombre} - ${grupo.nombreCompleto}';
}
@JsonSerializable()
class GrupoSimple {
  final String id;
  final String nombre;
  final String grado;
  final String? seccion;

  GrupoSimple({
    required this.id,
    required this.nombre,
    required this.grado,
    this.seccion,
  });

  factory GrupoSimple.fromJson(Map<String, dynamic> json) => _$GrupoSimpleFromJson(json);

  Map<String, dynamic> toJson() => _$GrupoSimpleToJson(this);

  String get nombreCompleto => seccion != null ? '$grado $seccion' : grado;
}

@JsonSerializable()
class MateriaSimple {
  final String id;
  final String nombre;
  final String? codigo;

  MateriaSimple({
    required this.id,
    required this.nombre,
    this.codigo,
  });

  factory MateriaSimple.fromJson(Map<String, dynamic> json) => _$MateriaSimpleFromJson(json);

  Map<String, dynamic> toJson() => _$MateriaSimpleToJson(this);

  String get nombreConCodigo => codigo != null ? '$codigo - $nombre' : nombre;
}

@JsonSerializable()
class PeriodoAcademicoSimple {
  final String id;
  final String nombre;
  final bool activo;

  PeriodoAcademicoSimple({
    required this.id,
    required this.nombre,
    required this.activo,
  });

  factory PeriodoAcademicoSimple.fromJson(Map<String, dynamic> json) => _$PeriodoAcademicoSimpleFromJson(json);

  Map<String, dynamic> toJson() => _$PeriodoAcademicoSimpleToJson(this);
}

@JsonSerializable()
class Institucion {
  final String id;
  final String nombre;

  Institucion({
    required this.id,
    required this.nombre,
  });

  factory Institucion.fromJson(Map<String, dynamic> json) => _$InstitucionFromJson(json);

  Map<String, dynamic> toJson() => _$InstitucionToJson(this);
}
/* Fin lib\models\clase_del_dia.dart */

/* Inicio lib\models\clase_del_dia.g.dart */


part of 'clase_del_dia.dart';

ClaseDelDia _$ClaseDelDiaFromJson(Map<String, dynamic> json) => ClaseDelDia(
      id: json['id'] as String,
      diaSemana: (json['diaSemana'] as num).toInt(),
      horaInicio: json['horaInicio'] as String,
      horaFin: json['horaFin'] as String,
      grupo: GrupoSimple.fromJson(json['grupo'] as Map<String, dynamic>),
      materia: MateriaSimple.fromJson(json['materia'] as Map<String, dynamic>),
      periodoAcademico: PeriodoAcademicoSimple.fromJson(
          json['periodoAcademico'] as Map<String, dynamic>),
      institucion:
          Institucion.fromJson(json['institucion'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$ClaseDelDiaToJson(ClaseDelDia instance) =>
    <String, dynamic>{
      'id': instance.id,
      'diaSemana': instance.diaSemana,
      'horaInicio': instance.horaInicio,
      'horaFin': instance.horaFin,
      'grupo': instance.grupo,
      'materia': instance.materia,
      'periodoAcademico': instance.periodoAcademico,
      'institucion': instance.institucion,
    };

GrupoSimple _$GrupoSimpleFromJson(Map<String, dynamic> json) => GrupoSimple(
      id: json['id'] as String,
      nombre: json['nombre'] as String,
      grado: json['grado'] as String,
      seccion: json['seccion'] as String?,
    );

Map<String, dynamic> _$GrupoSimpleToJson(GrupoSimple instance) =>
    <String, dynamic>{
      'id': instance.id,
      'nombre': instance.nombre,
      'grado': instance.grado,
      'seccion': instance.seccion,
    };

MateriaSimple _$MateriaSimpleFromJson(Map<String, dynamic> json) =>
    MateriaSimple(
      id: json['id'] as String,
      nombre: json['nombre'] as String,
      codigo: json['codigo'] as String?,
    );

Map<String, dynamic> _$MateriaSimpleToJson(MateriaSimple instance) =>
    <String, dynamic>{
      'id': instance.id,
      'nombre': instance.nombre,
      'codigo': instance.codigo,
    };

PeriodoAcademicoSimple _$PeriodoAcademicoSimpleFromJson(
        Map<String, dynamic> json) =>
    PeriodoAcademicoSimple(
      id: json['id'] as String,
      nombre: json['nombre'] as String,
      activo: json['activo'] as bool,
    );

Map<String, dynamic> _$PeriodoAcademicoSimpleToJson(
        PeriodoAcademicoSimple instance) =>
    <String, dynamic>{
      'id': instance.id,
      'nombre': instance.nombre,
      'activo': instance.activo,
    };

Institucion _$InstitucionFromJson(Map<String, dynamic> json) => Institucion(
      id: json['id'] as String,
      nombre: json['nombre'] as String,
    );

Map<String, dynamic> _$InstitucionToJson(Institucion instance) =>
    <String, dynamic>{
      'id': instance.id,
      'nombre': instance.nombre,
    };

/* Fin lib\models\clase_del_dia.g.dart */

/* Inicio lib\models\conflict_error.dart */
import 'dart:convert';
class ConflictError {
  final String code;
  final String reason;
  final String message;
  final Map<String, dynamic>? meta;

  ConflictError({
    required this.code,
    required this.reason,
    required this.message,
    this.meta,
  });
  factory ConflictError.fromBackendError(String errorMessage) {
    try {
      final parts = errorMessage.split(' - ');
      if (parts.length >= 4) {
        final code = parts[2];
        final reason = parts[3];
        final message = parts[1];

        Map<String, dynamic>? meta;
        if (parts.length > 4) {
          try {
            final metaString = parts.sublist(4).join(' - ');
            if (metaString.startsWith('{') && metaString.endsWith('}')) {
              meta = Map<String, dynamic>.from(
                jsonDecode(metaString) as Map
              );
            }
          } catch (_) {
          }
        }

        return ConflictError(
          code: code,
          reason: reason,
          message: message,
          meta: meta,
        );
      }
    } catch (_) {
    }
    return ConflictError(
      code: 'CONFLICT_ERROR',
      reason: 'unknown_conflict',
      message: errorMessage,
      meta: null,
    );
  }
  List<String> get conflictingHorarioIds {
    if (meta != null && meta!['conflictingHorarioIds'] is List) {
      return List<String>.from(meta!['conflictingHorarioIds']);
    }
    return [];
  }
  bool get isGrupoConflict => reason == 'grupo_conflict';
  bool get isProfesorConflict => reason == 'profesor_conflict';
  String get userFriendlyMessage {
    switch (reason) {
      case 'grupo_conflict':
        return 'El grupo ya tiene una clase programada en este horario.';
      case 'profesor_conflict':
        return 'El profesor ya tiene una clase programada en este horario.';
      default:
        return message;
    }
  }
  List<String> get suggestions {
    switch (reason) {
      case 'grupo_conflict':
        return [
          'Cambia la hora de la clase',
          'Selecciona un dÃ­a diferente',
          'Elige otra materia disponible',
          'Verifica los horarios existentes del grupo'
        ];
      case 'profesor_conflict':
        return [
          'Cambia la hora de la clase',
          'Selecciona un dÃ­a diferente',
          'Elige otro profesor disponible',
          'Verifica los horarios existentes del profesor'
        ];
      default:
        return [
          'Cambia la hora de la clase',
          'Selecciona un dÃ­a diferente',
          'Elige otro profesor disponible',
          'Verifica los horarios existentes'
        ];
    }
  }

  @override
  String toString() {
    return 'ConflictError(code: $code, reason: $reason, message: $message, meta: $meta)';
  }
}
/* Fin lib\models\conflict_error.dart */

/* Inicio lib\models\grupo.dart */
import 'package:json_annotation/json_annotation.dart';

part 'grupo.g.dart';

@JsonSerializable()
class Grupo {
  final String id;
  final String nombre;
  final String grado;
  final String? seccion;
  final String periodoId;
  final String institucionId;
  @JsonKey(fromJson: _dateTimeFromJson, toJson: _dateTimeToJson)
  final DateTime createdAt;
  final PeriodoAcademico periodoAcademico;
  @JsonKey(name: '_count')
  final GrupoCount count;

  Grupo({
    required this.id,
    required this.nombre,
    required this.grado,
    this.seccion,
    required this.periodoId,
    required this.institucionId,
    required this.createdAt,
    required this.periodoAcademico,
    required this.count,
  });

  factory Grupo.fromJson(Map<String, dynamic> json) => _$GrupoFromJson(json);
  Map<String, dynamic> toJson() => _$GrupoToJson(this);

  int get estudiantesGruposCount => count.estudiantesGrupos;
  int get horariosCount => count.horarios;
  String get nombreCompleto => seccion != null ? '$grado $seccion' : grado;
}

DateTime _dateTimeFromJson(String date) => DateTime.parse(date);
String _dateTimeToJson(DateTime date) => date.toIso8601String();

@JsonSerializable()
class GrupoCount {
  final int estudiantesGrupos;
  final int horarios;

  GrupoCount({
    required this.estudiantesGrupos,
    required this.horarios,
  });

  factory GrupoCount.fromJson(Map<String, dynamic> json) => _$GrupoCountFromJson(json);
  Map<String, dynamic> toJson() => _$GrupoCountToJson(this);
}

@JsonSerializable()
class PeriodoAcademico {
  final String id;
  final String nombre;
  @JsonKey(fromJson: _dateTimeFromJson, toJson: _dateTimeToJson)
  final DateTime fechaInicio;
  @JsonKey(fromJson: _dateTimeFromJson, toJson: _dateTimeToJson)
  final DateTime fechaFin;
  final bool activo;

  PeriodoAcademico({
    required this.id,
    required this.nombre,
    required this.fechaInicio,
    required this.fechaFin,
    required this.activo,
  });

  factory PeriodoAcademico.fromJson(Map<String, dynamic> json) => _$PeriodoAcademicoFromJson(json);
  Map<String, dynamic> toJson() => _$PeriodoAcademicoToJson(this);
}
/* Fin lib\models\grupo.dart */

/* Inicio lib\models\grupo.g.dart */


part of 'grupo.dart';

Grupo _$GrupoFromJson(Map<String, dynamic> json) => Grupo(
      id: json['id'] as String,
      nombre: json['nombre'] as String,
      grado: json['grado'] as String,
      seccion: json['seccion'] as String?,
      periodoId: json['periodoId'] as String,
      institucionId: json['institucionId'] as String,
      createdAt: _dateTimeFromJson(json['createdAt'] as String),
      periodoAcademico: PeriodoAcademico.fromJson(
          json['periodoAcademico'] as Map<String, dynamic>),
      count: GrupoCount.fromJson(json['_count'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$GrupoToJson(Grupo instance) => <String, dynamic>{
      'id': instance.id,
      'nombre': instance.nombre,
      'grado': instance.grado,
      'seccion': instance.seccion,
      'periodoId': instance.periodoId,
      'institucionId': instance.institucionId,
      'createdAt': _dateTimeToJson(instance.createdAt),
      'periodoAcademico': instance.periodoAcademico,
      '_count': instance.count,
    };

GrupoCount _$GrupoCountFromJson(Map<String, dynamic> json) => GrupoCount(
      estudiantesGrupos: (json['estudiantesGrupos'] as num).toInt(),
      horarios: (json['horarios'] as num).toInt(),
    );

Map<String, dynamic> _$GrupoCountToJson(GrupoCount instance) =>
    <String, dynamic>{
      'estudiantesGrupos': instance.estudiantesGrupos,
      'horarios': instance.horarios,
    };

PeriodoAcademico _$PeriodoAcademicoFromJson(Map<String, dynamic> json) =>
    PeriodoAcademico(
      id: json['id'] as String,
      nombre: json['nombre'] as String,
      fechaInicio: _dateTimeFromJson(json['fechaInicio'] as String),
      fechaFin: _dateTimeFromJson(json['fechaFin'] as String),
      activo: json['activo'] as bool,
    );

Map<String, dynamic> _$PeriodoAcademicoToJson(PeriodoAcademico instance) =>
    <String, dynamic>{
      'id': instance.id,
      'nombre': instance.nombre,
      'fechaInicio': _dateTimeToJson(instance.fechaInicio),
      'fechaFin': _dateTimeToJson(instance.fechaFin),
      'activo': instance.activo,
    };

/* Fin lib\models\grupo.g.dart */

/* Inicio lib\models\horario.dart */
import 'package:json_annotation/json_annotation.dart';
import 'grupo.dart';
import 'materia.dart';
import 'user.dart';

part 'horario.g.dart';

@JsonSerializable()
class Horario {
  final String id;
  final String periodoId;
  final String grupoId;
  final String materiaId;
  final String? profesorId;
  final int diaSemana;
  final String horaInicio;
  final String horaFin;
  final String institucionId;
  final DateTime createdAt;
  final Grupo grupo;
  final Materia materia;
  final PeriodoAcademico periodoAcademico;
  final User? profesor;

  Horario({
    required this.id,
    required this.periodoId,
    required this.grupoId,
    required this.materiaId,
    this.profesorId,
    required this.diaSemana,
    required this.horaInicio,
    required this.horaFin,
    required this.institucionId,
    required this.createdAt,
    required this.grupo,
    required this.materia,
    required this.periodoAcademico,
    this.profesor,
  });

  factory Horario.fromJson(Map<String, dynamic> json) => _$HorarioFromJson(json);

  Map<String, dynamic> toJson() => _$HorarioToJson(this);

  String get diaSemanaNombre {
    const dias = ['Lunes', 'Martes', 'MiÃ©rcoles', 'Jueves', 'Viernes', 'SÃ¡bado', 'Domingo'];
    return dias[diaSemana - 1];
  }

  String get horarioFormato => '$horaInicio - $horaFin';

  String get descripcion => '${materia.nombre} - ${grupo.nombreCompleto}${profesor != null ? ' (${profesor!.nombreCompleto})' : ''}';
}
/* Fin lib\models\horario.dart */

/* Inicio lib\models\horario.g.dart */


part of 'horario.dart';

Horario _$HorarioFromJson(Map<String, dynamic> json) => Horario(
      id: json['id'] as String,
      periodoId: json['periodoId'] as String,
      grupoId: json['grupoId'] as String,
      materiaId: json['materiaId'] as String,
      profesorId: json['profesorId'] as String?,
      diaSemana: (json['diaSemana'] as num).toInt(),
      horaInicio: json['horaInicio'] as String,
      horaFin: json['horaFin'] as String,
      institucionId: json['institucionId'] as String,
      createdAt: DateTime.parse(json['createdAt'] as String),
      grupo: Grupo.fromJson(json['grupo'] as Map<String, dynamic>),
      materia: Materia.fromJson(json['materia'] as Map<String, dynamic>),
      periodoAcademico: PeriodoAcademico.fromJson(
          json['periodoAcademico'] as Map<String, dynamic>),
      profesor: json['profesor'] == null
          ? null
          : User.fromJson(json['profesor'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$HorarioToJson(Horario instance) => <String, dynamic>{
      'id': instance.id,
      'periodoId': instance.periodoId,
      'grupoId': instance.grupoId,
      'materiaId': instance.materiaId,
      'profesorId': instance.profesorId,
      'diaSemana': instance.diaSemana,
      'horaInicio': instance.horaInicio,
      'horaFin': instance.horaFin,
      'institucionId': instance.institucionId,
      'createdAt': instance.createdAt.toIso8601String(),
      'grupo': instance.grupo,
      'materia': instance.materia,
      'periodoAcademico': instance.periodoAcademico,
      'profesor': instance.profesor,
    };

/* Fin lib\models\horario.g.dart */

/* Inicio lib\models\institution.dart */
import 'package:json_annotation/json_annotation.dart';

part 'institution.g.dart';

@JsonSerializable()
class Institution {
  final String id;
  final String nombre;
  final String? direccion;
  final String? telefono;
  final String? email;
  final bool activa;
  final DateTime? createdAt;
  final DateTime? updatedAt;
  final String? role
  final Map<String, dynamic>? metadata;

  Institution({
    required this.id,
    required this.nombre,
    this.direccion,
    this.telefono,
    this.email,
    this.activa = true,
    this.createdAt,
    this.updatedAt,
    this.role,
    this.metadata,
  });

  factory Institution.fromJson(Map<String, dynamic> json) => _$InstitutionFromJson(json);

  Map<String, dynamic> toJson() => _$InstitutionToJson(this);
  String get name => nombre;

  Institution copyWith({
    String? id,
    String? nombre,
    String? direccion,
    String? telefono,
    String? email,
    bool? activa,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? role,
    Map<String, dynamic>? metadata,
  }) {
    return Institution(
      id: id ?? this.id,
      nombre: nombre ?? this.nombre,
      direccion: direccion ?? this.direccion,
      telefono: telefono ?? this.telefono,
      email: email ?? this.email,
      activa: activa ?? this.activa,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      role: role ?? this.role,
      metadata: metadata ?? this.metadata,
    );
  }

  @override
  String toString() {
    return 'Institution(id: $id, nombre: $nombre, activa: $activa)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Institution && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;
}
/* Fin lib\models\institution.dart */

/* Inicio lib\models\institution.g.dart */


part of 'institution.dart';

Institution _$InstitutionFromJson(Map<String, dynamic> json) => Institution(
      id: json['id'] as String,
      nombre: json['nombre'] as String,
      direccion: json['direccion'] as String?,
      telefono: json['telefono'] as String?,
      email: json['email'] as String?,
      activa: json['activa'] as bool? ?? true,
      createdAt: json['createdAt'] == null
          ? null
          : DateTime.parse(json['createdAt'] as String),
      updatedAt: json['updatedAt'] == null
          ? null
          : DateTime.parse(json['updatedAt'] as String),
      role: json['role'] as String?,
      metadata: json['metadata'] as Map<String, dynamic>?,
    );

Map<String, dynamic> _$InstitutionToJson(Institution instance) =>
    <String, dynamic>{
      'id': instance.id,
      'nombre': instance.nombre,
      'direccion': instance.direccion,
      'telefono': instance.telefono,
      'email': instance.email,
      'activa': instance.activa,
      'createdAt': instance.createdAt?.toIso8601String(),
      'updatedAt': instance.updatedAt?.toIso8601String(),
      'role': instance.role,
      'metadata': instance.metadata,
    };

/* Fin lib\models\institution.g.dart */

/* Inicio lib\models\materia.dart */
import 'package:json_annotation/json_annotation.dart';

part 'materia.g.dart';

@JsonSerializable()
class Materia {
  final String id;
  final String nombre;
  final String? codigo;
  final String institucionId;
  final DateTime createdAt;

  Materia({
    required this.id,
    required this.nombre,
    this.codigo,
    required this.institucionId,
    required this.createdAt,
  });

  factory Materia.fromJson(Map<String, dynamic> json) => _$MateriaFromJson(json);

  Map<String, dynamic> toJson() => _$MateriaToJson(this);

  String get nombreConCodigo => codigo != null ? '$codigo - $nombre' : nombre;
}
/* Fin lib\models\materia.dart */

/* Inicio lib\models\materia.g.dart */


part of 'materia.dart';

Materia _$MateriaFromJson(Map<String, dynamic> json) => Materia(
      id: json['id'] as String,
      nombre: json['nombre'] as String,
      codigo: json['codigo'] as String?,
      institucionId: json['institucionId'] as String,
      createdAt: DateTime.parse(json['createdAt'] as String),
    );

Map<String, dynamic> _$MateriaToJson(Materia instance) => <String, dynamic>{
      'id': instance.id,
      'nombre': instance.nombre,
      'codigo': instance.codigo,
      'institucionId': instance.institucionId,
      'createdAt': instance.createdAt.toIso8601String(),
    };

/* Fin lib\models\materia.g.dart */

/* Inicio lib\models\pagination_types.dart */
import 'user.dart'
class PaginatedResponse<T> {
  final List<T> items;
  final PaginationInfo pagination;

  PaginatedResponse({required this.items, required this.pagination});
}
/* Fin lib\models\pagination_types.dart */

/* Inicio lib\models\user.dart */
import 'package:json_annotation/json_annotation.dart';
import '../constants/roles.dart';

part 'user.g.dart';

@JsonSerializable()
class User {
  final String id;
  final String email;
  final String nombres;
  final String apellidos;
  final String rol;
  final String? telefono;
  final String? identificacion;
  final bool activo;
  final List<UserInstitution>? instituciones;
  final StudentDetails? estudiante;
  final String? titulo;
  final String? especialidad;

  User({
    required this.id,
    required this.email,
    required this.nombres,
    required this.apellidos,
    required this.rol,
    this.telefono,
    this.identificacion,
    required this.activo,
    List<UserInstitution>? instituciones,
    this.estudiante,
    this.titulo,
    this.especialidad,
  }) : instituciones = instituciones ?? [];

  String get nombreCompleto => '$nombres $apellidos';

  bool get esProfesor => rol == UserRoles.profesor;
  bool get esEstudiante => rol == UserRoles.estudiante;
  bool get esAdminInstitucion => rol == UserRoles.adminInstitucion;
  bool get esSuperAdmin => rol == UserRoles.superAdmin;
  String get inicial {
    if (nombres.isNotEmpty) {
      return nombres[0].toUpperCase();
    }
    if (nombreCompleto.isNotEmpty && nombreCompleto != ' ') {
      return nombreCompleto[0].toUpperCase();
    }
    if (email.isNotEmpty) {
      return email[0].toUpperCase();
    }
    return '?';
  }

  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);

  Map<String, dynamic> toJson() => _$UserToJson(this);

  User copyWith({
    String? id,
    String? email,
    String? nombres,
    String? apellidos,
    String? rol,
    String? telefono,
    String? identificacion,
    bool? activo,
    List<UserInstitution>? instituciones,
    StudentDetails? estudiante,
    String? titulo,
    String? especialidad,
  }) {
    return User(
      id: id ?? this.id,
      email: email ?? this.email,
      nombres: nombres ?? this.nombres,
      apellidos: apellidos ?? this.apellidos,
      rol: rol ?? this.rol,
      telefono: telefono ?? this.telefono,
      identificacion: identificacion ?? this.identificacion,
      activo: activo ?? this.activo,
      instituciones: instituciones ?? this.instituciones,
      estudiante: estudiante ?? this.estudiante,
      titulo: titulo ?? this.titulo,
      especialidad: especialidad ?? this.especialidad,
    );
  }
}

@JsonSerializable()
class UserInstitution {
  final String id;
  final String nombre;
  final String? rolEnInstitucion;
  final bool activo;

  UserInstitution({
    required this.id,
    required this.nombre,
    this.rolEnInstitucion,
    required this.activo,
  });

  factory UserInstitution.fromJson(Map<String, dynamic> json) => _$UserInstitutionFromJson(json);

  Map<String, dynamic> toJson() => _$UserInstitutionToJson(this);
}

@JsonSerializable()
class StudentDetails {
  final String id;
  final String identificacion;
  final String codigoQr;
  final String? nombreResponsable;
  final String? telefonoResponsable;

  StudentDetails({
    required this.id,
    required this.identificacion,
    required this.codigoQr,
    this.nombreResponsable,
    this.telefonoResponsable,
  });

  factory StudentDetails.fromJson(Map<String, dynamic> json) => _$StudentDetailsFromJson(json);

  Map<String, dynamic> toJson() => _$StudentDetailsToJson(this);
}
class CreateUserRequest {
  final String email;
  final String password;
  final String nombres;
  final String apellidos;
  final String rol;
  final String? telefono;
  final String? institucionId;
  final String? rolEnInstitucion;
  final String? identificacion;
  final String? nombreResponsable;
  final String? telefonoResponsable;
  final String? titulo;
  final String? especialidad;

  CreateUserRequest({
    required this.email,
    required this.password,
    required this.nombres,
    required this.apellidos,
    required this.rol,
    this.telefono,
    this.institucionId,
    this.rolEnInstitucion,
    this.identificacion,
    this.nombreResponsable,
    this.telefonoResponsable,
    this.titulo,
    this.especialidad,
  });

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = {
      'email': email,
      'password': password,
      'nombres': nombres,
      'apellidos': apellidos,
      'rol': rol,
      if (telefono != null) 'telefono': telefono,
      if (institucionId != null) 'institucionId': institucionId,
      if (rolEnInstitucion != null) 'rolEnInstitucion': rolEnInstitucion,
    };
    if (rol == UserRoles.estudiante) {
      if (identificacion != null) data['identificacion'] = identificacion;
      if (nombreResponsable != null) data['nombreResponsable'] = nombreResponsable;
      if (telefonoResponsable != null) data['telefonoResponsable'] = telefonoResponsable;
    }
    if (rol == UserRoles.profesor) {
      if (titulo != null) data['titulo'] = titulo;
      if (especialidad != null) data['especialidad'] = especialidad;
    }

    return data;
  }
}

class UpdateUserRequest {
  final String? email;
  final String? nombres;
  final String? apellidos;
  final String? telefono;
  final bool? activo;
  final String? identificacion;
  final String? nombreResponsable;
  final String? telefonoResponsable;
  final String? titulo;
  final String? especialidad;

  UpdateUserRequest({
    this.email,
    this.nombres,
    this.apellidos,
    this.telefono,
    this.activo,
    this.identificacion,
    this.nombreResponsable,
    this.telefonoResponsable,
    this.titulo,
    this.especialidad,
  });

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = {};

    if (email != null) data['email'] = email;
    if (nombres != null) data['nombres'] = nombres;
    if (apellidos != null) data['apellidos'] = apellidos;
    if (telefono != null) data['telefono'] = telefono;
    if (activo != null) data['activo'] = activo;
    if (identificacion != null) data['identificacion'] = identificacion;
    if (nombreResponsable != null) data['nombreResponsable'] = nombreResponsable;
    if (telefonoResponsable != null) data['telefonoResponsable'] = telefonoResponsable;
    if (titulo != null) data['titulo'] = titulo;
    if (especialidad != null) data['especialidad'] = especialidad;

    return data;
  }
}

@JsonSerializable()
class PaginationInfo {
  final int page;
  final int limit;
  final int total;
  final int totalPages;
  final bool hasNext;
  final bool hasPrev;

  PaginationInfo({
    required this.page,
    required this.limit,
    required this.total,
    required this.totalPages,
    required this.hasNext,
    required this.hasPrev,
  });

  factory PaginationInfo.fromJson(Map<String, dynamic> json) => _$PaginationInfoFromJson(json);

  Map<String, dynamic> toJson() => _$PaginationInfoToJson(this);
}
/* Fin lib\models\user.dart */

/* Inicio lib\models\user.g.dart */


part of 'user.dart';

User _$UserFromJson(Map<String, dynamic> json) => User(
      id: json['id'] as String,
      email: json['email'] as String,
      nombres: json['nombres'] as String,
      apellidos: json['apellidos'] as String,
      rol: json['rol'] as String,
      telefono: json['telefono'] as String?,
      identificacion: json['identificacion'] as String?,
      activo: json['activo'] as bool,
      instituciones: (json['instituciones'] as List<dynamic>?)
          ?.map((e) => UserInstitution.fromJson(e as Map<String, dynamic>))
          .toList(),
      estudiante: json['estudiante'] == null
          ? null
          : StudentDetails.fromJson(json['estudiante'] as Map<String, dynamic>),
      titulo: json['titulo'] as String?,
      especialidad: json['especialidad'] as String?,
    );

Map<String, dynamic> _$UserToJson(User instance) => <String, dynamic>{
      'id': instance.id,
      'email': instance.email,
      'nombres': instance.nombres,
      'apellidos': instance.apellidos,
      'rol': instance.rol,
      'telefono': instance.telefono,
      'identificacion': instance.identificacion,
      'activo': instance.activo,
      'instituciones': instance.instituciones,
      'estudiante': instance.estudiante,
      'titulo': instance.titulo,
      'especialidad': instance.especialidad,
    };

UserInstitution _$UserInstitutionFromJson(Map<String, dynamic> json) =>
    UserInstitution(
      id: json['id'] as String,
      nombre: json['nombre'] as String,
      rolEnInstitucion: json['rolEnInstitucion'] as String?,
      activo: json['activo'] as bool,
    );

Map<String, dynamic> _$UserInstitutionToJson(UserInstitution instance) =>
    <String, dynamic>{
      'id': instance.id,
      'nombre': instance.nombre,
      'rolEnInstitucion': instance.rolEnInstitucion,
      'activo': instance.activo,
    };

StudentDetails _$StudentDetailsFromJson(Map<String, dynamic> json) =>
    StudentDetails(
      id: json['id'] as String,
      identificacion: json['identificacion'] as String,
      codigoQr: json['codigoQr'] as String,
      nombreResponsable: json['nombreResponsable'] as String?,
      telefonoResponsable: json['telefonoResponsable'] as String?,
    );

Map<String, dynamic> _$StudentDetailsToJson(StudentDetails instance) =>
    <String, dynamic>{
      'id': instance.id,
      'identificacion': instance.identificacion,
      'codigoQr': instance.codigoQr,
      'nombreResponsable': instance.nombreResponsable,
      'telefonoResponsable': instance.telefonoResponsable,
    };

PaginationInfo _$PaginationInfoFromJson(Map<String, dynamic> json) =>
    PaginationInfo(
      page: (json['page'] as num).toInt(),
      limit: (json['limit'] as num).toInt(),
      total: (json['total'] as num).toInt(),
      totalPages: (json['totalPages'] as num).toInt(),
      hasNext: json['hasNext'] as bool,
      hasPrev: json['hasPrev'] as bool,
    );

Map<String, dynamic> _$PaginationInfoToJson(PaginationInfo instance) =>
    <String, dynamic>{
      'page': instance.page,
      'limit': instance.limit,
      'total': instance.total,
      'totalPages': instance.totalPages,
      'hasNext': instance.hasNext,
      'hasPrev': instance.hasPrev,
    };

/* Fin lib\models\user.g.dart */

/* Inicio lib\providers\asistencia_provider.dart */
import 'dart:async';
import 'package:flutter/foundation.dart';
import '../services/asistencia_service.dart';
import '../models/asistencia_estudiante.dart';

enum AsistenciaState {
  initial,
  loading,
  loaded,
  error,
}

class AsistenciaProvider with ChangeNotifier {
  final AsistenciaService _asistenciaService;

  AsistenciaProvider({AsistenciaService? asistenciaService})
      : _asistenciaService = asistenciaService ?? AsistenciaService();

  AsistenciaState _state = AsistenciaState.initial;
  String? _errorMessage;
  List<AsistenciaEstudiante> _asistencias = [];
  String? _selectedHorarioId;
  AsistenciaState get state => _state;
  String? get errorMessage => _errorMessage;
  List<AsistenciaEstudiante> get asistencias => _asistencias;
  String? get selectedHorarioId => _selectedHorarioId;

  bool get isLoading => _state == AsistenciaState.loading;
  bool get hasError => _state == AsistenciaState.error;
  bool get isLoaded => _state == AsistenciaState.loaded;
  int get totalEstudiantes => _asistencias.length;
  int get presentes => _asistencias.where((a) => a.estaPresente).length;
  int get ausentes => _asistencias.where((a) => a.estaAusente).length;
  int get tardanzas => _asistencias.where((a) => a.tieneTardanza).length;
  int get justificados => _asistencias.where((a) => a.estaJustificado).length;
  int get sinRegistrar => _asistencias.where((a) => a.sinRegistrar).length;
  Future<void> fetchAsistencias(String accessToken, String horarioId, {DateTime? date}) async {
    try {
      debugPrint('AsistenciaProvider: Loading asistencias for horario: $horarioId');
      _setState(AsistenciaState.loading);

      final asistencias = await _asistenciaService.getAsistencias(
        accessToken: accessToken,
        horarioId: horarioId,
        date: date,
      );

      _asistencias = asistencias;
      _selectedHorarioId = horarioId;
      _setState(AsistenciaState.loaded);
      debugPrint('AsistenciaProvider: Loaded ${asistencias.length} asistencias');
    } catch (e) {
      debugPrint('AsistenciaProvider: Error loading asistencias: $e');
      _setState(AsistenciaState.error, e.toString());
    }
  }
  Future<bool> registrarAsistencia(String accessToken, String horarioId, String qrCode) async {
    try {
      debugPrint('AsistenciaProvider: Registrando asistencia con QR: $qrCode');
      final success = await _asistenciaService.registrarAsistencia(
        accessToken: accessToken,
        horarioId: horarioId,
        codigoQr: qrCode,
      );

      if (success && _selectedHorarioId == horarioId) {
        debugPrint('AsistenciaProvider: Refrescando lista de asistencias...');
        await fetchAsistencias(accessToken, horarioId);
      }

      return success;
    } catch (e) {
      debugPrint('AsistenciaProvider: Error registrando asistencia con QR: $e');
      return false;
    }
  }
  Future<bool> registrarAsistenciaManual(String accessToken, String horarioId, String estudianteId) async {
    try {
      debugPrint('AsistenciaProvider: Registrando asistencia manual para estudiante: $estudianteId');
      final success = await _asistenciaService.registrarAsistenciaManual(
        accessToken: accessToken,
        horarioId: horarioId,
        estudianteId: estudianteId,
      );

      if (success && _selectedHorarioId == horarioId) {
        debugPrint('AsistenciaProvider: Refrescando lista de asistencias...');
        await fetchAsistencias(accessToken, horarioId);
      }

      return success;
    } catch (e) {
      debugPrint('AsistenciaProvider: Error registrando asistencia manual: $e');
      return false;
    }
  }
  Future<bool> updateAsistencia({
    required String accessToken,
    required String asistenciaId,
    required String estado,
    String? observacion,
    bool? justificada,
  }) async {
    try {
      debugPrint('AsistenciaProvider: Actualizando asistencia: $asistenciaId');
      final success = await _asistenciaService.updateAsistencia(
        accessToken: accessToken,
        asistenciaId: asistenciaId,
        estado: estado,
        observacion: observacion,
        justificada: justificada,
      );

      if (success && _selectedHorarioId != null) {
        debugPrint('AsistenciaProvider: Refrescando lista de asistencias...');
        await fetchAsistencias(accessToken, _selectedHorarioId!);
      }

      return success;
    } catch (e) {
      debugPrint('AsistenciaProvider: Error actualizando asistencia: $e');
      return false;
    }
  }
  Future<void> refreshAsistencias(String accessToken) async {
    if (_selectedHorarioId != null) {
      await fetchAsistencias(accessToken, _selectedHorarioId!);
    }
  }
  List<AsistenciaEstudiante> searchEstudiantes(String query) {
    if (query.isEmpty) return _asistencias;

    final lowercaseQuery = query.toLowerCase();
    return _asistencias.where((asistencia) {
      return asistencia.nombreCompleto.toLowerCase().contains(lowercaseQuery) ||
             asistencia.identificacion.toLowerCase().contains(lowercaseQuery);
    }).toList();
  }
  Map<String, int> getEstadisticas() {
    return {
      'total': totalEstudiantes,
      'presentes': presentes,
      'ausentes': ausentes,
      'tardanzas': tardanzas,
      'justificados': justificados,
      'sinRegistrar': sinRegistrar,
    };
  }
  double getPorcentajeAsistencia() {
    if (totalEstudiantes == 0) return 0.0;
    return (presentes + justificados) / totalEstudiantes;
  }
  void clearData() {
    _asistencias = [];
    _selectedHorarioId = null;
    _setState(AsistenciaState.initial);
  }
  void selectHorario(String horarioId) {
    _selectedHorarioId = horarioId;
    notifyListeners();
  }
  void _setState(AsistenciaState newState, [String? errorMessage]) {
    _state = newState;
    _errorMessage = errorMessage;
    notifyListeners();
  }
}
/* Fin lib\providers\asistencia_provider.dart */

/* Inicio lib\providers\auth_provider.dart */
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../services/auth_service.dart';
import '../models/institution.dart';
import 'user_provider.dart';
import 'institution_provider.dart';

class AuthProvider with ChangeNotifier {
  final AuthService _authService;

  String? _accessToken;
  String? _refreshToken;
  Map<String, dynamic>? _user;
  String? _selectedInstitutionId;
  List<Institution>? _institutions;

  String? get accessToken => _accessToken;
  String? get refreshToken => _refreshToken;
  Map<String, dynamic>? get user => _user;
  String? get selectedInstitutionId => _selectedInstitutionId;
  List<Institution>? get institutions => _institutions;
  String? get administrationName {
    if (_user == null) return null;
    try {
      final userMap = _user!;
      if (userMap['administracion'] is Map) {
        final nombre = userMap['administracion']?['nombre'] as String?;
        if (nombre != null && nombre.isNotEmpty) return nombre;
      }
      final alt = (userMap['administracionNombre'] as String?) ??
          (userMap['administracion_nombre'] as String?) ??
          (userMap['company'] as String?) ??
          (userMap['organizacion'] as String?) ??
          (userMap['organization'] as String?);
      if (alt != null && alt.isNotEmpty) return alt;
      if (userMap['usuarioInstituciones'] is List) {
        final lista = userMap['usuarioInstituciones'] as List;
        if (lista.isNotEmpty) {
          final first = lista.first;
          if (first is Map) {
            if (first['institucion'] is Map) {
              final nombre = first['institucion']?['nombre'] as String?;
              if (nombre != null && nombre.isNotEmpty) return nombre;
            }
            final direct = first['nombre'] as String?;
            if (direct != null && direct.isNotEmpty) return direct;
          }
        }
      }
    } catch (e) {
      debugPrint('Error extracting administrationName: $e');
    }
    return null;
  }

  bool get isAuthenticated => _accessToken != null && _user != null;

  Institution? get selectedInstitution {
    if (_selectedInstitutionId == null || _institutions == null) return null;
    try {
      return _institutions!.firstWhere(
        (institution) => institution.id == _selectedInstitutionId,
      );
    } catch (e) {
      return null;
    }
  }
  AuthProvider({AuthService? authService}) : _authService = authService ?? AuthService() {
    _loadTokensFromStorage();
  }

  Future<void> _loadTokensFromStorage() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      _accessToken = prefs.getString('accessToken');
      _refreshToken = prefs.getString('refreshToken');
      final userJson = prefs.getString('user');
      if (userJson != null) {
        _user = Map<String, dynamic>.from(jsonDecode(userJson));
      }
      _selectedInstitutionId = prefs.getString('selectedInstitutionId');
      notifyListeners();
    } catch (e) {
      debugPrint('Error loading from storage: $e');
    }
  }

  Future<void> _saveTokensToStorage() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      if (_accessToken != null) {
        await prefs.setString('accessToken', _accessToken!);
      } else {
        await prefs.remove('accessToken');
      }
      if (_refreshToken != null) {
        await prefs.setString('refreshToken', _refreshToken!);
      } else {
        await prefs.remove('refreshToken');
      }
      if (_user != null) {
        await prefs.setString('user', jsonEncode(_user));
      } else {
        await prefs.remove('user');
      }
      if (_selectedInstitutionId != null) {
        await prefs.setString('selectedInstitutionId', _selectedInstitutionId!);
      } else {
        await prefs.remove('selectedInstitutionId');
      }
    } catch (e) {
      debugPrint('Error saving to storage: $e');
    }
  }

  Future<void> _clearTokens() async {
    _accessToken = null;
    _refreshToken = null;
    _user = null;
    _selectedInstitutionId = null;
    await _saveTokensToStorage();
    notifyListeners();
  }

  void clearHeavyData() {
    _institutions = null;
    notifyListeners();
  }

  void clearTemporaryData() {
    _institutions = null;
    _selectedInstitutionId = null;
    notifyListeners();
  }

  Future<void> recoverFullState() async {
    if (_accessToken != null) {
      debugPrint('Recuperando estado completo del usuario');
      await loadUserInstitutions();

      if (_selectedInstitutionId != null && _institutions != null) {
        final institutionExists = _institutions!.any((i) => i.id == _selectedInstitutionId);
        if (!institutionExists) {
          debugPrint('InstituciÃ³n guardada ya no existe, limpiando');
          _selectedInstitutionId = null;
          await _saveTokensToStorage();
        }
      }

      notifyListeners();
    }
  }

  Future<void> loadUserInstitutions({bool notify = true}) async {
    if (_accessToken == null) return;

    try {
      final institutionMaps = await _authService.getUserInstitutions(_accessToken!);
      _institutions = institutionMaps?.map((map) => Institution.fromJson(map)).toList();
      if (notify) notifyListeners();
    } catch (e) {
      debugPrint('Error loading user institutions: $e');
    }
  }

  void selectInstitution(String institutionId) {
    _selectedInstitutionId = institutionId;
    _saveTokensToStorage();
    notifyListeners();
  }

  Future<bool> login(String email, String password) async {
    try {
      final result = await _authService.login(email, password);
      if (result != null) {
        _accessToken = result.accessToken;
        _refreshToken = result.refreshToken;
        _user = result.user;

        await loadUserInstitutions(notify: false);
        if (_user?['rol'] == 'super_admin') {
          _selectedInstitutionId = null;
          debugPrint('Super Admin: No requiere selecciÃ³n de instituciÃ³n (acceso global)');
        } else if (_institutions != null && _institutions!.length == 1) {
          _selectedInstitutionId = _institutions!.first.id;
          debugPrint('InstituciÃ³n seleccionada automÃ¡ticamente: $_selectedInstitutionId');
        } else if (_institutions != null && _institutions!.length > 1) {
          _selectedInstitutionId = null;
          debugPrint('MÃºltiples instituciones encontradas, esperando selecciÃ³n manual');
        }

        await _saveTokensToStorage();
        notifyListeners();
        return true;
      }
      return false;
    } catch (e) {
      debugPrint('Login error: $e');
      rethrow;
    }
  }

  Future<bool> refreshAccessToken() async {
    if (_refreshToken == null) return false;

    try {
      final result = await _authService.refreshToken(_refreshToken!);
      if (result != null) {
        _accessToken = result.accessToken;
        _refreshToken = result.refreshToken;
        await _saveTokensToStorage();
        notifyListeners();
        return true;
      }
      return false;
    } catch (e) {
      debugPrint('Refresh error: $e');
      return false;
    }
  }

  Future<void> logout() async {
    if (_refreshToken != null) {
      await _authService.logout(_refreshToken!);
    }
    await _clearTokens();
  }

  Future<void> logoutAndClearAllData(BuildContext context) async {
    if (_refreshToken != null) {
      await _authService.logout(_refreshToken!);
    }
    await _clearTokens();
    if (context.mounted) {
      try {
        final userProvider = Provider.of<UserProvider>(context, listen: false);
        userProvider.clearData();

        final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);
        institutionProvider.clearData();
      } catch (e) {
        debugPrint('Error clearing provider data: $e');
      }
    }
  }
}
/* Fin lib\providers\auth_provider.dart */

/* Inicio lib\providers\common_types.dart */

export '../models/pagination_types.dart';
/* Fin lib\providers\common_types.dart */

/* Inicio lib\providers\estudiantes_by_grupo_paginated_provider.dart */
import 'package:flutter/foundation.dart';
import 'paginated_data_mixin.dart';
import '../models/pagination_types.dart';
import '../services/academic/grupo_service.dart';
import '../models/user.dart';

class EstudiantesByGrupoPaginatedProvider extends ChangeNotifier with PaginatedDataMixin<User> {
  final GrupoService _grupoService;

  EstudiantesByGrupoPaginatedProvider({GrupoService? grupoService})
      : _grupoService = grupoService ?? GrupoService();

  @override
  Future<PaginatedResponse<User>?> fetchPage(String accessToken, {int page = 1, int? limit, String? search, Map<String, String>? filters}) async {
      final grupoId = filters?['grupoId']?.trim();

      if (grupoId == null || grupoId.isEmpty) {
        return null;
      }

      final response = await _grupoService.getEstudiantesByGrupo(
        accessToken,
        grupoId,
        page: page,
        limit: limit,
      );

      if (response == null) {
        return null;
      }

      return PaginatedResponse(
        items: response.users,
        pagination: response.pagination,
      );
  }

  @override
  Future<User?> createItemApi(String accessToken, dynamic data) async {
    return null;
  }

  @override
  Future<bool> deleteItemApi(String accessToken, String id) async {
    return false;
  }

  @override
  Future<User?> updateItemApi(String accessToken, String id, dynamic data) async {
    return null;
  }
}

/* Fin lib\providers\estudiantes_by_grupo_paginated_provider.dart */

/* Inicio lib\providers\estudiantes_sin_asignar_paginated_provider.dart */
import 'package:flutter/foundation.dart';
import '../models/pagination_types.dart';
import 'paginated_data_mixin.dart';
import '../services/academic/grupo_service.dart';
import '../models/user.dart';

class EstudiantesSinAsignarPaginatedProvider extends ChangeNotifier with PaginatedDataMixin<User> {
  final GrupoService _grupoService;

  EstudiantesSinAsignarPaginatedProvider({GrupoService? grupoService})
      : _grupoService = grupoService ?? GrupoService();

  @override
  Future<PaginatedResponse<User>?> fetchPage(String accessToken, {int page = 1, int? limit, String? search, Map<String, String>? filters}) async {
  final response = await _grupoService.getEstudiantesSinAsignar(accessToken, page: page, limit: limit);
    if (response == null) return null;
    return PaginatedResponse(items: response.users, pagination: response.pagination);
  }

  @override
  Future<User?> createItemApi(String accessToken, dynamic data) async {
    return null;
  }

  @override
  Future<bool> deleteItemApi(String accessToken, String id) async {
    return false;
  }

  @override
  Future<User?> updateItemApi(String accessToken, String id, dynamic data) async {
    return null;
  }
}

/* Fin lib\providers\estudiantes_sin_asignar_paginated_provider.dart */

/* Inicio lib\providers\grupo_provider.dart */
import 'dart:async';
import 'package:flutter/foundation.dart';
import '../models/pagination_types.dart';
import '../services/academic/grupo_service.dart';
import '../models/grupo.dart';
import 'paginated_data_mixin.dart';

class GrupoProvider extends ChangeNotifier with PaginatedDataMixin<Grupo> {
  final GrupoService _grupoService;

  GrupoProvider({GrupoService? grupoService})
      : _grupoService = grupoService ?? GrupoService();

  String? _errorMessage;
  Grupo? _selectedGrupo;
  String? _selectedPeriodoId;
  @override
  String? get errorMessage => _errorMessage;
  List<Grupo> get grupos => items;
  Grupo? get selectedGrupo => _selectedGrupo;
  String? get selectedPeriodoId => _selectedPeriodoId;
  List<Grupo> get gruposActivos => items.where((grupo) => grupo.periodoAcademico.activo).toList();
  List<Grupo> get gruposInactivos => items.where((grupo) => !grupo.periodoAcademico.activo).toList();
  int get loadedGruposCount => items.length;
  int get gruposActivosCount => gruposActivos.length;
  int get gruposInactivosCount => gruposInactivos.length;
  int get totalGruposFromPagination => paginationInfo?.total ?? 0;
  Future<void> loadGrupos(String accessToken, {int? page, int? limit, String? periodoId, String? search}) async {
  if (isLoading) return;
    resetPagination()

    try {
      debugPrint('GrupoProvider: Iniciando carga de grupos...');
      await loadItems(accessToken, page: page ?? 1, limit: limit, search: search, filters: {
        if (periodoId != null) 'periodoId': periodoId,
      });
  notifyListeners();
      debugPrint('GrupoProvider: Estado cambiado a loaded');
    } catch (e) {
      debugPrint('GrupoProvider: Error loading grupos: $e');
  setError(e.toString());
    }
  }
  Future<void> loadGruposByPeriodo(String accessToken, String periodoId, {int? page, int limit = 10, String? search}) async {
  if (isLoading) return;
    _selectedPeriodoId = periodoId;
    resetPagination()

    try {
      debugPrint('GrupoProvider: Iniciando carga de grupos por periodo $periodoId...');
  _selectedPeriodoId = periodoId
      await loadItems(accessToken, page: page ?? 1, limit: limit, search: search, filters: {
        'periodoId': periodoId,
      });
  notifyListeners();
      debugPrint('GrupoProvider: Estado cambiado a loaded');
    } catch (e) {
      debugPrint('GrupoProvider: Error loading grupos by periodo: $e');
  setError(e.toString());
    }
  }
  Future<void> loadGrupoById(String accessToken, String grupoId) async {
  if (isLoading) return;

    try {
      final grupo = await _grupoService.getGrupoById(accessToken, grupoId);
      if (grupo != null) {
        _selectedGrupo = grupo;
  notifyListeners();
      } else {
  setError('Grupo no encontrado');
      }
    } catch (e) {
      debugPrint('Error loading grupo: $e');
  setError(e.toString());
    }
  }
  Future<bool> createGrupo(String accessToken, CreateGrupoRequest grupoData) async {
    if (isLoading) return false;

    try {
      final newGrupo = await _grupoService.createGrupo(accessToken, grupoData);
      if (newGrupo != null) {
        items.insert(0, newGrupo);
  notifyListeners();
        return true;
      } else {
  setError('Error al crear grupo');
        return false;
      }
    } catch (e) {
      debugPrint('Error creating grupo: $e');
  setError(e.toString());
      return false;
    }
  }
  Future<bool> updateGrupo(String accessToken, String grupoId, UpdateGrupoRequest grupoData) async {
    if (isLoading) return false;

    try {
      final updatedGrupo = await _grupoService.updateGrupo(accessToken, grupoId, grupoData);
      if (updatedGrupo != null) {
  final index = items.indexWhere((grupo) => grupo.id == grupoId);
        if (index != -1) {
          items[index] = updatedGrupo;
        }
        if (_selectedGrupo?.id == grupoId) {
          _selectedGrupo = updatedGrupo;
        }

  notifyListeners();
        return true;
      } else {
  setError('Error al actualizar grupo');
        return false;
      }
    } catch (e) {
      debugPrint('Error updating grupo: $e');
  setError(e.toString());
      return false;
    }
  }
  Future<bool> deleteGrupo(String accessToken, String grupoId) async {
    try {
      final success = await _grupoService.deleteGrupo(accessToken, grupoId);

      if (!success) {
        setError('Error al eliminar el grupo desde el servicio.');
      }
      return success;
    } catch (e) {
      debugPrint('Error deleting grupo: $e');
      setError(e.toString());
      return false;
    }
  }
  void selectGrupo(Grupo grupo) {
    _selectedGrupo = grupo;
    notifyListeners();
  }
  void clearSelectedGrupo() {
    _selectedGrupo = null;
    notifyListeners();
  }
  void clearData() {
  clearItems();
    _selectedGrupo = null;
    _selectedPeriodoId = null;
  clearError();
  }
  Future<void> refreshData(String accessToken) async {
    if (_selectedPeriodoId != null) {
      await loadGruposByPeriodo(accessToken, _selectedPeriodoId!);
    } else {
      await loadGrupos(accessToken);
    }
  }
  List<Grupo> searchGrupos(String query) {
  if (query.isEmpty) return items;

    final lowercaseQuery = query.toLowerCase();
  return items.where((grupo) {
      return grupo.nombre.toLowerCase().contains(lowercaseQuery) ||
             grupo.grado.toLowerCase().contains(lowercaseQuery) ||
             (grupo.seccion?.toLowerCase().contains(lowercaseQuery) ?? false);
    }).toList();
  }
  List<Grupo> filterGruposByGrado(String grado) {
    if (grado.isEmpty) return items;
    return items.where((grupo) => grupo.grado == grado).toList();
  }
  List<Grupo> filterGruposByPeriodoStatus({bool? activo}) {
    if (activo == null) return items;
    return items.where((grupo) => grupo.periodoAcademico.activo == activo).toList();
  }
  @override
  Future<void> loadNextPage(String accessToken, {Map<String, String>? filters}) async {
  if (paginationInfo == null || !paginationInfo!.hasNext || isLoading) return;

  final nextPage = paginationInfo!.page + 1;
    if (_selectedPeriodoId != null) {
  await loadGruposByPeriodo(accessToken, _selectedPeriodoId!, page: nextPage, limit: paginationInfo!.limit);
    } else {
  await loadGrupos(accessToken, page: nextPage, limit: paginationInfo!.limit);
    }
  }
  Future<void> loadPreviousPage(String accessToken) async {
  if (paginationInfo == null || !paginationInfo!.hasPrev || isLoading) return;

  final prevPage = paginationInfo!.page - 1;
    if (_selectedPeriodoId != null) {
  await loadGruposByPeriodo(accessToken, _selectedPeriodoId!, page: prevPage, limit: paginationInfo!.limit);
    } else {
  await loadGrupos(accessToken, page: prevPage, limit: paginationInfo!.limit);
    }
  }
  Future<void> loadPage(String accessToken, int page) async {
  if (isLoading) return;

    if (_selectedPeriodoId != null) {
  await loadGruposByPeriodo(accessToken, _selectedPeriodoId!, page: page, limit: paginationInfo?.limit ?? 10);
    } else {
  await loadGrupos(accessToken, page: page, limit: paginationInfo?.limit ?? 10);
    }
  }
  Map<String, int> getGruposStatistics() {
    return {
  'total': paginationInfo?.total ?? 0,
      'activos': gruposActivosCount,
      'inactivos': gruposInactivosCount,
    };
  }
  Future<void> loadMoreGrupos(String accessToken, {String? periodoId, String? search}) async {
    if (isLoadingMore || !hasMoreData || paginationInfo == null) return;
    if (periodoId != null) {
      setFilter('periodoId', periodoId);
    } else if (_selectedPeriodoId != null) {
      setFilter('periodoId', _selectedPeriodoId);
    }
    if (search != null) {
      setFilter('search', search);
    }
    await super.loadNextPage(accessToken);
  }
  Future<List<Grupo>?> searchGruposRemote(String accessToken, {String? search, int limit = 10}) async {
    try {
      final response = await _grupoService.getGrupos(
        accessToken,
        page: 1,
        limit: limit,
        search: search,
      );
      return response?.grupos;
    } catch (e) {
      debugPrint('Error searchGruposRemote: $e');
      return null;
    }
  }
  @override
  void resetPagination() {
    super.resetPagination();
  }

  @override
  Future<PaginatedResponse<Grupo>?> fetchPage(String accessToken, {int page = 1, int? limit, String? search, Map<String, String>? filters}) async {
    final periodoId = filters?['periodoId'] ?? _selectedPeriodoId;
    final searchFromFilters = search ?? filters?['search'];
    final response = await _grupoService.getGrupos(
      accessToken,
      page: page,
      limit: limit,
      periodoId: periodoId,
      search: searchFromFilters,
    );
    if (response == null) return null;
    return PaginatedResponse(items: response.grupos, pagination: response.pagination);
  }

  @override
  Future<Grupo?> createItemApi(String accessToken, dynamic data) async {
    final created = await _grupoService.createGrupo(accessToken, data as CreateGrupoRequest);
    return created;
  }

  @override
  Future<bool> deleteItemApi(String accessToken, String id) async {
    return await _grupoService.deleteGrupo(accessToken, id);
  }

  @override
  Future<Grupo?> updateItemApi(String accessToken, String id, dynamic data) async {
  final updated = await _grupoService.updateGrupo(accessToken, id, data as UpdateGrupoRequest);
    return updated;
  }
  @Deprecated('Use EstudiantesByGrupoPaginatedProvider instead')
  Future<void> loadEstudiantesByGrupo(String accessToken, String grupoId, {int? page, int? limit}) async {
    debugPrint('loadEstudiantesByGrupo is deprecated; use EstudiantesByGrupoPaginatedProvider instead.');
    try {
      await _grupoService.getEstudiantesByGrupo(accessToken, grupoId, page: page ?? 1, limit: limit ?? 10);
    } catch (e) {
      debugPrint('Error in deprecated loadEstudiantesByGrupo: $e');
      setError(e.toString());
    }
  }

  @Deprecated('Use EstudiantesSinAsignarPaginatedProvider instead')
  Future<void> loadEstudiantesSinAsignar(String accessToken, {int? page, int? limit}) async {
    debugPrint('loadEstudiantesSinAsignar is deprecated; use EstudiantesSinAsignarPaginatedProvider instead.');
    try {
      await _grupoService.getEstudiantesSinAsignar(accessToken, page: page ?? 1, limit: limit ?? 10);
    } catch (e) {
      debugPrint('Error in deprecated loadEstudiantesSinAsignar: $e');
      setError(e.toString());
    }
  }
  Future<bool> asignarEstudianteAGrupo(String accessToken, String grupoId, String estudianteId) async {
    try {
      final success = await _grupoService.asignarEstudianteAGrupo(accessToken, grupoId, estudianteId);
      if (success) {
        notifyListeners();
      }
      return success;
    } catch (e) {
      debugPrint('Error asignando estudiante a grupo: $e');
      setError(e.toString());
      notifyListeners();
      return false;
    }
  }
  Future<bool> desasignarEstudianteDeGrupo(String accessToken, String grupoId, String estudianteId) async {
    try {
      final success = await _grupoService.desasignarEstudianteDeGrupo(accessToken, grupoId, estudianteId);
      if (success) {
        notifyListeners();
      }
      return success;
    } catch (e) {
      debugPrint('Error desasignando estudiante de grupo: $e');
      setError(e.toString());
      notifyListeners();
      return false;
    }
  }
  void clearEstudiantesData() {
    notifyListeners();
  }
}
/* Fin lib\providers\grupo_provider.dart */

/* Inicio lib\providers\horario_paginated_provider.dart */
import 'package:flutter/foundation.dart';
import '../models/pagination_types.dart';
import 'paginated_data_mixin.dart';
import '../services/academic/horario_service.dart';
import '../models/horario.dart';

class HorarioPaginatedProvider extends ChangeNotifier with PaginatedDataMixin<Horario> {
  final HorarioService _horarioService;

  HorarioPaginatedProvider({HorarioService? horarioService})
      : _horarioService = horarioService ?? HorarioService();
  @override
  Future<PaginatedResponse<Horario>?> fetchPage(String accessToken, {int page = 1, int? limit, String? search, Map<String, String>? filters}) async {
    final grupoId = filters?['grupoId'];
    final periodoId = filters?['periodoId'];

  final response = await _horarioService.getHorarios(accessToken, page: page, limit: limit, grupoId: grupoId, periodoId: periodoId);
    if (response == null) return null;
    return PaginatedResponse(items: response.horarios, pagination: response.pagination);
  }

  @override
  Future<Horario?> createItemApi(String accessToken, dynamic data) async {
    final created = await _horarioService.createHorario(accessToken, data as CreateHorarioRequest);
    return created;
  }

  @override
  Future<bool> deleteItemApi(String accessToken, String id) async {
    return await _horarioService.deleteHorario(accessToken, id);
  }

  @override
  Future<Horario?> updateItemApi(String accessToken, String id, dynamic data) async {
    final updated = await _horarioService.updateHorario(accessToken, id, data as UpdateHorarioRequest);
    return updated;
  }
}

/* Fin lib\providers\horario_paginated_provider.dart */

/* Inicio lib\providers\horario_provider.dart */
import 'dart:async';
import 'package:flutter/foundation.dart';
import '../models/pagination_types.dart';
import '../services/academic/horario_service.dart';
import '../models/horario.dart';
import 'paginated_data_mixin.dart';
import '../models/clase_del_dia.dart';
import '../models/user.dart'
import '../models/conflict_error.dart';

class HorarioProvider extends ChangeNotifier with PaginatedDataMixin<Horario> {
  final HorarioService _horarioService;

  HorarioProvider({HorarioService? horarioService})
      : _horarioService = horarioService ?? HorarioService();
  ConflictError? _conflictError;
  List<ClaseDelDia> _clasesDelDia = [];
  List<ClaseDelDia> _horarioSemanal = [];
  Horario? _selectedHorario;
  String? _selectedGrupoId;
  String? _selectedPeriodoId;
  ConflictError? get conflictError => _conflictError;
  List<Horario> get horarios => items;
  List<ClaseDelDia> get clasesDelDia => _clasesDelDia;
  List<ClaseDelDia> get horarioSemanal => _horarioSemanal;
  Horario? get selectedHorario => _selectedHorario;
  String? get selectedGrupoId => _selectedGrupoId;
  String? get selectedPeriodoId => _selectedPeriodoId;
  List<Horario> get horariosActivos => items.where((horario) => horario.periodoAcademico.activo).toList();
  List<Horario> get horariosDelGrupoSeleccionado {
  if (_selectedGrupoId == null) return [];
  return items.where((h) => h.grupo.id == _selectedGrupoId).toList();
  }
  int get loadedHorariosCount => items.length;
  int get clasesDelDiaCount => _clasesDelDia.length;
  int get horarioSemanalCount => _horarioSemanal.length;
  int get totalHorariosFromPagination => paginationInfo?.total ?? 0;
  Future<void> loadHorarios(String accessToken, {int? page, int? limit, String? grupoId, String? periodoId}) async {
  if (isLoading) return;
    resetPagination()

    try {
      debugPrint('HorarioProvider: Iniciando carga de horarios...');
      await loadItems(accessToken, page: page ?? 1, limit: limit, filters: {
        if (grupoId != null) 'grupoId': grupoId,
        if (periodoId != null) 'periodoId': periodoId,
      });
      if (hasError) {
        setError(errorMessage ?? 'Error al cargar horarios');
      } else {
        debugPrint('HorarioProvider: Recibidos ${items.length} horarios');
        notifyListeners();
        debugPrint('HorarioProvider: Estado cambiado a loaded');
      }
    } catch (e) {
      debugPrint('HorarioProvider: Error loading horarios: $e');
  setError(e.toString());
    }
  }

  @override
  Future<PaginatedResponse<Horario>?> fetchPage(String accessToken, {int page = 1, int? limit, String? search, Map<String, String>? filters}) async {
    final grupoId = filters?['grupoId'];
    final periodoId = filters?['periodoId'];

    final response = await _horarioService.getHorarios(accessToken, page: page, limit: limit, grupoId: grupoId, periodoId: periodoId);
    if (response == null) return null;
    return PaginatedResponse(items: response.horarios, pagination: response.pagination);
  }

  @override
  Future<Horario?> createItemApi(String accessToken, dynamic data) async {
    final created = await _horarioService.createHorario(accessToken, data as CreateHorarioRequest);
    return created;
  }

  @override
  Future<bool> deleteItemApi(String accessToken, String id) async {
    return await _horarioService.deleteHorario(accessToken, id);
  }

  @override
  Future<Horario?> updateItemApi(String accessToken, String id, dynamic data) async {
    final updated = await _horarioService.updateHorario(accessToken, id, data as UpdateHorarioRequest);
    return updated;
  }
  Future<void> loadHorariosByGrupo(String accessToken, String grupoId) async {
  if (isLoading) return;
    _selectedGrupoId = grupoId;

    try {
      debugPrint('HorarioProvider: Iniciando carga de horarios por grupo $grupoId...');
      final horarios = await _horarioService.getHorariosPorGrupo(accessToken, grupoId);
      if (horarios != null) {
      debugPrint('HorarioProvider: Recibidos ${horarios.length} horarios del grupo $grupoId');
  clearItems();
  items.addAll(horarios);
      setHasMoreData(false);
  notifyListeners();
      } else {
  setError('Error al cargar horarios del grupo');
      }
    } catch (e) {
      debugPrint('HorarioProvider: Error loading horarios by grupo: $e');
  setError(e.toString());
    }
  }
  Future<void> loadHorariosForGrupoWithConflictDetection(
    String accessToken,
    String grupoId,
    String periodoId,
  ) async {
  if (isLoading) return;
    _selectedGrupoId = grupoId;
    _selectedPeriodoId = periodoId;

    try {
      debugPrint('HorarioProvider: Cargando horarios para grupo $grupoId y perÃ­odo $periodoId...');
      final grupoHorariosTask = _horarioService.getHorariosPorGrupo(accessToken, grupoId);
      final periodHorariosTask = _horarioService.getHorarios(
        accessToken,
        page: 1,
        limit: 100, // ğŸ”§ MÃ¡ximo permitido por el backend
        periodoId: periodoId,
      );

      final grupoHorarios = await grupoHorariosTask;
      final periodResponse = await periodHorariosTask;

  if (periodResponse != null) {
    debugPrint('HorarioProvider: Recibidos ${grupoHorarios?.length ?? 0} horarios del grupo');
        debugPrint('HorarioProvider: Recibidos ${periodResponse.horarios.length} horarios del perÃ­odo');
    clearItems();
    items.addAll(periodResponse.horarios);
    setPaginationInfo(periodResponse.pagination);
        _selectedGrupoId = grupoId
  notifyListeners();

  debugPrint('HorarioProvider: Total horarios en memoria: ${items.length}');
      } else {
  setError('Error al cargar horarios');
      }
    } catch (e) {
      debugPrint('HorarioProvider: Error loading horarios with conflict detection: $e');
  setError(e.toString());
    }
  }
  Future<void> loadHorarioById(String accessToken, String horarioId) async {
  if (isLoading) return;

    try {
      final horario = await _horarioService.getHorarioById(accessToken, horarioId);
      if (horario != null) {
        _selectedHorario = horario;
  notifyListeners();
      } else {
  setError('Horario no encontrado');
      }
    } catch (e) {
      debugPrint('Error loading horario: $e');
  setError(e.toString());
    }
  }
  Future<bool> createHorario(String accessToken, CreateHorarioRequest horarioData) async {
  if (isLoading) return false;

    try {
      final newHorario = await _horarioService.createHorario(accessToken, horarioData);
      if (newHorario != null) {
  items.insert(0, newHorario);
  notifyListeners();
        return true;
      } else {
  setError('Error al crear horario');
        return false;
      }
    } catch (e) {
      debugPrint('Error creating horario: $e');
      final errorString = e.toString();
      if (errorString.contains('409') || errorString.contains('Conflict')) {
  _conflictError = ConflictError.fromBackendError(errorString);
  setError(_conflictError!.userFriendlyMessage);
      } else {
  setError(errorString);
      }
      return false;
    }
  }
  Future<bool> updateHorario(String accessToken, String horarioId, UpdateHorarioRequest horarioData) async {
  if (isLoading) return false;

    try {
      final updatedHorario = await _horarioService.updateHorario(accessToken, horarioId, horarioData);
      if (updatedHorario != null) {
  final index = items.indexWhere((horario) => horario.id == horarioId);
        if (index != -1) {
          items[index] = updatedHorario;
        }
        if (_selectedHorario?.id == horarioId) {
          _selectedHorario = updatedHorario;
        }

  notifyListeners();
        return true;
      } else {
  setError('Error al actualizar horario');
        return false;
      }
    } catch (e) {
      debugPrint('Error updating horario: $e');
      final errorString = e.toString();
      if (errorString.contains('409') || errorString.contains('Conflict')) {
        _conflictError = ConflictError.fromBackendError(errorString);
        setError(_conflictError!.userFriendlyMessage);
      } else {
        setError(errorString);
      }
      return false;
    }
  }
  Future<bool> deleteHorario(String accessToken, String horarioId) async {
    try {
      final success = await _horarioService.deleteHorario(accessToken, horarioId);

      if (!success) {
    setError('Error al eliminar el horario desde el servicio.');
      }
      return success;
    } catch (e) {
      debugPrint('Error deleting horario: $e');
  setError(e.toString());
      return false;
    }
  }
  Future<void> cargarClasesDelDia(String accessToken) async {
  if (isLoading) return;

    try {
      debugPrint('HorarioProvider: Cargando clases del dÃ­a para el profesor...');
      final clases = await _horarioService.getMisClasesDelDia(accessToken);
      if (clases != null) {
        debugPrint('HorarioProvider: Recibidas ${clases.length} clases del dÃ­a');
        _clasesDelDia = clases;
  notifyListeners();
      } else {
  setError('Error al cargar clases del dÃ­a');
      }
    } catch (e) {
      debugPrint('HorarioProvider: Error loading clases del dia: $e');
  setError(e.toString());
    }
  }
  Future<void> cargarClasesPorDia(String accessToken, int diaSemana) async {
  if (isLoading) return;

    try {
      debugPrint('HorarioProvider: Cargando clases del dÃ­a $diaSemana para el profesor...');
      final clases = await _horarioService.getMisClasesPorDia(accessToken, diaSemana);
      if (clases != null) {
        debugPrint('HorarioProvider: Recibidas ${clases.length} clases del dÃ­a $diaSemana');
        _clasesDelDia = clases;
  notifyListeners();
      } else {
  setError('Error al cargar clases del dÃ­a especÃ­fico');
      }
    } catch (e) {
      debugPrint('HorarioProvider: Error loading clases por dia: $e');
  setError(e.toString());
    }
  }
  Future<void> cargarHorarioSemanal(String accessToken) async {
  if (isLoading) return;

    try {
      debugPrint('HorarioProvider: Cargando horario semanal para el profesor...');
      final horario = await _horarioService.getMiHorarioSemanal(accessToken);
      if (horario != null) {
        debugPrint('HorarioProvider: Recibido horario semanal con ${horario.length} clases');
        _horarioSemanal = horario;
  notifyListeners();
      } else {
    setError('Error al cargar horario semanal');
      }
    } catch (e) {
      debugPrint('HorarioProvider: Error loading horario semanal: $e');
  setError(e.toString());
    }
  }
  void selectHorario(Horario horario) {
    _selectedHorario = horario;
    notifyListeners();
  }
  void clearSelectedHorario() {
    _selectedHorario = null;
    notifyListeners();
  }
  void clearData() {
  clearItems();
    _clasesDelDia = [];
    _horarioSemanal = [];
    _selectedHorario = null;
    _selectedGrupoId = null;
    _selectedPeriodoId = null;
  clearError();
  }
  Future<void> refreshData(String accessToken) async {
    if (_selectedGrupoId != null) {
      await loadHorariosByGrupo(accessToken, _selectedGrupoId!);
    } else {
      await loadHorarios(accessToken);
    }
  }
  List<Horario> searchHorarios(String query) {
  if (query.isEmpty) return items;

    final lowercaseQuery = query.toLowerCase();
  return items.where((horario) {
      return horario.materia.nombre.toLowerCase().contains(lowercaseQuery) ||
             horario.grupo.nombre.toLowerCase().contains(lowercaseQuery) ||
             horario.descripcion.toLowerCase().contains(lowercaseQuery);
    }).toList();
  }
  List<Horario> filterHorariosByDia(int diaSemana) {
  return items.where((horario) => horario.diaSemana == diaSemana).toList();
  }
  List<ClaseDelDia> getClasesDelDiaOrdenadas() {
    return _clasesDelDia..sort((a, b) => a.horaInicio.compareTo(b.horaInicio));
  }
  List<ClaseDelDia> getHorarioPorDia(int diaSemana) {
    return _horarioSemanal.where((clase) => clase.diaSemana == diaSemana).toList()
      ..sort((a, b) => a.horaInicio.compareTo(b.horaInicio));
  }
  @override
  Future<void> loadNextPage(String accessToken, {Map<String, String>? filters}) async {
  if (paginationInfo == null || !paginationInfo!.hasNext || isLoading) return;

  final nextPage = paginationInfo!.page + 1;
    if (_selectedGrupoId != null) {
      await loadHorariosByGrupo(accessToken, _selectedGrupoId!);
    } else {
  await loadHorarios(accessToken, page: nextPage, limit: paginationInfo!.limit);
    }
  }
  Future<void> loadPreviousPage(String accessToken) async {
  if (paginationInfo == null || !paginationInfo!.hasPrev || isLoading) return;

  final prevPage = paginationInfo!.page - 1;
  await loadHorarios(accessToken, page: prevPage, limit: paginationInfo!.limit);
  }
  Future<void> loadPage(String accessToken, int page) async {
  if (isLoading) return;

  await loadHorarios(accessToken, page: page, limit: paginationInfo?.limit ?? 10);
  }
  Map<String, int> getHorariosStatistics() {
    return {
  'total': paginationInfo?.total ?? 0,
      'activos': horariosActivos.length,
      'clases_hoy': _clasesDelDia.length,
      'horario_semanal': _horarioSemanal.length,
    };
  }
  Future<void> loadMoreHorarios(String accessToken, {String? grupoId, String? periodoId}) async {
    if (isLoadingMore || !hasMoreData || paginationInfo == null) return;
    if (grupoId != null) {
      setFilter('grupoId', grupoId);
    }
    if (periodoId != null) {
      setFilter('periodoId', periodoId);
    }

    await super.loadNextPage(accessToken);
  }
  @override
  void resetPagination() {
    super.resetPagination();
  }
  List<User> getProfesoresDisponibles(
    List<User> allProfesors,
    int diaSemana,
    String horaInicio,
    String horaFin,
  ) {
    final profesoresConConflicto = <String>{};
    final inicioMinutos = _timeToMinutes(horaInicio);
    final finMinutos = _timeToMinutes(horaFin);
  for (final horario in items) {
      if (horario.diaSemana == diaSemana && horario.profesor != null) {
        final hInicio = _timeToMinutes(horario.horaInicio);
        final hFin = _timeToMinutes(horario.horaFin);
        if (inicioMinutos < hFin && finMinutos > hInicio) {
          profesoresConConflicto.add(horario.profesor!.id);
        }
      }
    }
    return allProfesors.where((profesor) => !profesoresConConflicto.contains(profesor.id)).toList();
  }
  int _timeToMinutes(String time) {
    final parts = time.split(':');
    final hours = int.parse(parts[0]);
    final minutes = int.parse(parts[1]);
    return hours * 60 + minutes;
  }

}
/* Fin lib\providers\horario_provider.dart */

/* Inicio lib\providers\institution_admins_paginated_provider.dart */
import 'package:flutter/foundation.dart';
import 'paginated_data_mixin.dart';
import '../models/pagination_types.dart';
import '../services/user_service.dart' as user_service;
import '../models/user.dart';

class InstitutionAdminsPaginatedProvider extends ChangeNotifier with PaginatedDataMixin<User> {
  final user_service.UserService _userService;

  InstitutionAdminsPaginatedProvider({user_service.UserService? userService})
      : _userService = userService ?? user_service.UserService();
  @override
  Future<PaginatedResponse<User>?> fetchPage(String accessToken, {int page = 1, int? limit, String? search, Map<String, String>? filters}) async {
    final institutionId = filters?['institutionId'];
    if (institutionId == null || institutionId.isEmpty) return null;
    final response = await _userService.getUsersByInstitution(
      accessToken,
      institutionId,
      page: page,
      limit: limit ?? 5,
      role: 'admin_institucion',
      search: search,
    );
    if (response == null) return null;
    return PaginatedResponse(items: response.users, pagination: response.pagination);
  }

  @override
  Future<User?> createItemApi(String accessToken, dynamic data) async {
    return null;
  }

  @override
  Future<bool> deleteItemApi(String accessToken, String id) async {
    return false;
  }

  @override
  Future<User?> updateItemApi(String accessToken, String id, dynamic data) async {
    return null;
  }
}

/* Fin lib\providers\institution_admins_paginated_provider.dart */

/* Inicio lib\providers\institution_provider.dart */
import 'dart:async';
import 'package:flutter/foundation.dart';
import '../models/pagination_types.dart';
import '../services/institution_service.dart';
import '../models/institution.dart';
import 'paginated_data_mixin.dart';

class InstitutionProvider extends ChangeNotifier with PaginatedDataMixin<Institution> {
  final InstitutionService _institutionService;

  InstitutionProvider({InstitutionService? institutionService})
      : _institutionService = institutionService ?? InstitutionService();
  Institution? _selectedInstitution;
  List<Institution> get institutions => items;
  Institution? get selectedInstitution => _selectedInstitution;
  List<Institution> get activeInstitutions =>
    items.where((inst) => inst.activa).toList();

  List<Institution> get inactiveInstitutions =>
    items.where((inst) => !inst.activa).toList();

  int get totalInstitutions => items.length;
  int get activeInstitutionsCount => activeInstitutions.length;
  int get inactiveInstitutionsCount => inactiveInstitutions.length;
  @override
  void resetPagination() {
    super.resetPagination();
  }
  Future<void> loadInstitutions(String accessToken, {int? page, int? limit, bool? activa, String? search}) async {
    if (isLoading) return;
    resetPagination()
    if (search != null && search.isNotEmpty) {
      setFilter('search', search);
    } else {
      removeFilter('search');
    }
    if (activa != null) {
      setFilter('activa', activa.toString());
    } else {
      removeFilter('activa');
    }

    try {
      debugPrint('InstitutionProvider: Iniciando carga de instituciones...');
      await loadItems(accessToken, page: page ?? 1, limit: limit, search: search, filters: filters.isNotEmpty ? filters.map((k, v) => MapEntry(k, v.toString())) : null);
      notifyListeners();
      debugPrint('InstitutionProvider: Estado cambiado a loaded');
    } catch (e) {
      debugPrint('InstitutionProvider: Error loading institutions: $e');
      setError(e.toString());
    }
  }
  Future<void> loadInstitutionById(String accessToken, String id) async {
  if (isLoading) return;

    try {
      final institution = await _institutionService.getInstitutionById(accessToken, id);
  _selectedInstitution = institution;
  notifyListeners();
    } catch (e) {
      debugPrint('Error loading institution: $e');
  setError(e.toString());
    }
  }
  Future<bool> createInstitution(
    String accessToken,
    Map<String, dynamic> institutionData,
  ) async {
  if (isLoading) return false;

    try {
      final newInstitution = await _institutionService.createInstitution(
        accessToken,
        nombre: institutionData['nombre'],
        direccion: institutionData['direccion'],
        telefono: institutionData['telefono'],
        email: institutionData['email'],
      );

      if (newInstitution != null) {
        items.insert(0, newInstitution);
        notifyListeners();
        return true;
      }
      setError('Error al crear instituciÃ³n');
      return false;
    } catch (e) {
      debugPrint('Error creating institution: $e');
      setError(e.toString());
      return false;
    }
  }
  Future<bool> updateInstitution(
    String accessToken,
    String id, {
    String? nombre,
    String? direccion,
    String? telefono,
    String? email,
    bool? activa,
  }) async {
  if (isLoading) return false;

    try {
      final updatedInstitution = await _institutionService.updateInstitution(
        accessToken,
        id,
        nombre: nombre,
        direccion: direccion,
        telefono: telefono,
        email: email,
        activa: activa,
      );
  final index = items.indexWhere((inst) => inst.id == id);
      if (index != -1 && updatedInstitution != null) {
  items[index] = updatedInstitution;
      }
      if (_selectedInstitution?.id == id && updatedInstitution != null) {
        _selectedInstitution = updatedInstitution;
      }

    notifyListeners();
      return true;
    } catch (e) {
      debugPrint('Error updating institution: $e');
      setError(e.toString());
      return false;
    }
  }
  Future<bool> deleteInstitution(String accessToken, String id) async {
    if (isLoading) return false;

    try {
      await _institutionService.deleteInstitution(accessToken, id);
  items.removeWhere((inst) => inst.id == id);
      if (_selectedInstitution?.id == id) {
        _selectedInstitution = null;
      }

  notifyListeners();
      return true;
    } catch (e) {
      debugPrint('Error deleting institution: $e');
      setError(e.toString());
      return false;
    }
  }
  void selectInstitution(Institution institution) {
    _selectedInstitution = institution;
    notifyListeners();
  }
  void clearSelectedInstitution() {
    _selectedInstitution = null;
    notifyListeners();
  }
  void clearData() {
    clearItems();
    clearFilters();
    _selectedInstitution = null;
    clearError();

  Future<void> refreshData(String accessToken) async {
    await loadInstitutions(accessToken);
  }
  List<Institution> searchInstitutions(String query) {
  if (query.isEmpty) return items;

    final lowercaseQuery = query.toLowerCase();
  return items.where((inst) {
      return inst.nombre.toLowerCase().contains(lowercaseQuery) ||
             (inst.email?.toLowerCase().contains(lowercaseQuery) ?? false);
    }).toList();
  }
  Future<void> loadMoreInstitutions(String accessToken) async {
    await super.loadNextPage(accessToken);
  }

  @override
  Future<PaginatedResponse<Institution>?> fetchPage(String accessToken, {int page = 1, int? limit, String? search, Map<String, String>? filters}) async {
    final activeStr = this.filters['activa'];
    final active = activeStr == 'true';
    final searchQuery = this.filters['search'] as String?;
    final response = await _institutionService.getAllInstitutions(accessToken, page: page, limit: limit, activa: activeStr != null ? active : null, search: searchQuery);
    if (response == null) return null;
    return PaginatedResponse(items: response.institutions, pagination: response.pagination);
  }

  @override
  Future<Institution?> createItemApi(String accessToken, dynamic data) async {
    final map = data as Map<String, dynamic>;
    final created = await _institutionService.createInstitution(
      accessToken,
      nombre: map['nombre'] as String,
      direccion: map['direccion'] as String?,
      telefono: map['telefono'] as String?,
      email: map['email'] as String?,
    );
    return created;
  }

  @override
  Future<bool> deleteItemApi(String accessToken, String id) async {
    return await _institutionService.deleteInstitution(accessToken, id);
  }

  @override
  Future<Institution?> updateItemApi(String accessToken, String id, dynamic data) async {
    final updated = await _institutionService.updateInstitution(accessToken, id,
      nombre: data['nombre'] as String?,
      direccion: data['direccion'] as String?,
      telefono: data['telefono'] as String?,
      email: data['email'] as String?,
      activa: data['activa'] as bool?,
    );
    return updated;
  }
}
/* Fin lib\providers\institution_provider.dart */

/* Inicio lib\providers\materia_provider.dart */
import 'dart:async';
import 'package:flutter/foundation.dart';
import '../models/pagination_types.dart';
import '../services/academic/materia_service.dart';
import '../models/materia.dart';
import 'paginated_data_mixin.dart';

class MateriaProvider extends ChangeNotifier with PaginatedDataMixin<Materia> {
  final MateriaService _materiaService;

  MateriaProvider({MateriaService? materiaService})
      : _materiaService = materiaService ?? MateriaService();
  Materia? _selectedMateria;
  List<Materia> get materias => items;
  Materia? get selectedMateria => _selectedMateria;

  int get loadedMateriasCount => items.length;

  int get totalMateriasFromPagination => paginationInfo?.total ?? 0;

  @override
  Future<PaginatedResponse<Materia>?> fetchPage(String accessToken, {int page = 1, int? limit, String? search, Map<String, String>? filters}) async {
    final response = await _materiaService.getMaterias(accessToken, page: page, limit: limit, search: search);
    if (response == null) return null;
    return PaginatedResponse(items: response.materias, pagination: response.pagination);
  }

  @override
  Future<Materia?> createItemApi(String accessToken, dynamic data) async {
    final created = await _materiaService.createMateria(accessToken, data as CreateMateriaRequest);
    return created;
  }

  @override
  Future<bool> deleteItemApi(String accessToken, String id) async {
    return await _materiaService.deleteMateria(accessToken, id);
  }

  @override
  Future<Materia?> updateItemApi(String accessToken, String id, dynamic data) async {
    final updated = await _materiaService.updateMateria(accessToken, id, data as UpdateMateriaRequest);
    return updated;
  }

  Future<void> loadMaterias(String accessToken, {int? page, int? limit, String? search}) async {
  if (isLoading) return;
    resetPagination();
    try {
      await loadItems(accessToken, page: page ?? 1, limit: limit, search: search);
  notifyListeners();
    } catch (e) {
      setError(e.toString());
    }
  }

  Future<void> loadMateriaById(String accessToken, String materiaId) async {
  if (isLoading) return;
    try {
      final materia = await _materiaService.getMateriaById(accessToken, materiaId);
      if (materia != null) {
        _selectedMateria = materia;
  notifyListeners();
      } else {
  setError('Materia no encontrada');
      }
    } catch (e) {
  setError(e.toString());
    }
  }

  Future<bool> createMateria(String accessToken, CreateMateriaRequest materiaData) async {
  if (isLoading) return false;
    try {
      final success = await createItem(accessToken, materiaData);
      if (success) {
  notifyListeners();
        return true;
      }
  setError(errorMessage ?? '');
      return false;
    } catch (e) {
  setError(e.toString());
      return false;
    }
  }

  Future<bool> updateMateria(String accessToken, String materiaId, UpdateMateriaRequest materiaData) async {
  if (isLoading) return false;
    try {
      final success = await updateItem(accessToken, materiaId, materiaData);
      if (success) {
        final updated = items.firstWhere((m) => m.id == materiaId, orElse: () => _selectedMateria!);
        if (_selectedMateria?.id == materiaId) _selectedMateria = updated;
  notifyListeners();
        return true;
      }
  setError(errorMessage ?? '');
      return false;
    } catch (e) {
  setError(e.toString());
      return false;
    }
  }

  Future<bool> deleteMateria(String accessToken, String materiaId) async {
    try {
      final success = await deleteItem(accessToken, materiaId);
      if (!success) {
        setError('Error al eliminar la materia desde el servicio.');
      }
      return success;
    } catch (e) {
      setError(e.toString());
      return false;
    }
  }

  void selectMateria(Materia materia) {
    _selectedMateria = materia;
    notifyListeners();
  }

  void clearSelectedMateria() {
    _selectedMateria = null;
    notifyListeners();
  }

  void clearData() {
    clearItems();
    _selectedMateria = null;
  clearError();
  }

  Future<void> refreshData(String accessToken) async {
    await loadMaterias(accessToken);
  }

  List<Materia> searchMaterias(String query) {
    if (query.isEmpty) return items;
    final lowercaseQuery = query.toLowerCase();
    return items.where((materia) {
      return materia.nombre.toLowerCase().contains(lowercaseQuery) || (materia.codigo?.toLowerCase().contains(lowercaseQuery) ?? false);
    }).toList();
  }

  @override
  Future<void> loadNextPage(String accessToken) async {
    await super.loadNextPage(accessToken);
  }

  Future<void> loadPreviousPage(String accessToken) async {
  if (paginationInfo == null || !paginationInfo!.hasPrev || isLoading) return;
    final prevPage = paginationInfo!.page - 1;
    await loadMaterias(accessToken, page: prevPage, limit: paginationInfo!.limit);
  }

  Future<void> loadPage(String accessToken, int page) async {
  if (isLoading) return;
    await loadMaterias(accessToken, page: page, limit: paginationInfo?.limit ?? 10);
  }

  Map<String, int> getMateriasStatistics() {
    return {
      'total': paginationInfo?.total ?? 0,
      'con_codigo': items.where((m) => m.codigo != null).length,
      'sin_codigo': items.where((m) => m.codigo == null).length,
    };
  }

  Future<void> loadMoreMaterias(String accessToken, {String? search}) async {
    if (isLoadingMore || !hasMoreData || paginationInfo == null) return;
    await super.loadNextPage(accessToken);
  }

  Future<List<Materia>?> searchMateriasRemote(String accessToken, {String? search, int limit = 10}) async {
    try {
      final response = await _materiaService.getMaterias(accessToken, page: 1, limit: limit, search: search);
      return response?.materias;
    } catch (e) {
      debugPrint('Error searchMateriasRemote: $e');
      return null;
    }
  }
}
/* Fin lib\providers\materia_provider.dart */

/* Inicio lib\providers\paginated_data_mixin.dart */
import 'package:flutter/foundation.dart';
import '../models/pagination_types.dart';
import '../models/user.dart'
mixin PaginatedDataMixin<T> on ChangeNotifier {
  List<T> _items = [];
  PaginationInfo? _paginationInfo;
  bool _isLoading = false;
  bool _isLoadingMore = false;
  bool _hasMoreData = true;
  String? _errorMessage;
  final Map<String, dynamic> _filters = {};

  List<T> get items => _items;
  PaginationInfo? get paginationInfo => _paginationInfo;
  bool get isLoading => _isLoading;
  bool get isLoadingMore => _isLoadingMore;
  bool get hasMoreData => _hasMoreData;
  String? get errorMessage => _errorMessage;
  bool get hasError => _errorMessage != null;
  Map<String, dynamic> get filters => _filters;
  bool get isLoaded => !_isLoading && !hasError && _items.isNotEmpty;
  Future<PaginatedResponse<T>?> fetchPage(String accessToken, {int page = 1, int? limit, String? search, Map<String, String>? filters});

  Future<void> loadItems(String accessToken, {int page = 1, int? limit, String? search, Map<String, String>? filters}) async {
    if (_isLoading) return;
    _isLoading = true;
    _errorMessage = null;
    _hasMoreData = true;
    notifyListeners();

    try {
      final response = await fetchPage(accessToken, page: page, limit: limit, search: search, filters: filters);
      if (response != null) {
        _items = response.items;
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
      } else {
        _errorMessage = 'Error al cargar datos';
      }
    } catch (e) {
      _errorMessage = e.toString();
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> loadNextPage(String accessToken) async {
    if (_paginationInfo == null || !_paginationInfo!.hasNext || _isLoading || _isLoadingMore) return;
    _isLoadingMore = true;
    notifyListeners();

    try {
      final nextPage = _paginationInfo!.page + 1;
      final response = await fetchPage(accessToken, page: nextPage, limit: _paginationInfo!.limit, filters: _filters.isNotEmpty ? _filters.map((k, v) => MapEntry(k, v.toString())) : null);
      if (response != null) {
        _items.addAll(response.items);
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
      } else {
        _hasMoreData = false;
      }
    } catch (e) {
      _errorMessage = e.toString();
    } finally {
      _isLoadingMore = false;
      notifyListeners();
    }
  }

  Future<bool> createItem(String accessToken, dynamic data) async {
    _isLoading = true;
    notifyListeners();
    try {
      final item = await createItemApi(accessToken, data);
      if (item != null) {
        _items.insert(0, item);
        notifyListeners();
        return true;
      }
      return false;
    } catch (e) {
      _errorMessage = e.toString();
      return false;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<bool> updateItem(String accessToken, String id, dynamic data) async {
    _isLoading = true;
    notifyListeners();
    try {
      final updated = await updateItemApi(accessToken, id, data);
      if (updated != null) {
        final index = _items.indexWhere((it) => _getItemId(it) == id);
        if (index != -1) _items[index] = updated;
        notifyListeners();
        return true;
      }
      return false;
    } catch (e) {
      _errorMessage = e.toString();
      return false;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<bool> deleteItem(String accessToken, String id) async {
    try {
      final success = await deleteItemApi(accessToken, id);
      if (success) {
        _items.removeWhere((it) => _getItemId(it) == id);
        notifyListeners();
      }
      return success;
    } catch (e) {
      _errorMessage = e.toString();
      notifyListeners();
      return false;
    }
  }
  Future<T?> createItemApi(String accessToken, dynamic data);
  Future<T?> updateItemApi(String accessToken, String id, dynamic data);
  Future<bool> deleteItemApi(String accessToken, String id);
  String _getItemId(dynamic item) => (item as dynamic).id as String;
  void resetPagination() {
    _items = [];
    _paginationInfo = null;
    _hasMoreData = true;
    _isLoadingMore = false;
  }
  void clearItems() {
    _items = [];
    _paginationInfo = null;
    notifyListeners();
  }
  void setError(String message) {
    _errorMessage = message;
    notifyListeners();
  }
  void clearError() {
    _errorMessage = null;
    notifyListeners();
  }
  void setFilter(String key, dynamic value) {
    _filters[key] = value;
    notifyListeners();
  }
  void removeFilter(String key) {
    _filters.remove(key);
    notifyListeners();
  }
  void clearFilters() {
    _filters.clear();
    notifyListeners();
  }
  void setPaginationInfo(PaginationInfo? info) {
    _paginationInfo = info;
    _hasMoreData = info?.hasNext ?? false;
    notifyListeners();
  }
  void setHasMoreData(bool hasMore) {
    _hasMoreData = hasMore;
    notifyListeners();
  }
  void setIsLoadingMore(bool value) {
    _isLoadingMore = value;
    notifyListeners();
  }
}

/* Fin lib\providers\paginated_data_mixin.dart */

/* Inicio lib\providers\paginated_data_provider.dart */
import 'package:flutter/foundation.dart';
import '../models/pagination_types.dart';
import '../models/user.dart'
abstract class PaginatedDataProvider<T> with ChangeNotifier {
  List<T> _items = [];
  PaginationInfo? _paginationInfo;
  bool _isLoading = false;
  bool _isLoadingMore = false;
  bool _hasMoreData = true;
  String? _errorMessage;

  List<T> get items => _items;
  PaginationInfo? get paginationInfo => _paginationInfo;
  bool get isLoading => _isLoading;
  bool get isLoadingMore => _isLoadingMore;
  bool get hasMoreData => _hasMoreData;
  String? get errorMessage => _errorMessage;
  bool get hasError => _errorMessage != null;
  bool get isLoaded => !_isLoading && !hasError && _items.isNotEmpty;
  Future<PaginatedResponse<T>?> fetchPage(String accessToken, {int page = 1, int? limit, String? search, Map<String, String>? filters});

  Future<void> loadItems(String accessToken, {int page = 1, int? limit, String? search, Map<String, String>? filters}) async {
    if (_isLoading) return;
    _isLoading = true;
    _errorMessage = null;
    _hasMoreData = true;
    notifyListeners();

    try {
      final response = await fetchPage(accessToken, page: page, limit: limit, search: search, filters: filters);
      if (response != null) {
        _items = response.items;
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
      } else {
        _errorMessage = 'Error al cargar datos';
      }
    } catch (e) {
      _errorMessage = e.toString();
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> loadNextPage(String accessToken, {Map<String, String>? filters}) async {
    if (_paginationInfo == null || !_paginationInfo!.hasNext || _isLoading || _isLoadingMore) return;
    _isLoadingMore = true;
    notifyListeners();

    try {
      final nextPage = _paginationInfo!.page + 1;
      final response = await fetchPage(accessToken, page: nextPage, limit: _paginationInfo!.limit, filters: filters);
      if (response != null) {
        _items.addAll(response.items);
        _paginationInfo = response.pagination;
        _hasMoreData = response.pagination.hasNext;
      } else {
        _hasMoreData = false;
      }
    } catch (e) {
      _errorMessage = e.toString();
    } finally {
      _isLoadingMore = false;
      notifyListeners();
    }
  }

  Future<bool> createItem(String accessToken, dynamic data) async {
    _isLoading = true;
    notifyListeners();
    try {
      final item = await createItemApi(accessToken, data);
      if (item != null) {
        _items.insert(0, item);
        notifyListeners();
        return true;
      }
      return false;
    } catch (e) {
      _errorMessage = e.toString();
      return false;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<bool> updateItem(String accessToken, String id, dynamic data) async {
    _isLoading = true;
    notifyListeners();
    try {
      final updated = await updateItemApi(accessToken, id, data);
      if (updated != null) {
        final index = _items.indexWhere((it) => _getItemId(it) == id);
        if (index != -1) _items[index] = updated;
        notifyListeners();
        return true;
      }
      return false;
    } catch (e) {
      _errorMessage = e.toString();
      return false;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<bool> deleteItem(String accessToken, String id) async {
    try {
      final success = await deleteItemApi(accessToken, id);
      if (success) {
        _items.removeWhere((it) => _getItemId(it) == id);
        notifyListeners();
      }
      return success;
    } catch (e) {
      _errorMessage = e.toString();
      notifyListeners();
      return false;
    }
  }
  Future<T?> createItemApi(String accessToken, dynamic data);
  Future<T?> updateItemApi(String accessToken, String id, dynamic data);
  Future<bool> deleteItemApi(String accessToken, String id);
  String _getItemId(dynamic item) => (item as dynamic).id as String;
  void resetPagination() {
    _hasMoreData = true;
    _isLoadingMore = false;
  }
  void clearItems() {
    _items = [];
    _paginationInfo = null;
    notifyListeners();
  }
  void setError(String message) {
    _errorMessage = message;
    notifyListeners();
  }
  void clearError() {
    _errorMessage = null;
    notifyListeners();
  }
  void setPaginationInfo(PaginationInfo? info) {
    _paginationInfo = info;
    _hasMoreData = info?.hasNext ?? false;
    notifyListeners();
  }
  void setHasMoreData(bool hasMore) {
    _hasMoreData = hasMore;
    notifyListeners();
  }
  void setIsLoadingMore(bool value) {
    _isLoadingMore = value;
    notifyListeners();
  }
}

/* Fin lib\providers\paginated_data_provider.dart */

/* Inicio lib\providers\periodo_academico_provider.dart */
import 'dart:async';
import 'package:flutter/foundation.dart';
import '../models/pagination_types.dart';
import '../services/academic/periodo_service.dart';
import '../models/grupo.dart'
import 'paginated_data_mixin.dart';

class PeriodoAcademicoProvider extends ChangeNotifier with PaginatedDataMixin<PeriodoAcademico> {
  final PeriodoService _periodoService;

  PeriodoAcademicoProvider({PeriodoService? periodoService})
      : _periodoService = periodoService ?? PeriodoService();
  PeriodoAcademico? _selectedPeriodo;
  List<PeriodoAcademico> get periodosAcademicos => items;
  PeriodoAcademico? get selectedPeriodo => _selectedPeriodo;
  List<PeriodoAcademico> get periodosActivos => items.where((periodo) => periodo.activo).toList();
  List<PeriodoAcademico> get periodosInactivos => items.where((periodo) => !periodo.activo).toList();
  int get loadedPeriodosCount => items.length;
  int get periodosActivosCount => periodosActivos.length;
  int get periodosInactivosCount => periodosInactivos.length;
  int get totalPeriodosFromPagination => paginationInfo?.total ?? 0;
  Future<void> loadPeriodosAcademicos(String accessToken, {int? page, int? limit}) async {
  if (isLoading) return;

    try {
      debugPrint('PeriodoAcademicoProvider: Iniciando carga de perÃ­odos acadÃ©micos...');
        await loadItems(accessToken, page: page ?? 1, limit: limit);
  notifyListeners();
    } catch (e) {
      debugPrint('PeriodoAcademicoProvider: Error loading perÃ­odos acadÃ©micos: $e');
  setError(e.toString());
    }
  }
  Future<void> loadPeriodosActivos(String accessToken) async {
  if (isLoading) return;

    try {
      debugPrint('PeriodoAcademicoProvider: Iniciando carga de perÃ­odos activos...');
      final periodos = await _periodoService.getPeriodosActivos(accessToken);
      if (periodos != null) {
        debugPrint('PeriodoAcademicoProvider: Recibidos ${periodos.length} perÃ­odos activos');
  clearItems();
  items.addAll(periodos);
  notifyListeners();
      } else {
  setError('Error al cargar perÃ­odos activos');
      }
    } catch (e) {
      debugPrint('PeriodoAcademicoProvider: Error loading perÃ­odos activos: $e');
  setError(e.toString());
    }
  }
  Future<void> loadPeriodoById(String accessToken, String periodoId) async {
  if (isLoading) return;

    try {
      final periodo = await _periodoService.getPeriodoAcademicoById(accessToken, periodoId);
      if (periodo != null) {
        _selectedPeriodo = periodo;
  notifyListeners();
      } else {
  setError('PerÃ­odo acadÃ©mico no encontrado');
      }
    } catch (e) {
      debugPrint('Error loading perÃ­odo acadÃ©mico: $e');
  setError(e.toString());
    }
  }
  Future<bool> createPeriodoAcademico(String accessToken, CreatePeriodoAcademicoRequest periodoData) async {
  if (isLoading) return false;

    try {
      final newPeriodo = await _periodoService.createPeriodoAcademico(accessToken, periodoData);
      if (newPeriodo != null) {
    items.insert(0, newPeriodo);
  notifyListeners();
        return true;
      } else {
  setError('Error al crear perÃ­odo acadÃ©mico');
        return false;
      }
    } catch (e) {
      debugPrint('Error creating perÃ­odo acadÃ©mico: $e');
  setError(e.toString());
      return false;
    }
  }
  Future<bool> updatePeriodoAcademico(String accessToken, String periodoId, UpdatePeriodoAcademicoRequest periodoData) async {
  if (isLoading) return false;

    try {
      final updatedPeriodo = await _periodoService.updatePeriodoAcademico(accessToken, periodoId, periodoData);
      if (updatedPeriodo != null) {
        final index = items.indexWhere((periodo) => periodo.id == periodoId);
        if (index != -1) {
          items[index] = updatedPeriodo;
        }
        if (_selectedPeriodo?.id == periodoId) {
          _selectedPeriodo = updatedPeriodo;
        }

  notifyListeners();
        return true;
      } else {
  setError('Error al actualizar perÃ­odo acadÃ©mico');
        return false;
      }
    } catch (e) {
      debugPrint('Error updating perÃ­odo acadÃ©mico: $e');
  setError(e.toString());
      return false;
    }
  }
  Future<bool> deletePeriodoAcademico(String accessToken, String periodoId) async {
    try {
      final success = await _periodoService.deletePeriodoAcademico(accessToken, periodoId);

      if (!success) {
    setError('Error al eliminar el perÃ­odo acadÃ©mico desde el servicio.');
      } else {
  items.removeWhere((periodo) => periodo.id == periodoId);
        notifyListeners();
      }
      return success;
    } catch (e) {
      debugPrint('Error deleting perÃ­odo acadÃ©mico: $e');
  setError(e.toString());
      return false;
    }
  }
  Future<bool> togglePeriodoStatus(String accessToken, String periodoId) async {
    try {
      final updatedPeriodo = await _periodoService.togglePeriodoStatus(accessToken, periodoId);

      if (updatedPeriodo != null) {
        final index = items.indexWhere((periodo) => periodo.id == periodoId);
        if (index != -1) {
          items[index] = updatedPeriodo;
        }
        if (_selectedPeriodo?.id == periodoId) {
          _selectedPeriodo = updatedPeriodo;
        }

        notifyListeners();
        return true;
      } else {
  setError('Error al cambiar el status del perÃ­odo acadÃ©mico');
        return false;
      }
    } catch (e) {
      debugPrint('Error toggling perÃ­odo status: $e');
  setError(e.toString());
      return false;
    }
  }
  void selectPeriodo(PeriodoAcademico periodo) {
    _selectedPeriodo = periodo;
    notifyListeners();
  }
  void clearSelectedPeriodo() {
    _selectedPeriodo = null;
    notifyListeners();
  }
  void clearData() {
  clearItems();
  _selectedPeriodo = null;
  clearError();
  }
  Future<void> refreshData(String accessToken) async {
    await loadPeriodosAcademicos(accessToken);
  }
  List<PeriodoAcademico> searchPeriodos(String query) {
  if (query.isEmpty) return items;

    final lowercaseQuery = query.toLowerCase();
  return items.where((periodo) {
      return periodo.nombre.toLowerCase().contains(lowercaseQuery);
    }).toList();
  }
  List<PeriodoAcademico> filterPeriodosByStatus({bool? activo}) {
  if (activo == null) return items;
  return items.where((periodo) => periodo.activo == activo).toList();
  }
  @override
  Future<void> loadNextPage(String accessToken, {Map<String, String>? filters}) async {
  if (paginationInfo == null || !paginationInfo!.hasNext || isLoading) return;

  final nextPage = paginationInfo!.page + 1;
  await loadPeriodosAcademicos(accessToken, page: nextPage, limit: paginationInfo!.limit);
  }
  Future<void> loadPreviousPage(String accessToken) async {
  if (paginationInfo == null || !paginationInfo!.hasPrev || isLoading) return;

  final prevPage = paginationInfo!.page - 1;
  await loadPeriodosAcademicos(accessToken, page: prevPage, limit: paginationInfo!.limit);
  }
  Future<void> loadPage(String accessToken, int page) async {
  if (isLoading) return;

  await loadPeriodosAcademicos(accessToken, page: page, limit: paginationInfo?.limit ?? 10);
  }

  @override
  Future<PaginatedResponse<PeriodoAcademico>?> fetchPage(String accessToken, {int page = 1, int? limit, String? search, Map<String, String>? filters}) async {
    final response = await _periodoService.getPeriodosAcademicos(accessToken, page: page, limit: limit);
    if (response == null) return null;
    return PaginatedResponse(items: response.periodosAcademicos, pagination: response.pagination);
  }

  @override
  Future<PeriodoAcademico?> createItemApi(String accessToken, dynamic data) async {
    final created = await _periodoService.createPeriodoAcademico(accessToken, data as CreatePeriodoAcademicoRequest);
    return created;
  }

  @override
  Future<bool> deleteItemApi(String accessToken, String id) async {
    return await _periodoService.deletePeriodoAcademico(accessToken, id);
  }

  @override
  Future<PeriodoAcademico?> updateItemApi(String accessToken, String id, dynamic data) async {
    final updated = await _periodoService.updatePeriodoAcademico(accessToken, id, data as UpdatePeriodoAcademicoRequest);
    return updated;
  }
  Map<String, int> getPeriodosStatistics() {
    return {
      'total': paginationInfo?.total ?? 0,
      'activos': periodosActivosCount,
      'inactivos': periodosInactivosCount,
    };
  }
}
/* Fin lib\providers\periodo_academico_provider.dart */

/* Inicio lib\providers\user_provider.dart */
import 'dart:async';
import 'package:flutter/foundation.dart';
import '../models/pagination_types.dart';
import '../services/user_service.dart' as user_service;
import '../models/user.dart';
import 'paginated_data_mixin.dart';

class UserProvider extends ChangeNotifier with PaginatedDataMixin<User> {
  final user_service.UserService _userService;

  UserProvider({user_service.UserService? userService})
      : _userService = userService ?? user_service.UserService();
  User? _selectedUser;
  String? _selectedInstitutionId;
  List<User> get users => items;
  User? get selectedUser => _selectedUser;
  String? get selectedInstitutionId => _selectedInstitutionId;
  List<User> get activeUsers => items.where((user) => user.activo).toList();
  List<User> get inactiveUsers => items.where((user) => !user.activo).toList();

  List<User> get professors => items.where((user) => user.esProfesor).toList();
  List<User> get students => items.where((user) => user.esEstudiante).toList();
  List<User> get adminInstitutions => items.where((user) => user.esAdminInstitucion).toList();
  int get loadedUsersCount => items.length;
  int get activeUsersCount => activeUsers.length;
  int get inactiveUsersCount => inactiveUsers.length;

  int get professorsCount => professors.length;
  int get studentsCount => students.length;
  int get adminInstitutionsCount => adminInstitutions.length;
  int get totalUsersFromPagination => paginationInfo?.total ?? 0;
  Future<void> loadUsers(String accessToken, {int? page, int? limit, bool? activo, String? search, List<String>? roles}) async {
    if (isLoading) return;
    resetPagination()
    removeFilter('institutionId');
    _selectedInstitutionId = null;
    if (search != null && search.isNotEmpty) {
      setFilter('search', search);
    } else {
      removeFilter('search');
    }
    if (activo != null) {
      setFilter('activo', activo.toString());
    } else {
      removeFilter('activo');
    }
    if (roles != null && roles.isNotEmpty) {
      setFilter('roles', roles.join(','));
    } else {
      removeFilter('roles');
    }

    try {
      debugPrint('UserProvider: Iniciando carga de usuarios...');
      await loadItems(accessToken, page: page ?? 1, limit: limit, search: search, filters: filters.isNotEmpty ? filters.map((k, v) => MapEntry(k, v.toString())) : null);
      notifyListeners();
    } catch (e) {
      debugPrint('UserProvider: Error loading users: $e');
      setError(e.toString());
    }
  }
  Future<void> loadUsersByInstitution(String accessToken, String institutionId, {int? page, int limit = 5, String? role, bool? activo, String? search}) async {
    if (isLoading) return;
    clearItems();
    _selectedInstitutionId = institutionId;
    resetPagination()
    setFilter('institutionId', institutionId);
    if (role != null && role.isNotEmpty) {
      setFilter('role', role);
    } else {
      removeFilter('role');
    }
    if (activo != null) {
      setFilter('activo', activo.toString());
    } else {
      removeFilter('activo');
    }
    if (search != null && search.isNotEmpty) {
      setFilter('search', search);
    } else {
      removeFilter('search');
    }

    try {
      debugPrint('UserProvider: Iniciando carga de usuarios por instituciÃ³n $institutionId...');
      await loadItems(accessToken, page: page ?? 1, limit: limit, filters: filters.isNotEmpty ? filters.map((k, v) => MapEntry(k, v.toString())) : null);
      notifyListeners();
    } catch (e) {
      debugPrint('UserProvider: Error loading users by institution: $e');
      setError(e.toString());
    }
  }
  Future<void> loadAdminsByInstitution(String accessToken, String institutionId) async {
  if (isLoading) return;
    _selectedInstitutionId = institutionId;

    try {
      debugPrint('UserProvider: Cargando admins de la instituciÃ³n $institutionId...');
      final admins = await _userService.getAdminsByInstitution(accessToken, institutionId);
      if (admins != null) {
        clearItems();
  items.addAll(admins);
  setHasMoreData(false);
  notifyListeners();
      } else {
  setError('Error al cargar administradores de la instituciÃ³n');
      }
    } catch (e) {
      debugPrint('UserProvider: Error loading admins by institution: $e');
  setError(e.toString());
    }
  }
  Future<bool> assignAdminToInstitution(String accessToken, String institutionId, String userId) async {
    try {
      final updated = await _userService.assignAdminToInstitution(accessToken, institutionId, userId);
      if (updated != null) {
        await loadAdminsByInstitution(accessToken, institutionId);
        return true;
      }
      return false;
    } catch (e) {
      debugPrint('Error assignAdminToInstitution: $e');
      return false;
    }
  }
  Future<bool> removeAdminFromInstitution(String accessToken, String institutionId, String userId) async {
    try {
      final result = await _userService.removeAdminFromInstitution(accessToken, institutionId, userId);
      if (result != null) {
        await loadAdminsByInstitution(accessToken, institutionId);
        return true;
      }
      return false;
    } catch (e) {
      debugPrint('Error removeAdminFromInstitution: $e');
      return false;
    }
  }
  Future<void> loadUsersByRole(String accessToken, String role, {int? page, int? limit}) async {
  if (isLoading) return;
    resetPagination()

    try {
      debugPrint('UserProvider: Iniciando carga de usuarios por rol $role...');
      final response = await _userService.getUsersByRole(accessToken, role, page: page ?? 1, limit: limit);
      if (response != null) {
        debugPrint('UserProvider: Recibidos ${response.users.length} usuarios con rol $role');
  setPaginationInfo(response.pagination);
  notifyListeners();
      } else {
  setError('Error al cargar usuarios por rol');
      }
    } catch (e) {
      debugPrint('UserProvider: Error loading users by role: $e');
  setError(e.toString());
    }
  }
  Future<void> loadUserById(String accessToken, String userId) async {

    try {
      final user = await _userService.getUserById(accessToken, userId);
      if (user != null) {
        _selectedUser = user;
  notifyListeners();
      } else {
  setError('Usuario no encontrado');
      }
    } catch (e) {
      debugPrint('Error loading user: $e');
  setError(e.toString());
    }
  }
  Future<bool> createUser(String accessToken, CreateUserRequest userData) async {

    try {
      final newUser = await _userService.createUser(accessToken, userData);
      if (newUser != null) {
  items.insert(0, newUser);
  notifyListeners();
        return true;
      } else {
  setError('Error al crear usuario');
        return false;
      }
    } catch (e) {
      debugPrint('Error creating user: $e');
  setError(e.toString());
      return false;
    }
  }
  Future<bool> updateUser(String accessToken, String userId, UpdateUserRequest userData) async {

    try {
      final updatedUser = await _userService.updateUser(accessToken, userId, userData);
      if (updatedUser != null) {
        final index = items.indexWhere((user) => user.id == userId);
        if (index != -1) {
          items[index] = updatedUser;
        }
        if (_selectedUser?.id == userId) {
          _selectedUser = updatedUser;
        }

  notifyListeners();
        return true;
      } else {
  setError('Error al actualizar usuario');
        return false;
      }
    } catch (e) {
      debugPrint('Error updating user: $e');
  setError(e.toString());
      return false;
    }
  }
  Future<bool> deleteUser(String accessToken, String userId) async {
    try {
      final success = await _userService.deleteUser(accessToken, userId);

      if (!success) {
        setError('Error al eliminar el usuario desde el servicio.');
      }
      return success;
    } catch (e) {
      debugPrint('Error deleting user: $e');
      setError(e.toString());
      return false;
    }
  }
  Future<bool> changeUserPassword(String accessToken, String userId, String newPassword) async {
    try {
      final result = await _userService.changePassword(accessToken, userId, newPassword);
      return result == true;
    } catch (e) {
      debugPrint('Error changeUserPassword: $e');
      setError(e.toString());
      return false;
    }
  }
  void selectUser(User user) {
    _selectedUser = user;
  setIsLoadingMore(true);
  }
  void clearSelectedUser() {
    _selectedUser = null;
    notifyListeners();
  }
  void clearData() {
    clearItems();
    clearFilters();
    _selectedUser = null;
    _selectedInstitutionId = null;
    setPaginationInfo(null);
    clearError();

  Future<void> refreshData(String accessToken) async {
    if (filters['institutionId'] != null) {
      await loadUsersByInstitution(accessToken, filters['institutionId'] as String);
    } else {
      await loadUsers(accessToken);
    }
  }
  List<User> searchUsers(String query) {
  if (query.isEmpty) return items;

    final lowercaseQuery = query.toLowerCase();
  return items.where((user) {
      return user.nombreCompleto.toLowerCase().contains(lowercaseQuery) ||
             user.email.toLowerCase().contains(lowercaseQuery) ||
             (user.telefono?.contains(lowercaseQuery) ?? false);
    }).toList();
  }
  List<User> filterUsersByRole(String role) {
  if (role.isEmpty) return items;
  return items.where((user) => user.rol == role).toList();
  }
  List<User> filterUsersByStatus({bool? active}) {
  if (active == null) return items;
  return items.where((user) => user.activo == active).toList();
  }
  @override
  Future<void> loadNextPage(String accessToken) async {
    await super.loadNextPage(accessToken);
  }
  Future<void> loadPreviousPage(String accessToken) async {
  if (paginationInfo == null || !paginationInfo!.hasPrev || isLoading) return;

    final prevPage = paginationInfo!.page - 1;
    if (_selectedInstitutionId != null) {
      await loadUsersByInstitution(accessToken, _selectedInstitutionId!, page: prevPage, limit: paginationInfo!.limit);
    } else {
  await loadUsers(accessToken, page: prevPage, limit: paginationInfo!.limit);
    }
  }
  Future<void> loadPage(String accessToken, int page) async {
  if (isLoading) return;

    if (_selectedInstitutionId != null) {
      await loadUsersByInstitution(accessToken, _selectedInstitutionId!, page: page, limit: paginationInfo?.limit ?? 5);
    } else {
  await loadUsers(accessToken, page: page, limit: paginationInfo?.limit ?? 5);
    }
  }
  Map<String, int> getUserStatistics() {
    return {
  'total': paginationInfo?.total ?? 0,
      'activos': activeUsersCount,
      'inactivos': inactiveUsersCount,
      'profesores': professorsCount,
      'estudiantes': studentsCount,
      'admins_institucion': adminInstitutionsCount,
    };
  }
  Future<void> loadMoreUsers(String accessToken) async {
    await super.loadNextPage(accessToken);
  }

  @override
  Future<PaginatedResponse<User>?> fetchPage(String accessToken, {int page = 1, int? limit, String? search, Map<String, String>? filters}) async {
    final institutionId = this.filters['institutionId'];
    final role = this.filters['role'];
    final activoStr = this.filters['activo'];
    final activo = activoStr == 'true';
    final searchQuery = this.filters['search'] as String?;
    final rolesStr = this.filters['roles'] as String?;
    final roles = rolesStr != null && rolesStr.isNotEmpty ? rolesStr.split(',') : null;

    if (institutionId != null && institutionId.isNotEmpty) {
      final response = await _userService.getUsersByInstitution(
        accessToken,
        institutionId,
        page: page,
        limit: limit ?? 5,
        role: role,
        activo: activoStr != null ? activo : null,
        search: searchQuery,
      );
      if (response == null) return null;
      return PaginatedResponse(items: response.users, pagination: response.pagination);
    }

    final response = await _userService.getAllUsers(accessToken, page: page, limit: limit, search: searchQuery, activo: activoStr != null ? activo : null, roles: roles);
    if (response == null) return null;
    return PaginatedResponse(items: response.users, pagination: response.pagination);
  }

  @override
  Future<User?> createItemApi(String accessToken, dynamic data) async {
    final created = await _userService.createUser(accessToken, data as CreateUserRequest);
    return created;
  }

  @override
  Future<bool> deleteItemApi(String accessToken, String id) async {
    return await _userService.deleteUser(accessToken, id);
  }

  @override
  Future<User?> updateItemApi(String accessToken, String id, dynamic data) async {
    final updated = await _userService.updateUser(accessToken, id, data as UpdateUserRequest);
    return updated;
  }
  Future<List<User>?> searchUsersRemote(String accessToken, {String? search, int limit = 10}) async {
    try {
      final response = await _userService.getAllUsers(
        accessToken,
        page: 1,
        limit: limit,
        search: search,
      );
      return response?.users;
    } catch (e) {
      debugPrint('Error searchUsersRemote: $e');
      return null;
    }
  }
  @override
  void resetPagination() {
    super.resetPagination();
  }
}
/* Fin lib\providers\user_provider.dart */

/* Inicio lib\screens\academic\gestion_academica_screen.dart */
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import '../../theme/app_colors.dart';
import '../../theme/app_text_styles.dart';
import '../../theme/app_spacing.dart';
import '../../widgets/components/index.dart';

class GestionAcademicaScreen extends StatelessWidget {
  const GestionAcademicaScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final textStyles = AppTextStyles.instance;
    final spacing = AppSpacing.instance;

    return Scaffold(
      backgroundColor: colors.background,
      appBar: AppBar(
        backgroundColor: colors.primary,
        foregroundColor: colors.white,
        elevation: 0,
        title: Text(
          'GestiÃ³n AcadÃ©mica',
          style: textStyles.headlineMedium.copyWith(color: colors.white),
        ),
      ),
      body: SingleChildScrollView(
        padding: EdgeInsets.all(spacing.screenPadding),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Administrar Estructura AcadÃ©mica',
              style: textStyles.displayMedium,
            ),
            SizedBox(height: spacing.sm),
            Text(
              'Gestiona grupos, materias y horarios de tu instituciÃ³n',
              style: textStyles.bodyLarge.copyWith(color: colors.textSecondary),
            ),
            SizedBox(height: spacing.xl),
            Container(
              decoration: BoxDecoration(
                color: colors.surface,
                borderRadius: BorderRadius.circular(spacing.borderRadius),
                border: Border.all(color: colors.borderLight),
              ),
              child: Column(
                children: [
                  _buildMenuOption(
                    context,
                    icon: Icons.calendar_today,
                    title: 'Gestionar PerÃ­odos',
                    subtitle: 'Administrar perÃ­odos acadÃ©micos',
                    color: colors.info,
                    onTap: () => context.push('/academic/periodos'),
                  ),
                  Divider(color: colors.borderLight),
                  _buildMenuOption(
                    context,
                    icon: Icons.group,
                    title: 'Gestionar Grupos',
                    subtitle: 'Crear y administrar grupos acadÃ©micos',
                    color: colors.primary,
                    onTap: () => context.push('/academic/grupos'),
                  ),
                  Divider(color: colors.borderLight),
                  _buildMenuOption(
                    context,
                    icon: Icons.book,
                    title: 'Gestionar Materias',
                    subtitle: 'Administrar catÃ¡logo de materias',
                    color: colors.warning,
                    onTap: () => context.push('/academic/materias'),
                  ),
                  Divider(color: colors.borderLight),
                  _buildMenuOption(
                    context,
                    icon: Icons.calendar_view_week,
                    title: 'Gestionar Horarios',
                    subtitle: 'Asignar clases y gestionar horarios',
                    color: colors.success,
                    onTap: () => context.push('/academic/horarios'),
                  ),
                ],
              ),
            ),

            SizedBox(height: spacing.xxl),
            ClarityCard(
              leading: Icon(Icons.info_outline, color: colors.info),
              title: Text(
                'InformaciÃ³n Importante',
                style: textStyles.headlineSmall,
              ),
              subtitle: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'â€¢ Los grupos deben estar asociados a un periodo acadÃ©mico activo',
                    style: textStyles.bodyMedium,
                  ),
                  SizedBox(height: spacing.xs),
                  Text(
                    'â€¢ Las materias pueden ser reutilizadas en diferentes horarios',
                    style: textStyles.bodyMedium,
                  ),
                  SizedBox(height: spacing.xs),
                  Text(
                    'â€¢ Los horarios incluyen validaciÃ³n automÃ¡tica de conflictos',
                    style: textStyles.bodyMedium,
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildMenuOption(
    BuildContext context, {
    required IconData icon,
    required String title,
    required String subtitle,
    required Color color,
    required VoidCallback onTap,
  }) {
    final colors = AppColors.instance;
    final textStyles = AppTextStyles.instance;
    final spacing = AppSpacing.instance;

    return ListTile(
      leading: CircleAvatar(
        backgroundColor: color.withValues(alpha: 0.1),
        child: Icon(icon, color: color),
      ),
      title: Text(title, style: textStyles.headlineSmall),
      subtitle: Text(
        subtitle,
        style: textStyles.bodyMedium.copyWith(color: colors.textMuted),
      ),
      trailing: Icon(Icons.arrow_forward_ios, color: colors.textDisabled),
      onTap: onTap,
      contentPadding: EdgeInsets.symmetric(
        horizontal: spacing.lg,
        vertical: spacing.md,
      ),
    );
  }
}
/* Fin lib\screens\academic\gestion_academica_screen.dart */

/* Inicio lib\screens\academic\grupos_screen.dart */
import 'package:flutter/material.dart';
import '../../theme/app_colors.dart';
import '../../theme/app_spacing.dart';

class GruposScreen extends StatefulWidget {
  const GruposScreen({super.key});

  @override
  State<GruposScreen> createState() => _GruposScreenState();
}

class _GruposScreenState extends State<GruposScreen> {
  final AppColors colors = AppColors.instance;
  final AppSpacing spacing = AppSpacing.instance;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Grupos'),
        backgroundColor: colors.primary,
        foregroundColor: colors.white,
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.group,
              size: 64,
              color: colors.textMuted,
            ),
            SizedBox(height: spacing.md),
            Text(
              'Pantalla de Grupos',
              style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                color: colors.textPrimary,
              ),
            ),
            SizedBox(height: spacing.sm),
            Text(
              'Esta funcionalidad estÃ¡ en desarrollo',
              style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                color: colors.textMuted,
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
}

/* Fin lib\screens\academic\grupos_screen.dart */

/* Inicio lib\screens\academic\grupo_detail_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'dart:async';
import '../../models/grupo.dart';
import '../../models/user.dart';
import '../../providers/auth_provider.dart';
import '../../providers/grupo_provider.dart';
import '../../providers/estudiantes_by_grupo_paginated_provider.dart';
import '../../providers/estudiantes_sin_asignar_paginated_provider.dart';
import '../../theme/theme_extensions.dart';
import '../../widgets/components/index.dart';

class GrupoDetailScreen extends StatefulWidget {
  final Grupo grupo;

  const GrupoDetailScreen({
    super.key,
    required this.grupo,
  });

  @override
  State<GrupoDetailScreen> createState() => _GrupoDetailScreenState();
}

class _GrupoDetailScreenState extends State<GrupoDetailScreen> {

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      await _loadEstudiantes();
    });
  }

  Future<void> _loadEstudiantes() async {

    try {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

      final token = authProvider.accessToken;
      if (token == null) return;
    final byGrupo = Provider.of<EstudiantesByGrupoPaginatedProvider>(context, listen: false);
    final sinAsignar = Provider.of<EstudiantesSinAsignarPaginatedProvider>(context, listen: false);
    await byGrupo.loadItems(token, page: 1, limit: 10, filters: {'grupoId': widget.grupo.id});
    await sinAsignar.loadItems(token, page: 1, limit: 10);

    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error al cargar estudiantes: $e'),
            backgroundColor: context.colors.error,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {});
      }
    }
  }
  Future<void> _asignarEstudiante(User estudiante) async {
    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final grupoProvider = Provider.of<GrupoProvider>(context, listen: false);
      final byGrupo = Provider.of<EstudiantesByGrupoPaginatedProvider>(context, listen: false);
      final sinAsignar = Provider.of<EstudiantesSinAsignarPaginatedProvider>(context, listen: false);

      final token = authProvider.accessToken;
      if (token == null) return;

      final success = await grupoProvider.asignarEstudianteAGrupo(
        token,
        widget.grupo.id,
        estudiante.id,
      );

      if (success) {
        await byGrupo.loadItems(token, page: 1, limit: 10, filters: {'grupoId': widget.grupo.id});
        await sinAsignar.loadItems(token, page: 1, limit: 10);
        setState(() {});

        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('${estudiante.nombreCompleto} asignado al grupo'),
              backgroundColor: context.colors.success,
            ),
          );
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error al asignar estudiante: $e'),
            backgroundColor: context.colors.error,
          ),
        );
      }
    }
  }

  Future<void> _desasignarEstudiante(User estudiante) async {
    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final grupoProvider = Provider.of<GrupoProvider>(context, listen: false);
      final byGrupo = Provider.of<EstudiantesByGrupoPaginatedProvider>(context, listen: false);
      final sinAsignar = Provider.of<EstudiantesSinAsignarPaginatedProvider>(context, listen: false);

      final token = authProvider.accessToken;
      if (token == null) return;

      final success = await grupoProvider.desasignarEstudianteDeGrupo(
        token,
        widget.grupo.id,
        estudiante.id,
      );

      if (success) {
        await byGrupo.loadItems(token, page: 1, limit: 10, filters: {'grupoId': widget.grupo.id});
        await sinAsignar.loadItems(token, page: 1, limit: 10);
        setState(() {});

        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('${estudiante.nombreCompleto} removido del grupo'),
              backgroundColor: context.colors.success,
            ),
          );
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error al remover estudiante: $e'),
            backgroundColor: context.colors.error,
          ),
        );
      }
    }
  }

  void _showAsignarEstudianteDialog() {
    showDialog(
      context: context,
      builder: (context) => AsignarEstudianteDialog(
        onAsignar: (estudiantes) {
          for (final estudiante in estudiantes) {
            _asignarEstudiante(estudiante);
          }
        },
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Detalles del Grupo'),
        backgroundColor: colors.primary,
        foregroundColor: colors.getTextColorForBackground(colors.primary),
      ),
      body: Builder(builder: (context) {
        final byGrupo = Provider.of<EstudiantesByGrupoPaginatedProvider>(context);
        final sinAsignar = Provider.of<EstudiantesSinAsignarPaginatedProvider>(context);
        final isLoading = (byGrupo.isLoading || sinAsignar.isLoading) &&
            (byGrupo.items.isEmpty && sinAsignar.items.isEmpty);

        return isLoading
            ? const Center(child: CircularProgressIndicator())
        : SingleChildScrollView(
            padding: EdgeInsets.all(spacing.lg),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                ClarityCard(
                  title: Text(
                    'InformaciÃ³n del Grupo',
                    style: textStyles.titleMedium.bold,
                  ),
                  leading: Icon(
                    Icons.group,
                    color: colors.primary,
                  ),
                  subtitle: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        widget.grupo.nombre,
                        style: textStyles.headlineMedium.bold,
                      ),
                      SizedBox(height: spacing.sm),
                      Text(
                        'Estudiantes: ${byGrupo.items.length}',
                        style: textStyles.bodyMedium,
                      ),
                      Text(
                        'Horarios: ${widget.grupo.horariosCount}',
                        style: textStyles.bodyMedium,
                      ),
                    ],
                  ),
                ),

                SizedBox(height: spacing.xl),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      'Estudiantes Asignados',
                      style: textStyles.headlineMedium.bold,
                    ),
                    ElevatedButton.icon(
                      onPressed: _showAsignarEstudianteDialog,
                      icon: const Icon(Icons.add),
                      label: const Text('Asignar Estudiante'),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: colors.primary,
                        foregroundColor: colors.onPrimary,
                      ),
                    ),
                  ],
                ),

                SizedBox(height: spacing.lg),

                byGrupo.items.isEmpty
                  ? Center(
                      child: Padding(
                        padding: EdgeInsets.all(spacing.xl),
                        child: Column(
                          children: [
                            Icon(
                              Icons.group_off,
                              size: 64,
                              color: colors.textSecondary,
                            ),
                            SizedBox(height: spacing.md),
                            Text(
                              'No hay estudiantes asignados',
                              style: textStyles.bodyLarge.withColor(colors.textSecondary),
                            ),
                            SizedBox(height: spacing.md),
                            Text(
                              'Asigna estudiantes para que puedan registrar asistencia',
                              style: textStyles.bodyMedium.withColor(colors.textSecondary),
                              textAlign: TextAlign.center,
                            ),
                          ],
                        ),
                      ),
                    )
                  : ListView.builder(
                      shrinkWrap: true,
                      physics: const NeverScrollableScrollPhysics(),
                      itemCount: byGrupo.items.length,
                      itemBuilder: (context, index) {
                        final estudiante = byGrupo.items[index];
                        return Card(
                          margin: EdgeInsets.only(bottom: spacing.sm),
                          child: ListTile(
                            leading: CircleAvatar(
                              backgroundColor: colors.primary,
                              child: Text(
                                estudiante.inicial,
                                style: textStyles.button.withColor(colors.onPrimary),
                              ),
                            ),
                            title: Text(estudiante.nombreCompleto),
                            subtitle: Text(estudiante.email),
                            trailing: IconButton(
                              icon: Icon(Icons.remove_circle, color: colors.error),
                              onPressed: () => _desasignarEstudiante(estudiante),
                              tooltip: 'Remover del grupo',
                            ),
                          ),
                        );
                      },
                    ),
              ],
            ),
      );
    }),
    );
  }
}

class AsignarEstudianteDialog extends StatefulWidget {
  final Function(List<User>) onAsignar;

  const AsignarEstudianteDialog({
    super.key,
    required this.onAsignar,
  });

  @override
  State<AsignarEstudianteDialog> createState() => _AsignarEstudianteDialogState();
}

class _AsignarEstudianteDialogState extends State<AsignarEstudianteDialog> {
  final TextEditingController _searchController = TextEditingController();
  List<User> _filteredEstudiantes = [];
  Timer? _debounce;
  final ScrollController _scrollController = ScrollController();
  Set<String> _selectedEstudiantes = {};

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final token = authProvider.accessToken;
      final sinAsignar = Provider.of<EstudiantesSinAsignarPaginatedProvider>(context, listen: false);
      if (token != null) {
        sinAsignar.loadItems(token, page: 1, limit: 10);
      }
      setState(() {
        _filteredEstudiantes = sinAsignar.items;
      });
    });
  _searchController.addListener(_filterEstudiantes);
    _scrollController.addListener(_onScroll);
  }

  @override
  void dispose() {
    _searchController.dispose();
    _debounce?.cancel();
    _scrollController.removeListener(_onScroll);
    _scrollController.dispose();
    super.dispose();
  }

  void _filterEstudiantes() {
    final query = _searchController.text.toLowerCase();
    final sinAsignar = Provider.of<EstudiantesSinAsignarPaginatedProvider>(context, listen: false);
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final token = authProvider.accessToken;
    _debounce?.cancel();
    _debounce = Timer(const Duration(milliseconds: 300), () {
      if (token == null) return;
      if (query.isEmpty) {
        sinAsignar.loadItems(token, page: 1, limit: 10);
      } else {
        sinAsignar.loadItems(token, page: 1, limit: 10, search: query);
      }
      setState(() {
        _filteredEstudiantes = sinAsignar.items;
      });
    });
  }

  void _toggleSeleccion(String estudianteId) {
    setState(() {
      if (_selectedEstudiantes.contains(estudianteId)) {
        _selectedEstudiantes.remove(estudianteId);
      } else {
        _selectedEstudiantes.add(estudianteId);
      }
    });
  }

  void _asignarSeleccionados() {
    final sinAsignar = Provider.of<EstudiantesSinAsignarPaginatedProvider>(context, listen: false);
    final estudiantesSeleccionados = sinAsignar.items
        .where((estudiante) => _selectedEstudiantes.contains(estudiante.id))
        .toList();

    if (estudiantesSeleccionados.isNotEmpty) {
      widget.onAsignar(estudiantesSeleccionados);
      Navigator.of(context).pop();
    }
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return AlertDialog(
      title: Text('Asignar Estudiantes', style: textStyles.headlineMedium),
      content: SizedBox(
        width: double.maxFinite,
        height: 400,
        child: Column(
            children: [
            TextField(
              controller: _searchController,
                decoration: InputDecoration(
                hintText: 'Buscar estudiantes...',
                prefixIcon: const Icon(Icons.search),
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(spacing.borderRadius),
                ),
                contentPadding: EdgeInsets.symmetric(
                  horizontal: spacing.md,
                  vertical: spacing.sm,
                ),
              ),
            ),
            SizedBox(height: spacing.md),
            if (_selectedEstudiantes.isNotEmpty)
              Container(
                padding: EdgeInsets.symmetric(horizontal: spacing.sm, vertical: 4),
                decoration: BoxDecoration(
                  color: colors.primary.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(spacing.borderRadius / 2),
                ),
                child: Text(
                  '${_selectedEstudiantes.length} estudiante${_selectedEstudiantes.length != 1 ? 's' : ''} seleccionado${_selectedEstudiantes.length != 1 ? 's' : ''}',
                  style: textStyles.labelSmall.copyWith(
                    color: colors.primary,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),

            SizedBox(height: spacing.md),
            Expanded(
              child: Builder(builder: (context) {
                final sinAsignar = Provider.of<EstudiantesSinAsignarPaginatedProvider>(context);
                final items = _searchController.text.isEmpty ? sinAsignar.items : _filteredEstudiantes.isNotEmpty ? _filteredEstudiantes : sinAsignar.items;
                if (sinAsignar.isLoading && items.isEmpty) {
                  return const Center(child: CircularProgressIndicator());
                }

                return items.isEmpty
                ? Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(
                          Icons.person_search,
                          size: 48,
                          color: colors.textMuted,
                        ),
                        SizedBox(height: spacing.md),
                        Text(
                          _searchController.text.isEmpty
                            ? 'No hay estudiantes disponibles'
                            : 'No se encontraron estudiantes',
                          style: textStyles.bodyMedium.copyWith(color: colors.textSecondary),
                          textAlign: TextAlign.center,
                        ),
                      ],
                    ),
                  )
                : ListView.builder(
                    controller: _scrollController,
                    itemCount: items.length + (sinAsignar.hasMoreData ? 1 : 0),
                    itemBuilder: (context, index) {
                      if (index >= items.length) {
                        return Padding(
                          padding: const EdgeInsets.symmetric(vertical: 8),
                          child: Center(
                            child: ElevatedButton(
                              onPressed: sinAsignar.isLoadingMore || !sinAsignar.hasMoreData
                                  ? null
                                  : () {
                                      final token = Provider.of<AuthProvider>(context, listen: false).accessToken;
                                      if (token != null) sinAsignar.loadNextPage(token);
                                    },
                              child: Text(sinAsignar.isLoadingMore ? 'Cargando...' : 'Cargar mÃ¡s'),
                            ),
                          ),
                        );
                      }

                      final estudiante = items[index];
                      final isSelected = _selectedEstudiantes.contains(estudiante.id);

                      return Card(
                        margin: EdgeInsets.only(bottom: spacing.xs),
                        color: isSelected ? colors.primary.withValues(alpha: 0.05) : null,
                        child: InkWell(
                          onTap: () => _toggleSeleccion(estudiante.id),
                          child: Padding(
                            padding: EdgeInsets.all(spacing.sm),
                            child: Row(
                              children: [
                                Checkbox(
                                  value: isSelected,
                                  onChanged: (value) => _toggleSeleccion(estudiante.id),
                                  activeColor: colors.primary,
                                ),
                                SizedBox(width: spacing.sm),
                                CircleAvatar(
                                  backgroundColor: colors.primary,
                                  radius: 20,
                                  child: Text(
                                    estudiante.inicial,
                                    style: textStyles.button.copyWith(color: colors.onPrimary),
                                  ),
                                ),
                                SizedBox(width: spacing.md),
                                Expanded(
                                  child: Column(
                                    crossAxisAlignment: CrossAxisAlignment.start,
                                    children: [
                                      Text(
                                        estudiante.nombreCompleto,
                                        style: textStyles.bodyMedium.copyWith(
                                          fontWeight: FontWeight.w600,
                                          color: colors.textPrimary,
                                        ),
                                      ),
                                      Text(
                                        estudiante.email,
                                        style: textStyles.bodySmall.copyWith(
                                          color: colors.textSecondary,
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ),
                      );
                    },
        );
      }),
            ),
          ],
        ),
      ),
        actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Cancelar'),
        ),
        ElevatedButton(
          onPressed: _selectedEstudiantes.isEmpty ? null : _asignarSeleccionados,
          style: ElevatedButton.styleFrom(
            backgroundColor: colors.primary,
            foregroundColor: colors.onPrimary,
          ),
          child: Text('Asignar (${_selectedEstudiantes.length})'),
        ),
      ],
    );
  }

  void _onScroll() {
    final sinAsignar = Provider.of<EstudiantesSinAsignarPaginatedProvider>(context, listen: false);
    if (!_scrollController.hasClients) return;
    final maxScroll = _scrollController.position.maxScrollExtent;
    final currentScroll = _scrollController.position.pixels;
    if (currentScroll >= (maxScroll - 100) && sinAsignar.hasMoreData && !sinAsignar.isLoadingMore) {
      final token = Provider.of<AuthProvider>(context, listen: false).accessToken;
      if (token != null) sinAsignar.loadNextPage(token);
    }
  }
}
/* Fin lib\screens\academic\grupo_detail_screen.dart */

/* Inicio lib\screens\academic\horarios_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:focus_detector/focus_detector.dart';

import '../../models/grupo.dart';
import '../../models/horario.dart';
import '../../providers/auth_provider.dart';
import '../../providers/grupo_provider.dart';
import '../../providers/horario_provider.dart';
import '../../providers/materia_provider.dart';
import '../../providers/periodo_academico_provider.dart';
import '../../providers/user_provider.dart';
import '../../theme/theme_extensions.dart';
import '../../widgets/components/index.dart';
import '../../widgets/horarios/create_class_dialog.dart';
import '../../widgets/horarios/edit_class_dialog.dart';
import '../../widgets/horarios/weekly_calendar.dart';

const List<String> _horas = [
  '07:00',
  '08:00',
  '09:00',
  '10:00',
  '11:00',
  '12:00',
  '13:00',
  '14:00',
  '15:00',
  '16:00',
  '17:00',
  '18:00',
];

const List<String> _diasSemana = [
  'Lunes',
  'Martes',
  'MiÃ©rcoles',
  'Jueves',
  'Viernes',
  'SÃ¡bado',
  'Domingo',
];

const List<int> _diasSemanaValues = [1, 2, 3, 4, 5, 6, 7];

class HorariosScreen extends StatefulWidget {
  const HorariosScreen({super.key});

  @override
  State<HorariosScreen> createState() => _HorariosScreenState();
}

class _HorariosScreenState extends State<HorariosScreen> {
  Grupo? _selectedGrupo;
  PeriodoAcademico? _selectedPeriodo;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadInitialData();
    });
  }

  Future<void> _loadInitialData() async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final token = authProvider.accessToken;
    if (token == null) return;

    final periodoProvider = Provider.of<PeriodoAcademicoProvider>(context, listen: false);
    final grupoProvider = Provider.of<GrupoProvider>(context, listen: false);
    final materiaProvider = Provider.of<MateriaProvider>(context, listen: false);
    final userProvider = Provider.of<UserProvider>(context, listen: false);

    try {
      await periodoProvider.loadPeriodosActivos(token);

      if (periodoProvider.periodosActivos.isNotEmpty) {
        final periodo = periodoProvider.periodosActivos.first;
        if (!mounted) return;
        setState(() => _selectedPeriodo = periodo);
        await grupoProvider.loadGrupos(token, periodoId: periodo.id);
      } else {
        await grupoProvider.loadGrupos(token);
      }

      if (!mounted) return;
      if (grupoProvider.items.isNotEmpty) {
        setState(() => _selectedGrupo = grupoProvider.items.first);
        await _loadHorariosForGrupo(_selectedGrupo!.id);
      }

      await materiaProvider.loadMaterias(token);

      final institutionId = authProvider.selectedInstitutionId;
      if (institutionId != null) {
        await userProvider.loadUsersByInstitution(token, institutionId);
      } else {
        await userProvider.loadUsers(token, roles: ['profesor']);
      }
    } catch (error) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error cargando datos iniciales: $error'),
          backgroundColor: context.colors.error,
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return FocusDetector(
      onFocusGained: _onFocusGained,
      child: Consumer4<PeriodoAcademicoProvider, GrupoProvider, HorarioProvider, MateriaProvider>(
        builder: (context, periodoProvider, grupoProvider, horarioProvider, materiaProvider, child) {
          return ClarityManagementPage(
            title: 'Horarios',
            isLoading: horarioProvider.isLoading,
            hasError: horarioProvider.hasError,
            errorMessage: horarioProvider.errorMessage,
            itemCount: _selectedGrupo != null ? 1 : 0,
            itemBuilder: (context, index) => WeeklyCalendar(
              horarioProvider: horarioProvider,
              horas: _horas,
              diasSemana: _diasSemana,
              diasSemanaValues: _diasSemanaValues,
              onEmptyCellTap: _handleEmptyCellTap,
              onHorarioTap: _handleHorarioTap,
            ),
            filterWidgets: _buildFilterWidgets(context, periodoProvider, grupoProvider, materiaProvider),
            onRefresh: () async {
              if (_selectedGrupo != null) {
                await _loadHorariosForGrupo(_selectedGrupo!.id);
              }

              await materiaProvider.loadMaterias(
                Provider.of<AuthProvider>(context, listen: false).accessToken!
              );
            },
            scrollController: null,
            emptyStateWidget: ClarityEmptyState(
              icon: Icons.calendar_month,
              title: _selectedGrupo == null ? 'Selecciona un grupo' : 'No hay clases en el grupo',
              subtitle: _selectedGrupo == null
                  ? 'Selecciona un grupo para ver el calendario semanal'
                  : 'Crea la primera clase para este grupo',
            ),
            floatingActionButton: FloatingActionButton(
              onPressed: () {
                if (_selectedGrupo == null) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('Selecciona un grupo para crear una clase')),
                  );
                  return;
                }
                _handleEmptyCellTap(_horas.first, _diasSemanaValues.first);
              },
              tooltip: 'Crear Clase',
              child: const Icon(Icons.add),
            ),
          );
        },
      ),
    );
  }

  Future<void> _onFocusGained() async {

    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final token = authProvider.accessToken;
    if (token == null) return;

    final materiaProvider = Provider.of<MateriaProvider>(context, listen: false);

    await materiaProvider.loadMaterias(token);

  }

  List<Widget> _buildFilterWidgets(
    BuildContext context,
    PeriodoAcademicoProvider periodoProvider,
    GrupoProvider grupoProvider,
    MateriaProvider materiaProvider,
  ) {
    final spacing = context.spacing;

    return [
      LayoutBuilder(
        builder: (context, constraints) {
          final width = constraints.maxWidth;
          final columns = width >= 1024 ? 3 : (width >= 600 ? 2 : 1);
          final itemWidth = (width - ((columns - 1) * 12)) / columns;

          return Wrap(
            spacing: 12,
            runSpacing: 12,
            alignment: WrapAlignment.start,
            children: [
              SizedBox(
                width: itemWidth,
                child: DropdownButtonFormField<PeriodoAcademico>(
                  isExpanded: true,
                  value: _selectedPeriodo,
                  decoration: InputDecoration(
                    labelText: 'PerÃ­odo AcadÃ©mico',
                    isDense: true,
                    contentPadding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
                  ),
                  style: context.textStyles.bodyLarge,
                  items: periodoProvider.periodosActivos
                      .map(
                        (periodo) => DropdownMenuItem<PeriodoAcademico>(
                          value: periodo,
                          child: Text(periodo.nombre, overflow: TextOverflow.ellipsis, maxLines: 1),
                        ),
                      )
                      .toList(),
                  onChanged: (periodo) => _onPeriodoChanged(periodo, grupoProvider),
                ),
              ),
              SizedBox(
                width: itemWidth,
                child: DropdownButtonFormField<Grupo>(
                  isExpanded: true,
                  value: _selectedGrupo,
                  decoration: const InputDecoration(labelText: 'Grupo'),
                  items: _buildGrupoItems(grupoProvider),
                  onChanged: _handleGrupoDropdownChanged,
                ),
              ),
            ],
          );
        },
      ),
    ];
  }

  List<DropdownMenuItem<Grupo>> _buildGrupoItems(GrupoProvider grupoProvider) {
    final grupos = _selectedPeriodo == null
        ? grupoProvider.items
        : grupoProvider.items.where((grupo) => grupo.periodoId == _selectedPeriodo!.id).toList();

    return grupos
        .map(
          (grupo) => DropdownMenuItem<Grupo>(
            value: grupo,
            child: Text('${grupo.nombre} - ${grupo.grado}', overflow: TextOverflow.ellipsis, maxLines: 1),
          ),
        )
        .toList();
  }

  Future<void> _onPeriodoChanged(PeriodoAcademico? periodo, GrupoProvider grupoProvider) async {
    if (!mounted) return;

    setState(() {
      _selectedPeriodo = periodo;
      _selectedGrupo = null;
    });

    final token = Provider.of<AuthProvider>(context, listen: false).accessToken;
    if (token == null) return;

    if (periodo != null) {
      await grupoProvider.loadGrupos(token, periodoId: periodo.id);
    } else {
      await grupoProvider.loadGrupos(token);
    }

    if (!mounted) return;

    if (grupoProvider.items.isNotEmpty) {
      setState(() => _selectedGrupo = grupoProvider.items.first);
      await _loadHorariosForGrupo(_selectedGrupo!.id);
    }
  }

  void _handleGrupoDropdownChanged(Grupo? grupo) {
    _onGrupoChanged(grupo);
  }

  Future<void> _onGrupoChanged(Grupo? grupo) async {
    if (!mounted) return;

    setState(() => _selectedGrupo = grupo);

    if (grupo != null) {
      await _loadHorariosForGrupo(grupo.id);
    }
  }

  Future<void> _loadHorariosForGrupo(String grupoId) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final horarioProvider = Provider.of<HorarioProvider>(context, listen: false);
    final token = authProvider.accessToken;
    if (token == null) return;

    try {
      if (_selectedPeriodo != null) {
        await horarioProvider.loadHorariosForGrupoWithConflictDetection(token, grupoId, _selectedPeriodo!.id);
      } else {
        await horarioProvider.loadHorariosByGrupo(token, grupoId);
      }
    } catch (error) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error cargando horarios: $error'),
          backgroundColor: context.colors.error,
        ),
      );
    }
  }

  Future<void> _handleEmptyCellTap(String horaInicio, int diaSemana) async {
    if (_selectedGrupo == null) return;

    final created = await showDialog<bool>(
      context: context,
      builder: (context) => CreateClassDialog(
        grupo: _selectedGrupo!,
        horaInicio: horaInicio,
        diaSemana: diaSemana,
      ),
    );

    if (created == true && _selectedGrupo != null) {
      await _loadHorariosForGrupo(_selectedGrupo!.id);
    }
  }

  Future<void> _handleHorarioTap(Horario horario) async {
    final edited = await showDialog<bool>(
      context: context,
      builder: (context) => EditClassDialog(horario: horario),
    );

    if (edited == true && _selectedGrupo != null) {
      await _loadHorariosForGrupo(_selectedGrupo!.id);
    }
  }
}

/* Fin lib\screens\academic\horarios_screen.dart */

/* Inicio lib\screens\academic\materias_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../../widgets/components/clarity_management_page.dart';
import '../../widgets/components/clarity_components.dart';
import '../../theme/theme_extensions.dart';
import '../../providers/materia_provider.dart';
import '../../providers/auth_provider.dart';
import '../../models/materia.dart';
import 'materia_dialogs.dart';

class MateriasScreen extends StatefulWidget {
  const MateriasScreen({super.key});

  @override
  State<MateriasScreen> createState() => _MateriasScreenState();
}

class _MateriasScreenState extends State<MateriasScreen> {
  final TextEditingController _searchController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  bool _isSearching = false;

  @override
  void initState() {
    super.initState();
    _searchController.addListener(_onSearchChanged);
    _scrollController.addListener(_onScroll);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadMaterias();
    });
  }

  @override
  void dispose() {
    _searchController.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  void _onSearchChanged() {
    final query = _searchController.text.trim();
    setState(() => _isSearching = query.isNotEmpty);

    if (query.isNotEmpty) {
      _loadMaterias(search: query);
    } else {
      _loadMaterias();
    }
  }

  void _onScroll() {
    if (_scrollController.position.pixels == _scrollController.position.maxScrollExtent) {
      _loadMoreMaterias();
    }
  }

  Future<void> _loadMaterias({String? search}) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final materiaProvider = Provider.of<MateriaProvider>(context, listen: false);

    final token = authProvider.accessToken;
    if (token != null) {
      await materiaProvider.loadMaterias(token, search: search);
    }
  }

  Future<void> _loadMoreMaterias() async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final materiaProvider = Provider.of<MateriaProvider>(context, listen: false);

    final token = authProvider.accessToken;
    if (token != null) {
      final search = _isSearching ? _searchController.text.trim() : null;
      await materiaProvider.loadMoreMaterias(token, search: search);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Consumer2<AuthProvider, MateriaProvider>(
      builder: (context, authProvider, materiaProvider, child) {
        return ClarityManagementPage(
          title: 'GestiÃ³n de Materias',
          isLoading: materiaProvider.isLoading,
          hasError: materiaProvider.hasError,
          errorMessage: materiaProvider.errorMessage,
          itemCount: materiaProvider.materias.length,
          itemBuilder: (context, index) {
            final materia = materiaProvider.materias[index];
            return _buildMateriaCard(materia, materiaProvider, context);
          },
          filterWidgets: _buildFilterWidgets(context),
          statisticWidgets: _buildStatisticWidgets(context, materiaProvider),
          onRefresh: _loadMaterias,
          scrollController: _scrollController,
          hasMoreData: materiaProvider.hasMoreData,
          isLoadingMore: materiaProvider.isLoadingMore,
          emptyStateWidget: ClarityEmptyState(
            icon: _isSearching ? Icons.search_off : Icons.subject,
            title: _isSearching
              ? 'No se encontraron resultados'
              : 'AÃºn no has creado ninguna materia',
            subtitle: _isSearching
              ? 'Intenta con otros tÃ©rminos de bÃºsqueda'
              : 'Comienza creando tu primera materia acadÃ©mica',
          ),
          floatingActionButton: FloatingActionButton(
            onPressed: () => _showCreateMateriaDialog(context),
            tooltip: 'Crear Materia',
            child: const Icon(Icons.add),
          ),
        );
      },
    );
  }

  List<Widget> _buildFilterWidgets(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return [
      TextField(
        controller: _searchController,
        style: textStyles.bodyLarge,
        decoration: InputDecoration(
          hintText: 'Buscar por nombre o cÃ³digo...',
          hintStyle: textStyles.bodyMedium.withColor(colors.textMuted),
          prefixIcon: Icon(Icons.search, color: colors.textSecondary),
          suffixIcon: _isSearching
              ? IconButton(
                  icon: Icon(Icons.clear, color: colors.textSecondary),
                  onPressed: () {
                    _searchController.clear();
                    _onSearchChanged();
                  },
                )
              : null,
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.border),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.borderLight),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.primary, width: 2),
          ),
          filled: true,
          fillColor: colors.surface,
          contentPadding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
        ),
        onChanged: (value) => _onSearchChanged(),
      ),
      SizedBox(height: spacing.sm),
      Text(
        'PrÃ³ximamente: MÃ¡s filtros disponibles',
        style: textStyles.bodySmall.copyWith(color: colors.textMuted),
      ),
    ];
  }

  List<Widget> _buildStatisticWidgets(BuildContext context, MateriaProvider provider) {
    final stats = provider.getMateriasStatistics();
    final colors = context.colors;

    return [
      ClarityCompactStat(
        title: 'Total',
        value: stats['total'].toString(),
        icon: Icons.subject,
        color: colors.primary,
      ),
      ClarityCompactStat(
        title: 'Con CÃ³digo',
        value: stats['con_codigo'].toString(),
        icon: Icons.tag,
        color: colors.success,
      ),
      ClarityCompactStat(
        title: 'Sin CÃ³digo',
        value: stats['sin_codigo'].toString(),
        icon: Icons.label_off,
        color: colors.warning,
      ),
    ];
  }

  Widget _buildMateriaCard(Materia materia, MateriaProvider provider, BuildContext context) {
    final colors = context.colors;

    final List<ClarityContextMenuAction> contextActions = [
      ClarityContextMenuAction(
        label: 'Editar',
        icon: Icons.edit,
        color: colors.primary,
        onPressed: () => _showEditMateriaDialog(context, materia),
      ),
      ClarityContextMenuAction(
        label: 'Eliminar',
        icon: Icons.delete,
        color: colors.error,
        onPressed: () => _showDeleteConfirmationDialog(materia, provider),
      ),
    ];

    return ClarityListItem(
      leading: CircleAvatar(
        backgroundColor: colors.primary,
        child: Icon(
          Icons.subject,
          color: colors.white,
        ),
      ),
      title: materia.nombre,
      subtitle: materia.codigo != null ? 'CÃ³digo: ${materia.codigo}' : 'Sin cÃ³digo asignado',
      contextActions: contextActions,
      onTap: () => _navigateToMateriaDetail(materia),
    );
  }

  void _showCreateMateriaDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => const CreateMateriaDialog(),
    ).then((result) {
      if (result == true) {
        _loadMaterias()
      }
    });
  }

  void _showEditMateriaDialog(BuildContext context, Materia materia) {
    showDialog(
      context: context,
      builder: (context) => EditMateriaDialog(materia: materia),
    ).then((result) {
      if (result == true) {
        _loadMaterias()
      }
    });
  }

  void _showDeleteConfirmationDialog(Materia materia, MateriaProvider provider) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Eliminar Materia', style: Theme.of(context).textTheme.headlineSmall),
        content: Text(
          'Â¿EstÃ¡s seguro de que quieres eliminar "${materia.nombre}"?\n\n'
          'Esta acciÃ³n no se puede deshacer.',
          style: Theme.of(context).textTheme.bodyMedium,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: Text('Cancelar', style: Theme.of(context).textTheme.labelLarge),
          ),
          TextButton(
            onPressed: () async {
              Navigator.of(context).pop();
              await _deleteMateria(materia, provider);
            },
            style: TextButton.styleFrom(foregroundColor: Theme.of(context).colorScheme.error),
            child: Text('Eliminar', style: Theme.of(context).textTheme.labelLarge?.copyWith(color: Theme.of(context).colorScheme.error)),
          ),
        ],
      ),
    );
  }

  Future<void> _deleteMateria(Materia materia, MateriaProvider provider) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    final token = authProvider.accessToken;
    if (token == null) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Debes iniciar sesiÃ³n para eliminar una materia')));
      return;
    }

    final success = await provider.deleteMateria(
      token,
      materia.id,
    );

    if (!mounted) return;

    if (success) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            'Materia eliminada correctamente',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onPrimary),
          ),
          backgroundColor: Theme.of(context).colorScheme.primary,
        ),
      );
      await _loadMaterias();
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            provider.errorMessage ?? 'Error al eliminar materia',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onError),
          ),
          backgroundColor: Theme.of(context).colorScheme.error,
        ),
      );
    }
  }

  void _navigateToMateriaDetail(Materia materia) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('Detalle de materia: ${materia.nombre}')),
    );
  }
}
/* Fin lib\screens\academic\materias_screen.dart */

/* Inicio lib\screens\academic\materia_dialogs.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../models/materia.dart';
import '../../providers/auth_provider.dart';
import '../../providers/materia_provider.dart';
import '../../services/academic/materia_service.dart';
import '../../theme/theme_extensions.dart';
import '../../widgets/components/index.dart';
class CreateMateriaDialog extends StatefulWidget {
  const CreateMateriaDialog({super.key});

  @override
  State<CreateMateriaDialog> createState() => _CreateMateriaDialogState();
}

class _CreateMateriaDialogState extends State<CreateMateriaDialog> {
  final _formKey = GlobalKey<FormState>();
  final _nombreController = TextEditingController();
  final _codigoController = TextEditingController();

  @override
  void dispose() {
    _nombreController.dispose();
    _codigoController.dispose();
    super.dispose();
  }

  Future<bool> _createMateria() async {
    if (!_formKey.currentState!.validate()) return false;
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final materiaProvider = Provider.of<MateriaProvider>(context, listen: false);
    final messenger = ScaffoldMessenger.of(context);
    final colors = Theme.of(context).colorScheme;

    try {
      final token = authProvider.accessToken;
      if (token == null) {
        messenger.showSnackBar(const SnackBar(content: Text('Debes iniciar sesiÃ³n para crear una materia')));
        return false;
      }

      final success = await materiaProvider.createMateria(
        token,
        CreateMateriaRequest(
          nombre: _nombreController.text.trim(),
          codigo: _codigoController.text.trim().isEmpty ? null : _codigoController.text.trim(),
        ),
      );

      if (success && mounted) {
        messenger.showSnackBar(const SnackBar(content: Text('Materia creada correctamente')));
        return true;
      } else if (mounted) {
        messenger.showSnackBar(SnackBar(content: Text(materiaProvider.errorMessage ?? 'Error al crear materia'), backgroundColor: colors.error));
      }
    } catch (e) {
      if (mounted) messenger.showSnackBar(SnackBar(content: Text('Error: $e'), backgroundColor: colors.error));
    }
    return false;
  }

  @override
  Widget build(BuildContext context) {
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return ClarityFormDialog(
      title: Text('Crear Materia', style: textStyles.headlineMedium),
      formKey: _formKey,
      onSave: _createMateria,
      saveLabel: 'Crear',
      cancelLabel: 'Cancelar',
      children: [
            TextFormField(
              controller: _nombreController,
              decoration: const InputDecoration(
                labelText: 'Nombre de la Materia',
                hintText: 'Ej: MatemÃ¡ticas, Lenguaje, Ciencias',
              ),
              validator: (value) {
                if (value == null || value.isEmpty) {
                  return 'El nombre es requerido';
                }
                return null;
              },
            ),
            SizedBox(height: spacing.md),
            TextFormField(
              controller: _codigoController,
              decoration: const InputDecoration(
                labelText: 'CÃ³digo (opcional)',
                hintText: 'Ej: MAT101, LEN201',
              ),
            ),
      ],
    );
  }
}
class EditMateriaDialog extends StatefulWidget {
  final Materia materia;

  const EditMateriaDialog({super.key, required this.materia});

  @override
  State<EditMateriaDialog> createState() => _EditMateriaDialogState();
}

class _EditMateriaDialogState extends State<EditMateriaDialog> {
  final _formKey = GlobalKey<FormState>();
  late final TextEditingController _nombreController;
  late final TextEditingController _codigoController;

  @override
  void initState() {
    super.initState();
    _nombreController = TextEditingController(text: widget.materia.nombre);
    _codigoController = TextEditingController(text: widget.materia.codigo ?? '');
  }

  @override
  void dispose() {
    _nombreController.dispose();
    _codigoController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return ClarityFormDialog(
      title: Text('Editar Materia', style: textStyles.headlineMedium),
      formKey: _formKey,
      onSave: _updateMateria,
      saveLabel: 'Actualizar',
      cancelLabel: 'Cancelar',
  children: [
            TextFormField(
              controller: _nombreController,
              decoration: const InputDecoration(
                labelText: 'Nombre de la Materia',
                hintText: 'Ej: MatemÃ¡ticas, Lenguaje, Ciencias',
              ),
              validator: (value) {
                if (value == null || value.isEmpty) {
                  return 'El nombre es requerido';
                }
                return null;
              },
            ),
            SizedBox(height: spacing.md),
            TextFormField(
              controller: _codigoController,
              decoration: const InputDecoration(
                labelText: 'CÃ³digo (opcional)',
                hintText: 'Ej: MAT101, LEN201',
              ),
            ),
      ],
    );
  }

  Future<bool> _updateMateria() async {
    if (!_formKey.currentState!.validate()) return false;
    final messenger = ScaffoldMessenger.of(context);
    final colors = Theme.of(context).colorScheme;

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final materiaProvider = Provider.of<MateriaProvider>(context, listen: false);

      final token = authProvider.accessToken;
      if (token == null) {
        messenger.showSnackBar(const SnackBar(content: Text('Debes iniciar sesiÃ³n para editar una materia')));
        return false;
      }

      final success = await materiaProvider.updateMateria(
        token,
        widget.materia.id,
        UpdateMateriaRequest(
          nombre: _nombreController.text.trim(),
          codigo: _codigoController.text.trim().isEmpty ? null : _codigoController.text.trim(),
        ),
      );

      if (success && mounted) {
        messenger.showSnackBar(
          const SnackBar(content: Text('Materia actualizada correctamente')),
        );
        return true;
      } else if (mounted) {
        messenger.showSnackBar(
          SnackBar(
            content: Text(materiaProvider.errorMessage ?? 'Error al actualizar materia'),
            backgroundColor: colors.error,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        messenger.showSnackBar(
          SnackBar(
            content: Text('Error: $e'),
            backgroundColor: colors.error,
          ),
        );
      }
    } finally {}
    return false;
  }
}

/* Fin lib\screens\academic\materia_dialogs.dart */

/* Inicio lib\screens\academic\periodos_academicos_screen.dart */
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../models/grupo.dart'
import '../../providers/auth_provider.dart';
import '../../providers/periodo_academico_provider.dart';
import '../../services/academic/periodo_service.dart';
import '../../theme/theme_extensions.dart';
import '../../widgets/components/index.dart';

class PeriodosAcademicosScreen extends StatefulWidget {
  const PeriodosAcademicosScreen({super.key});

  @override
  State<PeriodosAcademicosScreen> createState() => _PeriodosAcademicosScreenState();
}

class _PeriodosAcademicosScreenState extends State<PeriodosAcademicosScreen> {
  final TextEditingController _searchController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  bool _isSearching = false;

  @override
  void initState() {
    super.initState();
    _searchController.addListener(_onSearchChanged);
    _scrollController.addListener(_onScroll);
    WidgetsBinding.instance.addPostFrameCallback((_) => _loadPeriodos());
  }

  @override
  void dispose() {
    _searchController.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  void _onSearchChanged() {
    final query = _searchController.text.trim();
    setState(() => _isSearching = query.isNotEmpty);
    _loadPeriodos(search: query.isEmpty ? null : query);
  }

  void _onScroll() {
    if (_scrollController.position.pixels >= _scrollController.position.maxScrollExtent - 180) {
      _loadMorePeriodos();
    }
  }

  Future<void> _loadPeriodos({String? search}) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final periodoProvider = Provider.of<PeriodoAcademicoProvider>(context, listen: false);
    final token = authProvider.accessToken;
    if (token != null) {
      await periodoProvider.loadPeriodosAcademicos(token);
    }
  }

  Future<void> _loadMorePeriodos() async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final periodoProvider = Provider.of<PeriodoAcademicoProvider>(context, listen: false);
    final token2 = authProvider.accessToken;
    if (token2 != null && (periodoProvider.paginationInfo?.hasNext ?? false)) {
      await periodoProvider.loadNextPage(token2);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Consumer2<AuthProvider, PeriodoAcademicoProvider>(
      builder: (context, authProvider, periodoProvider, child) {
        return ClarityManagementPage(
          title: 'PerÃ­odos AcadÃ©micos',
          isLoading: periodoProvider.isLoading,
          hasError: periodoProvider.hasError,
          errorMessage: periodoProvider.errorMessage,
          itemCount: periodoProvider.periodosAcademicos.length,
          itemBuilder: (context, index) {
            final periodo = periodoProvider.periodosAcademicos[index];
            return _buildPeriodoCard(periodo, periodoProvider, context);
          },
          filterWidgets: _buildFilterWidgets(context),
          statisticWidgets: _buildStatisticWidgets(context, periodoProvider),
          onRefresh: _loadPeriodos,
          scrollController: _scrollController,
          hasMoreData: periodoProvider.paginationInfo?.hasNext ?? false,
          isLoadingMore: periodoProvider.isLoading && (periodoProvider.paginationInfo?.hasNext ?? false),
          emptyStateWidget: ClarityEmptyState(
            icon: _isSearching ? Icons.search_off : Icons.calendar_today,
            title: _isSearching ? 'No se encontraron resultados' : 'AÃºn no has creado ningÃºn perÃ­odo acadÃ©mico',
            subtitle: _isSearching ? 'Intenta con otros tÃ©rminos de bÃºsqueda' : 'Comienza creando tu primer perÃ­odo acadÃ©mico',
          ),
          floatingActionButton: FloatingActionButton(
            onPressed: () => _showCreatePeriodoDialog(context),
            tooltip: 'Crear PerÃ­odo AcadÃ©mico',
            child: const Icon(Icons.add),
          ),
        );
      },
    );
  }

  List<Widget> _buildFilterWidgets(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return [
      TextField(
        controller: _searchController,
        style: textStyles.bodyLarge,
        decoration: InputDecoration(
          hintText: 'Buscar por nombre...',
          hintStyle: textStyles.bodyMedium.withColor(colors.textMuted),
          prefixIcon: Icon(Icons.search, color: colors.textSecondary),
          suffixIcon: _isSearching
              ? IconButton(
                  icon: Icon(Icons.clear, color: colors.textSecondary),
                  onPressed: () {
                    _searchController.clear();
                    _onSearchChanged();
                  },
                )
              : null,
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.border),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.borderLight),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.primary, width: 2),
          ),
          filled: true,
          fillColor: colors.surface,
          contentPadding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
        ),
        onChanged: (_) => _onSearchChanged(),
      ),
    ];
  }

  List<Widget> _buildStatisticWidgets(BuildContext context, PeriodoAcademicoProvider provider) {
    final stats = provider.getPeriodosStatistics();
    final colors = context.colors;

    return [
      ClarityCompactStat(
        title: 'Total',
        value: stats['total'].toString(),
        icon: Icons.calendar_today,
        color: colors.primary,
      ),
      ClarityCompactStat(
        title: 'Activos',
        value: stats['activos'].toString(),
        icon: Icons.check_circle,
        color: colors.success,
      ),
      ClarityCompactStat(
        title: 'Inactivos',
        value: stats['inactivos'].toString(),
        icon: Icons.cancel,
        color: colors.error,
      ),
    ];
  }

  Widget _buildPeriodoCard(PeriodoAcademico periodo, PeriodoAcademicoProvider provider, BuildContext context) {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return ClarityListItem(
      leading: Container(
        width: 44,
        height: 44,
        decoration: BoxDecoration(
          color: colors.primary.withValues(alpha: 0.07),
          borderRadius: BorderRadius.circular(8),
        ),
        child: Icon(Icons.calendar_today, color: colors.primary),
      ),
      title: periodo.nombre,
      subtitleWidget: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Del ${periodo.fechaInicio.day}/${periodo.fechaInicio.month}/${periodo.fechaInicio.year} al ${periodo.fechaFin.day}/${periodo.fechaFin.month}/${periodo.fechaFin.year}',
            style: textStyles.bodySmall.copyWith(color: colors.textSecondary),
          ),
          SizedBox(height: spacing.xs),
          Text(
            '${0} grupos asociados',
            style: textStyles.bodySmall.copyWith(color: colors.textMuted),
          ),
        ],
      ),
      badgeText: periodo.activo ? 'Activo' : 'Inactivo',
      badgeColor: periodo.activo ? colors.success : colors.error,
      contextActions: [
        ClarityContextMenuAction(
          label: periodo.activo ? 'Desactivar' : 'Activar',
          icon: periodo.activo ? Icons.visibility_off : Icons.visibility,
          color: periodo.activo ? colors.error : colors.success,
          onPressed: () => _togglePeriodoStatus(context, periodo, provider),
        ),
        ClarityContextMenuAction(
          label: 'Editar',
          icon: Icons.edit,
          color: colors.primary,
          onPressed: () => _showEditPeriodoDialog(context, periodo),
        ),
        ClarityContextMenuAction(
          label: 'Eliminar',
          icon: Icons.delete,
          color: colors.error,
          onPressed: () => _showDeletePeriodoDialog(context, periodo, provider),
        ),
      ],
      onTap: () => Navigator.of(context).pushNamed('/academic/periodos/${periodo.id}'),
    );
  }

  Future<void> _togglePeriodoStatus(BuildContext context, PeriodoAcademico periodo, PeriodoAcademicoProvider provider) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
  final colors = Theme.of(context).colorScheme;
  final messenger = ScaffoldMessenger.of(context);

  final tokenLocal = authProvider.accessToken;
  if (tokenLocal == null) {
    messenger.showSnackBar(const SnackBar(content: Text('Debes iniciar sesiÃ³n para cambiar el estado de un perÃ­odo')));
    return;
  }

  final success = await provider.togglePeriodoStatus(tokenLocal, periodo.id);

    if (!mounted) return;

    if (success) {
  messenger.showSnackBar(
        SnackBar(
          content: Text('PerÃ­odo ${periodo.activo ? 'desactivado' : 'activado'} correctamente'),
        ),
      );
    } else {
  messenger.showSnackBar(
        SnackBar(
          content: Text(provider.errorMessage ?? 'Error al cambiar el status del perÃ­odo'),
          backgroundColor: colors.error,
        ),
      );
    }
  }

  void _showCreatePeriodoDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => const CreatePeriodoDialog(),
    ).then((result) {
      if (result == true) _loadPeriodos();
    });
  }

  void _showEditPeriodoDialog(BuildContext context, PeriodoAcademico periodo) {
    showDialog(
      context: context,
      builder: (context) => EditPeriodoDialog(periodo: periodo),
    ).then((result) {
      if (result == true) _loadPeriodos();
    });
  }

  void _showDeletePeriodoDialog(BuildContext context, PeriodoAcademico periodo, PeriodoAcademicoProvider provider) {
    final colors = Theme.of(context).colorScheme;

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Eliminar PerÃ­odo AcadÃ©mico'),
        content: Text(
          'Â¿EstÃ¡s seguro de que quieres eliminar el perÃ­odo "${periodo.nombre}"? Esta acciÃ³n no se puede deshacer y eliminarÃ¡ todos los grupos asociados.',
        ),
        actions: [
          TextButton(onPressed: () => Navigator.of(context).pop(), child: const Text('Cancelar')),
          TextButton(
            onPressed: () async {
              Navigator.of(context).pop();
              final authProvider = Provider.of<AuthProvider>(context, listen: false);
              final messenger = ScaffoldMessenger.of(context);
              final tokenDelete = authProvider.accessToken;
              if (tokenDelete == null) {
                messenger.showSnackBar(const SnackBar(content: Text('Debes iniciar sesiÃ³n para eliminar un perÃ­odo')));
                return;
              }

              final success = await provider.deletePeriodoAcademico(tokenDelete, periodo.id);
              if (!mounted) return;
              if (success) {
                messenger.showSnackBar(const SnackBar(content: Text('PerÃ­odo acadÃ©mico eliminado correctamente')));
                _loadPeriodos();
              } else {
                messenger.showSnackBar(SnackBar(content: Text(provider.errorMessage ?? 'Error al eliminar perÃ­odo acadÃ©mico'), backgroundColor: colors.error));
              }
            },
            style: TextButton.styleFrom(foregroundColor: colors.error),
            child: const Text('Eliminar'),
          ),
        ],
      ),
    );
  }
}
class CreatePeriodoDialog extends StatefulWidget {
  const CreatePeriodoDialog({super.key});

  @override
  State<CreatePeriodoDialog> createState() => _CreatePeriodoDialogState();
}

class _CreatePeriodoDialogState extends State<CreatePeriodoDialog> {
  final _formKey = GlobalKey<FormState>();
  final TextEditingController _nombreController = TextEditingController();
  DateTime? _fechaInicio;
  DateTime? _fechaFin;

  @override
  void dispose() {
    _nombreController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final textStyles = context.textStyles;
    final spacing = context.spacing;
    return ClarityFormDialog(
      title: Text('Crear PerÃ­odo AcadÃ©mico', style: textStyles.headlineMedium),
      formKey: _formKey,
      onSave: _createPeriodo,
      saveLabel: 'Crear',
      cancelLabel: 'Cancelar',
      children: [
        TextFormField(
          controller: _nombreController,
          decoration: const InputDecoration(
            labelText: 'Nombre del PerÃ­odo',
            hintText: 'Ej: AÃ±o 2025, Semestre 2025-I',
          ),
          validator: (value) {
            if (value == null || value.isEmpty) return 'El nombre es requerido';
            return null;
          },
        ),

        SizedBox(height: spacing.md),
        InkWell(
          onTap: () async {
            final picked = await showDatePicker(
              context: context,
              initialDate: DateTime.now(),
              firstDate: DateTime(2020),
              lastDate: DateTime(2030),
            );
            if (picked != null) setState(() => _fechaInicio = picked);
          },
          child: InputDecorator(
            decoration: const InputDecoration(labelText: 'Fecha de Inicio'),
            child: Text(_fechaInicio != null ? '${_fechaInicio!.day}/${_fechaInicio!.month}/${_fechaInicio!.year}' : 'Seleccionar fecha'),
          ),
        ),

        SizedBox(height: spacing.md),
        InkWell(
          onTap: () async {
            final picked = await showDatePicker(
              context: context,
              initialDate: _fechaInicio ?? DateTime.now(),
              firstDate: _fechaInicio ?? DateTime(2020),
              lastDate: DateTime(2030),
            );
            if (picked != null) setState(() => _fechaFin = picked);
          },
          child: InputDecorator(
            decoration: const InputDecoration(labelText: 'Fecha de Fin'),
            child: Text(_fechaFin != null ? '${_fechaFin!.day}/${_fechaFin!.month}/${_fechaFin!.year}' : 'Seleccionar fecha'),
          ),
        ),
      ],
    );
  }

  Future<bool> _createPeriodo() async {
    if (!_formKey.currentState!.validate()) return false;
    if (_fechaInicio == null || _fechaFin == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Debes seleccionar ambas fechas'),
          backgroundColor: Colors.orange,
        ),
      );
      return false;
    }

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final periodoProvider = Provider.of<PeriodoAcademicoProvider>(context, listen: false);
      final colors = Theme.of(context).colorScheme;

      final token = authProvider.accessToken;
      if (token == null) {
        if (mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Debes iniciar sesiÃ³n para crear perÃ­odos')));
        return false;
      }

      final success = await periodoProvider.createPeriodoAcademico(
        token,
        CreatePeriodoAcademicoRequest(
          nombre: _nombreController.text.trim(),
          fechaInicio: _fechaInicio!.toIso8601String(),
          fechaFin: _fechaFin!.toIso8601String(),
        ),
      );

      if (success && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('PerÃ­odo acadÃ©mico creado correctamente')),
        );
        return true;
      } else if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(periodoProvider.errorMessage ?? 'Error al crear perÃ­odo acadÃ©mico'),
            backgroundColor: colors.error,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: $e'),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
      return false;
    } finally {}
    return false;
  }
}
class EditPeriodoDialog extends StatefulWidget {
  final PeriodoAcademico periodo;

  const EditPeriodoDialog({super.key, required this.periodo});

  @override
  State<EditPeriodoDialog> createState() => _EditPeriodoDialogState();
}

class _EditPeriodoDialogState extends State<EditPeriodoDialog> {
  final _formKey = GlobalKey<FormState>();
  late final TextEditingController _nombreController;
  DateTime? _fechaInicio;
  DateTime? _fechaFin;

  @override
  void initState() {
    super.initState();
    _nombreController = TextEditingController(text: widget.periodo.nombre);
    _fechaInicio = widget.periodo.fechaInicio;
    _fechaFin = widget.periodo.fechaFin;
  }

  @override
  void dispose() {
    _nombreController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return ClarityFormDialog(
      title: Text('Editar PerÃ­odo AcadÃ©mico', style: textStyles.headlineMedium),
      formKey: _formKey,
      onSave: _updatePeriodo,
      saveLabel: 'Actualizar',
      cancelLabel: 'Cancelar',
      children: [
        TextFormField(
          controller: _nombreController,
          decoration: const InputDecoration(
            labelText: 'Nombre del PerÃ­odo',
            hintText: 'Ej: AÃ±o 2025, Semestre 2025-I',
          ),
          validator: (value) {
            if (value == null || value.isEmpty) return 'El nombre es requerido';
            return null;
          },
        ),

        SizedBox(height: spacing.md),
        InkWell(
          onTap: () async {
            final picked = await showDatePicker(
              context: context,
              initialDate: _fechaInicio ?? DateTime.now(),
              firstDate: DateTime(2020),
              lastDate: DateTime(2030),
            );
            if (picked != null) setState(() => _fechaInicio = picked);
          },
          child: InputDecorator(
            decoration: const InputDecoration(labelText: 'Fecha de Inicio'),
            child: Text(_fechaInicio != null ? '${_fechaInicio!.day}/${_fechaInicio!.month}/${_fechaInicio!.year}' : 'Seleccionar fecha'),
          ),
        ),

        SizedBox(height: spacing.md),
        InkWell(
          onTap: () async {
            final picked = await showDatePicker(
              context: context,
              initialDate: _fechaFin ?? DateTime.now(),
              firstDate: _fechaInicio ?? DateTime(2020),
              lastDate: DateTime(2030),
            );
            if (picked != null) setState(() => _fechaFin = picked);
          },
          child: InputDecorator(
            decoration: const InputDecoration(labelText: 'Fecha de Fin'),
            child: Text(_fechaFin != null ? '${_fechaFin!.day}/${_fechaFin!.month}/${_fechaFin!.year}' : 'Seleccionar fecha'),
          ),
        ),
      ],
    );
  }

  Future<bool> _updatePeriodo() async {
    if (!_formKey.currentState!.validate()) return false;
    if (_fechaInicio == null || _fechaFin == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Debes seleccionar ambas fechas'),
          backgroundColor: Colors.orange,
        ),
      );
          return false;
    }

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final periodoProvider = Provider.of<PeriodoAcademicoProvider>(context, listen: false);
      final colors = Theme.of(context).colorScheme;

      final token = authProvider.accessToken;
      if (token == null) {
        if (mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Debes iniciar sesiÃ³n para actualizar perÃ­odos')));
        return false;
      }

      final success = await periodoProvider.updatePeriodoAcademico(
        token,
        widget.periodo.id,
        UpdatePeriodoAcademicoRequest(
          nombre: _nombreController.text.trim(),
          fechaInicio: _fechaInicio!.toIso8601String(),
          fechaFin: _fechaFin!.toIso8601String(),
        ),
      );

      if (success && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('PerÃ­odo acadÃ©mico actualizado correctamente')),
        );
        return true;
          } else if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(periodoProvider.errorMessage ?? 'Error al actualizar perÃ­odo acadÃ©mico'),
            backgroundColor: colors.error,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: $e'),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    } finally {}
    return false;
  }
}
/* Fin lib\screens\academic\periodos_academicos_screen.dart */

/* Inicio lib\screens\admin_dashboard.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../providers/user_provider.dart';
import '../providers/institution_provider.dart';
import '../theme/theme_extensions.dart';
import '../widgets/components/index.dart';
import '../widgets/common/dashboard_scaffold.dart';

class AdminDashboard extends StatefulWidget {
  const AdminDashboard({super.key});

  @override
  @override
  State<AdminDashboard> createState() => _AdminDashboardState();
}

class _AdminDashboardState extends State<AdminDashboard> {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      try {
        final authProvider = Provider.of<AuthProvider>(context, listen: false);
        final userProvider = Provider.of<UserProvider>(context, listen: false);

        final selectedInstitutionId = authProvider.selectedInstitutionId;
        final token = authProvider.accessToken;
        if (selectedInstitutionId != null && token != null) {
          await userProvider.loadUsersByInstitution(token, selectedInstitutionId);
        }
      } catch (e) {
        debugPrint('AdminDashboard init load error: $e');
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final userProvider = Provider.of<UserProvider>(context);
  final colors = context.colors;

    final user = authProvider.user;
    final userName = user?['nombres'] ?? 'Usuario';
    final stats = userProvider.getUserStatistics();
    return DashboardScaffold(
      userName: userName,
      subtitle: 'Bienvenido al panel de administraciÃ³n.',
      statsWidgets: [
        ClarityCompactStat(value: stats['total']?.toString() ?? '0', title: 'Usuarios', icon: Icons.people, color: colors.primary),
        ClarityCompactStat(value: stats['profesores']?.toString() ?? userProvider.professorsCount.toString(), title: 'Profesores', icon: Icons.school, color: colors.info),
        ClarityCompactStat(value: stats['estudiantes']?.toString() ?? userProvider.studentsCount.toString(), title: 'Estudiantes', icon: Icons.person, color: colors.warning),
      ],
      kpiWidget: _buildKpiRow(context, userProvider),
      recentActivityWidget: _buildRecentActivity(context, userProvider),
      actionItems: [
        DashboardActionItem(icon: Icons.people_outline_rounded, label: 'Usuarios', onTap: () => context.go('/users')),
        DashboardActionItem(icon: Icons.school_outlined, label: 'GestiÃ³n AcadÃ©mica', onTap: () => context.go('/academic')),
        DashboardActionItem(icon: Icons.calendar_today_outlined, label: 'Horarios', onTap: () {}),
        DashboardActionItem(icon: Icons.settings_outlined, label: 'Ajustes', onTap: () {}),
      ],
    );
  }

  Widget _buildKpiRow(BuildContext context, UserProvider userProvider) {
    final institutionProvider = Provider.of<InstitutionProvider>(context);
    final colors = context.colors;
    final spacing = context.spacing;

    return Padding(
      padding: EdgeInsets.symmetric(horizontal: spacing.lg),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('MÃ©tricas RÃ¡pidas', style: context.textStyles.headlineSmall),
          SizedBox(height: spacing.md),
          LayoutBuilder(builder: (context, constraints) {
            final width = constraints.maxWidth;
            final columns = width >= 1024 ? 3 : (width >= 600 ? 2 : 1);
            final itemWidth = (width - ((columns - 1) * spacing.md)) / columns;

            return Wrap(
              spacing: spacing.md,
              runSpacing: spacing.md,
              alignment: WrapAlignment.start,
              children: [
                SizedBox(
                  width: itemWidth,
                  child: ClarityKPICard(
                    value: institutionProvider.totalInstitutions.toString(),
                    label: 'Instituciones',
                    icon: Icons.apartment,
                    iconColor: colors.primary,
                    backgroundColor: colors.primary.withValues(alpha: 0.05),
                  ),
                ),
                SizedBox(
                  width: itemWidth,
                  child: ClarityKPICard(
                    value: (userProvider.paginationInfo?.total ?? userProvider.loadedUsersCount).toString(),
                    label: 'Usuarios',
                    icon: Icons.people,
                    iconColor: colors.info,
                    backgroundColor: colors.info.withValues(alpha: 0.05),
                  ),
                ),
                SizedBox(
                  width: itemWidth,
                  child: ClarityKPICard(
                    value: userProvider.professorsCount.toString(),
                    label: 'Profesores',
                    icon: Icons.school,
                    iconColor: colors.warning,
                    backgroundColor: colors.warning.withValues(alpha: 0.05),
                  ),
                ),
              ],
            );
          }),
        ],
      ),
    );
  }

  Widget _buildRecentActivity(BuildContext context, UserProvider userProvider) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    final recent = userProvider.users.take(6).toList();

    return Container(
      padding: EdgeInsets.all(spacing.lg),
      decoration: BoxDecoration(
        color: colors.surface,
        borderRadius: BorderRadius.circular(spacing.borderRadius),
        border: Border.all(color: colors.borderLight),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('Actividad reciente', style: textStyles.headlineSmall),
          SizedBox(height: spacing.md),
          if (recent.isEmpty)
            Center(
              child: Text('No hay actividad reciente', style: textStyles.bodyMedium.copyWith(color: colors.textSecondary)),
            )
          else
            Material(
              type: MaterialType.transparency,
              child: Column(
                children: recent.map((u) {
                  return ListTile(
                    onTap: () => context.go('/users?edit=true&userId=${u.id}'),
                    contentPadding: EdgeInsets.zero,
                    leading: CircleAvatar(backgroundColor: colors.primary.withValues(alpha: 0.12), child: Text(u.inicial, style: textStyles.bodyMedium.withColor(colors.primary))),
                    title: Text(u.nombreCompleto, style: textStyles.bodyMedium.copyWith(fontWeight: FontWeight.w600)),
                    subtitle: Text(u.email, style: textStyles.bodySmall.copyWith(color: colors.textSecondary)),
                    trailing: Chip(label: Text(u.rol, style: textStyles.labelSmall)),
                  );
                }).toList(),
              ),
            ),
        ],
      ),
    );
  }
}
/* Fin lib\screens\admin_dashboard.dart */

/* Inicio lib\screens\app_shell.dart */
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:go_router/go_router.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart'
import '../theme/app_colors.dart';
import '../utils/responsive_utils.dart';
import '../widgets/components/command_palette.dart';

class AppShell extends StatefulWidget {
  final StatefulNavigationShell navigationShell;

  const AppShell({
    super.key,
    required this.navigationShell,
  });

  @override
  State<AppShell> createState() => _AppShellState();
}

class _AppShellState extends State<AppShell> {
  late FocusNode _focusNode;
  final GlobalKey<ScaffoldState> _scaffoldKey = GlobalKey<ScaffoldState>();

  @override
  void initState() {
    super.initState();
    _focusNode = FocusNode();
    _focusNode.addListener(_handleKeyboardShortcuts);
  }

  @override
  void dispose() {
    _focusNode.removeListener(_handleKeyboardShortcuts);
    _focusNode.dispose();
    super.dispose();
  }

  void _handleKeyboardShortcuts() {
  }

  void _showCommandPalette() {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final userRole = authProvider.user?['rol'] as String?;
    final items = _buildCommandPaletteItems(userRole);

    showDialog(
      context: context,
      builder: (context) => CommandPalette(
        items: items,
        onDismiss: () {
          FocusScope.of(context).requestFocus(_focusNode);
        },
      ),
    );
  }

  List<CommandPaletteItem> _buildCommandPaletteItems(String? userRole) {
    final items = <CommandPaletteItem>[
      CommandPaletteItem(
        title: 'Ir a Dashboard',
        description: 'Abre el dashboard principal',
        icon: Icons.dashboard_rounded,
        shortcut: 'âŒ˜D',
        onExecute: () {
          context.go('/');
        },
      ),
    ];
    if (userRole == 'super_admin') {
      items.addAll([
        CommandPaletteItem(
          title: 'Ir a Instituciones',
          description: 'Gestiona todas las instituciones',
          icon: Icons.business_rounded,
          shortcut: 'âŒ˜I',
          onExecute: () {
            context.go('/instituciones');
          },
        ),
        CommandPaletteItem(
          title: 'Ir a Usuarios',
          description: 'Gestiona todos los usuarios',
          icon: Icons.people_alt_rounded,
          shortcut: 'âŒ˜U',
          onExecute: () {
            context.go('/usuarios');
          },
        ),
      ]);
    }

    if (userRole == 'super_admin' || userRole == 'admin_institucion') {
      items.addAll([
        CommandPaletteItem(
          title: 'Crear Nueva InstituciÃ³n',
          description: 'Agrega una instituciÃ³n nueva',
          icon: Icons.add_business_rounded,
          onExecute: () {
          },
        ),
      ]);
    }
    items.addAll([
      CommandPaletteItem(
        title: 'Cerrar SesiÃ³n',
        description: 'Cierra tu sesiÃ³n actual',
        icon: Icons.logout_rounded,
        color: AppColors.instance.error, // Rojo error con mejor contraste
        onExecute: () {
          Provider.of<AuthProvider>(context, listen: false).logout();
          context.go('/login');
        },
      ),
      CommandPaletteItem(
        title: 'Preferencias',
        description: 'Accede a la configuraciÃ³n',
        icon: Icons.settings_rounded,
        onExecute: () {
        },
      ),
      CommandPaletteItem(
        title: 'Ayuda',
        description: 'Ver documentaciÃ³n y ayuda',
        icon: Icons.help_rounded,
        onExecute: () {
        },
      ),
    ]);

    return items;
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final userRole = authProvider.user?['rol'] as String?;

    final allBranches = [
      (label: 'Dashboard', icon: Icons.dashboard_rounded, branchIndex: 0, roles: ['super_admin', 'admin_institucion', 'profesor', 'estudiante']),
      (label: 'Instituciones', icon: Icons.business_rounded, branchIndex: 1, roles: ['super_admin']),
      (label: 'Usuarios', icon: Icons.people_alt_rounded, branchIndex: 2, roles: ['super_admin', 'admin_institucion']),
    ];

    final accessibleBranches = allBranches.where((branch) => branch.roles.contains(userRole)).toList();
    int selectedIndex = 0
    if (accessibleBranches.isNotEmpty) {
      final currentBranchIndex = widget.navigationShell.currentIndex;
      final foundIndex = accessibleBranches.indexWhere((b) => b.branchIndex == currentBranchIndex);
      if (foundIndex != -1) {
        selectedIndex = foundIndex;
      }
    }
  final institutionName = authProvider.selectedInstitution?.name;
    return Focus(
      focusNode: _focusNode,
      onKeyEvent: (node, event) {
        if (HardwareKeyboard.instance.isLogicalKeyPressed(LogicalKeyboardKey.keyK) &&
            (HardwareKeyboard.instance.isControlPressed || HardwareKeyboard.instance.isMetaPressed)) {
          _showCommandPalette();
          return KeyEventResult.handled;
        }
        return KeyEventResult.ignored;
      },
      child: LayoutBuilder(
        builder: (context, constraints) {
          final responsive = ResponsiveUtils.getResponsiveValues(constraints);
          if (accessibleBranches.isEmpty) {
            return Scaffold(
              key: _scaffoldKey,
              appBar: AppBar(
                backgroundColor: context.colors.surface,
                elevation: 0,
                foregroundColor: context.colors.textPrimary,
                title: Text(institutionName != null ? 'Dashboard â€” $institutionName' : 'Dashboard'),
                actions: [
                  IconButton(
                    icon: Icon(Icons.logout, color: context.colors.error),
                    tooltip: 'Cerrar sesiÃ³n',
                    onPressed: () async {
                      await authProvider.logoutAndClearAllData(context);
                      if (context.mounted) context.go('/login');
                    },
                  ),
                ],
              ),
              body: widget.navigationShell,
            );
          }
          if (!responsive['isMobile']) {
            return Scaffold(
              key: _scaffoldKey,
              appBar: AppBar(
                backgroundColor: context.colors.surface,
                elevation: 0,
                foregroundColor: context.colors.textPrimary,
        title: Text(institutionName != null
          ? '${accessibleBranches[selectedIndex].label} â€” $institutionName'
          : accessibleBranches[selectedIndex].label),
                actions: [
                  IconButton(
                    icon: Icon(Icons.logout, color: context.colors.error),
                    tooltip: 'Cerrar sesiÃ³n',
                    onPressed: () async {
                      await authProvider.logoutAndClearAllData(context);
                      if (context.mounted) context.go('/login');
                    },
                  ),
                ],
              ),
              body: Row(
                children: [
                  if (accessibleBranches.isNotEmpty)
                    NavigationRail(
                      selectedIndex: selectedIndex,
                      onDestinationSelected: (index) {
                        final branchIndexToGo = accessibleBranches[index].branchIndex;
                        widget.navigationShell.goBranch(branchIndexToGo, initialLocation: index == widget.navigationShell.currentIndex);
                      },
                      labelType: NavigationRailLabelType.all,
                      destinations: [
                        for (final branch in accessibleBranches)
                          NavigationRailDestination(
                            icon: Icon(branch.icon),
                            label: Text(branch.label),
                          ),
                      ],
                    ),
                  const VerticalDivider(thickness: 1, width: 1),
                  Expanded(child: widget.navigationShell),
                ],
              ),
            );
          } else {
            return Scaffold(
              key: _scaffoldKey,
              appBar: AppBar(
                backgroundColor: context.colors.primary,
                elevation: 0,
                foregroundColor: Theme.of(context).colorScheme.onPrimary,
                title: Text(institutionName != null
                  ? '${accessibleBranches[selectedIndex].label} â€” $institutionName'
                  : accessibleBranches[selectedIndex].label),
                leading: IconButton(
                  icon: const Icon(Icons.menu),
                  tooltip: 'MenÃº',
                  color: Theme.of(context).colorScheme.onPrimary,
                  onPressed: () {
                    _scaffoldKey.currentState?.openDrawer();
                  },
                ),
              ),
              drawer: Drawer(
                backgroundColor: context.colors.surface,
                child: Column(
                  children: [
                    Container(
                      height: 120,
                      color: context.colors.primary,
                      padding: const EdgeInsets.all(16),
                      alignment: Alignment.bottomLeft,
                      child: Text(
                        'MenÃº',
                        style: context.textStyles.headlineSmall.copyWith(
                          color: Theme.of(context).colorScheme.onPrimary,
                        ),
                      ),
                    ),
                    const SizedBox(height: 16),
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 16),
                      child: ElevatedButton.icon(
                        onPressed: () {
                          Navigator.of(context).pop();
                          authProvider.logoutAndClearAllData(context).then((_) {
                            if (context.mounted) context.go('/login');
                          });
                        },
                        icon: Icon(Icons.logout, color: context.colors.white),
                        label: const Text('Cerrar SesiÃ³n'),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: context.colors.error,
                          foregroundColor: context.colors.white,
                          minimumSize: const Size(double.infinity, 48),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
              body: widget.navigationShell,
              bottomNavigationBar: accessibleBranches.length > 1 ? BottomNavigationBar(
                currentIndex: selectedIndex,
                onTap: (index) {
                  final branchIndexToGo = accessibleBranches[index].branchIndex;
                  widget.navigationShell.goBranch(branchIndexToGo, initialLocation: index == widget.navigationShell.currentIndex);
                },
                type: BottomNavigationBarType.fixed, // Muestra siempre los labels
                backgroundColor: context.colors.surface,
                selectedItemColor: context.colors.primary,
                unselectedItemColor: context.colors.textMuted,
                selectedLabelStyle: context.textStyles.labelSmall.bold,
                unselectedLabelStyle: context.textStyles.labelSmall,
                items: [
                  for (final branch in accessibleBranches)
                    BottomNavigationBarItem(
                      icon: Icon(branch.icon),
                      label: branch.label,
                    ),
                  ],
              ) : null, // No mostrar la barra si solo hay una opciÃ³n
            );
          }
        },
      ),
    );
  }
}
/* Fin lib\screens\app_shell.dart */

/* Inicio lib\screens\attendance_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../models/clase_del_dia.dart';
import '../models/asistencia_estudiante.dart';
import '../providers/asistencia_provider.dart';
import '../providers/auth_provider.dart';
import '../theme/app_colors.dart';
import '../theme/app_spacing.dart';
import '../screens/qr_scanner_screen.dart';

class AttendanceScreen extends StatefulWidget {
  final ClaseDelDia clase;

  const AttendanceScreen({
    super.key,
    required this.clase,
  });

  @override
  State<AttendanceScreen> createState() => _AttendanceScreenState();
}

class _AttendanceScreenState extends State<AttendanceScreen> {
  final AppColors colors = AppColors.instance;
  final AppSpacing spacing = AppSpacing.instance;
  String? _estudianteSeleccionadoId;
  DateTime _selectedDate = DateTime.now();
  void _showTopSnackBar({
    required String message,
    Color? backgroundColor,
    Widget? leading,
    Duration duration = const Duration(seconds: 2),
  }) {
    if (!mounted) return;

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            if (leading != null) ...[
              leading,
              SizedBox(width: spacing.sm),
            ],
            Expanded(child: Text(message)),
          ],
        ),
        backgroundColor: backgroundColor,
        duration: duration,
        behavior: SnackBarBehavior.floating,
        margin: EdgeInsets.only(
          top: MediaQuery.of(context).padding.top + 16,
          left: 16,
          right: 16,
          bottom: MediaQuery.of(context).size.height - 150,
        ),
      ),
    );
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadAsistencias();
    });
  }

  void _limpiarSeleccion() {
    if (_estudianteSeleccionadoId != null) {
      setState(() {
        _estudianteSeleccionadoId = null;
      });
    }
  }

  Future<void> _loadAsistencias() async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final asistenciaProvider = Provider.of<AsistenciaProvider>(context, listen: false);

    final token = authProvider.accessToken;
    if (token != null) {
      await asistenciaProvider.fetchAsistencias(token, widget.clase.id, date: _selectedDate);
    }
  }

  Future<void> _pickDate() async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
      builder: (context, child) {
        return Theme(
          data: Theme.of(context).copyWith(
            colorScheme: ColorScheme.light(
              primary: colors.primary,
              onPrimary: colors.white,
              onSurface: colors.textPrimary,
            ),
          ),
          child: child!,
        );
      },
    );
    if (picked != null && picked != _selectedDate) {
      setState(() {
        _selectedDate = picked;
      });
      _loadAsistencias();
    }
  }

  Future<void> _onScanQR() async {
    final result = await Navigator.push<bool>(
      context,
      MaterialPageRoute(
        builder: (context) => QRScannerScreen(
          horarioId: widget.clase.id,
        ),
      ),
    );
    if (result == true && mounted) {
      await _loadAsistencias();
    }
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: _limpiarSeleccion, // Limpiar selecciÃ³n al tocar fuera
      child: LayoutBuilder(
        builder: (context, constraints) {
          return Scaffold(
            appBar: AppBar(
              title: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text('Tomar Asistencia'),
                  Text(
                    '${_selectedDate.day}/${_selectedDate.month}/${_selectedDate.year}',
                    style: const TextStyle(fontSize: 12, fontWeight: FontWeight.normal),
                  ),
                ],
              ),
              backgroundColor: colors.primary,
              foregroundColor: colors.white,
              actions: [
                IconButton(
                  icon: const Icon(Icons.calendar_today),
                  onPressed: _pickDate,
                  tooltip: 'Cambiar fecha',
                ),
              ],
            ),
            body: Consumer<AsistenciaProvider>(
              builder: (context, asistenciaProvider, child) {
                if (asistenciaProvider.isLoading) {
                  return const Center(
                    child: CircularProgressIndicator(),
                  );
                }

                if (asistenciaProvider.hasError) {
                  return Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(
                          Icons.error_outline,
                          size: 64,
                          color: colors.error,
                        ),
                        SizedBox(height: spacing.md),
                        Text(
                          'Error al cargar asistencias',
                          style: Theme.of(context).textTheme.headlineSmall,
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                        ),
                        SizedBox(height: spacing.sm),
                        Text(
                          asistenciaProvider.errorMessage ?? 'Error desconocido',
                          style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                            color: colors.textMuted,
                          ),
                          textAlign: TextAlign.center,
                          maxLines: 3,
                          overflow: TextOverflow.ellipsis,
                        ),
                        SizedBox(height: spacing.lg),
                        ElevatedButton.icon(
                          onPressed: _loadAsistencias,
                          icon: const Icon(Icons.refresh),
                          label: const Text('Reintentar'),
                        ),
                      ],
                    ),
                  );
                }

                return Column(
                  children: [
                    _buildClassInfo(constraints),
                    _buildAttendanceStats(asistenciaProvider, constraints),
                    Expanded(
                      child: _buildStudentsList(asistenciaProvider.asistencias),
                    ),
                  ],
                );
              },
            ),
            floatingActionButton: FloatingActionButton.extended(
              onPressed: _onScanQR,
              icon: const Icon(Icons.qr_code_scanner),
              label: const Text('Escanear QR'),
              backgroundColor: colors.primary,
              foregroundColor: colors.white,
            ),
          );
        },
      ),
    );
  }

  Widget _buildClassInfo(BoxConstraints constraints) {
    return Container(
      padding: EdgeInsets.all(spacing.lg),
      decoration: BoxDecoration(
        color: colors.surface,
        border: Border(
          bottom: BorderSide(color: colors.borderLight, width: 1),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            widget.clase.materia.nombre,
            style: Theme.of(context).textTheme.headlineMedium?.copyWith(
              fontWeight: FontWeight.bold,
              color: colors.textPrimary,
            ),
            maxLines: 2,
            overflow: TextOverflow.ellipsis,
          ),
          SizedBox(height: spacing.xs),
          Text(
            '${widget.clase.grupo.nombreCompleto} - ${widget.clase.diaSemanaNombre}',
            style: Theme.of(context).textTheme.titleMedium?.copyWith(
              color: colors.textSecondary,
            ),
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
          SizedBox(height: spacing.sm),
          Row(
            children: [
              Icon(
                Icons.access_time,
                size: 20,
                color: colors.textMuted,
              ),
              SizedBox(width: spacing.sm),
              Expanded(
                child: Text(
                  widget.clase.horarioFormato,
                  style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                    color: colors.textMuted,
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildAttendanceStats(AsistenciaProvider provider, BoxConstraints constraints) {
    final stats = provider.getEstadisticas();
    final porcentaje = (provider.getPorcentajeAsistencia() * 100).round();
    final isSmallScreen = constraints.maxWidth < 400;

    return Container(
      padding: EdgeInsets.symmetric(horizontal: spacing.lg, vertical: spacing.md),
      decoration: BoxDecoration(
        color: colors.surfaceLight,
        border: Border(
          bottom: BorderSide(color: colors.borderLight, width: 1),
        ),
      ),
      child: isSmallScreen
          ? Column(
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    _buildStatItem('Presentes', stats['presentes']!, colors.success),
                    _buildStatItem('Ausentes', stats['ausentes']!, colors.error),
                  ],
                ),
                SizedBox(height: spacing.sm),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    _buildStatItem('Sin registrar', stats['sinRegistrar']!, colors.textMuted),
                    Container(
                      padding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
                      decoration: BoxDecoration(
                        color: colors.primary.withValues(alpha: 0.1),
                        borderRadius: BorderRadius.circular(spacing.borderRadius),
                      ),
                      child: Text(
                        '$porcentaje%',
                        style: Theme.of(context).textTheme.titleMedium?.copyWith(
                          color: colors.primary,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ],
                ),
              ],
            )
          : Row(
              children: [
                Expanded(
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                    children: [
                      _buildStatItem('Presentes', stats['presentes']!, colors.success),
                      _buildStatItem('Ausentes', stats['ausentes']!, colors.error),
                      _buildStatItem('Sin registrar', stats['sinRegistrar']!, colors.textMuted),
                    ],
                  ),
                ),
                Container(
                  padding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
                  decoration: BoxDecoration(
                    color: colors.primary.withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(spacing.borderRadius),
                  ),
                  child: Text(
                    '$porcentaje%',
                    style: Theme.of(context).textTheme.titleMedium?.copyWith(
                      color: colors.primary,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ],
            ),
    );
  }

  Widget _buildStatItem(String label, int value, Color color) {
    return Column(
      children: [
        Text(
          value.toString(),
          style: Theme.of(context).textTheme.headlineSmall?.copyWith(
            color: color,
            fontWeight: FontWeight.bold,
          ),
        ),
        Text(
          label,
          style: Theme.of(context).textTheme.bodySmall?.copyWith(
            color: colors.textMuted,
          ),
        ),
      ],
    );
  }

  Widget _buildStudentsList(List<AsistenciaEstudiante> asistencias) {
    if (asistencias.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.people_outline,
              size: 64,
              color: colors.textMuted,
            ),
            SizedBox(height: spacing.md),
            Text(
              'No hay estudiantes en este grupo',
              style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                color: colors.textMuted,
              ),
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
              textAlign: TextAlign.center,
            ),
          ],
        ),
      );
    }

    return ListView.builder(
      padding: EdgeInsets.all(spacing.md),
      itemCount: asistencias.length,
      itemBuilder: (context, index) {
        final estudiante = asistencias[index];
        final puedeMarcarManualmente = estudiante.sinRegistrar || estudiante.estaAusente;
        final estaSeleccionado = _estudianteSeleccionadoId == estudiante.estudianteId;

        return Card(
          margin: EdgeInsets.only(bottom: spacing.sm),
          color: estaSeleccionado
              ? colors.warning.withValues(alpha: 0.15
              : null,
          elevation: estaSeleccionado ? 4 : 1,
          child: ListTile(
            onTap: puedeMarcarManualmente
                ? () => _onEstudianteTap(estudiante)
                : null,
            leading: CircleAvatar(
              backgroundColor: estaSeleccionado
                  ? colors.warning.withValues(alpha: 0.3)
                  : colors.primary.withValues(alpha: 0.1),
              child: Text(
                estudiante.inicial,
                style: TextStyle(
                  color: estaSeleccionado ? colors.warning : colors.primary,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
            title: Text(
              estudiante.nombreCompleto,
              style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                fontWeight: FontWeight.w500,
              ),
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
            subtitle: Row(
              children: [
                Text(
                  'ID: ${estudiante.identificacion}',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: colors.textMuted,
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
                if (estaSeleccionado) ...[
                  SizedBox(width: spacing.sm),
                  Expanded(
                    child: Text(
                      'Toca de nuevo para confirmar',
                      style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: colors.warning,
                        fontWeight: FontWeight.bold,
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ],
            ),
            trailing: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                _buildStatusChip(estudiante),
                if (puedeMarcarManualmente && !estaSeleccionado) ...[
                  SizedBox(width: spacing.xs),
                  Icon(
                    Icons.touch_app,
                    color: colors.primary.withValues(alpha: 0.5),
                    size: 20,
                  ),
                ],
                if (estaSeleccionado) ...[
                  SizedBox(width: spacing.xs),
                  Icon(
                    Icons.check_circle_outline,
                    color: colors.warning,
                    size: 24,
                  ),
                ],
                IconButton(
                  icon: const Icon(Icons.edit),
                  color: colors.primary,
                  onPressed: () => _showEditDialog(estudiante),
                  tooltip: 'Editar asistencia',
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  void _onEstudianteTap(AsistenciaEstudiante estudiante) {
    if (_estudianteSeleccionadoId == estudiante.estudianteId) {
      _registrarAsistenciaManual(estudiante);
    } else {
      setState(() {
        _estudianteSeleccionadoId = estudiante.estudianteId;
      });
    }
  }

  Future<void> _registrarAsistenciaManual(AsistenciaEstudiante estudiante) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final asistenciaProvider = Provider.of<AsistenciaProvider>(context, listen: false);

    final token = authProvider.accessToken;
    if (token == null) {
      _showTopSnackBar(
        message: 'Error: No estÃ¡s autenticado',
        backgroundColor: colors.error,
        leading: const Icon(Icons.error, color: Colors.white),
      );
      return;
    }
    setState(() {
      _estudianteSeleccionadoId = null;
    });
    _showTopSnackBar(
      message: 'Registrando asistencia...',
      duration: const Duration(seconds: 2),
      leading: SizedBox(
        width: 20,
        height: 20,
        child: CircularProgressIndicator(
          strokeWidth: 2,
          valueColor: AlwaysStoppedAnimation<Color>(colors.white),
        ),
      ),
    );

    try {
      final success = await asistenciaProvider.registrarAsistenciaManual(
        token,
        widget.clase.id,
        estudiante.estudianteId,
      );

      if (mounted) {
        ScaffoldMessenger.of(context).hideCurrentSnackBar();

        if (success) {
          _showTopSnackBar(
            message: 'âœ“ ${estudiante.nombreCompleto} marcado como presente',
            backgroundColor: colors.success,
            leading: const Icon(Icons.check_circle, color: Colors.white),
          );
        } else {
          _showTopSnackBar(
            message: 'Error al registrar asistencia',
            backgroundColor: colors.error,
            leading: const Icon(Icons.error, color: Colors.white),
          );
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).hideCurrentSnackBar();
        _showTopSnackBar(
          message: 'Error: ${e.toString()}',
          backgroundColor: colors.error,
          leading: const Icon(Icons.error, color: Colors.white),
          duration: const Duration(seconds: 4),
        );
      }
    }
  }

  Future<void> _showEditDialog(AsistenciaEstudiante estudiante) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final asistenciaProvider = Provider.of<AsistenciaProvider>(context, listen: false);
    final token = authProvider.accessToken;

    if (token == null) return;

    String estado = estudiante.estado ?? 'PRESENTE';
    if (estado.isEmpty) estado = 'PRESENTE';

    final String observacion = estudiante.observacion ?? '';
    bool justificada = estudiante.estaJustificado;
    final observacionController = TextEditingController(text: observacion);

    await showDialog(
      context: context,
      builder: (context) {
        return StatefulBuilder(
          builder: (context, setStateDialog) {
            return AlertDialog(
              title: Text('Editar Asistencia: ${estudiante.nombreCompleto}'),
              content: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    DropdownButtonFormField<String>(
                      value: estado,
                      decoration: const InputDecoration(labelText: 'Estado'),
                      items: ['PRESENTE', 'AUSENTE', 'TARDANZA', 'JUSTIFICADO']
                          .map((e) => DropdownMenuItem(value: e, child: Text(e)))
                          .toList(),
                      onChanged: (value) {
                        if (value != null) {
                          setStateDialog(() {
                            estado = value;
                            if (estado == 'JUSTIFICADO') {
                              justificada = true;
                            } else {
                              justificada = false;
                            }
                          });
                        }
                      },
                    ),
                    const SizedBox(height: 16),
                    TextField(
                      controller: observacionController,
                      decoration: const InputDecoration(labelText: 'ObservaciÃ³n'),
                      maxLines: 3,
                    ),
                    const SizedBox(height: 16),
                    CheckboxListTile(
                      title: const Text('Justificada'),
                      value: justificada,
                      onChanged: (value) {
                        setStateDialog(() {
                          justificada = value ?? false;
                          if (justificada && estado != 'JUSTIFICADO') {
                          }
                        });
                      },
                    ),
                  ],
                ),
              ),
              actions: [
                TextButton(
                  onPressed: () => Navigator.pop(context),
                  child: const Text('Cancelar'),
                ),
                ElevatedButton(
                  onPressed: () async {
                    Navigator.pop(context)
                    _showTopSnackBar(
                      message: 'Actualizando asistencia...',
                      leading: const CircularProgressIndicator(color: Colors.white),
                    );

                    try {

                      if (estudiante.id == null || estudiante.id!.isEmpty) {
                         _showTopSnackBar(
                          message: 'Error: Primero registre la asistencia (toque el estudiante)',
                          backgroundColor: colors.error,
                        );
                        return;
                      }

                      final success = await asistenciaProvider.updateAsistencia(
                        accessToken: token,
                        asistenciaId: estudiante.id!,
                        estado: estado,
                        observacion: observacionController.text,
                        justificada: justificada,
                      );

                      if (success) {
                        _showTopSnackBar(
                          message: 'Asistencia actualizada',
                          backgroundColor: colors.success,
                        );
                        _loadAsistencias();
                      } else {
                        _showTopSnackBar(
                          message: 'Error al actualizar',
                          backgroundColor: colors.error,
                        );
                      }
                    } catch (e) {
                      _showTopSnackBar(
                        message: 'Error: $e',
                        backgroundColor: colors.error,
                      );
                    }
                  },
                  child: const Text('Guardar'),
                ),
              ],
            );
          },
        );
      },
    );
  }

  Widget _buildStatusChip(AsistenciaEstudiante estudiante) {
    final Color chipColor;
    final String statusText;

    if (estudiante.estaPresente) {
      chipColor = colors.success;
      statusText = 'Presente';
    } else if (estudiante.estaAusente) {
      chipColor = colors.error;
      statusText = 'Ausente';
    } else if (estudiante.tieneTardanza) {
      chipColor = colors.warning;
      statusText = 'Tardanza';
    } else if (estudiante.estaJustificado) {
      chipColor = colors.info;
      statusText = 'Justificado';
    } else {
      chipColor = colors.textMuted;
      statusText = 'Sin registrar';
    }

    return Chip(
      label: Text(
        statusText,
        style: const TextStyle(
          color: Colors.white,
          fontSize: 12,
          fontWeight: FontWeight.w500,
        ),
      ),
      backgroundColor: chipColor,
      padding: EdgeInsets.symmetric(horizontal: spacing.xs),
    );
  }
}
/* Fin lib\screens\attendance_screen.dart */

/* Inicio lib\screens\institutions\create_institution_admin_screen.dart */
import 'package:flutter/material.dart';
import '../../models/institution.dart';
import '../users/user_form_screen.dart';

class CreateInstitutionAdminScreen extends StatelessWidget {
  final Institution institution;

  const CreateInstitutionAdminScreen({
    super.key,
    required this.institution,
  });

  @override
  Widget build(BuildContext context) {
    return UserFormScreen(
      userRole: 'admin_institucion',
      initialInstitutionId: institution.id,
    );
  }
}
/* Fin lib\screens\institutions\create_institution_admin_screen.dart */

/* Inicio lib\screens\institutions\form_steps\index.dart */

export 'institution_basic_info_step.dart';
export 'institution_contact_step.dart';
export 'institution_config_step.dart';

/* Fin lib\screens\institutions\form_steps\index.dart */

/* Inicio lib\screens\institutions\form_steps\institution_basic_info_step.dart */
import 'package:flutter/material.dart';
import '../../../theme/theme_extensions.dart';
import '../../../widgets/form_widgets.dart';
class InstitutionBasicInfoStep extends StatelessWidget {
  final TextEditingController nombreController;
  final TextEditingController emailController;

  const InstitutionBasicInfoStep({
    super.key,
    required this.nombreController,
    required this.emailController,
  });

  @override
  Widget build(BuildContext context) {
    final spacing = context.spacing;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'InformaciÃ³n BÃ¡sica',
          style: context.textStyles.headlineSmall,
        ),
        SizedBox(height: spacing.md),
        Text(
          'Ingrese los datos fundamentales de la instituciÃ³n',
          style: context.textStyles.bodyMedium.copyWith(
            color: context.colors.textSecondary,
          ),
        ),
        SizedBox(height: spacing.lg),

        CustomTextFormField(
          key: const Key('nombreInstitucionField'),
          controller: nombreController,
          labelText: 'Nombre de la InstituciÃ³n',
          hintText: 'Ingrese el nombre completo',
          prefixIcon: const Icon(Icons.business),
          validator: (value) {
            if (value == null || value.trim().isEmpty) {
              return 'El nombre es obligatorio';
            }
            if (value.trim().length < 3) {
              return 'El nombre debe tener al menos 3 caracteres';
            }
            return null;
          },
        ),
        SizedBox(height: spacing.md),

        CustomTextFormField(
          key: const Key('emailInstitucionField'),
          controller: emailController,
          labelText: 'Email Institucional',
          hintText: 'contacto@institucion.com',
          prefixIcon: const Icon(Icons.email),
          keyboardType: TextInputType.emailAddress,
          validator: (value) {
            if (value != null && value.trim().isNotEmpty) {
              final emailRegex = RegExp(r'^[^@\s]+@[^@\s]+\.[^@\s]+$');
              if (!emailRegex.hasMatch(value.trim())) {
                return 'Ingrese un email vÃ¡lido';
              }
            }
            return null;
          },
        ),
      ],
    );
  }
}

/* Fin lib\screens\institutions\form_steps\institution_basic_info_step.dart */

/* Inicio lib\screens\institutions\form_steps\institution_config_step.dart */
import 'package:flutter/material.dart';
import '../../../theme/theme_extensions.dart';
import '../../../widgets/components/clarity_components.dart';
class InstitutionConfigStep extends StatelessWidget {
  final bool activa;
  final ValueChanged<bool> onActivaChanged;
  final bool isEditMode;

  const InstitutionConfigStep({
    super.key,
    required this.activa,
    required this.onActivaChanged,
    this.isEditMode = false,
  });

  @override
  Widget build(BuildContext context) {
    final spacing = context.spacing;
    final colors = context.colors;
    final textStyles = context.textStyles;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'ConfiguraciÃ³n',
          style: textStyles.headlineSmall,
        ),
        SizedBox(height: spacing.md),
        Text(
          'Establezca el estado operativo de la instituciÃ³n',
          style: textStyles.bodyMedium.copyWith(
            color: colors.textSecondary,
          ),
        ),
        SizedBox(height: spacing.lg),

        ClarityCard(
          leading: Icon(
            activa ? Icons.check_circle : Icons.cancel,
            color: activa ? colors.success : colors.error,
            size: 48,
          ),
          title: Text(
            'Estado de la InstituciÃ³n',
            style: textStyles.bodyLarge.semiBold,
          ),
          subtitle: Text(
            activa ? 'InstituciÃ³n operativa' : 'InstituciÃ³n inactiva',
            style: textStyles.bodyMedium.withColor(
              activa ? colors.success : colors.error,
            ),
          ),
          trailing: Switch(
            value: activa,
            onChanged: onActivaChanged,
            activeColor: colors.success,
          ),
        ),

        SizedBox(height: spacing.lg),

        Container(
          padding: EdgeInsets.all(spacing.md),
          decoration: BoxDecoration(
            color: colors.warning.withValues(alpha: 0.1),
            borderRadius: BorderRadius.circular(8),
            border: Border.all(color: colors.warning.withValues(alpha: 0.3)),
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Icon(Icons.warning_amber_rounded, color: colors.warning, size: 20),
                  SizedBox(width: spacing.sm),
                  Expanded(
                    child: Text(
                      'Importante',
                      style: textStyles.bodyMedium.semiBold.withColor(colors.warning),
                    ),
                  ),
                ],
              ),
              SizedBox(height: spacing.sm),
              Text(
                activa
                    ? 'Los usuarios podrÃ¡n acceder y usar los servicios de esta instituciÃ³n.'
                    : 'Si desactiva la instituciÃ³n, los usuarios no podrÃ¡n iniciar sesiÃ³n ni acceder a sus datos.',
                style: textStyles.bodySmall.copyWith(
                  color: colors.textSecondary,
                ),
              ),
            ],
          ),
        ),

        if (!isEditMode) ...[
          SizedBox(height: spacing.lg),
          Container(
            padding: EdgeInsets.all(spacing.md),
            decoration: BoxDecoration(
              color: colors.info.withValues(alpha: 0.1),
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: colors.info.withValues(alpha: 0.3)),
            ),
            child: Row(
              children: [
                Icon(Icons.lightbulb_outline, color: colors.info, size: 20),
                SizedBox(width: spacing.sm),
                Expanded(
                  child: Text(
                    'DespuÃ©s de crear la instituciÃ³n, podrÃ¡ asignarle administradores y usuarios.',
                    style: textStyles.bodySmall.copyWith(
                      color: colors.info,
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ],
    );
  }
}

/* Fin lib\screens\institutions\form_steps\institution_config_step.dart */

/* Inicio lib\screens\institutions\form_steps\institution_contact_step.dart */
import 'package:flutter/material.dart';
import '../../../theme/theme_extensions.dart';
import '../../../widgets/form_widgets.dart';
class InstitutionContactStep extends StatelessWidget {
  final TextEditingController direccionController;
  final TextEditingController telefonoController;

  const InstitutionContactStep({
    super.key,
    required this.direccionController,
    required this.telefonoController,
  });

  @override
  Widget build(BuildContext context) {
    final spacing = context.spacing;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Contacto y UbicaciÃ³n',
          style: context.textStyles.headlineSmall,
        ),
        SizedBox(height: spacing.md),
        Text(
          'InformaciÃ³n para contactar y localizar la instituciÃ³n',
          style: context.textStyles.bodyMedium.copyWith(
            color: context.colors.textSecondary,
          ),
        ),
        SizedBox(height: spacing.lg),

        CustomTextFormField(
          key: const Key('direccionInstitucionField'),
          controller: direccionController,
          labelText: 'DirecciÃ³n',
          hintText: 'DirecciÃ³n completa de la instituciÃ³n',
          prefixIcon: const Icon(Icons.location_on),
          maxLines: 3,
          validator: (value) {
            return null;
          },
        ),
        SizedBox(height: spacing.md),

        CustomTextFormField(
          key: const Key('telefonoInstitucionField'),
          controller: telefonoController,
          labelText: 'TelÃ©fono',
          hintText: '+57 300 123 4567',
          prefixIcon: const Icon(Icons.phone),
          keyboardType: TextInputType.phone,
          validator: (value) {
            if (value != null && value.trim().isNotEmpty) {
              final phoneRegex = RegExp(r'^\+?[0-9\s\-\(\)]+$');
              if (!phoneRegex.hasMatch(value.trim())) {
                return 'Ingrese un telÃ©fono vÃ¡lido';
              }
            }
            return null;
          },
        ),

        SizedBox(height: spacing.md),
        Container(
          padding: EdgeInsets.all(spacing.md),
          decoration: BoxDecoration(
            color: context.colors.info.withValues(alpha: 0.1),
            borderRadius: BorderRadius.circular(8),
            border: Border.all(color: context.colors.info.withValues(alpha: 0.3)),
          ),
          child: Row(
            children: [
              Icon(Icons.info_outline, color: context.colors.info, size: 20),
              SizedBox(width: spacing.sm),
              Expanded(
                child: Text(
                  'Estos datos serÃ¡n visibles para los usuarios de la instituciÃ³n.',
                  style: context.textStyles.bodySmall.copyWith(
                    color: context.colors.info,
                  ),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }
}

/* Fin lib\screens\institutions\form_steps\institution_contact_step.dart */

/* Inicio lib\screens\institutions\institutions_list_screen.dart */
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../models/institution.dart';
import '../../providers/auth_provider.dart';
import '../../providers/institution_provider.dart';
import '../../theme/theme_extensions.dart';
import '../../widgets/components/index.dart';

class InstitutionsListScreen extends StatefulWidget {
  const InstitutionsListScreen({super.key});

  @override
  State<InstitutionsListScreen> createState() => _InstitutionsListScreenState();
}

class _InstitutionsListScreenState extends State<InstitutionsListScreen> {
  final TextEditingController _searchController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  Timer? _searchDebounceTimer;

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadInstitutions();
    });
  }

  @override
  void dispose() {
    _searchDebounceTimer?.cancel();
    _scrollController.dispose();
    _searchController.dispose();
    super.dispose();
  }

  void _onScroll() {
    if (_scrollController.position.pixels == _scrollController.position.maxScrollExtent) {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);

      final token = authProvider.accessToken;
      if (token != null && institutionProvider.hasMoreData && !institutionProvider.isLoadingMore) {
        institutionProvider.loadMoreInstitutions(token);
      }
    }
  }

  Future<void> _loadInstitutions() async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);

    final token = authProvider.accessToken;
    if (token != null) {
      debugPrint('Cargando instituciones con token: ${token.substring(0, 20)}...');
      await institutionProvider.loadInstitutions(token);
      debugPrint('Instituciones cargadas: ${institutionProvider.institutions.length}');
      debugPrint('Estado del provider: isLoading=${institutionProvider.isLoading}, hasError=${institutionProvider.hasError}');
      if (institutionProvider.hasError) {
        debugPrint('Error del provider: ${institutionProvider.errorMessage}');
      }
    } else {
      debugPrint('No hay token de acceso disponible');
    }
  }

  void _onSearchChanged(String query) {
    _searchDebounceTimer?.cancel();
    _searchDebounceTimer = Timer(const Duration(milliseconds: 500), () {
      final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);
      if (query.isNotEmpty) {
        institutionProvider.setFilter('search', query);
      } else {
        institutionProvider.removeFilter('search');
      }
      institutionProvider.refreshData(Provider.of<AuthProvider>(context, listen: false).accessToken!);
    });
  }

  void _onStatusFilterChanged(bool? status) {
    final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);
    if (status != null) {
      institutionProvider.setFilter('activa', status.toString());
    } else {
      institutionProvider.removeFilter('activa');
    }
    institutionProvider.refreshData(Provider.of<AuthProvider>(context, listen: false).accessToken!);
  }

  @override
  Widget build(BuildContext context) {
    return Consumer2<AuthProvider, InstitutionProvider>(
      builder: (context, authProvider, institutionProvider, child) {
        final userRole = authProvider.user?['rol'] as String?;
        final canCreateInstitutions = userRole == 'super_admin';
        final administrationName = authProvider.administrationName;

        final List<Widget> filters = _buildFilterWidgets(context);
        if (userRole == 'admin_institucion' && administrationName != null) {
          filters.insert(
            0,
            Padding(
              padding: const EdgeInsets.only(bottom: 8.0),
              child: Row(
                children: [
                  Icon(Icons.admin_panel_settings, size: 18, color: context.colors.primary),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      'Eres administrador de: $administrationName',
                      style: context.textStyles.bodyMedium.copyWith(color: context.colors.textPrimary),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                  const SizedBox(width: 8),
                  Tooltip(
                    message: 'Tu cuenta tiene permisos administrativos sobre esta instituciÃ³n',
                    child: Icon(Icons.info_outline, size: 18, color: context.colors.textSecondary),
                  ),
                ],
              ),
            ),
          );
        }

        return ClarityManagementPage(
          title: 'GestiÃ³n de Instituciones',
          isLoading: institutionProvider.isLoading,
          hasError: institutionProvider.hasError,
          errorMessage: institutionProvider.errorMessage,
          itemCount: institutionProvider.institutions.length,
          itemBuilder: (context, index) {
            final institution = institutionProvider.institutions[index];
            return _buildInstitutionCard(institution, institutionProvider, context);
          },
          filterWidgets: _buildFilterWidgets(context),
          statisticWidgets: _buildStatisticWidgets(context, institutionProvider),
          onRefresh: _loadInstitutions,
          scrollController: _scrollController,
          hasMoreData: institutionProvider.hasMoreData,
          isLoadingMore: institutionProvider.isLoadingMore,
      emptyStateWidget: (institutionProvider.institutions.isEmpty || institutionProvider.hasError) && administrationName != null
        ? ClarityEmptyState(
          icon: Icons.account_balance,
          title: administrationName,
          subtitle: institutionProvider.hasError
            ? 'No tienes permiso para ver la lista completa de instituciones. Mostrando el nombre de la administraciÃ³n.'
            : ((institutionProvider.filters['search'] as String?)?.isNotEmpty ?? false
              ? 'No se encontraron instituciones para "${institutionProvider.filters['search']}". Mostrando la administraciÃ³n: $administrationName'
              : 'No hay instituciones disponibles. Mostrando la administraciÃ³n: $administrationName'),
        )
        : ClarityEmptyState(
          icon: (institutionProvider.filters['search'] as String?)?.isNotEmpty ?? false ? Icons.search_off : Icons.business,
          title: (institutionProvider.filters['search'] as String?)?.isNotEmpty ?? false
            ? 'No se encontraron instituciones'
            : 'No hay instituciones',
          subtitle: (institutionProvider.filters['search'] as String?)?.isNotEmpty ?? false
            ? 'Intenta con otros tÃ©rminos de bÃºsqueda'
            : 'Comienza creando tu primera instituciÃ³n',
        ),
          floatingActionButton: canCreateInstitutions
              ? FloatingActionButton(
                  onPressed: () => _navigateToForm(context),
                  backgroundColor: context.colors.primary,
                  child: Icon(
                    Icons.add,
                    color: context.colors.getTextColorForBackground(context.colors.primary),
                  ),
                )
              : null,
        );
      },
    );
  }

  List<Widget> _buildFilterWidgets(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return [
      Consumer<InstitutionProvider>(
        builder: (context, institutionProvider, child) => TextField(
          key: const Key('searchInstitutionField'),
          controller: _searchController,
          style: textStyles.bodyLarge,
          decoration: InputDecoration(
            hintText: 'Buscar por nombre, cÃ³digo o email...',
            hintStyle: textStyles.bodyMedium.withColor(colors.textMuted),
            prefixIcon: Icon(Icons.search, color: colors.textSecondary),
            suffixIcon: (institutionProvider.filters['search'] as String?)?.isNotEmpty ?? false
                ? IconButton(
                    icon: Icon(Icons.clear, color: colors.textSecondary),
                    onPressed: () {
                      _searchController.clear();
                      _onSearchChanged('');
                    },
                  )
                : null,
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(spacing.borderRadius),
              borderSide: BorderSide(color: colors.border),
            ),
            enabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(spacing.borderRadius),
              borderSide: BorderSide(color: colors.borderLight),
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(spacing.borderRadius),
              borderSide: BorderSide(color: colors.primary, width: 2),
            ),
            filled: true,
            fillColor: colors.surface,
            contentPadding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
          ),
          onChanged: _onSearchChanged,
        ),
      ),
      SizedBox(height: spacing.sm),
      Consumer<InstitutionProvider>(
        builder: (context, institutionProvider, child) => Wrap(
          spacing: spacing.md,
          runSpacing: spacing.sm,
          crossAxisAlignment: WrapCrossAlignment.center,
          children: [
            Text('Mostrar:', style: textStyles.labelMedium),
            FilterChip(
              label: const Text('Todas'),
              selected: institutionProvider.filters['activa'] == null,
              onSelected: (selected) {
                if (selected) _onStatusFilterChanged(null);
              },
            ),
            FilterChip(
              label: const Text('Activas'),
              selected: institutionProvider.filters['activa'] == 'true',
              onSelected: (selected) {
                if (selected) _onStatusFilterChanged(true);
              },
            ),
            FilterChip(
              label: const Text('Inactivas'),
              selected: institutionProvider.filters['activa'] == 'false',
              onSelected: (selected) {
                if (selected) _onStatusFilterChanged(false);
              },
            ),
          ],
        ),
      ),
    ];
  }

  List<Widget> _buildStatisticWidgets(BuildContext context, InstitutionProvider provider) {
    final colors = context.colors;
    return [
      ClarityCompactStat(
        title: 'Total',
        value: provider.totalInstitutions.toString(),
        icon: Icons.business,
        color: colors.primary,
      ),
      ClarityCompactStat(
        title: 'Activas',
        value: provider.activeInstitutionsCount.toString(),
        icon: Icons.check_circle,
        color: colors.success,
      ),
      ClarityCompactStat(
        title: 'Inactivas',
        value: provider.inactiveInstitutionsCount.toString(),
        icon: Icons.cancel,
        color: colors.error,
      ),
    ];
  }

  Widget _buildInstitutionCard(Institution institution, InstitutionProvider provider, BuildContext context) {
    final colors = context.colors;

    return Consumer<AuthProvider>(
      builder: (context, authProvider, child) {
        final userRole = authProvider.user?['rol'] as String?;
        final isSuperAdmin = userRole == 'super_admin';
        final List<ClarityContextMenuAction> contextActions = [
          if (isSuperAdmin) ...[
            ClarityContextMenuAction(
              label: 'Crear Admin',
              icon: Icons.admin_panel_settings,
              color: colors.primary,
              onPressed: () => _navigateToCreateInstitutionAdmin(institution),
            ),
            ClarityContextMenuAction(
              label: 'Gestionar Admins',
              icon: Icons.group,
              color: colors.info,
              onPressed: () => context.push('/institutions/${institution.id}/admins'),
            ),
          ],
          ClarityContextMenuAction(
            label: 'Editar',
            icon: Icons.edit,
            color: colors.primary,
            onPressed: () => _navigateToForm(context, institution: institution),
          ),
          ClarityContextMenuAction(
            label: institution.activa ? 'Desactivar' : 'Activar',
            icon: institution.activa ? Icons.toggle_off : Icons.toggle_on,
            color: institution.activa ? colors.warning : colors.success,
            onPressed: () => _handleMenuAction('toggle_status', institution, provider),
          ),
          ClarityContextMenuAction(
            label: 'Eliminar',
            icon: Icons.delete,
            color: colors.error,
            onPressed: () => _handleMenuAction('delete', institution, provider),
          ),
        ];

        return ClarityListItem(
          leading: Icon(
            Icons.business,
            color: colors.primary,
            size: 32,
          ),
          title: institution.nombre,
          subtitleWidget: Row(
            children: [
              Expanded(
                child: Text(
                  institution.email ?? institution.telefono ?? 'Sin contacto',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: colors.textSecondary,
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
              const SizedBox(width: 8),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 3),
                decoration: BoxDecoration(
                  color: colors.surfaceVariant,
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(
                    color: colors.borderLight,
                    width: 1,
                  ),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Container(
                      width: 6,
                      height: 6,
                      decoration: BoxDecoration(
                        color: institution.activa
                          ? colors.primary.withValues(alpha: 0.7)
                          : colors.textMuted,
                        shape: BoxShape.circle,
                      ),
                    ),
                    const SizedBox(width: 4),
                    Text(
                      institution.activa ? 'Activa' : 'Inactiva',
                      style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: colors.textSecondary,
                        fontSize: 11,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          contextActions: contextActions,
          onTap: () => _navigateToForm(context, institution: institution),
        );
      },
    );
  }

  void _handleMenuAction(String action, Institution institution, InstitutionProvider provider) async {
  final authProvider = Provider.of<AuthProvider>(context, listen: false);
  final token = authProvider.accessToken;

    switch (action) {
      case 'create_admin':
        _navigateToCreateInstitutionAdmin(institution);
        break;

      case 'edit':
        _navigateToForm(context, institution: institution);
        break;

      case 'toggle_status':
        final newStatus = !institution.activa;
        if (token == null) {
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Debes iniciar sesiÃ³n para modificar la instituciÃ³n')));
          return;
        }

        final success = await provider.updateInstitution(
          token,
          institution.id,
          activa: newStatus,
        );

        if (success && mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                'InstituciÃ³n ${newStatus ? 'activada' : 'desactivada'} correctamente',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onPrimary),
              ),
              backgroundColor: Theme.of(context).colorScheme.primary,
            ),
          );
        }
        break;

      case 'delete':
        _showDeleteConfirmationDialog(institution, provider);
        break;
      case 'manage_admins':
        context.push('/institutions/${institution.id}/admins');
        break;
    }
  }

  void _showDeleteConfirmationDialog(Institution institution, InstitutionProvider provider) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Eliminar InstituciÃ³n', style: Theme.of(context).textTheme.headlineSmall),
        content: Text(
          'Â¿EstÃ¡s seguro de que quieres eliminar "${institution.nombre}"?\n\n'
          'Esta acciÃ³n no se puede deshacer.',
          style: Theme.of(context).textTheme.bodyMedium,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: Text('Cancelar', style: Theme.of(context).textTheme.labelLarge),
          ),
          TextButton(
            onPressed: () async {
              Navigator.of(context).pop();
              await _deleteInstitution(institution, provider);
            },
            style: TextButton.styleFrom(foregroundColor: Theme.of(context).colorScheme.error),
            child: Text('Eliminar', style: Theme.of(context).textTheme.labelLarge?.copyWith(color: Theme.of(context).colorScheme.error)),
          ),
        ],
      ),
    );
  }

  Future<void> _deleteInstitution(Institution institution, InstitutionProvider provider) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final token = authProvider.accessToken;

    if (token == null) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Debes iniciar sesiÃ³n para eliminar la instituciÃ³n')));
      return;
    }

    final success = await provider.deleteInstitution(
      token,
      institution.id,
    );

    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            'InstituciÃ³n eliminada correctamente',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onPrimary),
          ),
          backgroundColor: Theme.of(context).colorScheme.primary,
        ),
      );
    }
  }

  void _navigateToForm(BuildContext context, {Institution? institution}) {
    context.push('/institutions/form', extra: institution);
  }

  void _navigateToCreateInstitutionAdmin(Institution institution) {
    context.push('/institutions/create-admin', extra: institution);
  }
}
/* Fin lib\screens\institutions\institutions_list_screen.dart */

/* Inicio lib\screens\institutions\institution_admins_screen.dart */
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../providers/user_provider.dart';
import '../../providers/institution_admins_paginated_provider.dart';
import '../../providers/auth_provider.dart';
import '../../providers/institution_provider.dart';
import '../../widgets/components/index.dart';
import '../../theme/theme_extensions.dart';
import '../../models/user.dart';

class InstitutionAdminsScreen extends StatefulWidget {
  final String institutionId;

  const InstitutionAdminsScreen({super.key, required this.institutionId});

  @override
  State<InstitutionAdminsScreen> createState() => _InstitutionAdminsScreenState();
}

class _InstitutionAdminsScreenState extends State<InstitutionAdminsScreen> {
  final ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadAdmins();
    });
  }

  void _showAssignExistingUserDialog() {
    showDialog(
      context: context,
      builder: (context) => AssignExistingUserDialog(institutionId: widget.institutionId, onAssigned: () async {
        await _loadAdmins();
      }),
    );
  }

  @override
  Widget build(BuildContext context) {
  final pag = Provider.of<InstitutionAdminsPaginatedProvider>(context);
    return ClarityManagementPage(
      title: 'Administradores de InstituciÃ³n',
  isLoading: pag.isLoading,
  hasError: pag.hasError,
  errorMessage: pag.errorMessage,
  itemCount: pag.items.length,
      itemBuilder: (context, index) {
        if (index >= pag.items.length) {
          return pag.isLoadingMore
              ? const Center(
                  child: Padding(
                    padding: EdgeInsets.all(16.0),
                    child: CircularProgressIndicator(),
                  ),
                )
              : const SizedBox.shrink();
        }

  final user = pag.items[index];
        return _buildAdminCard(user, context);
      },
      onRefresh: _loadAdmins,
      scrollController: _scrollController,
  hasMoreData: pag.hasMoreData,
      floatingActionButton: FloatingActionButton(
        onPressed: _openAddAdminSheet,
        backgroundColor: context.colors.primary,
        child: Icon(
          Icons.add,
          color: context.colors.getTextColorForBackground(context.colors.primary),
        ),
      ),
      emptyStateWidget: const ClarityEmptyState(
        icon: Icons.group_off,
        title: 'No hay administradores',
        subtitle: 'Agrega administradores a esta instituciÃ³n',
      ),
    );
  }

  Future<void> _loadAdmins() async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
  final pag = Provider.of<InstitutionAdminsPaginatedProvider>(context, listen: false);
    final token = authProvider.accessToken;
    if (token != null) {
  await pag.loadItems(token, page: 1, limit: 10, filters: {'institutionId': widget.institutionId});
    }
  }

  Future<void> _removeAdmin(User user) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
  final userProvider = Provider.of<UserProvider>(context, listen: false);
  final pag = Provider.of<InstitutionAdminsPaginatedProvider>(context, listen: false);

    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Remover Administrador'),
        content: Text('Â¿Deseas remover el rol de administrador a ${user.nombreCompleto}?'),
        actions: [
          TextButton(onPressed: () => Navigator.of(context).pop(false), child: const Text('Cancelar')),
          TextButton(onPressed: () => Navigator.of(context).pop(true), child: const Text('Remover')),
        ],
      ),
    );

    if (confirmed != true) return;

    final token = authProvider.accessToken;
    if (token != null) {
      final success = await userProvider.removeAdminFromInstitution(token, widget.institutionId, user.id);
      if (success && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Administrador removido correctamente')));
  await pag.loadItems(token, page: 1, limit: 10, filters: {'institutionId': widget.institutionId});
      }
    }
  }

  void _openAddAdminSheet() {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (context) {
        final colors = context.colors;
        return Padding(
          padding: EdgeInsets.only(bottom: MediaQuery.of(context).viewInsets.bottom),
          child: Wrap(
            children: [
              ListTile(
                leading: Icon(Icons.person_add, color: colors.primary),
                title: const Text('Crear Nuevo Administrador'),
                onTap: () {
                  Navigator.of(context).pop();
                  final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);
                  final institution = institutionProvider.institutions.firstWhere((i) => i.id == widget.institutionId);
                  context.pushNamed('institution-create-admin', extra: institution);
                },
              ),
              ListTile(
                leading: Icon(Icons.person_search, color: colors.primary),
                title: const Text('Asignar Usuario Existente'),
                onTap: () {
                  Navigator.of(context).pop();
                  _showAssignExistingUserDialog();
                },
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildAdminCard(User user, BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return ClarityCard(
      title: Row(
        children: [
          CircleAvatar(
            backgroundColor: colors.primary.withValues(alpha: 0.1),
            child: Text(
              user.inicial,
              style: textStyles.bodyMedium.withColor(colors.primary),
            ),
          ),
          SizedBox(width: spacing.sm),
          Expanded(
            child: Text(
              user.nombreCompleto,
              style: textStyles.titleMedium.bold,
            ),
          ),
        ],
      ),
      subtitle: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.email, size: 16, color: colors.textSecondary),
              SizedBox(width: spacing.xs),
              Expanded(
                child: Text(
                  user.email,
                  style: textStyles.bodySmall,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ],
          ),
          if (user.telefono != null)
            SizedBox(height: spacing.xs),
          if (user.telefono != null)
            Row(
              children: [
                Icon(Icons.phone, size: 16, color: colors.textSecondary),
                SizedBox(width: spacing.xs),
                Expanded(
                  child: Text(
                    user.telefono!,
                    style: textStyles.bodySmall,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ],
            ),
          ],
      ),
      trailing: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          ClarityActionButton(
            icon: Icons.key,
            tooltip: 'Cambiar contraseÃ±a',
            color: colors.primary,
            onPressed: () => _showChangePasswordDialog(context, user),
          ),
          SizedBox(width: spacing.sm),
          ClarityActionButton(
            icon: Icons.remove_circle,
            tooltip: 'Remover administrador',
            color: colors.error,
            onPressed: () => _removeAdmin(user),
          ),
        ],
      ),
    );
  }

  void _showChangePasswordDialog(BuildContext context, User user) {
    showDialog<void>(
      context: context,
      barrierDismissible: false,
      builder: (context) => _ChangePasswordDialog(user: user, onSaved: () async {
        await _loadAdmins();
      }),
    );
  }

}

class _ChangePasswordDialog extends StatefulWidget {
  final User user;
  final VoidCallback? onSaved;

  const _ChangePasswordDialog({required this.user, this.onSaved});

  @override
  State<_ChangePasswordDialog> createState() => _ChangePasswordDialogState();
}

class _ChangePasswordDialogState extends State<_ChangePasswordDialog> {
  final _formKey = GlobalKey<FormState>();
  final TextEditingController _newPasswordController = TextEditingController();
  final TextEditingController _confirmPasswordController = TextEditingController();

  @override
  void dispose() {
    _newPasswordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  Future<bool> _save() async {
    if (!_formKey.currentState!.validate()) return false;

    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final userProvider = Provider.of<UserProvider>(context, listen: false);

    try {
      final token = authProvider.accessToken;
      if (token == null) throw Exception('No hay sesiÃ³n activa');

      final success = await userProvider.changeUserPassword(
        token,
        widget.user.id,
        _newPasswordController.text.trim(),
      );

      if (success && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('ContraseÃ±a de ${widget.user.nombreCompleto} cambiada correctamente')));
        widget.onSaved?.call();
        return true;
      }
    } catch (e) {
      if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error: ${e.toString()}')));
    }

    if (mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Error al cambiar la contraseÃ±a')));
    return false;
  }

  @override
  Widget build(BuildContext context) {
    final spacing = context.spacing;

    return ClarityFormDialog(
      title: Text('Cambiar contraseÃ±a - ${widget.user.nombreCompleto}'),
      formKey: _formKey,
      onSave: _save,
      saveLabel: 'Guardar',
      cancelLabel: 'Cancelar',
      children: [
        TextFormField(
          controller: _newPasswordController,
          obscureText: true,
          decoration: const InputDecoration(labelText: 'Nueva contraseÃ±a'),
          validator: (value) {
            if (value == null || value.trim().isEmpty) return 'La contraseÃ±a es requerida';
            if (value.trim().length < 8) return 'La contraseÃ±a debe tener al menos 8 caracteres';
            return null;
          },
        ),
        SizedBox(height: spacing.md),
        TextFormField(
          controller: _confirmPasswordController,
          obscureText: true,
          decoration: const InputDecoration(labelText: 'Confirmar contraseÃ±a'),
          validator: (value) {
            if (value == null || value.trim().isEmpty) return 'La confirmaciÃ³n es requerida';
            if (value.trim() != _newPasswordController.text.trim()) return 'Las contraseÃ±as no coinciden';
            return null;
          },
        ),
      ],
    );
  }
}

class AssignExistingUserDialog extends StatefulWidget {
  final String institutionId;
  final VoidCallback? onAssigned;

  const AssignExistingUserDialog({super.key, required this.institutionId, this.onAssigned});

  @override
  State<AssignExistingUserDialog> createState() => _AssignExistingUserDialogState();
}

class _AssignExistingUserDialogState extends State<AssignExistingUserDialog> {
  final _searchController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  Timer? _debounce;
  static const int _pageSize = 20;
  bool _isAssigning = false;

  @override
  void initState() {
    super.initState();
    _searchController.addListener(_onSearchChanged);
    _scrollController.addListener(_onScroll);
    _loadInitialUsers();
  }

  @override
  void dispose() {
  _searchController.removeListener(_onSearchChanged);
  if (_debounce?.isActive ?? false) _debounce!.cancel();
    _scrollController.removeListener(_onScroll);
    _searchController.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  void _onSearchChanged() {
    final query = _searchController.text.trim();
    if (_debounce?.isActive ?? false) _debounce!.cancel();
    _debounce = Timer(const Duration(milliseconds: 400), () async {
      final token = Provider.of<AuthProvider>(context, listen: false).accessToken;
      if (token == null) return;
      final pag = Provider.of<InstitutionAdminsPaginatedProvider>(context, listen: false);
      pag.resetPagination();
      await pag.loadItems(token, page: 1, limit: _pageSize, search: query.isEmpty ? null : query, filters: {'institutionId': widget.institutionId});
    });
  }

  Future<void> _loadInitialUsers() async {
    final token = Provider.of<AuthProvider>(context, listen: false).accessToken;
    if (token == null) return;
    final pag = Provider.of<InstitutionAdminsPaginatedProvider>(context, listen: false);
    try {
      await pag.loadItems(token, page: 1, limit: _pageSize, filters: {'institutionId': widget.institutionId});
    } catch (e) {
      debugPrint('Error cargando usuarios iniciales: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error al cargar usuarios: ${e.toString()}')),
        );
      }
    } finally {
    }
  }

  void _onScroll() {
    if (_scrollController.position.pixels >= _scrollController.position.maxScrollExtent - 200) {
      _loadMoreUsers();
    }
  }

  Future<void> _loadMoreUsers() async {
    final token = Provider.of<AuthProvider>(context, listen: false).accessToken;
    if (token == null) return;
    final pag = Provider.of<InstitutionAdminsPaginatedProvider>(context, listen: false);
    if (pag.isLoadingMore || !pag.hasMoreData) return;
    pag.setFilter('institutionId', widget.institutionId);
    await pag.loadNextPage(token);
  }

  Future<void> _assign(User user) async {
  setState(() => _isAssigning = true);
    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final userProvider = Provider.of<UserProvider>(context, listen: false);

      final token = authProvider.accessToken;
      if (token == null) {
        throw Exception('No hay sesiÃ³n activa');
      }

      final success = await userProvider.assignAdminToInstitution(
        token,
        widget.institutionId,
        user.id,
      );

      if (success && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('${user.nombreCompleto} asignado como administrador')),
        );
        widget.onAssigned?.call();
        Navigator.of(context).pop();
      } else {
        throw Exception('No se pudo asignar el administrador');
      }
    } catch (e) {
      debugPrint('Error asignando administrador: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error al asignar administrador: ${e.toString()}')),
        );
      }
    } finally {
      if (mounted) setState(() => _isAssigning = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Asignar Administrador de InstituciÃ³n'),
      content: SizedBox(
        width: 500,
        height: 600,
        child: Column(
          children: [
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
              child: TextField(
                controller: _searchController,
                decoration: InputDecoration(
                  hintText: 'Buscar administradores...',
                  prefixIcon: const Icon(Icons.search, size: 20),
                  suffixIcon: _searchController.text.isNotEmpty
                    ? IconButton(
                        icon: const Icon(Icons.clear, size: 20),
                        onPressed: () {
                          _searchController.clear();
                          _onSearchChanged();
                        },
                      )
                    : null,
                  contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(10),
                    borderSide: BorderSide(color: Theme.of(context).dividerColor),
                  ),
                  enabledBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(10),
                    borderSide: BorderSide(color: Theme.of(context).dividerColor.withValues(alpha: 0.5)),
                  ),
                  focusedBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(10),
                    borderSide: BorderSide(color: Theme.of(context).primaryColor, width: 2),
                  ),
                  filled: true,
                  fillColor: Theme.of(context).inputDecorationTheme.fillColor ?? Theme.of(context).cardColor,
                ),
                textInputAction: TextInputAction.search,
              ),
            ),
            const SizedBox(height: 12),
            Expanded(
              child: Consumer<InstitutionAdminsPaginatedProvider>(
                  builder: (context, pag, child) {
                    if (pag.isLoading && pag.items.isEmpty) {
                      return const Center(child: CircularProgressIndicator());
                    }
                    if (!pag.isLoading && pag.items.isEmpty) {
                      return const Center(
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Icon(Icons.people_outline, size: 56, color: Colors.grey),
                            SizedBox(height: 12),
                            Text('No hay administradores disponibles', style: TextStyle(fontSize: 15, color: Colors.grey, fontWeight: FontWeight.w500), textAlign: TextAlign.center),
                          ],
                        ),
                      );
                    }
                    final items = pag.items;
                    return ListView.builder(
                  controller: _scrollController,
                  padding: EdgeInsets.zero,
                  itemCount: items.length + (pag.hasMoreData ? 1 : 0),
                  itemBuilder: (context, index) {
                    if (index == items.length) {
                      return Container(
                        padding: const EdgeInsets.symmetric(vertical: 16),
                        child: const Center(
                          child: SizedBox(
                            width: 28,
                            height: 28,
                            child: CircularProgressIndicator(strokeWidth: 2.5),
                          ),
                        ),
                      );
                    }

                    final user = items[index];
                    final alreadyAssigned = (user.instituciones ?? []).any((inst) => inst.id == widget.institutionId);

                    return Card(
                      margin: const EdgeInsets.symmetric(vertical: 6),
                      elevation: 1,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(10),
                      ),
                      child: InkWell(
                        borderRadius: BorderRadius.circular(10),
                              onTap: (pag.isLoading || alreadyAssigned || _isAssigning) ? null : () => _assign(user),
                        child: Padding(
                          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 12),
                          child: Row(
                            crossAxisAlignment: CrossAxisAlignment.center,
                            children: [
                              Expanded(
                                child: Column(
                                    crossAxisAlignment: CrossAxisAlignment.start,
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      Text(
                                        user.nombreCompleto,
                                        style: const TextStyle(
                                          fontWeight: FontWeight.w600,
                                          fontSize: 15,
                                          height: 1.2,
                                        ),
                                      ),
                                      const SizedBox(height: 2),
                                      Text(
                                        user.email,
                                        style: TextStyle(
                                          color: Theme.of(context).textTheme.bodyMedium?.color?.withValues(alpha: 0.7),
                                          fontSize: 13,
                                          height: 1.2,
                                        ),
                                      ),
                                      if ((user.instituciones ?? []).any((inst) => inst.activo)) ...[
                                        const SizedBox(height: 3),
                                        Text(
                                          'En: ${(user.instituciones ?? []).where((inst) => inst.activo).map((inst) => inst.nombre).join(', ')}',
                                          style: TextStyle(
                                            color: Theme.of(context).colorScheme.secondary.withValues(alpha: 0.8),
                                            fontSize: 12,
                                            fontWeight: FontWeight.w500,
                                            height: 1.2,
                                          ),
                                        ),
                                      ],
                                    ],
                                  ),
                              ),

                              const SizedBox(width: 12),
                              SizedBox(
                                height: 36,
                                child: ElevatedButton(
                                  onPressed: (pag.isLoading || alreadyAssigned || _isAssigning) ? null : () => _assign(user),
                                  style: ElevatedButton.styleFrom(
                                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 0),
                                    shape: RoundedRectangleBorder(
                                      borderRadius: BorderRadius.circular(6),
                                    ),
                                  ),
                                  child: Text(
                                    alreadyAssigned ? 'Ya asignado' : 'Asignar',
                                    style: const TextStyle(
                                      fontSize: 13,
                                      fontWeight: FontWeight.w500,
                                    ),
                                  ),
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    );
                  },
                );
              },
            ),
          ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Cerrar'),
        ),
      ],
    );
  }
}

/* Fin lib\screens\institutions\institution_admins_screen.dart */

/* Inicio lib\screens\institutions\institution_form_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../models/institution.dart';
import '../../providers/auth_provider.dart';
import '../../providers/institution_provider.dart';
import '../../widgets/common/multi_step_form_scaffold.dart';
import 'form_steps/index.dart';

class InstitutionFormScreen extends StatefulWidget {
  final Institution? institution;

  const InstitutionFormScreen({super.key, this.institution});

  @override
  State<InstitutionFormScreen> createState() => _InstitutionFormScreenState();
}

class _InstitutionFormScreenState extends State<InstitutionFormScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nombreController = TextEditingController();
  final _direccionController = TextEditingController();
  final _telefonoController = TextEditingController();
  final _emailController = TextEditingController();

  bool _activa = true;

  bool get isEditing => widget.institution != null;

  @override
  void initState() {
    super.initState();
    debugPrint('ğŸ—ï¸ InstitutionFormScreen: initState called (isEditing: $isEditing)');
    if (widget.institution != null) {
      _loadInstitutionData();
    }
  }

  @override
  void dispose() {
    _nombreController.dispose();
    _direccionController.dispose();
    _telefonoController.dispose();
    _emailController.dispose();
    super.dispose();
  }

  void _loadInstitutionData() {
    final institution = widget.institution!;
    _nombreController.text = institution.nombre;
    _direccionController.text = institution.direccion ?? '';
    _telefonoController.text = institution.telefono ?? '';
    _emailController.text = institution.email ?? '';
    _activa = institution.activa;
  }

  Future<void> _saveInstitution() async {
    if (!_formKey.currentState!.validate()) return;

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);

      final institutionData = {
        'nombre': _nombreController.text.trim(),
        'direccion': _direccionController.text.trim(),
        'telefono': _telefonoController.text.trim(),
        'email': _emailController.text.trim(),
        'activa': _activa,
      };

      final token = authProvider.accessToken;
      if (token == null) {
        if (mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Debes iniciar sesiÃ³n para crear una instituciÃ³n')));
        return;
      }

      bool success;
      if (widget.institution == null) {
        success = await institutionProvider.createInstitution(
          token,
          institutionData,
        );
      } else {
        success = await institutionProvider.updateInstitution(
          token,
          widget.institution!.id,
          nombre: institutionData['nombre'] as String?,
          direccion: institutionData['direccion'] as String?,
          telefono: institutionData['telefono'] as String?,
          email: institutionData['email'] as String?,
          activa: institutionData['activa'] as bool?,
        );
      }

      if (success && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              widget.institution == null
                  ? 'InstituciÃ³n creada correctamente'
                  : 'InstituciÃ³n actualizada correctamente',
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onPrimary),
            ),
            backgroundColor: Theme.of(context).colorScheme.primary,
          ),
        );
        context.pop(true);
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              'Error: ${e.toString()}',
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onError),
            ),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    } finally {
    }
  }

  @override
  Widget build(BuildContext context) {
    final title = isEditing ? 'Editar InstituciÃ³n' : 'Nueva InstituciÃ³n';
    debugPrint('ğŸ—ï¸ InstitutionFormScreen: Building form with title: $title');

    return MultiStepFormScaffold(
      title: title,
      formKey: _formKey,
      onSave: _saveInstitution,
      submitLabel: isEditing ? 'Actualizar' : 'Crear',
      steps: [
        Step(
          title: const Text('InformaciÃ³n'),
          subtitle: const Text('Datos bÃ¡sicos'),
          content: InstitutionBasicInfoStep(
            nombreController: _nombreController,
            emailController: _emailController,
          ),
        ),
            Step(
              title: const Text('Contacto'),
              subtitle: const Text('UbicaciÃ³n y telÃ©fono'),
              content: InstitutionContactStep(
                direccionController: _direccionController,
                telefonoController: _telefonoController,
              ),
            ),
            Step(
              title: const Text('ConfiguraciÃ³n'),
              subtitle: const Text('Estado'),
              content: InstitutionConfigStep(
                activa: _activa,
                onActivaChanged: (value) => setState(() => _activa = value),
                isEditMode: isEditing,
              ),
            ),
        ],
    );
  }
}
/* Fin lib\screens\institutions\institution_form_screen.dart */

/* Inicio lib\screens\institution_selection_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../utils/responsive_utils.dart';
import '../models/institution.dart';

class InstitutionSelectionScreen extends StatefulWidget {
  const InstitutionSelectionScreen({super.key});

  @override
  State<InstitutionSelectionScreen> createState() => _InstitutionSelectionScreenState();
}

class _InstitutionSelectionScreenState extends State<InstitutionSelectionScreen> {
  String? _selectedInstitutionId;
  bool _isLoading = false;

  Map<String, dynamic> _getResponsiveValues(BoxConstraints constraints) {
    return ResponsiveUtils.getResponsiveValues(constraints);
  }

  Widget _buildMainTitle(Map<String, dynamic> responsive) {
    final titleFontSize = responsive['titleFontSize'] as double;

    return Builder(
      builder: (context) {
        final colors = context.colors;
        return Text(
          'Seleccionar InstituciÃ³n',
          style: TextStyle(
            fontSize: titleFontSize,
            fontWeight: FontWeight.bold,
            color: colors.textPrimary,
          ),
          textAlign: TextAlign.center,
        );
      },
    );
  }

  Widget _buildSubtitle(Map<String, dynamic> responsive, Color textMuted) {
    final subtitleFontSize = responsive['subtitleFontSize'] as double;

    return Text(
      'Elija la instituciÃ³n con la que desea trabajar',
      style: TextStyle(
        color: textMuted,
        fontSize: subtitleFontSize,
      ),
      textAlign: TextAlign.center,
    );
  }

  Widget _buildInstitutionList(List<Institution> institutions, Map<String, dynamic> responsive) {
    final bodyFontSize = responsive['bodyFontSize'] as double;

    return ListView.builder(
      shrinkWrap: true,
      itemCount: institutions.length,
      itemBuilder: (context, index) {
        final institution = institutions[index];
        final isSelected = _selectedInstitutionId == institution.id;

        return Card(
          margin: const EdgeInsets.symmetric(vertical: 8),
          color: isSelected ? Theme.of(context).colorScheme.primaryContainer : Theme.of(context).colorScheme.surface,
          child: ListTile(
            leading: Radio<String>(
              value: institution.id,
              groupValue: _selectedInstitutionId,
              onChanged: (value) {
                setState(() {
                  _selectedInstitutionId = value;
                });
              },
            ),
            title: Text(
              institution.name,
              style: TextStyle(
                fontSize: bodyFontSize,
                color: isSelected ? Theme.of(context).colorScheme.onPrimaryContainer : Theme.of(context).colorScheme.onSurface,
              ),
            ),
            subtitle: institution.role != null
                ? Text('Rol: ${institution.role}', style: TextStyle(fontSize: bodyFontSize * 0.9))
                : null,
            onTap: () {
              setState(() {
                _selectedInstitutionId = institution.id;
              });
            },
          ),
        );
      },
    );
  }

  Widget _buildContinueButton(Map<String, dynamic> responsive) {
    final buttonWidth = responsive['buttonWidth'] as double;

    return SizedBox(
      width: buttonWidth,
      child: ElevatedButton(
        onPressed: _isLoading || _selectedInstitutionId == null ? null : _continue,
        child: Text(_isLoading ? 'Continuando...' : 'Continuar'),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final authProvider = Provider.of<AuthProvider>(context);
    final institutions = authProvider.institutions;

    if (institutions == null || institutions.isEmpty) {
      return const Scaffold(
        body: Center(
          child: Text('No hay instituciones disponibles'),
        ),
      );
    }

    return Scaffold(
      backgroundColor: colors.background,
      body: SafeArea(
        child: ResponsiveUtils.buildResponsiveContainer(
          context: context,
          child: SingleChildScrollView(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                LayoutBuilder(
                  builder: (context, constraints) {
                    final responsive = _getResponsiveValues(constraints);
                    final elementSpacing = responsive['elementSpacing'] as double;

                    return Column(
                      children: [
                        _buildMainTitle(responsive),
                        SizedBox(height: elementSpacing),

                        _buildSubtitle(responsive, colors.textMuted),
                        SizedBox(height: elementSpacing * 1.5),

                        _buildInstitutionList(institutions, responsive),
                        SizedBox(height: elementSpacing * 2),

                        _buildContinueButton(responsive),
                      ],
                    );
                  },
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _continue() async {
    if (_selectedInstitutionId == null) return;

    setState(() {
      _isLoading = true;
    });
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    authProvider.selectInstitution(_selectedInstitutionId!);
  }
}
/* Fin lib\screens\institution_selection_screen.dart */

/* Inicio lib\screens\login_screen.dart */
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../utils/responsive_utils.dart';

class LoginScreen extends StatefulWidget {
  const LoginScreen({super.key});

  @override
  State<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {

  final _emailController = TextEditingController(text: 'superadmin@asistapp.com');
  final _passwordController = TextEditingController(text: 'Admin123!');
  bool _isLoading = false;
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Widget _buildMainTitle(Map<String, dynamic> responsive) {
    final titleFontSize = responsive['titleFontSize'] as double;

    return Builder(
      builder: (context) {
        final colors = context.colors;
        return Text(
          'AsistApp',
          key: const Key('appTitle'),
          style: TextStyle(
            fontSize: titleFontSize,
            fontWeight: FontWeight.bold,
            color: colors.textPrimary,
          ),
          textAlign: TextAlign.center,
        );
      },
    );
  }

  Widget _buildSubtitle(Map<String, dynamic> responsive, Color textMuted) {
    final subtitleFontSize = responsive['subtitleFontSize'] as double;

    return Text(
      'Sistema de Registro de Asistencia Escolar',
      style: TextStyle(
        color: textMuted,
        fontSize: subtitleFontSize,
      ),
      textAlign: TextAlign.center,
    );
  }

  Widget _buildEmailField() {
    return TextFormField(
      key: const Key('emailField'),
      controller: _emailController,
      decoration: const InputDecoration(
        labelText: 'Correo electrÃ³nico',
      ),
      keyboardType: TextInputType.emailAddress,
    );
  }

  Widget _buildPasswordField() {
    return TextFormField(
      key: const Key('passwordField'),
      controller: _passwordController,
      decoration: const InputDecoration(
        labelText: 'ContraseÃ±a',
      ),
      obscureText: true,
    );
  }

  Widget _buildLoginButton(Map<String, dynamic> responsive) {
    final buttonWidth = responsive['buttonWidth'] as double;

    return SizedBox(
      width: buttonWidth,
      child: ElevatedButton(
        key: const Key('loginButton'),
        onPressed: _isLoading ? null : _login,
        child: Text(_isLoading ? 'Iniciando sesiÃ³n...' : 'Iniciar SesiÃ³n'),
      ),
    );
  }

  Widget _buildTestUsersSection(Map<String, dynamic> responsive) {
    final bodyFontSize = responsive['bodyFontSize'] as double;

    return Builder(
      builder: (context) {
        final colors = context.colors;
        return Column(
          children: [
            const SizedBox(height: 32),
            Text(
              'Usuarios de Prueba (Desarrollo)',
              style: TextStyle(
                fontSize: bodyFontSize,
                fontWeight: FontWeight.bold,
                color: colors.textSecondary,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 16),

            _buildUserCategory(
              'ğŸ‘‘ Super Administradores',
              [
                _buildTestUserButton('Super Admin', 'superadmin@asistapp.com', 'Admin123!', 'super_admin', 'GestiÃ³n de instituciones y admins.', responsive),
              ],
              responsive,
            ),

            _buildUserCategory(
              'ğŸ‘¨â€ğŸ’¼ Administradores de InstituciÃ³n',
              [
                _buildTestUserButton('Admin San JosÃ©', 'admin@sanjose.edu', 'SanJose123!', 'admin_institucion', 'Probar gestiÃ³n acadÃ©mica (grupos, materias, horarios).', responsive),
                _buildTestUserButton('Admin Santander', 'admin@santander.edu', 'Santander123!', 'admin_institucion', 'Probar en instituciÃ³n con menos datos.', responsive),
                _buildTestUserButton('Admin Multi-Sede', 'multiadmin@asistapp.com', 'Multi123!', 'admin_institucion', 'Probar pantalla de selecciÃ³n de instituciÃ³n.', responsive),
              ],
              responsive,
            ),

            _buildUserCategory(
              'ğŸ‘¨â€ğŸ« Profesores',
              [
                _buildTestUserButton('Juan PÃ©rez', 'juan.perez@sanjose.edu', 'Prof123!', 'profesor', 'San JosÃ© - Tiene clases hoy para probar el dashboard.', responsive),
                _buildTestUserButton('Laura GÃ³mez', 'laura.gomez@sanjose.edu', 'Prof123!', 'profesor', 'San JosÃ© - Tiene clases en diferentes grupos.', responsive),
                _buildTestUserButton('Profe Sin Clases', 'vacio.profe@sanjose.edu', 'Prof123!', 'profesor', 'San JosÃ© - Probar dashboard sin clases asignadas.', responsive),
                _buildTestUserButton('Carlos DÃ­az', 'carlos.diaz@santander.edu', 'Prof123!', 'profesor', 'Santander - Probar dashboard en otra instituciÃ³n.', responsive),
              ],
              responsive,
            ),

            _buildUserCategory(
              'ğŸ‘¨â€ğŸ“ Estudiantes',
              [
                _buildTestUserButton('Santiago Mendoza', 'santiago.mendoza@sanjose.edu', 'Est123!', 'estudiante', 'San JosÃ© - Asignado al Grupo 10-A.', responsive),
                _buildTestUserButton('Mateo Castro', 'mateo.castro@sanjose.edu', 'Est123!', 'estudiante', 'San JosÃ© - Asignado al Grupo 11-B.', responsive),
                _buildTestUserButton('SofÃ­a NÃºÃ±ez', 'sofia.nunez@santander.edu', 'Est123!', 'estudiante', 'Santander - Asignada al Grupo 6-1.', responsive),
              ],
              responsive,
            ),
          ],
        );
      },
    );
  }

  Widget _buildUserCategory(String title, List<Widget> buttons, Map<String, dynamic> responsive) {
    return Builder(
      builder: (context) {
        final colors = context.colors;
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
              child: Text(
                title,
                style: TextStyle(
                  fontSize: responsive['bodyFontSize'] as double,
                  fontWeight: FontWeight.bold,
                  color: colors.textPrimary,
                ),
              ),
            ),
            Wrap(
              spacing: 8,
              runSpacing: 8,
              alignment: WrapAlignment.start,
              children: buttons,
            ),
            const SizedBox(height: 8),
          ],
        );
      },
    );
  }

  Widget _buildTestUserButton(
    String name,
    String email,
    String password,
    String role,
    String institutions,
    Map<String, dynamic> responsive,
  ) {
    final isSmallScreen = responsive['isSmallScreen'] as bool;
    final buttonWidth = isSmallScreen ? 140.0 : 160.0;

    return Builder(
      builder: (context) {
        final colors = context.colors;
        final textStyles = context.textStyles;

        return SizedBox(
          width: buttonWidth,
          child: OutlinedButton(
            onPressed: () {
              setState(() {
                _emailController.text = email;
                _passwordController.text = password;
                _errorMessage = null;
              });
            },
            style: OutlinedButton.styleFrom(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 12),
              side: BorderSide(color: colors.primary.withValues(alpha: 0.5)),
            ),
            child: Column(
              children: [
                Text(
                  name,
                  style: textStyles.labelMedium.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 2),
                Text(
                  role,
                  style: textStyles.bodySmall,
                  textAlign: TextAlign.center,
                ),
                Text(
                  institutions,
                  style: textStyles.bodySmall.copyWith(
                    fontStyle: FontStyle.italic,
                    color: colors.textMuted,
                  ),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildErrorMessage() {
    if (_errorMessage == null) return const SizedBox.shrink();

    return Builder(
      builder: (context) {
        final textStyles = context.textStyles;
        final colors = context.colors;
        return Text(
          _errorMessage!,
          style: textStyles.bodyMedium.copyWith(color: colors.error),  // Usar estilo del tema
          textAlign: TextAlign.center,
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;

    return Scaffold(
      backgroundColor: colors.background,
      body: SafeArea(
        child: LayoutBuilder(
          builder: (context, constraints) {
            final responsive = ResponsiveUtils.getResponsiveValues(constraints);

            return SingleChildScrollView(
              child: ConstrainedBox(
                constraints: BoxConstraints(maxWidth: responsive['maxWidth']),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    Padding(
                      padding: EdgeInsets.symmetric(
                        horizontal: responsive['horizontalPadding'],
                        vertical: responsive['verticalPadding'],
                      ),
                      child: Column(
                        children: [
                          _buildMainTitle(responsive),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildSubtitle(responsive, colors.textMuted),
                          SizedBox(height: responsive['elementSpacing'] * 1.5),

                          _buildEmailField(),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildPasswordField(),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildErrorMessage(),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildLoginButton(responsive),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildTestUsersSection(responsive),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            );
          },
        ),
      ),
    );
  }

  Future<void> _login() async {
    if (_emailController.text.isEmpty ||
        _passwordController.text.isEmpty) {
      setState(() {
        _errorMessage = 'Por favor complete todos los campos';
      });
      return;
    }

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final success = await authProvider.login(
        _emailController.text.trim(),
        _passwordController.text,
      );

      if (success) {
        debugPrint('Login exitoso, AuthWrapper manejarÃ¡ la navegaciÃ³n');
      } else {
        setState(() {
          _errorMessage = 'Credenciales incorrectas';
        });
      }
    } catch (e) {
      String raw = e.toString();
      const exceptionPrefix = 'Exception: ';
      if (raw.startsWith(exceptionPrefix)) {
        raw = raw.substring(exceptionPrefix.length);
      }

      String messageToShow = raw;
      try {
        final parsed = jsonDecode(raw);
        if (parsed is Map<String, dynamic>) {
          messageToShow = parsed['message'] ?? parsed['error'] ?? (parsed['data'] is Map ? (parsed['data']['message'] ?? parsed['data']['error']) : null) ?? raw;
        }
      } catch (_) {
      }

      setState(() {
        _errorMessage = messageToShow;
      });
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }
}
/* Fin lib\screens\login_screen.dart */

/* Inicio lib\screens\my_qr_code_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:qr_flutter/qr_flutter.dart';
import '../providers/auth_provider.dart';
import '../services/estudiante_service.dart';
import '../theme/app_colors.dart';
import '../theme/app_spacing.dart';

class MyQRCodeScreen extends StatefulWidget {
  const MyQRCodeScreen({super.key});

  @override
  State<MyQRCodeScreen> createState() => _MyQRCodeScreenState();
}

class _MyQRCodeScreenState extends State<MyQRCodeScreen> {
  final AppColors colors = AppColors.instance;
  final AppSpacing spacing = AppSpacing.instance;
  final EstudianteService _estudianteService = EstudianteService();

  String? _qrCode;
  bool _isLoading = true;
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
    _loadQRCode();
  }

  Future<void> _loadQRCode() async {
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final accessToken = authProvider.accessToken;

      if (accessToken == null) {
        throw Exception('Usuario no autenticado');
      }

      final estudianteInfo = await _estudianteService.getEstudianteInfo(
        accessToken: accessToken,
      );

      if (estudianteInfo == null) {
        throw Exception('No se pudo obtener la informaciÃ³n del estudiante');
      }

      final qrCode = estudianteInfo['codigoQr'] as String?;
      if (qrCode == null || qrCode.isEmpty) {
        throw Exception('CÃ³digo QR no disponible');
      }

      setState(() {
        _qrCode = qrCode;
        _isLoading = false;
      });

    } catch (e) {
      setState(() {
        _errorMessage = e.toString();
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final user = authProvider.user;
    final userName = user?['nombres'] ?? 'Usuario';
    final userLastName = user?['apellidos'] ?? '';

    return LayoutBuilder(
      builder: (context, constraints) {
        return Scaffold(
          appBar: AppBar(
            title: const Text('Mi CÃ³digo QR'),
            backgroundColor: colors.primary,
            foregroundColor: colors.white,
          ),
          body: SingleChildScrollView(
            padding: EdgeInsets.all(spacing.lg),
            child: Column(
              children: [
                Container(
                  padding: EdgeInsets.all(spacing.lg),
                  decoration: BoxDecoration(
                    color: colors.surface,
                    borderRadius: BorderRadius.circular(spacing.borderRadius),
                    border: Border.all(color: colors.borderLight),
                  ),
                  child: Column(
                    children: [
                      Icon(
                        Icons.person,
                        size: 48,
                        color: colors.primary,
                      ),
                      SizedBox(height: spacing.md),
                      Text(
                        '$userName $userLastName',
                        style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                          fontWeight: FontWeight.bold,
                          color: colors.textPrimary,
                        ),
                        textAlign: TextAlign.center,
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                      SizedBox(height: spacing.sm),
                      Text(
                        'Estudiante',
                        style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                          color: colors.textSecondary,
                        ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ],
                  ),
                ),

                SizedBox(height: spacing.xl),
                Container(
                  padding: EdgeInsets.all(spacing.xl),
                  decoration: BoxDecoration(
                    color: colors.white,
                    borderRadius: BorderRadius.circular(spacing.borderRadius),
                    border: Border.all(color: colors.borderLight),
                  ),
                  child: _buildQRContent(constraints),
                ),

                SizedBox(height: spacing.lg),
                Text(
                  'Muestra este cÃ³digo QR a tu profesor para registrar tu asistencia',
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    color: colors.textSecondary,
                  ),
                  textAlign: TextAlign.center,
                  maxLines: 3,
                  overflow: TextOverflow.ellipsis,
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildQRContent(BoxConstraints constraints) {
    final qrSize = constraints.maxWidth < 400 ? 150.0 : 200.0;

    if (_isLoading) {
      return const Center(
        child: CircularProgressIndicator(),
      );
    }

    if (_errorMessage != null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.error_outline,
              size: 48,
              color: colors.error,
            ),
            SizedBox(height: spacing.md),
            Text(
              'Error al cargar el cÃ³digo QR',
              style: Theme.of(context).textTheme.headlineSmall,
              textAlign: TextAlign.center,
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
            ),
            SizedBox(height: spacing.sm),
            Text(
              _errorMessage!,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: colors.textSecondary,
              ),
              textAlign: TextAlign.center,
              maxLines: 3,
              overflow: TextOverflow.ellipsis,
            ),
            SizedBox(height: spacing.lg),
            ElevatedButton.icon(
              onPressed: _loadQRCode,
              icon: const Icon(Icons.refresh),
              label: const Text('Reintentar'),
            ),
          ],
        ),
      );
    }

    if (_qrCode == null || _qrCode!.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.qr_code_2,
              size: 48,
              color: colors.textMuted,
            ),
            SizedBox(height: spacing.md),
            Text(
              'CÃ³digo QR no disponible',
              style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                color: colors.textMuted,
              ),
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
              textAlign: TextAlign.center,
            ),
          ],
        ),
      );
    }

    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Container(
          padding: EdgeInsets.all(spacing.md),
          decoration: BoxDecoration(
            color: colors.white,
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            boxShadow: [
              BoxShadow(
                color: colors.shadow.withValues(alpha: 0.1),
                blurRadius: 8,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: QrImageView(
            data: _qrCode!,
            version: QrVersions.auto,
            size: qrSize,
            backgroundColor: colors.white,
          ),
        ),

        SizedBox(height: spacing.lg),
        Text(
          'ID: $_qrCode',
          style: Theme.of(context).textTheme.bodySmall?.copyWith(
            color: colors.textMuted,
            fontFamily: 'monospace',
          ),
          textAlign: TextAlign.center,
          maxLines: 2,
          overflow: TextOverflow.ellipsis,
        ),
      ],
    );
  }
}
/* Fin lib\screens\my_qr_code_screen.dart */

/* Inicio lib\screens\qr_scanner_screen.dart */
import 'package:flutter/material.dart';
import 'package:mobile_scanner/mobile_scanner.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../services/asistencia_service.dart';

class QRScannerScreen extends StatefulWidget {
  final String horarioId;

  const QRScannerScreen({
    super.key,
    required this.horarioId,
  });

  @override
  State<QRScannerScreen> createState() => _QRScannerScreenState();
}

class _QRScannerScreenState extends State<QRScannerScreen> {
  MobileScannerController? controller
  final AsistenciaService _asistenciaService = AsistenciaService();
  bool _isProcessing = false;
  bool _isScannerReady = false
  String? _lastScannedCode;
  DateTime? _lastScanTime;

  @override
  void initState() {
    super.initState();
    _initializeScanner();
  }

  Future<void> _initializeScanner() async {
    try {
      controller = MobileScannerController();
      await controller!.start();
      if (mounted) {
        setState(() {
          _isScannerReady = true;
        });
      }
    } catch (e) {
      debugPrint('âŒ Error inicializando scanner: $e');
      if (mounted) {
        _showErrorSnackBar('Error al inicializar la cÃ¡mara');
        Future.delayed(const Duration(seconds: 2), () {
          if (mounted) {
            _initializeScanner();
          }
        });
      }
    }
  }
  Future<void> _safeStopScanner() async {
    if (controller == null || !_isScannerReady) {
      debugPrint('âš ï¸ Scanner no estÃ¡ listo para detenerse');
      return;
    }

    try {
      await controller!.stop();
      debugPrint('âœ… Scanner detenido de forma segura');
    } catch (e) {
      debugPrint('âŒ Error al detener scanner de forma segura: $e');
      if (mounted) {
        setState(() {
          _isScannerReady = false;
        });
      }
      _initializeScanner();
    }
  }
  Future<void> _safeStartScanner() async {
    if (controller == null) {
      debugPrint('âš ï¸ Controller es null, inicializando...');
      await _initializeScanner();
      return;
    }

    if (_isScannerReady) {
      debugPrint('âš ï¸ Scanner ya estÃ¡ listo');
      return;
    }

    try {
      await controller!.start();
      if (mounted) {
        setState(() {
          _isScannerReady = true;
        });
      }
      debugPrint('âœ… Scanner iniciado de forma segura');
    } catch (e) {
      debugPrint('âŒ Error al iniciar scanner de forma segura: $e');
      if (mounted) {
        setState(() {
          _isScannerReady = false;
        });
      }
      _initializeScanner();
    }
  }

  @override
  void dispose() {
    controller?.dispose();
    super.dispose();
  }

  Future<void> _onDetect(BarcodeCapture capture) async {
    if (_isProcessing) return;
    if (!_isScannerReady || controller == null) {
      debugPrint('âš ï¸ Scanner no estÃ¡ listo, ignorando detecciÃ³n');
      return;
    }

    final List<Barcode> barcodes = capture.barcodes;
    if (barcodes.isEmpty) return;

    final String? code = barcodes.first.rawValue;
    if (code == null || code.isEmpty) return;
    if (_lastScannedCode == code) return;
    final now = DateTime.now();
    if (_lastScanTime != null) {
      final difference = now.difference(_lastScanTime!);
      if (difference.inMilliseconds < 500) {
        debugPrint('âš ï¸ Escaneo muy rÃ¡pido, ignorando (${difference.inMilliseconds}ms)');
        return;
      }
    }
    _isProcessing = true;
    _lastScannedCode = code;
    _lastScanTime = now;
    await _safeStopScanner();
    final currentContext = context;

    try {
      final authProvider = Provider.of<AuthProvider>(currentContext, listen: false);
      final token = authProvider.accessToken;

      if (token == null) {
        _showErrorSnackBar('Error de autenticaciÃ³n');
        return;
      }
      if (mounted) {
        final snackBarContext = context
        final screenHeight = MediaQuery.of(snackBarContext).size.height;
        final topPadding = MediaQuery.of(snackBarContext).padding.top;
        ScaffoldMessenger.of(snackBarContext).showSnackBar(
          SnackBar(
            content: const Row(
              children: [
                CircularProgressIndicator(color: Colors.white),
                SizedBox(width: 16),
                Expanded(child: Text('Registrando asistencia...')),
              ],
            ),
            duration: const Duration(seconds: 10),
            behavior: SnackBarBehavior.floating,
            margin: EdgeInsets.only(
              top: topPadding + 16,
              left: 16,
              right: 16,
              bottom: screenHeight - 150,
            ),
          ),
        );
      }
      final success = await _asistenciaService.registrarAsistencia(
        accessToken: token,
        horarioId: widget.horarioId,
        codigoQr: code,
      );

      if (success && mounted) {
        ScaffoldMessenger.of(currentContext).hideCurrentSnackBar();
        final successSnackBarContext = context
        final successScreenHeight = MediaQuery.of(successSnackBarContext).size.height;
        final successTopPadding = MediaQuery.of(successSnackBarContext).padding.top;
        ScaffoldMessenger.of(successSnackBarContext).showSnackBar(
          SnackBar(
            content: const Row(
              children: [
                Icon(Icons.check_circle, color: Colors.white),
                SizedBox(width: 8),
                Expanded(child: Text('Â¡Asistencia registrada exitosamente!')),
              ],
            ),
            backgroundColor: Colors.green,
            duration: const Duration(seconds: 2),
            behavior: SnackBarBehavior.floating,
            margin: EdgeInsets.only(
              top: successTopPadding + 16,
              left: 16,
              right: 16,
              bottom: successScreenHeight - 150,
            ),
          ),
        );
        Future.delayed(const Duration(seconds: 1), () {
          if (mounted) {
            Navigator.of(currentContext).pop(true);
          }
        });
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(currentContext).hideCurrentSnackBar();
        _showErrorSnackBar(e.toString());
        await _safeStartScanner();
        Future.delayed(const Duration(seconds: 2), () {
          if (mounted) {
            setState(() {
              _lastScannedCode = null;
            });
          }
        });
      }
    } finally {
      if (mounted) {
        setState(() {
          _isProcessing = false;
        });
      }
    }
  }

  void _showErrorSnackBar(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            const Icon(Icons.error, color: Colors.white),
            const SizedBox(width: 8),
            Expanded(child: Text(message)),
          ],
        ),
        backgroundColor: Colors.red,
        duration: const Duration(seconds: 4),
        behavior: SnackBarBehavior.floating,
        margin: EdgeInsets.only(
          top: MediaQuery.of(context).padding.top + 16,
          left: 16,
          right: 16,
          bottom: MediaQuery.of(context).size.height - 150,
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final frameSize = constraints.maxWidth < 400 ? 200.0 : 250.0;

        return Scaffold(
          appBar: AppBar(
            title: const Text('Escanear CÃ³digo QR'),
            backgroundColor: Colors.black,
            foregroundColor: Colors.white,
            actions: [
              IconButton(
                icon: const Icon(Icons.flashlight_on),
                onPressed: () => controller?.toggleTorch(),
                tooltip: 'Alternar flash',
              ),
              IconButton(
                icon: const Icon(Icons.cameraswitch),
                onPressed: () => controller?.switchCamera(),
                tooltip: 'Cambiar cÃ¡mara',
              ),
            ],
          ),
          body: Stack(
            children: [
              MobileScanner(
                controller: controller,
                onDetect: _onDetect,
              ),
              Container(
                decoration: BoxDecoration(
                  color: Colors.black.withValues(alpha: 0.5),
                ),
                child: Stack(
                  children: [
                    Center(
                      child: Container(
                        width: frameSize,
                        height: frameSize,
                        decoration: BoxDecoration(
                          border: Border.all(
                            color: Colors.white,
                            width: 2,
                          ),
                          borderRadius: BorderRadius.circular(12),
                        ),
                        child: Stack(
                          children: [
                            Positioned(
                              top: 0,
                              left: 0,
                              child: Container(
                                width: 20,
                                height: 20,
                                decoration: const BoxDecoration(
                                  border: Border(
                                    top: BorderSide(color: Colors.blue, width: 4),
                                    left: BorderSide(color: Colors.blue, width: 4),
                                  ),
                                ),
                              ),
                            ),
                            Positioned(
                              top: 0,
                              right: 0,
                              child: Container(
                                width: 20,
                                height: 20,
                                decoration: const BoxDecoration(
                                  border: Border(
                                    top: BorderSide(color: Colors.blue, width: 4),
                                    right: BorderSide(color: Colors.blue, width: 4),
                                  ),
                                ),
                              ),
                            ),
                            Positioned(
                              bottom: 0,
                              left: 0,
                              child: Container(
                                width: 20,
                                height: 20,
                                decoration: const BoxDecoration(
                                  border: Border(
                                    bottom: BorderSide(color: Colors.blue, width: 4),
                                    left: BorderSide(color: Colors.blue, width: 4),
                                  ),
                                ),
                              ),
                            ),
                            Positioned(
                              bottom: 0,
                              right: 0,
                              child: Container(
                                width: 20,
                                height: 20,
                                decoration: const BoxDecoration(
                                  border: Border(
                                    bottom: BorderSide(color: Colors.blue, width: 4),
                                    right: BorderSide(color: Colors.blue, width: 4),
                                  ),
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                    Positioned(
                      top: constraints.maxWidth < 400 ? 80 : 100,
                      left: 20,
                      right: 20,
                      child: Container(
                        padding: const EdgeInsets.all(16),
                        decoration: BoxDecoration(
                          color: Colors.black.withValues(alpha: 0.8),
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: Text(
                          'Coloca el cÃ³digo QR dentro del marco para registrar la asistencia',
                          style: TextStyle(
                            color: Colors.white,
                            fontSize: constraints.maxWidth < 400 ? 14 : 16,
                            fontWeight: FontWeight.w500,
                          ),
                          textAlign: TextAlign.center,
                          maxLines: 3,
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                    ),
                    Positioned(
                      bottom: 50,
                      left: 20,
                      right: 20,
                      child: ElevatedButton(
                        onPressed: () => Navigator.of(context).pop(false),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.red,
                          foregroundColor: Colors.white,
                          padding: const EdgeInsets.symmetric(vertical: 16),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                        ),
                        child: const Text(
                          'Cancelar',
                          style: TextStyle(fontSize: 18),
                        ),
                      ),
                    ),
                    if (_isProcessing)
                      Container(
                        color: Colors.black.withValues(alpha: 0.7),
                        child: const Center(
                          child: Column(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              CircularProgressIndicator(
                                color: Colors.white,
                              ),
                              SizedBox(height: 16),
                              Text(
                                'Procesando...',
                                style: TextStyle(
                                  color: Colors.white,
                                  fontSize: 16,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                  ],
                ),
              ),
            ],
          ),
        );
      },
    );
  }
}
/* Fin lib\screens\qr_scanner_screen.dart */

/* Inicio lib\screens\student_attendance_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';

class StudentAttendanceScreen extends StatefulWidget {
  const StudentAttendanceScreen({super.key});

  @override
  State<StudentAttendanceScreen> createState() => _StudentAttendanceScreenState();
}

class _StudentAttendanceScreenState extends State<StudentAttendanceScreen> {
  bool _isLoading = true;
  List<Map<String, dynamic>> _asistencias = [];
  String? _errorMessage;
  DateTime _selectedDate = DateTime.now();

  @override
  void initState() {
    super.initState();
    _loadAsistencias();
  }

  Future<void> _loadAsistencias() async {
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final token = authProvider.accessToken;

      if (token == null) {
        setState(() {
          _errorMessage = 'No se pudo obtener el token de autenticaciÃ³n';
          _isLoading = false;
        });
        return;
      }
      await Future.delayed(const Duration(seconds: 1))

      setState(() {
        _asistencias = [
          {
            'fecha': '2024-01-15',
            'hora': '07:00',
            'materia': {'nombre': 'MatemÃ¡ticas'},
            'profesor': {'nombres': 'Juan', 'apellidos': 'PÃ©rez'},
            'estado': 'presente',
            'tipo': 'qr',
          },
          {
            'fecha': '2024-01-15',
            'hora': '08:00',
            'materia': {'nombre': 'FÃ­sica'},
            'profesor': {'nombres': 'Laura', 'apellidos': 'GÃ³mez'},
            'estado': 'presente',
            'tipo': 'manual',
          },
          {
            'fecha': '2024-01-14',
            'hora': '07:00',
            'materia': {'nombre': 'QuÃ­mica'},
            'profesor': {'nombres': 'Laura', 'apellidos': 'GÃ³mez'},
            'estado': 'ausente',
            'tipo': 'qr',
          },
        ];
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _errorMessage = 'Error al cargar asistencias: $e';
        _isLoading = false;
      });
    }
  }

  Future<void> _selectDate(BuildContext context) async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
      builder: (context, child) {
        return Theme(
          data: Theme.of(context).copyWith(
            colorScheme: ColorScheme.light(
              primary: context.colors.primary,
              onPrimary: context.colors.onPrimary,
              surface: context.colors.surface,
              onSurface: context.colors.textPrimary,
            ),
          ),
          child: child!,
        );
      },
    );
    if (picked != null && picked != _selectedDate) {
      setState(() {
        _selectedDate = picked;
      });
      _loadAsistencias()
    }
  }

  void _previousMonth() {
    setState(() {
      _selectedDate = DateTime(_selectedDate.year, _selectedDate.month - 1, 1);
    });
    _loadAsistencias();
  }

  void _nextMonth() {
    final nextMonth = DateTime(_selectedDate.year, _selectedDate.month + 1, 1);
    if (nextMonth.isBefore(DateTime.now()) || nextMonth.month == DateTime.now().month) {
      setState(() {
        _selectedDate = nextMonth;
      });
      _loadAsistencias();
    }
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final textStyles = context.textStyles;

    return Scaffold(
      appBar: AppBar(
        title: Text('Mi Asistencia', style: textStyles.headlineMedium),
        backgroundColor: colors.surface,
        foregroundColor: colors.textPrimary,
        elevation: 0,
        actions: [
          IconButton(
            icon: const Icon(Icons.chevron_left),
            onPressed: _previousMonth,
            tooltip: 'Mes anterior',
          ),
          TextButton(
            onPressed: () => _selectDate(context),
            child: Text(
              '${_getMonthName(_selectedDate.month)} ${_selectedDate.year}',
              style: textStyles.titleMedium.copyWith(
                color: colors.primary,
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          IconButton(
            icon: const Icon(Icons.chevron_right),
            onPressed: _nextMonth,
            tooltip: 'Mes siguiente',
          ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _errorMessage != null
              ? _buildErrorState()
              : _buildAttendanceContent(),
    );
  }

  Widget _buildErrorState() {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.error_outline, size: 64, color: colors.error),
          SizedBox(height: spacing.lg),
          Text(
            'Error al cargar asistencia',
            style: textStyles.headlineSmall.copyWith(color: colors.error),
          ),
          SizedBox(height: spacing.sm),
          Text(
            _errorMessage ?? 'OcurriÃ³ un error desconocido',
            style: textStyles.bodyMedium.copyWith(color: colors.textSecondary),
            textAlign: TextAlign.center,
          ),
          SizedBox(height: spacing.xl),
          ElevatedButton.icon(
            onPressed: _loadAsistencias,
            icon: const Icon(Icons.refresh),
            label: const Text('Reintentar'),
          ),
        ],
      ),
    );
  }

  Widget _buildAttendanceContent() {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    if (_asistencias.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.check_circle_outline, size: 64, color: colors.textMuted),
            SizedBox(height: spacing.lg),
            Text(
              'No hay registros de asistencia',
              style: textStyles.headlineSmall.copyWith(color: colors.textSecondary),
            ),
            SizedBox(height: spacing.sm),
            Text(
              'Los registros aparecerÃ¡n aquÃ­ cuando marques asistencia',
              style: textStyles.bodyMedium.copyWith(color: colors.textMuted),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      );
    }
    final total = _asistencias.length;
    final presentes = _asistencias.where((a) => a['estado'] == 'presente').length;
    final ausentes = _asistencias.where((a) => a['estado'] == 'ausente').length;
    final porcentajeAsistencia = total > 0 ? (presentes / total * 100).round() : 0;

    return RefreshIndicator(
      onRefresh: _loadAsistencias,
      child: ListView(
        padding: EdgeInsets.all(spacing.lg),
        children: [
          Card(
            child: Padding(
              padding: EdgeInsets.all(spacing.md),
              child: Column(
                children: [
                  Text(
                    'EstadÃ­sticas de Asistencia',
                    style: textStyles.titleMedium.copyWith(
                      fontWeight: FontWeight.w600,
                      color: colors.textPrimary,
                    ),
                  ),
                  SizedBox(height: spacing.md),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceAround,
                    children: [
                      _buildStatItem('Total', total.toString(), colors.textPrimary),
                      _buildStatItem('Presente', presentes.toString(), colors.success),
                      _buildStatItem('Ausente', ausentes.toString(), colors.error),
                    ],
                  ),
                  SizedBox(height: spacing.md),
                  LinearProgressIndicator(
                    value: porcentajeAsistencia / 100,
                    backgroundColor: colors.error.withValues(alpha: 0.2),
                    valueColor: AlwaysStoppedAnimation<Color>(colors.success),
                  ),
                  SizedBox(height: spacing.sm),
                  Text(
                    '$porcentajeAsistencia% de asistencia',
                    style: textStyles.bodyMedium.copyWith(
                      color: colors.textSecondary,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ],
              ),
            ),
          ),
          SizedBox(height: spacing.xl),
          Text(
            'Historial de Asistencia',
            style: textStyles.titleLarge.copyWith(
              fontWeight: FontWeight.w600,
              color: colors.textPrimary,
            ),
          ),
          SizedBox(height: spacing.md),
          ..._asistencias.map((asistencia) => _buildAttendanceCard(asistencia)),
        ],
      ),
    );
  }

  Widget _buildStatItem(String label, String value, Color color) {
    final textStyles = context.textStyles;

    return Column(
      children: [
        Text(
          value,
          style: textStyles.headlineMedium.copyWith(
            color: color,
            fontWeight: FontWeight.w700,
          ),
        ),
  const SizedBox(height: 4),
        Text(
          label,
          style: textStyles.bodySmall.copyWith(color: color),
        ),
      ],
    );
  }

  Widget _buildAttendanceCard(Map<String, dynamic> asistencia) {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    final materia = asistencia['materia'] as Map<String, dynamic>;
    final profesor = asistencia['profesor'] as Map<String, dynamic>;
    final estado = asistencia['estado'] as String;
    final tipo = asistencia['tipo'] as String;

    final isPresente = estado == 'presente';
    final statusColor = isPresente ? colors.success : colors.error;
    final statusIcon = isPresente ? Icons.check_circle : Icons.cancel;
    final statusText = isPresente ? 'Presente' : 'Ausente';

    return Card(
      margin: EdgeInsets.only(bottom: spacing.md),
      child: Padding(
        padding: EdgeInsets.all(spacing.md),
        child: Row(
          children: [
            Container(
              width: 50,
              height: 50,
              decoration: BoxDecoration(
                color: statusColor.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(spacing.borderRadius),
              ),
              child: Icon(
                statusIcon,
                color: statusColor,
                size: 28,
              ),
            ),
            SizedBox(width: spacing.md),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Text(
                        materia['nombre'] ?? 'Sin nombre',
                        style: textStyles.bodyLarge.copyWith(
                          fontWeight: FontWeight.w600,
                          color: colors.textPrimary,
                        ),
                      ),
                      const Spacer(),
                      Container(
                        padding: EdgeInsets.symmetric(horizontal: spacing.sm, vertical: 2),
                        decoration: BoxDecoration(
                          color: statusColor.withValues(alpha: 0.1),
                          borderRadius: BorderRadius.circular(spacing.borderRadius / 2),
                        ),
                        child: Text(
                          statusText,
                          style: textStyles.labelSmall.copyWith(
                            color: statusColor,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                    ],
                  ),
                  SizedBox(height: spacing.xs),
                  Text(
                    'Prof. ${profesor['nombres']} ${profesor['apellidos']}',
                    style: textStyles.bodyMedium.copyWith(color: colors.textSecondary),
                  ),
                  SizedBox(height: spacing.xs),
                  Row(
                    children: [
                      Icon(
                        tipo == 'qr' ? Icons.qr_code : Icons.edit,
                        size: 16,
                        color: colors.textMuted,
                      ),
                      const SizedBox(width: 4),
                      Text(
                        '${asistencia['fecha']} â€¢ ${asistencia['hora']}',
                        style: textStyles.bodySmall.copyWith(color: colors.textMuted),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  String _getMonthName(int month) {
    const months = [
      'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
      'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'
    ];
    return months[month - 1];
  }
}
/* Fin lib\screens\student_attendance_screen.dart */

/* Inicio lib\screens\student_dashboard.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../widgets/components/index.dart';
Widget _buildMenuActionItem(
  BuildContext context, {
  required IconData icon,
  required String label,
  required String value,
  required Color color,
  required VoidCallback onTap,
  bool isFirst = false,
  bool isLast = false,
}) {
  final textStyles = context.textStyles;
  final spacing = context.spacing;
  final colors = context.colors;

  return Material(
    color: Colors.transparent,
    child: InkWell(
      onTap: onTap,
      child: Padding(
        padding: EdgeInsets.symmetric(
          horizontal: spacing.lg,
          vertical: spacing.sm,
        ),
        child: Row(
          children: [
              Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: color.withValues(alpha: 0.12),
                  borderRadius: BorderRadius.circular(8),
                ),
              child: Icon(icon, color: color, size: 20),
            ),
            SizedBox(width: spacing.md),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    label,
                    style: textStyles.bodyMedium.copyWith(
                      fontWeight: FontWeight.w600,
                      color: colors.textPrimary,
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  Text(
                    value,
                    style: textStyles.bodySmall.copyWith(
                      color: color,
                      fontWeight: FontWeight.w500,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
              ),
            ),
            Icon(
              Icons.arrow_forward_ios_rounded,
              size: 16,
              color: colors.textSecondary,
            ),
          ],
        ),
      ),
    ),
  );
}

class StudentDashboard extends StatelessWidget {
  const StudentDashboard({super.key});

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    final user = authProvider.user;
    final userName = user?['nombres'] ?? 'Usuario';

    return SingleChildScrollView(
      padding: EdgeInsets.all(spacing.lg),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
            Text('Â¡Hola, $userName!', style: textStyles.displayMedium, maxLines: 1, overflow: TextOverflow.ellipsis),
            SizedBox(height: spacing.sm),
            Text(
              'Bienvenido al panel estudiantil.',
              style: textStyles.bodyLarge.copyWith(color: colors.textSecondary),
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
            ),
            SizedBox(height: spacing.xl),
            _buildCompactStatsBar(context),

            SizedBox(height: spacing.xl),
            Text('Acciones Principales', style: textStyles.headlineSmall),
            SizedBox(height: spacing.md),
            Container(
              decoration: BoxDecoration(
                color: colors.surface,
                borderRadius: BorderRadius.circular(spacing.borderRadius),
                border: Border.all(color: colors.borderLight),
              ),
              child: Column(
                children: [
                  _buildMenuActionItem(
                    context,
                    icon: Icons.qr_code_2_rounded,
                    label: 'Mi CÃ³digo QR',
                    value: 'Para registrar asistencia',
                    color: colors.primary,
                    onTap: () => context.go('/student/qr'),
                    isFirst: true,
                  ),
                  Divider(height: 0, indent: spacing.lg, endIndent: spacing.lg),
                  _buildMenuActionItem(
                    context,
                    icon: Icons.calendar_today_outlined,
                    label: 'Mi Horario',
                    value: 'Ver mis clases',
                    color: const Color(0xFF06B6D4),
                    onTap: () => context.go('/student/schedule'),
                  ),
                  Divider(height: 0, indent: spacing.lg, endIndent: spacing.lg),
                  _buildMenuActionItem(
                    context,
                    icon: Icons.check_circle_outline_rounded,
                    label: 'Mi Asistencia',
                    value: 'Historial y estadÃ­sticas',
                    color: colors.success,
                    onTap: () => context.go('/student/attendance'),
                  ),
                  Divider(height: 0, indent: spacing.lg, endIndent: spacing.lg),
                  _buildMenuActionItem(
                    context,
                    icon: Icons.notifications_outlined,
                    label: 'Notificaciones',
                    value: 'Ver mensajes',
                    color: colors.warning,
                    onTap: () => context.go('/student/notifications'),
                    isLast: true,
                  ),
                ],
              ),
            ),
          ],
        ),
      );
  }
  Widget _buildCompactStatsBar(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;

    return Container(
      padding: EdgeInsets.symmetric(horizontal: spacing.sm, vertical: spacing.md),
      decoration: BoxDecoration(
        color: colors.surface,
        borderRadius: BorderRadius.circular(spacing.borderRadius),
        border: Border.all(color: colors.borderLight),
      ),
      child: SingleChildScrollView
        scrollDirection: Axis.horizontal,
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceAround,
          children: [
            ClarityCompactStat(
              value: '85%', // Placeholder - se puede conectar a datos reales
              title: 'Asistencia',
              icon: Icons.check_circle,
              color: colors.success,
            ),
            SizedBox(width: spacing.lg),
            ClarityCompactStat(
              value: '4.2', // Placeholder - se puede conectar a datos reales
              title: 'Promedio',
              icon: Icons.grade,
              color: colors.primary,
            ),
            SizedBox(width: spacing.lg),
            ClarityCompactStat(
              value: '12', // Placeholder - se puede conectar a datos reales
              title: 'Materias',
              icon: Icons.book,
              color: colors.info,
            ),
          ],
        ),
      ),
    );
  }
}
/* Fin lib\screens\student_dashboard.dart */

/* Inicio lib\screens\student_notifications_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';

class StudentNotificationsScreen extends StatefulWidget {
  const StudentNotificationsScreen({super.key});

  @override
  State<StudentNotificationsScreen> createState() => _StudentNotificationsScreenState();
}

class _StudentNotificationsScreenState extends State<StudentNotificationsScreen> {
  bool _isLoading = true;
  List<Map<String, dynamic>> _notificaciones = [];
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
    _loadNotificaciones();
  }

  Future<void> _loadNotificaciones() async {
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final token = authProvider.accessToken;

      if (token == null) {
        setState(() {
          _errorMessage = 'No se pudo obtener el token de autenticaciÃ³n';
          _isLoading = false;
        });
        return;
      }
      await Future.delayed(const Duration(seconds: 1))

      setState(() {
        _notificaciones = [
          {
            'id': '1',
            'titulo': 'Nueva tarea de MatemÃ¡ticas',
            'mensaje': 'Se ha asignado una nueva tarea: "Ecuaciones cuadrÃ¡ticas". Fecha lÃ­mite: 20/01/2024',
            'tipo': 'tarea',
            'fecha': '2024-01-15T10:30:00Z',
            'leida': false,
            'importante': true,
          },
          {
            'id': '2',
            'titulo': 'Cambio de horario',
            'mensaje': 'La clase de FÃ­sica del martes ha sido cambiada a las 14:00',
            'tipo': 'horario',
            'fecha': '2024-01-14T16:45:00Z',
            'leida': true,
            'importante': false,
          },
          {
            'id': '3',
            'titulo': 'Recordatorio de asistencia',
            'mensaje': 'No olvides marcar tu asistencia al inicio de cada clase',
            'tipo': 'recordatorio',
            'fecha': '2024-01-13T08:00:00Z',
            'leida': true,
            'importante': false,
          },
          {
            'id': '4',
            'titulo': 'Anuncio importante',
            'mensaje': 'MaÃ±ana no habrÃ¡ clases debido a mantenimiento del edificio',
            'tipo': 'anuncio',
            'fecha': '2024-01-12T12:00:00Z',
            'leida': false,
            'importante': true,
          },
        ];
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _errorMessage = 'Error al cargar notificaciones: $e';
        _isLoading = false;
      });
    }
  }

  Future<void> _markAsRead(String id) async {
    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final token = authProvider.accessToken;

      if (token == null) return;
      setState(() {
        final index = _notificaciones.indexWhere((n) => n['id'] == id);
        if (index != -1) {
          _notificaciones[index]['leida'] = true;
        }
      });
    } catch (e) {
    }
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final textStyles = context.textStyles;

    return Scaffold(
      appBar: AppBar(
        title: Text('Notificaciones', style: textStyles.headlineMedium),
        backgroundColor: colors.surface,
        foregroundColor: colors.textPrimary,
        elevation: 0,
        actions: [
          IconButton(
            icon: const Icon(Icons.mark_email_read),
            onPressed: _markAllAsRead,
          ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _errorMessage != null
              ? _buildErrorState()
              : _buildNotificationsContent(),
    );
  }

  void _markAllAsRead() {
    setState(() {
      for (final notif in _notificaciones) {
        notif['leida'] = true;
      }
    });
  }

  Widget _buildErrorState() {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.notifications_off, size: 64, color: colors.error),
          SizedBox(height: spacing.lg),
          Text(
            'Error al cargar notificaciones',
            style: textStyles.headlineSmall.copyWith(color: colors.error),
          ),
          SizedBox(height: spacing.sm),
          Text(
            _errorMessage ?? 'OcurriÃ³ un error desconocido',
            style: textStyles.bodyMedium.copyWith(color: colors.textSecondary),
            textAlign: TextAlign.center,
          ),
          SizedBox(height: spacing.xl),
          ElevatedButton.icon(
            onPressed: _loadNotificaciones,
            icon: const Icon(Icons.refresh),
            label: const Text('Reintentar'),
          ),
        ],
      ),
    );
  }

  Widget _buildNotificationsContent() {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    if (_notificaciones.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.notifications_none, size: 64, color: colors.textMuted),
            SizedBox(height: spacing.lg),
            Text(
              'No tienes notificaciones',
              style: textStyles.headlineSmall.copyWith(color: colors.textSecondary),
            ),
            SizedBox(height: spacing.sm),
            Text(
              'Las notificaciones aparecerÃ¡n aquÃ­ cuando tengas mensajes nuevos',
              style: textStyles.bodyMedium.copyWith(color: colors.textMuted),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      );
    }

    final unreadCount = _notificaciones.where((n) => !(n['leida'] as bool)).length;

    return RefreshIndicator(
      onRefresh: _loadNotificaciones,
      child: ListView(
        padding: EdgeInsets.all(spacing.lg),
        children: [
          if (unreadCount > 0)
            Container(
              padding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
              decoration: BoxDecoration(
                color: colors.primary.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(spacing.borderRadius),
              ),
              child: Text(
                '$unreadCount notificaciÃ³n${unreadCount != 1 ? 'es' : ''} sin leer',
                style: textStyles.labelLarge.copyWith(
                  color: colors.primary,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          if (unreadCount > 0) SizedBox(height: spacing.lg),

          ..._notificaciones.map((notif) => _buildNotificationCard(notif)),
        ],
      ),
    );
  }

  Widget _buildNotificationCard(Map<String, dynamic> notificacion) {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    final leida = notificacion['leida'] as bool;
    final importante = notificacion['importante'] as bool;
    final tipo = notificacion['tipo'] as String;

    return Dismissible(
      key: Key(notificacion['id']),
      direction: DismissDirection.endToStart,
      background: Container(
        alignment: Alignment.centerRight,
        padding: EdgeInsets.only(right: spacing.lg),
        decoration: BoxDecoration(
          color: colors.error,
          borderRadius: BorderRadius.circular(spacing.borderRadius),
        ),
        child: const Icon(
          Icons.delete,
          color: Colors.white,
        ),
      ),
      onDismissed: (direction) {
        setState(() {
          _notificaciones.removeWhere((n) => n['id'] == notificacion['id']);
        });
      },
      child: Card(
        margin: EdgeInsets.only(bottom: spacing.md),
        color: leida ? colors.surface : colors.primary.withValues(alpha: 0.05),
        child: InkWell(
          onTap: () => _markAsRead(notificacion['id']),
          child: Padding(
            padding: EdgeInsets.all(spacing.md),
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Container(
                  width: 40,
                  height: 40,
                  decoration: BoxDecoration(
                    color: _getNotificationColor(tipo, colors).withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(spacing.borderRadius),
                  ),
                  child: Icon(
                    _getNotificationIcon(tipo),
                    color: _getNotificationColor(tipo, colors),
                    size: 20,
                  ),
                ),
                SizedBox(width: spacing.md),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          Expanded(
                            child: Text(
                              notificacion['titulo'],
                              style: textStyles.bodyLarge.copyWith(
                                fontWeight: FontWeight.w600,
                                color: colors.textPrimary,
                              ),
                            ),
                          ),
                          if (importante)
                            Container(
                              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                              decoration: BoxDecoration(
                                color: colors.error.withValues(alpha: 0.1),
                                borderRadius: BorderRadius.circular(10),
                              ),
                              child: Text(
                                '!',
                                style: textStyles.labelSmall.copyWith(
                                  color: colors.error,
                                  fontWeight: FontWeight.w700,
                                ),
                              ),
                            ),
                          if (!leida)
                            Container(
                              width: 8,
                              height: 8,
                              decoration: BoxDecoration(
                                color: colors.primary,
                                shape: BoxShape.circle,
                              ),
                            ),
                        ],
                      ),
                      SizedBox(height: spacing.xs),
                      Text(
                        notificacion['mensaje'],
                        style: textStyles.bodyMedium.copyWith(
                          color: colors.textSecondary,
                          height: 1.4,
                        ),
                      ),
                      SizedBox(height: spacing.sm),
                      Text(
                        _formatDate(notificacion['fecha']),
                        style: textStyles.bodySmall.copyWith(color: colors.textMuted),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Color _getNotificationColor(String tipo, dynamic colors) {
    switch (tipo) {
      case 'tarea': return colors.primary;
      case 'horario': return colors.warning;
      case 'recordatorio': return colors.info;
      case 'anuncio': return colors.success;
      default: return colors.textSecondary;
    }
  }

  IconData _getNotificationIcon(String tipo) {
    switch (tipo) {
      case 'tarea': return Icons.assignment;
      case 'horario': return Icons.schedule;
      case 'recordatorio': return Icons.notifications;
      case 'anuncio': return Icons.campaign;
      default: return Icons.notifications_none;
    }
  }

  String _formatDate(String dateString) {
    try {
      final date = DateTime.parse(dateString);
      final now = DateTime.now();
      final difference = now.difference(date);

      if (difference.inDays == 0) {
        return 'Hoy ${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}';
      } else if (difference.inDays == 1) {
        return 'Ayer ${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}';
      } else if (difference.inDays < 7) {
        return '${difference.inDays} dÃ­as atrÃ¡s';
      } else {
        return '${date.day.toString().padLeft(2, '0')}/${date.month.toString().padLeft(2, '0')}/${date.year}';
      }
    } catch (e) {
      return dateString;
    }
  }
}
/* Fin lib\screens\student_notifications_screen.dart */

/* Inicio lib\screens\student_schedule_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';

class StudentScheduleScreen extends StatefulWidget {
  const StudentScheduleScreen({super.key});

  @override
  State<StudentScheduleScreen> createState() => _StudentScheduleScreenState();
}

class _StudentScheduleScreenState extends State<StudentScheduleScreen> {
  bool _isLoading = true;
  List<Map<String, dynamic>> _horarios = [];
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
    _loadHorarios();
  }

  Future<void> _loadHorarios() async {
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final token = authProvider.accessToken;

      if (token == null) {
        setState(() {
          _errorMessage = 'No se pudo obtener el token de autenticaciÃ³n';
          _isLoading = false;
        });
        return;
      }
      await Future.delayed(const Duration(seconds: 1))

      setState(() {
        _horarios = [
          {
            'diaSemana': 1,
            'horaInicio': '07:00',
            'horaFin': '08:00',
            'materia': {'nombre': 'MatemÃ¡ticas'},
            'profesor': {'nombres': 'Juan', 'apellidos': 'PÃ©rez'},
            'grupo': {'nombre': 'DÃ©cimo A'},
          },
          {
            'diaSemana': 1,
            'horaInicio': '08:00',
            'horaFin': '09:00',
            'materia': {'nombre': 'FÃ­sica'},
            'profesor': {'nombres': 'Laura', 'apellidos': 'GÃ³mez'},
            'grupo': {'nombre': 'DÃ©cimo A'},
          },
          {
            'diaSemana': 2,
            'horaInicio': '07:00',
            'horaFin': '08:00',
            'materia': {'nombre': 'QuÃ­mica'},
            'profesor': {'nombres': 'Laura', 'apellidos': 'GÃ³mez'},
            'grupo': {'nombre': 'DÃ©cimo A'},
          },
        ];
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _errorMessage = 'Error al cargar el horario: $e';
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final textStyles = context.textStyles;

    return Scaffold(
      appBar: AppBar(
        title: Text('Mi Horario', style: textStyles.headlineMedium),
        backgroundColor: colors.surface,
        foregroundColor: colors.textPrimary,
        elevation: 0,
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _errorMessage != null
              ? _buildErrorState()
              : _buildScheduleContent(),
    );
  }

  Widget _buildErrorState() {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.error_outline, size: 64, color: colors.error),
          SizedBox(height: spacing.lg),
          Text(
            'Error al cargar horario',
            style: textStyles.headlineSmall.copyWith(color: colors.error),
          ),
          SizedBox(height: spacing.sm),
          Text(
            _errorMessage ?? 'OcurriÃ³ un error desconocido',
            style: textStyles.bodyMedium.copyWith(color: colors.textSecondary),
            textAlign: TextAlign.center,
          ),
          SizedBox(height: spacing.xl),
          ElevatedButton.icon(
            onPressed: _loadHorarios,
            icon: const Icon(Icons.refresh),
            label: const Text('Reintentar'),
          ),
        ],
      ),
    );
  }

  Widget _buildScheduleContent() {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    if (_horarios.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.calendar_today_outlined, size: 64, color: colors.textMuted),
            SizedBox(height: spacing.lg),
            Text(
              'No tienes clases programadas',
              style: textStyles.headlineSmall.copyWith(color: colors.textSecondary),
            ),
            SizedBox(height: spacing.sm),
            Text(
              'Tu horario aparecerÃ¡ aquÃ­ cuando tengas clases asignadas',
              style: textStyles.bodyMedium.copyWith(color: colors.textMuted),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      );
    }
    final horariosPorDia = <int, List<Map<String, dynamic>>>{};
    for (final horario in _horarios) {
      final dia = horario['diaSemana'] as int;
      horariosPorDia.putIfAbsent(dia, () => []).add(horario);
    }

    return RefreshIndicator(
      onRefresh: _loadHorarios,
      child: ListView.builder(
        padding: EdgeInsets.all(spacing.lg),
        itemCount: horariosPorDia.length,
        itemBuilder: (context, index) {
          final dia = horariosPorDia.keys.elementAt(index);
          final horariosDelDia = horariosPorDia[dia]!;
          return _buildDiaSchedule(dia, horariosDelDia);
        },
      ),
    );
  }

  Widget _buildDiaSchedule(int diaSemana, List<Map<String, dynamic>> horarios) {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    final nombreDia = _getNombreDia(diaSemana);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          padding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
          decoration: BoxDecoration(
            color: colors.primary.withValues(alpha: 0.1),
            borderRadius: BorderRadius.circular(spacing.borderRadius),
          ),
          child: Text(
            nombreDia,
            style: textStyles.labelLarge.copyWith(
              color: colors.primary,
              fontWeight: FontWeight.w600,
            ),
          ),
        ),
        SizedBox(height: spacing.md),
        ...horarios.map((horario) => _buildHorarioCard(horario)),
        SizedBox(height: spacing.xl),
      ],
    );
  }

  Widget _buildHorarioCard(Map<String, dynamic> horario) {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    final materia = horario['materia'] as Map<String, dynamic>;
    final profesor = horario['profesor'] as Map<String, dynamic>;
    final grupo = horario['grupo'] as Map<String, dynamic>;

    return Card(
      margin: EdgeInsets.only(bottom: spacing.md),
      child: Padding(
        padding: EdgeInsets.all(spacing.md),
        child: Row(
          children: [
            Container(
              width: 60,
              height: 60,
              decoration: BoxDecoration(
                color: colors.primary.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(spacing.borderRadius),
              ),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text(
                    horario['horaInicio'],
                    style: textStyles.labelMedium.copyWith(
                      color: colors.primary,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  Text(
                    '-',
                    style: textStyles.bodySmall.copyWith(color: colors.primary),
                  ),
                  Text(
                    horario['horaFin'],
                    style: textStyles.labelMedium.copyWith(
                      color: colors.primary,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ],
              ),
            ),
            SizedBox(width: spacing.md),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    materia['nombre'] ?? 'Sin nombre',
                    style: textStyles.bodyLarge.copyWith(
                      fontWeight: FontWeight.w600,
                      color: colors.textPrimary,
                    ),
                  ),
                  SizedBox(height: spacing.xs),
                  Text(
                    'Prof. ${profesor['nombres']} ${profesor['apellidos']}',
                    style: textStyles.bodyMedium.copyWith(color: colors.textSecondary),
                  ),
                  SizedBox(height: spacing.xs),
                  Text(
                    grupo['nombre'] ?? 'Sin grupo',
                    style: textStyles.bodySmall.copyWith(color: colors.textMuted),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  String _getNombreDia(int diaSemana) {
    switch (diaSemana) {
      case 1: return 'Lunes';
      case 2: return 'Martes';
      case 3: return 'MiÃ©rcoles';
      case 4: return 'Jueves';
      case 5: return 'Viernes';
      case 6: return 'SÃ¡bado';
      case 7: return 'Domingo';
      default: return 'DÃ­a $diaSemana';
    }
  }
}
/* Fin lib\screens\student_schedule_screen.dart */

/* Inicio lib\screens\super_admin_dashboard.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../providers/institution_provider.dart';
import '../providers/user_provider.dart';
import '../theme/theme_extensions.dart';
import '../widgets/components/index.dart';

class SuperAdminDashboard extends StatefulWidget {
  const SuperAdminDashboard({super.key});

  @override
  State<SuperAdminDashboard> createState() => _SuperAdminDashboardState();
}

class _SuperAdminDashboardState extends State<SuperAdminDashboard> {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      try {
        final authProvider = Provider.of<AuthProvider>(context, listen: false);
        final userProvider = Provider.of<UserProvider>(context, listen: false);
        final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);

        final token = authProvider.accessToken;
        if (token != null) {
          await userProvider.loadUsers(token);
          await institutionProvider.loadInstitutions(token);
        }
      } catch (e) {
        debugPrint('SuperAdminDashboard init load error: $e');
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final institutionProvider = Provider.of<InstitutionProvider>(context);
    final userProvider = Provider.of<UserProvider>(context, listen: false);

    final user = authProvider.user;
    final userName = user?['nombres'] ?? 'Usuario';

    return LayoutBuilder(
      builder: (context, constraints) {
          final isDesktop = constraints.maxWidth > 1024;
          final isTablet = constraints.maxWidth > 600;
          final columnCount = isDesktop ? 4 : (isTablet ? 3 : 2);
          return isDesktop
              ? _buildDesktopLayout(
                  context,
                  userName,
                  institutionProvider,
                  userProvider,
                  columnCount,
                )
              : _buildMobileLayout(
                  context,
                  userName,
                  institutionProvider,
                  userProvider,
                  columnCount,
                );
        },
    );
  }
  Widget _buildDesktopLayout(
    BuildContext context,
    String userName,
    InstitutionProvider institutionProvider,
    UserProvider userProvider,
    int columnCount,
  ) {
    final spacing = context.spacing;

    return SingleChildScrollView(
      child: Padding(
        padding: EdgeInsets.all(spacing.screenPadding),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Expanded(
              flex: 70,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  _buildGreeting(context, userName),
                  SizedBox(height: spacing.xl),
                  _buildKPIRow(context, institutionProvider, userProvider),
                  SizedBox(height: spacing.xl),
                  _buildActionsGrid(context, columnCount),
                ],
              ),
            ),
            SizedBox(width: spacing.lg),
          ],
        ),
      ),
    );
  }
  Widget _buildMobileLayout(
    BuildContext context,
    String userName,
    InstitutionProvider institutionProvider,
    UserProvider userProvider,
    int columnCount,
  ) {
    final spacing = context.spacing;

    return SingleChildScrollView(
      padding: EdgeInsets.all(spacing.screenPadding),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildGreeting(context, userName),
          SizedBox(height: spacing.xl),
          _buildKPIRow(context, institutionProvider, userProvider),
          SizedBox(height: spacing.xl),
          _buildActionsGrid(context, columnCount),
        ],
      ),
    );
  }
  Widget _buildGreeting(BuildContext context, String userName) {
    final textStyles = context.textStyles;
    final colors = context.colors;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Â¡Hola, $userName!',
          style: textStyles.headlineMedium.copyWith(
            fontWeight: FontWeight.w700,
          ),
        ),
        SizedBox(height: context.spacing.sm),
        Text(
          'Bienvenido al panel de administraciÃ³n del sistema.',
          style: textStyles.bodyLarge.copyWith(color: colors.textSecondary),
        ),
      ],
    );
  }
  Widget _buildKPIRow(
    BuildContext context,
    InstitutionProvider institutionProvider,
    UserProvider userProvider,
  ) {
    final spacing = context.spacing;

    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      child: Row(
        children: [
          ClarityCompactStat(
            value: (institutionProvider.paginationInfo?.total ?? 0).toString(),
            title: 'Instituciones',
            icon: Icons.business,
            color: context.colors.primary,
          ),
          SizedBox(width: spacing.lg),
          ClarityCompactStat(
            value: userProvider.totalUsersFromPagination.toString(),
            title: 'Usuarios',
            icon: Icons.people,
            color: context.colors.info,
          ),
          SizedBox(width: spacing.lg),
          ClarityCompactStat(
            value: '3',
            title: 'Reportes',
            icon: Icons.analytics,
            color: context.colors.warning,
          ),
        ],
      ),
    );
  }
  Widget _buildActionsGrid(BuildContext context, int columnCount) {
    final spacing = context.spacing;

    final colors = context.colors;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Acciones Principales',
          style: context.textStyles.headlineSmall,
        ),
        SizedBox(height: spacing.md),
        Container(
          decoration: BoxDecoration(
            color: colors.surface,
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            border: Border.all(color: colors.borderLight),
          ),
          child: Column(
            children: [
              _buildMenuActionItem(
                context,
                icon: Icons.business_rounded,
                label: 'Instituciones',
                value: 'GestiÃ³n Total',
                color: colors.primary,
                onTap: () => context.go('/institutions'),
                isFirst: true,
              ),
              Divider(height: 0, indent: spacing.lg, endIndent: spacing.lg),
              _buildMenuActionItem(
                context,
                icon: Icons.people_alt_rounded,
                label: 'Usuarios',
                value: 'Admins y Super Admins',
                color: colors.info,
                onTap: () => context.go('/users'),
              ),
              Divider(height: 0, indent: spacing.lg, endIndent: spacing.lg),
              _buildMenuActionItem(
                context,
                icon: Icons.schedule_rounded,
                label: 'Prueba Multi-Hora',
                value: 'Validar Horarios',
                color: const Color(0xFF10B981),
                onTap: () => context.go('/test-multi-hora'),
              ),
              Divider(height: 0, indent: spacing.lg, endIndent: spacing.lg),
              Divider(height: 0, indent: spacing.lg, endIndent: spacing.lg),
              _buildMenuActionItem(
                context,
                icon: Icons.settings_outlined,
                label: 'Ajustes',
                value: 'Sistema',
                color: const Color(0xFF8B5CF6),
                onTap: () {},
                isLast: true,
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildMenuActionItem(
    BuildContext context, {
    required IconData icon,
    required String label,
    required String value,
    required Color color,
    required VoidCallback onTap,
    bool isFirst = false,
    bool isLast = false,
  }) {
    final textStyles = context.textStyles;
    final spacing = context.spacing;
    final colors = context.colors;

    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: EdgeInsets.symmetric(
            horizontal: spacing.lg,
            vertical: spacing.sm,
          ),
          child: Row(
            children: [
              Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: color.withValues(alpha: 0.12),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Icon(icon, color: color, size: 20),
              ),
              SizedBox(width: spacing.md),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      label,
                      style: textStyles.bodyMedium.copyWith(
                        fontWeight: FontWeight.w600,
                        color: colors.textPrimary,
                      ),
                    ),
                    Text(
                      value,
                      style: textStyles.bodySmall.copyWith(
                        color: color,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ],
                ),
              ),
              Icon(
                Icons.arrow_forward_ios_rounded,
                size: 16,
                color: colors.textSecondary,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
/* Fin lib\screens\super_admin_dashboard.dart */

/* Inicio lib\screens\teacher_dashboard.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../providers/horario_provider.dart';
import '../theme/theme_extensions.dart';
import '../widgets/components/index.dart';
import '../models/clase_del_dia.dart';

class TeacherDashboard extends StatefulWidget {
  const TeacherDashboard({super.key});

  @override
  State<TeacherDashboard> createState() => _TeacherDashboardState();
}

class _TeacherDashboardState extends State<TeacherDashboard> with TickerProviderStateMixin {
  late AnimationController _fadeController;
  late Animation<double> _fadeAnimation;

  @override
  void initState() {
    super.initState();
    _fadeController = AnimationController(
      duration: const Duration(milliseconds: 800),
      vsync: this,
    );
    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _fadeController, curve: Curves.easeOut),
    );

    WidgetsBinding.instance.addPostFrameCallback((_) async {
      try {
        final authProvider = Provider.of<AuthProvider>(context, listen: false);
        final horarioProvider = Provider.of<HorarioProvider>(context, listen: false);

        final token = authProvider.accessToken;
        if (token != null) {
          await horarioProvider.cargarClasesDelDia(token);
          _fadeController.forward();
        }
      } catch (e) {
        debugPrint('TeacherDashboard init load error: $e');
      }
    });
  }

  @override
  void dispose() {
    _fadeController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final horarioProvider = Provider.of<HorarioProvider>(context);
    final colors = context.colors;
    final spacing = context.spacing;

    final user = authProvider.user;
    final userName = user?['nombres'] ?? 'Profesor';

    return Scaffold(
      backgroundColor: colors.background,
      body: RefreshIndicator(
        onRefresh: () async {
          final token = authProvider.accessToken;
          if (token != null) {
            await horarioProvider.cargarClasesDelDia(token);
          }
        },
        child: SingleChildScrollView(
          physics: const AlwaysScrollableScrollPhysics(),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildHeader(context, userName),

              SizedBox(height: spacing.xl),
              _buildStatsSection(context, horarioProvider),

              SizedBox(height: spacing.xl),
              _buildClasesSection(context, horarioProvider),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildHeader(BuildContext context, String userName) {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return Container(
      padding: EdgeInsets.all(spacing.xl),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: [
            colors.primary,
            colors.primary.withValues(alpha: 0.8),
            colors.secondary.withValues(alpha: 0.6),
          ],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.only(
          bottomLeft: Radius.circular(spacing.xl),
          bottomRight: Radius.circular(spacing.xl),
        ),
      ),
      child: SafeArea(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Container(
                  padding: EdgeInsets.all(spacing.md),
                  decoration: BoxDecoration(
                    color: colors.white.withValues(alpha: 0.2),
                    borderRadius: BorderRadius.circular(spacing.borderRadiusLarge),
                  ),
                  child: Icon(
                    Icons.school,
                    color: colors.white,
                    size: 32,
                  ),
                ),
                SizedBox(width: spacing.lg),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'Â¡Hola, $userName!',
                        style: textStyles.displayMedium.copyWith(
                          color: colors.white,
                          fontWeight: FontWeight.bold,
                        ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                      SizedBox(height: spacing.xs),
                      Text(
                        'Bienvenido a tu panel docente',
                        style: textStyles.bodyLarge.copyWith(
                          color: colors.white.withValues(alpha: 0.9),
                        ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ],
                  ),
                ),
              ],
            ),
            SizedBox(height: spacing.lg),
            Container(
              padding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
              decoration: BoxDecoration(
                color: colors.white.withValues(alpha: 0.15),
                borderRadius: BorderRadius.circular(spacing.borderRadius),
              ),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Icon(
                    Icons.calendar_today,
                    color: colors.white,
                    size: 18,
                  ),
                  SizedBox(width: spacing.sm),
                  Flexible(
                    child: Text(
                      _getCurrentDate(),
                      style: textStyles.bodyMedium.copyWith(
                        color: colors.white,
                        fontWeight: FontWeight.w500,
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildStatsSection(BuildContext context, HorarioProvider horarioProvider) {
    final colors = context.colors;
    final spacing = context.spacing;

    return Padding(
      padding: EdgeInsets.symmetric(horizontal: spacing.lg),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Resumen del DÃ­a',
            style: context.textStyles.headlineMedium.copyWith(
              fontWeight: FontWeight.bold,
              color: colors.textPrimary,
            ),
          ),
          SizedBox(height: spacing.md),
          LayoutBuilder(
            builder: (context, constraints) {
              if (constraints.maxWidth < 400) {
                return Column(
                  children: [
                    ClarityKPICard(
                      value: horarioProvider.clasesDelDiaCount.toString(),
                      label: 'Clases Hoy',
                      icon: Icons.class_,
                      iconColor: colors.primary,
                      backgroundColor: colors.primary.withValues(alpha: 0.05),
                    ),
                    SizedBox(height: spacing.md),
                    ClarityKPICard(
                      value: _calculateTotalStudents(horarioProvider).toString(),
                      label: 'Estudiantes',
                      icon: Icons.people,
                      iconColor: colors.info,
                      backgroundColor: colors.info.withValues(alpha: 0.05),
                    ),
                    SizedBox(height: spacing.md),
                    ClarityKPICard(
                      value: '95%', // TODO: Calcular asistencia real
                      label: 'Asistencia Promedio',
                      icon: Icons.check_circle,
                      iconColor: colors.success,
                      backgroundColor: colors.success.withValues(alpha: 0.05),
                    ),
                  ],
                );
              } else {
                return Row(
                  children: [
                    Expanded(
                      child: ClarityKPICard(
                        value: horarioProvider.clasesDelDiaCount.toString(),
                        label: 'Clases Hoy',
                        icon: Icons.class_,
                        iconColor: colors.primary,
                        backgroundColor: colors.primary.withValues(alpha: 0.05),
                      ),
                    ),
                    SizedBox(width: spacing.md),
                    Expanded(
                      child: ClarityKPICard(
                        value: _calculateTotalStudents(horarioProvider).toString(),
                        label: 'Estudiantes',
                        icon: Icons.people,
                        iconColor: colors.info,
                        backgroundColor: colors.info.withValues(alpha: 0.05),
                      ),
                    ),
                    SizedBox(width: spacing.md),
                    Expanded(
                      child: ClarityKPICard(
                        value: '95%', // TODO: Calcular asistencia real
                        label: 'Asistencia Promedio',
                        icon: Icons.check_circle,
                        iconColor: colors.success,
                        backgroundColor: colors.success.withValues(alpha: 0.05),
                      ),
                    ),
                  ],
                );
              }
            },
          ),
        ],
      ),
    );
  }

  Widget _buildClasesSection(BuildContext context, HorarioProvider horarioProvider) {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return Padding(
      padding: EdgeInsets.symmetric(horizontal: spacing.lg),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Expanded(
                child: Text(
                  'Mis Clases de Hoy',
                  style: textStyles.headlineMedium.copyWith(
                    fontWeight: FontWeight.bold,
                    color: colors.textPrimary,
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
              IconButton(
                onPressed: () async {
                  final authProvider = Provider.of<AuthProvider>(context, listen: false);
                  final token = authProvider.accessToken;
                  if (token != null) {
                    await horarioProvider.cargarClasesDelDia(token);
                  }
                },
                icon: Icon(Icons.refresh, color: colors.primary),
                tooltip: 'Actualizar',
              ),
            ],
          ),
          SizedBox(height: spacing.md),

          if (horarioProvider.isLoading)
            const Center(child: CircularProgressIndicator())
          else if (horarioProvider.clasesDelDia.isEmpty)
            _buildEmptyState(context)
          else
            FadeTransition(
              opacity: _fadeAnimation,
              child: _buildClasesList(context, horarioProvider.getClasesDelDiaOrdenadas()),
            ),
        ],
      ),
    );
  }

  Widget _buildEmptyState(BuildContext context) {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return Container(
      padding: EdgeInsets.all(spacing.xl),
      decoration: BoxDecoration(
        color: colors.surface,
        borderRadius: BorderRadius.circular(spacing.borderRadiusLarge),
        border: Border.all(color: colors.borderLight),
      ),
      child: Column(
        children: [
          Container(
            padding: EdgeInsets.all(spacing.lg),
            decoration: BoxDecoration(
              color: colors.primary.withValues(alpha: 0.1),
              shape: BoxShape.circle,
            ),
            child: Icon(
              Icons.event_available,
              size: 48,
              color: colors.primary,
            ),
          ),
          SizedBox(height: spacing.lg),
          Text(
            'Â¡DÃ­a Libre!',
            style: textStyles.headlineMedium.copyWith(
              color: colors.textPrimary,
              fontWeight: FontWeight.bold,
            ),
            textAlign: TextAlign.center,
          ),
          SizedBox(height: spacing.sm),
          Text(
            'No tienes clases programadas para hoy.\nÂ¡Disfruta tu tiempo libre!',
            style: textStyles.bodyLarge.copyWith(
              color: colors.textSecondary,
            ),
            textAlign: TextAlign.center,
          ),
          SizedBox(height: spacing.lg),
          OutlinedButton.icon(
            onPressed: () {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Horario semanal prÃ³ximamente')),
              );
            },
            icon: const Icon(Icons.calendar_view_week),
            label: const Text('Ver Horario Semanal'),
            style: OutlinedButton.styleFrom(
              padding: EdgeInsets.symmetric(horizontal: spacing.lg, vertical: spacing.md),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildClasesList(BuildContext context, List<ClaseDelDia> clases) {
    return ListView.builder(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      itemCount: clases.length,
      itemBuilder: (context, index) {
        final clase = clases[index];
        return Padding(
          padding: EdgeInsets.only(bottom: context.spacing.md),
          child: ClaseCardPro(clase: clase, index: index),
        );
      },
    );
  }

  String _getCurrentDate() {
    final now = DateTime.now();
    final dias = ['Domingo', 'Lunes', 'Martes', 'MiÃ©rcoles', 'Jueves', 'Viernes', 'SÃ¡bado'];
    final meses = ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio',
                   'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'];

    return '${dias[now.weekday % 7]} ${now.day} de ${meses[now.month - 1]}';
  }

  int _calculateTotalStudents(HorarioProvider horarioProvider) {
    return horarioProvider.clasesDelDiaCount * 25;
  }
}
class ClaseCardPro extends StatefulWidget {
  final ClaseDelDia clase;
  final int index;

  const ClaseCardPro({
    super.key,
    required this.clase,
    required this.index,
  });

  @override
  State<ClaseCardPro> createState() => _ClaseCardProState();
}

class _ClaseCardProState extends State<ClaseCardPro> with TickerProviderStateMixin {
  late AnimationController _scaleController;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _scaleController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 0.8, end: 1.0).animate(
      CurvedAnimation(parent: _scaleController, curve: Curves.elasticOut),
    );
    Future.delayed(Duration(milliseconds: widget.index * 100), () {
      if (mounted) _scaleController.forward();
    });
  }

  @override
  void dispose() {
    _scaleController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return ScaleTransition(
      scale: _scaleAnimation,
      child: Container(
        decoration: BoxDecoration(
          gradient: LinearGradient(
            colors: [
              colors.surface,
              colors.surface.withValues(alpha: 0.8),
            ],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
          borderRadius: BorderRadius.circular(spacing.borderRadiusLarge),
          border: Border.all(color: colors.borderLight, width: 1),
          boxShadow: [
            BoxShadow(
              color: colors.shadow.withValues(alpha: 0.1),
              blurRadius: 8,
              offset: const Offset(0, 4),
            ),
          ],
        ),
        child: Material(
          color: Colors.transparent,
          child: InkWell(
            onTap: () {
            },
            borderRadius: BorderRadius.circular(spacing.borderRadiusLarge),
            child: Padding(
              padding: EdgeInsets.all(spacing.lg),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Container(
                        padding: EdgeInsets.all(spacing.sm),
                        decoration: BoxDecoration(
                          color: colors.primary.withValues(alpha: 0.1),
                          borderRadius: BorderRadius.circular(spacing.borderRadius),
                        ),
                        child: Icon(
                          Icons.book,
                          color: colors.primary,
                          size: 24,
                        ),
                      ),
                      SizedBox(width: spacing.md),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              widget.clase.materia.nombre,
                              style: textStyles.headlineSmall.copyWith(
                                fontWeight: FontWeight.bold,
                                color: colors.primary,
                              ),
                              maxLines: 2,
                              overflow: TextOverflow.ellipsis,
                            ),
                            SizedBox(height: spacing.xs),
                            Text(
                              widget.clase.grupo.nombreCompleto,
                              style: textStyles.bodyMedium.copyWith(
                                color: colors.textSecondary,
                              ),
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ],
                        ),
                      ),
                      SizedBox(width: spacing.sm),
                      Container(
                        padding: EdgeInsets.symmetric(horizontal: spacing.sm, vertical: spacing.xs),
                        decoration: BoxDecoration(
                          color: colors.success.withValues(alpha: 0.1),
                          borderRadius: BorderRadius.circular(spacing.borderRadius),
                        ),
                        child: Text(
                          'Activa',
                          style: textStyles.labelSmall.copyWith(
                            color: colors.success,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      ),
                    ],
                  ),

                  SizedBox(height: spacing.lg),
                  Container(
                    padding: EdgeInsets.all(spacing.md),
                    decoration: BoxDecoration(
                      color: colors.background,
                      borderRadius: BorderRadius.circular(spacing.borderRadius),
                      border: Border.all(color: colors.borderLight),
                    ),
                    child: Row(
                      children: [
                        Icon(
                          Icons.access_time,
                          color: colors.primary,
                          size: 20,
                        ),
                        SizedBox(width: spacing.sm),
                        Text(
                          widget.clase.horarioFormato,
                          style: textStyles.bodyLarge.copyWith(
                            fontWeight: FontWeight.w600,
                            color: colors.textPrimary,
                          ),
                        ),
                        const Spacer(),
                        Flexible(
                          child: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Icon(
                                Icons.location_on,
                                color: colors.textMuted,
                                size: 18,
                              ),
                              SizedBox(width: spacing.xs),
                              Flexible(
                                child: Text(
                                  'Aula 101', // TODO: Agregar informaciÃ³n real de aula
                                  style: textStyles.bodyMedium.copyWith(
                                    color: colors.textMuted,
                                  ),
                                  maxLines: 1,
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ),

                  SizedBox(height: spacing.lg),
                  Row(
                    children: [
                      Expanded(
                        child: ElevatedButton.icon(
                          onPressed: () async {
                            context.pushNamed('teacher-attendance', extra: widget.clase);
                          },
                          icon: const Icon(Icons.qr_code_scanner),
                          label: const Text('Tomar Asistencia'),
                          style: ElevatedButton.styleFrom(
                            backgroundColor: colors.primary,
                            foregroundColor: colors.white,
                            padding: EdgeInsets.symmetric(vertical: spacing.md),
                            shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(spacing.borderRadius),
                            ),
                          ),
                        ),
                      ),
                      SizedBox(width: spacing.md),
                      SizedBox(
                        width: 48,
                        height: 48,
                        child: IconButton(
                          onPressed: () {
                            ScaffoldMessenger.of(context).showSnackBar(
                              const SnackBar(content: Text('Opciones prÃ³ximamente')),
                            );
                          },
                          icon: Icon(Icons.more_vert, color: colors.textMuted),
                          style: IconButton.styleFrom(
                            backgroundColor: colors.surface,
                            side: BorderSide(color: colors.borderLight),
                          ),
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}
/* Fin lib\screens\teacher_dashboard.dart */

/* Inicio lib\screens\test_multi_hora_screen.dart */
import 'package:flutter/material.dart';
import 'package:asistapp/widgets/test_multi_hora_widget.dart';

class TestMultiHoraScreen extends StatelessWidget {
  const TestMultiHoraScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Prueba Multi-Hora'),
        backgroundColor: Theme.of(context).primaryColor,
      ),
      body: const SingleChildScrollView(
        padding: EdgeInsets.all(16.0),
        child: TestMultiHoraWidget(),
      ),
    );
  }
}
/* Fin lib\screens\test_multi_hora_screen.dart */

/* Inicio lib\screens\test_runner_screen.dart */
import 'package:flutter/material.dart';
import '../utils/test_flow_manager.dart';
import '../theme/app_colors.dart';
import '../theme/app_text_styles.dart';
import '../theme/app_spacing.dart';
class TestRunnerScreen extends StatefulWidget {
  const TestRunnerScreen({super.key});

  @override
  State<TestRunnerScreen> createState() => _TestRunnerScreenState();
}

class _TestRunnerScreenState extends State<TestRunnerScreen> {
  bool _isRunning = false;
  String _currentStep = '';
  final List<String> _logs = [];
  final ScrollController _scrollController = ScrollController();

  void _addLog(String message) {
    setState(() {
      _logs.add('[${DateTime.now().toString().split('.')[0]}] $message');
    });
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _scrollController.animateTo(
        _scrollController.position.maxScrollExtent,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
    });
  }

  Future<void> _runFullFlow() async {
    if (_isRunning) return;

    setState(() {
      _isRunning = true;
      _logs.clear();
      _currentStep = 'Iniciando flujo completo...';
    });

    _addLog('ğŸš€ Iniciando Flujo Completo de Pruebas');

    try {
      await TestFlowManager.ejecutarFlujoCompleto(context);
      _addLog('ğŸ‰ Flujo completado exitosamente');
    } catch (e) {
      _addLog('âŒ Error en el flujo: $e');
    } finally {
      setState(() {
        _isRunning = false;
        _currentStep = '';
      });
    }
  }

  Future<void> _runUITests() async {
    if (_isRunning) return;

    setState(() {
      _isRunning = true;
      _logs.clear();
      _currentStep = 'Probando UI...';
    });

    _addLog('ğŸ¨ Iniciando Pruebas de UI');

    try {
      await TestFlowManager.ejecutarPruebasUI(context);
      _addLog('âœ… Pruebas de UI completadas');
    } catch (e) {
      _addLog('âŒ Error en pruebas UI: $e');
    } finally {
      setState(() {
        _isRunning = false;
        _currentStep = '';
      });
    }
  }

  Future<void> _runIndividualStep(String stepName, Future<void> Function() stepFunction) async {
    if (_isRunning) return;

    setState(() {
      _isRunning = true;
      _currentStep = stepName;
    });

    _addLog('ğŸ§ª Ejecutando: $stepName');

    try {
      await stepFunction();
      _addLog('âœ… $stepName completado');
    } catch (e) {
      _addLog('âŒ Error en $stepName: $e');
    } finally {
      setState(() {
        _isRunning = false;
        _currentStep = '';
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final textStyles = AppTextStyles.instance;
    final spacing = AppSpacing.instance;

    return Scaffold(
      backgroundColor: colors.background,
      appBar: AppBar(
        backgroundColor: colors.primary,
        foregroundColor: colors.white,
        title: Text(
          'Flujo de Pruebas',
          style: textStyles.headlineMedium.copyWith(color: colors.white),
        ),
        elevation: 0,
      ),
      body: Padding(
        padding: EdgeInsets.all(spacing.screenPadding),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Herramientas de Testing',
              style: textStyles.displayMedium,
            ),
            SizedBox(height: spacing.sm),
            Text(
              'Ejecuta flujos completos de pruebas para validar todas las funcionalidades de la aplicaciÃ³n.',
              style: textStyles.bodyLarge.copyWith(color: colors.textSecondary),
            ),
            SizedBox(height: spacing.xl),
            if (_currentStep.isNotEmpty)
              Container(
                padding: EdgeInsets.all(spacing.md),
                decoration: BoxDecoration(
                  color: colors.primary.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(spacing.borderRadius),
                  border: Border.all(color: colors.primary.withValues(alpha: 0.3)),
                ),
                child: Row(
                  children: [
                    SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        valueColor: AlwaysStoppedAnimation<Color>(colors.primary),
                      ),
                    ),
                    SizedBox(width: spacing.md),
                    Expanded(
                      child: Text(
                        _currentStep,
                        style: textStyles.bodyMedium.copyWith(color: colors.primary),
                      ),
                    ),
                  ],
                ),
              ),

            if (_currentStep.isNotEmpty) SizedBox(height: spacing.lg),
            Text(
              'Flujos de Prueba',
              style: textStyles.headlineSmall,
            ),
            SizedBox(height: spacing.md),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: _isRunning ? null : _runFullFlow,
                icon: Icon(_isRunning ? Icons.hourglass_top : Icons.play_arrow),
                label: Text(_isRunning ? 'Ejecutando...' : 'Ejecutar Flujo Completo'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: colors.primary,
                  foregroundColor: colors.white,
                  padding: EdgeInsets.symmetric(vertical: spacing.lg),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(spacing.borderRadius),
                  ),
                ),
              ),
            ),

            SizedBox(height: spacing.md),
            SizedBox(
              width: double.infinity,
              child: OutlinedButton.icon(
                onPressed: _isRunning ? null : _runUITests,
                icon: const Icon(Icons.visibility),
                label: const Text('Probar Solo UI'),
                style: OutlinedButton.styleFrom(
                  side: BorderSide(color: colors.primary),
                  foregroundColor: colors.primary,
                  padding: EdgeInsets.symmetric(vertical: spacing.lg),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(spacing.borderRadius),
                  ),
                ),
              ),
            ),

            SizedBox(height: spacing.xl),
            Text(
              'Pasos Individuales',
              style: textStyles.headlineSmall,
            ),
            SizedBox(height: spacing.md),

            Expanded(
              child: ListView(
                children: [
                  _buildStepButton('1. Login Super Admin', () => TestFlowManager.step1LoginSuperAdmin(context)),
                  _buildStepButton('2. Crear InstituciÃ³n', () => TestFlowManager.step2CrearInstitucion(context)),
                  _buildStepButton('3. Crear Admin InstituciÃ³n', () => TestFlowManager.step3CrearAdminInstitucion(context)),
                  _buildStepButton('4. Crear Profesores', () => TestFlowManager.step4CrearProfesores(context)),
                  _buildStepButton('5. Crear Estudiantes', () => TestFlowManager.step5CrearEstudiantes(context)),
                  _buildStepButton('6. Crear Materias', () => TestFlowManager.step6CrearMaterias(context)),
                  _buildStepButton('7. Crear Grupos', () => TestFlowManager.step7CrearGrupos(context)),
                  _buildStepButton('8. Crear Horarios', () => TestFlowManager.step8CrearHorarios(context)),
                  _buildStepButton('9. Verificar Asistencias', () => TestFlowManager.step9VerificarAsistencias(context)),
                  _buildStepButton('10. Verificar Dashboards', () => TestFlowManager.step10VerificarDashboards(context)),
                ],
              ),
            ),

            SizedBox(height: spacing.xl),
            if (_logs.isNotEmpty) ...[
              Text(
                'Logs de EjecuciÃ³n',
                style: textStyles.headlineSmall,
              ),
              SizedBox(height: spacing.md),
              Expanded(
                child: Container(
                  decoration: BoxDecoration(
                    color: colors.surface,
                    borderRadius: BorderRadius.circular(spacing.borderRadius),
                    border: Border.all(color: colors.borderLight),
                  ),
                  child: ListView.builder(
                    controller: _scrollController,
                    padding: EdgeInsets.all(spacing.md),
                    itemCount: _logs.length,
                    itemBuilder: (context, index) {
                      return Padding(
                        padding: EdgeInsets.only(bottom: spacing.xs),
                        child: Text(
                          _logs[index],
                          style: textStyles.bodySmall.copyWith(
                            fontFamily: 'monospace',
                            color: _logs[index].contains('âœ…')
                                ? colors.success
                                : _logs[index].contains('âŒ')
                                    ? colors.error
                                    : colors.textPrimary,
                          ),
                        ),
                      );
                    },
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildStepButton(String title, Future<void> Function() onPressed) {
    final colors = AppColors.instance;
    final textStyles = AppTextStyles.instance;
    final spacing = AppSpacing.instance;

    return Padding(
      padding: EdgeInsets.only(bottom: spacing.sm),
      child: SizedBox(
        width: double.infinity,
        child: TextButton(
          onPressed: _isRunning ? null : () => _runIndividualStep(title, onPressed),
          style: TextButton.styleFrom(
            padding: EdgeInsets.symmetric(vertical: spacing.md, horizontal: spacing.lg),
            alignment: Alignment.centerLeft,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(spacing.borderRadius),
            ),
          ),
          child: Text(
            title,
            style: textStyles.bodyMedium.copyWith(
              color: _isRunning ? colors.textSecondary : colors.primary,
            ),
          ),
        ),
      ),
    );
  }
}
/* Fin lib\screens\test_runner_screen.dart */

/* Inicio lib\screens\users\form_steps\index.dart */

export 'user_account_step.dart';
export 'user_personal_info_step.dart';
export 'role_specific_details_step.dart';

/* Fin lib\screens\users\form_steps\index.dart */

/* Inicio lib\screens\users\form_steps\role_specific_details_step.dart */
import 'package:flutter/material.dart';
import '../../../theme/theme_extensions.dart';
import '../../../widgets/form_widgets.dart';
import '../../../widgets/components/clarity_components.dart';
class RoleSpecificDetailsStep extends StatelessWidget {
  final String userRole;
  final TextEditingController? tituloController;
  final TextEditingController? especialidadController;
  final TextEditingController? nombreResponsableController;
  final TextEditingController? telefonoResponsableController;

  final GlobalKey<FormFieldState<String>>? tituloFieldKey;
  final GlobalKey<FormFieldState<String>>? especialidadFieldKey;
  final GlobalKey<FormFieldState<String>>? nombreResponsableFieldKey;
  final GlobalKey<FormFieldState<String>>? telefonoResponsableFieldKey;

  const RoleSpecificDetailsStep({
    super.key,
    required this.userRole,
    this.tituloController,
    this.especialidadController,
    this.nombreResponsableController,
    this.telefonoResponsableController,
    this.tituloFocusNode,
    this.especialidadFocusNode,
    this.nombreResponsableFocusNode,
    this.telefonoResponsableFocusNode,
    this.tituloFieldKey,
    this.especialidadFieldKey,
    this.nombreResponsableFieldKey,
    this.telefonoResponsableFieldKey,
  });

  final FocusNode? tituloFocusNode;
  final FocusNode? especialidadFocusNode;
  final FocusNode? nombreResponsableFocusNode;
  final FocusNode? telefonoResponsableFocusNode;

  @override
  Widget build(BuildContext context) {
    final spacing = context.spacing;

    if (userRole == 'profesor') {
      return _buildProfesorDetails(context, spacing);
    } else if (userRole == 'estudiante') {
      return _buildEstudianteDetails(context, spacing);
    } else {
      return _buildNoAdditionalDetails(context);
    }
  }

  Widget _buildProfesorDetails(BuildContext context, dynamic spacing) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'InformaciÃ³n AcadÃ©mica',
          style: context.textStyles.headlineSmall,
        ),
        SizedBox(height: spacing.md),
        Text(
          'Complete los datos acadÃ©micos del profesor',
          style: context.textStyles.bodyMedium.copyWith(
            color: context.colors.textSecondary,
          ),
        ),
        SizedBox(height: spacing.lg),

        ClaritySection(
          title: 'Credenciales AcadÃ©micas',
          child: Column(
            children: [
              LayoutBuilder(
                builder: (context, constraints) {
                  final isWide = constraints.maxWidth > 600;
                  return isWide
                      ? Row(
                          children: [
                            Expanded(
                              child: CustomTextFormField(
                  fieldKey: tituloFieldKey,
                  focusNode: tituloFocusNode,
                                controller: tituloController!,
                                labelText: 'TÃ­tulo AcadÃ©mico',
                                hintText: 'Licenciado en..., MagÃ­ster en...',
                                validator: (value) {
                                  if (value == null || value.trim().isEmpty) {
                                    return 'El tÃ­tulo acadÃ©mico es requerido';
                                  }
                                  if (value.trim().length < 3) {
                                    return 'El tÃ­tulo debe tener al menos 3 caracteres';
                                  }
                                  return null;
                                },
                              ),
                            ),
                            SizedBox(width: spacing.md),
                            Expanded(
                              child: CustomTextFormField(
                  fieldKey: especialidadFieldKey,
                  focusNode: especialidadFocusNode,
                                controller: especialidadController!,
                                labelText: 'Especialidad',
                                hintText: 'MatemÃ¡ticas, FÃ­sica, etc.',
                                validator: (value) {
                                  if (value == null || value.trim().isEmpty) {
                                    return 'La especialidad es requerida';
                                  }
                                  if (value.trim().length < 3) {
                                    return 'La especialidad debe tener al menos 3 caracteres';
                                  }
                                  return null;
                                },
                              ),
                            ),
                          ],
                        )
                      : Column(
                          children: [
                            CustomTextFormField(
                              fieldKey: tituloFieldKey,
                              controller: tituloController!,
                              labelText: 'TÃ­tulo AcadÃ©mico',
                              hintText: 'Licenciado en..., MagÃ­ster en...',
                              validator: (value) {
                                if (value == null || value.trim().isEmpty) {
                                  return 'El tÃ­tulo acadÃ©mico es requerido';
                                }
                                if (value.trim().length < 3) {
                                  return 'El tÃ­tulo debe tener al menos 3 caracteres';
                                }
                                return null;
                              },
                            ),
                            SizedBox(height: spacing.md),
                            CustomTextFormField(
                              fieldKey: especialidadFieldKey,
                              controller: especialidadController!,
                              labelText: 'Especialidad',
                              hintText: 'MatemÃ¡ticas, FÃ­sica, etc.',
                              validator: (value) {
                                if (value == null || value.trim().isEmpty) {
                                  return 'La especialidad es requerida';
                                }
                                if (value.trim().length < 3) {
                                  return 'La especialidad debe tener al menos 3 caracteres';
                                }
                                return null;
                              },
                            ),
                          ],
                        );
                },
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildEstudianteDetails(BuildContext context, dynamic spacing) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'InformaciÃ³n del Responsable',
          style: context.textStyles.headlineSmall,
        ),
        SizedBox(height: spacing.md),
        Text(
          'Datos del padre, madre o tutor del estudiante (opcional)',
          style: context.textStyles.bodyMedium.copyWith(
            color: context.colors.textSecondary,
          ),
        ),
        SizedBox(height: spacing.lg),

        ClaritySection(
          title: 'Contacto de Emergencia',
          child: Column(
            children: [
              CustomTextFormField(
                fieldKey: nombreResponsableFieldKey,
                focusNode: nombreResponsableFocusNode,
                controller: nombreResponsableController!,
                labelText: 'Nombre del Responsable',
                hintText: 'Padre, madre o tutor',
                validator: (value) {
                  return null;
                },
              ),
              SizedBox(height: spacing.md),
              CustomTextFormField(
                fieldKey: telefonoResponsableFieldKey,
                focusNode: telefonoResponsableFocusNode,
                controller: telefonoResponsableController!,
                labelText: 'TelÃ©fono del Responsable',
                hintText: '+57 300 123 4567',
                keyboardType: TextInputType.phone,
                validator: (value) {
                  if (value != null && value.trim().isNotEmpty) {
                    final phoneRegex = RegExp(r'^\+?[0-9\s\-\(\)]+$');
                    if (!phoneRegex.hasMatch(value.trim())) {
                      return 'Ingrese un telÃ©fono vÃ¡lido';
                    }
                  }
                  return null;
                },
              ),
            ],
          ),
        ),

        SizedBox(height: spacing.md),
        Container(
          padding: EdgeInsets.all(spacing.md),
          decoration: BoxDecoration(
            color: context.colors.info.withValues(alpha: 0.1),
            borderRadius: BorderRadius.circular(8),
            border: Border.all(color: context.colors.info.withValues(alpha: 0.3)),
          ),
          child: Row(
            children: [
              Icon(Icons.info_outline, color: context.colors.info, size: 20),
              SizedBox(width: spacing.sm),
              Expanded(
                child: Text(
                  'Esta informaciÃ³n serÃ¡ utilizada para contacto en caso de emergencia.',
                  style: context.textStyles.bodySmall.copyWith(
                    color: context.colors.info,
                  ),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildNoAdditionalDetails(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Resumen',
          style: context.textStyles.headlineSmall,
        ),
        SizedBox(height: context.spacing.md),
        ClarityCard(
          leading: Icon(
            Icons.check_circle,
            color: context.colors.success,
            size: 48,
          ),
          title: const Text('InformaciÃ³n Completa'),
          subtitle: const Text(
            'Este tipo de usuario no requiere informaciÃ³n adicional. Puede proceder a guardar.',
          ),
        ),
      ],
    );
  }
}

/* Fin lib\screens\users\form_steps\role_specific_details_step.dart */

/* Inicio lib\screens\users\form_steps\user_account_step.dart */


import 'package:flutter/material.dart';
import '../../../theme/theme_extensions.dart';
import '../../../widgets/form_widgets.dart';
import '../../../providers/institution_provider.dart';
import '../../../models/institution.dart';
import '../../../providers/auth_provider.dart';
import 'package:provider/provider.dart';
class UserAccountStep extends StatefulWidget {
  final TextEditingController emailController;
  final String userRole;
  final String? selectedInstitutionId;
  final String? selectedInstitutionName;
  final ValueChanged<String?> onInstitutionChanged;
  final bool isEditMode;
  final bool disableInstitution;
  final FocusNode? emailFocusNode;
  final FocusNode? institutionFocusNode;
  final GlobalKey<FormFieldState<String>>? emailFieldKey;
  final GlobalKey<FormFieldState<String>>? institutionFieldKey;
  final String? errorEmail;

  const UserAccountStep({
    super.key,
    required this.emailController,
    required this.userRole,
    required this.selectedInstitutionId,
    required this.onInstitutionChanged,
    this.isEditMode = false,
    this.selectedInstitutionName,
    this.disableInstitution = false,
    this.emailFocusNode,
    this.institutionFocusNode,
    this.emailFieldKey,
    this.institutionFieldKey,
    this.errorEmail,
  });

  @override
  State<UserAccountStep> createState() => _UserAccountStepState();
}

class _UserAccountStepState extends State<UserAccountStep> {
  bool _isReloading = false;
  final TextEditingController _institutionController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _updateInstitutionController();
  }

  @override
  void didUpdateWidget(covariant UserAccountStep oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.selectedInstitutionId != widget.selectedInstitutionId ||
        oldWidget.selectedInstitutionName != widget.selectedInstitutionName) {
      _updateInstitutionController();
    }
  }

  void _updateInstitutionController() {
    final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);
    final selected = institutionProvider.institutions.firstWhere(
      (i) => i.id == widget.selectedInstitutionId,
      orElse: () => Institution(id: '', nombre: widget.selectedInstitutionName ?? '', direccion: null, telefono: null, email: null, activa: true),
    );
    _institutionController.text = selected.nombre;
  }

  @override
  void dispose() {
    _institutionController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final spacing = context.spacing;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'InformaciÃ³n de la Cuenta',
          style: context.textStyles.headlineSmall,
        ),
        SizedBox(height: spacing.md),
        Text(
          'Configure las credenciales de acceso del usuario',
          style: context.textStyles.bodyMedium.copyWith(
            color: context.colors.textSecondary,
          ),
        ),
        SizedBox(height: spacing.lg),
        CustomTextFormField(
          key: const Key('emailUsuarioField'),
          fieldKey: widget.emailFieldKey,
          focusNode: widget.emailFocusNode,
          controller: widget.emailController,
          labelText: 'Email',
          hintText: '${widget.userRole}@ejemplo.com',
          keyboardType: TextInputType.emailAddress,
          enabled: !widget.isEditMode, // No editable en modo ediciÃ³n
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'El email es requerido';
              }
              final emailRegex = RegExp(r'^[^@\s]+@[^@\s]+\.[^@\s]+$');
              if (!emailRegex.hasMatch(value.trim())) {
                return 'Ingrese un email vÃ¡lido';
              }
              return null;
            },
          errorText: widget.errorEmail,
        ),
        SizedBox(height: spacing.md),
        if (widget.userRole == 'admin_institucion') ...[
          Consumer2<AuthProvider, InstitutionProvider>(
            builder: (context, authProvider, institutionProvider, child) {
              if (widget.disableInstitution) {
                final selected = institutionProvider.institutions.firstWhere(
                  (i) => i.id == widget.selectedInstitutionId,
                  orElse: () {
                    final fallbackName = widget.selectedInstitutionName ?? authProvider.administrationName ?? 'â€”';
                    return Institution(id: widget.selectedInstitutionId ?? '', nombre: fallbackName, direccion: null, telefono: null, email: null, activa: true);
                  },
                );

                return Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text('InstituciÃ³n', style: context.textStyles.labelLarge),
                    SizedBox(height: spacing.sm),
                    Container(
                      width: double.infinity,
                      padding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
                      decoration: BoxDecoration(
                        color: context.colors.surfaceVariant,
                        borderRadius: BorderRadius.circular(8),
                        border: Border.all(color: context.colors.borderLight),
                      ),
                      child: Text(selected.nombre, style: context.textStyles.bodyMedium),
                    ),
                    SizedBox(height: spacing.sm),
                    Text(
                      'No puedes cambiar la instituciÃ³n de tu propia cuenta',
                      style: context.textStyles.bodySmall.copyWith(color: context.colors.textSecondary),
                    ),
                    SizedBox(height: spacing.md),
                  ],
                );
              }
              if (institutionProvider.institutions.isEmpty) {
                return Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'No se encontraron instituciones.',
                      style: context.textStyles.bodyMedium.copyWith(color: context.colors.textSecondary),
                    ),
                    SizedBox(height: spacing.sm),
                    Row(
                      children: [
                        ElevatedButton(
                          onPressed: _isReloading
                              ? null
                              : () async {
                                  final token = authProvider.accessToken;
                                  if (token != null) {
                                    setState(() => _isReloading = true);
                                    try {
                                      await institutionProvider.loadInstitutions(token, page: 1, limit: 100);
                                    } finally {
                                      if (mounted) setState(() => _isReloading = false);
                                    }
                                  } else {
                                    ScaffoldMessenger.of(context).showSnackBar(
                                      const SnackBar(content: Text('No hay sesiÃ³n activa para recargar instituciones')),
                                    );
                                  }
                                },
                          child: _isReloading
                              ? const SizedBox(width: 16, height: 16, child: CircularProgressIndicator(strokeWidth: 2))
                              : const Text('Recargar instituciones'),
                        ),
                        SizedBox(width: spacing.md),
                        TextButton(
                          onPressed: () {},
                          child: Text('Contactar soporte', style: context.textStyles.bodySmall.withColor(context.colors.info)),
                        ),
                      ],
                    ),
                  ],
                );
              }

              return TextFormField(
                key: const Key('institucionField'),
                controller: _institutionController,
                focusNode: widget.institutionFocusNode,
                decoration: InputDecoration(
                  labelText: 'InstituciÃ³n',
                  hintText: 'Seleccione una instituciÃ³n',
                  suffixIcon: const Icon(Icons.arrow_drop_down),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                ),
                readOnly: true,
                onTap: widget.disableInstitution ? null : () => _showInstitutionSelectionModal(context, institutionProvider, authProvider),
                validator: (value) {
                  if (widget.selectedInstitutionId == null || widget.selectedInstitutionId!.isEmpty) {
                    return 'Debe seleccionar una instituciÃ³n';
                  }
                  return null;
                },
              );
            },
          ),
          SizedBox(height: spacing.md),
        ],

        if (!widget.isEditMode) ...[
          Container(
            padding: EdgeInsets.all(spacing.md),
            decoration: BoxDecoration(
              color: context.colors.info.withValues(alpha: 0.1),
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: context.colors.info.withValues(alpha: 0.3)),
            ),
            child: Row(
              children: [
                Icon(Icons.info_outline, color: context.colors.info, size: 20),
                SizedBox(width: spacing.sm),
                Expanded(
                  child: Text(
                    'Se generarÃ¡ una contraseÃ±a temporal. El usuario deberÃ¡ cambiarla en su primer acceso.',
                    style: context.textStyles.bodySmall.copyWith(
                      color: context.colors.info,
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ],
    );
  }

  void _showInstitutionSelectionModal(BuildContext context, InstitutionProvider institutionProvider, AuthProvider authProvider) {
    final TextEditingController searchController = TextEditingController();
    List<Institution> filteredInstitutions = institutionProvider.institutions;

    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (modalContext) {
        return StatefulBuilder(
          builder: (context, setModalState) {
            void updateFiltered() {
              final query = searchController.text.toLowerCase();
              setModalState(() {
                filteredInstitutions = institutionProvider.institutions
                    .where((inst) => inst.nombre.toLowerCase().contains(query))
                    .toList();
              });
            }

            return Container(
              height: MediaQuery.of(context).size.height * 0.8,
              padding: const EdgeInsets.all(16),
              child: Column(
                children: [
                  Text('Seleccionar InstituciÃ³n', style: Theme.of(context).textTheme.headlineSmall),
                  const SizedBox(height: 16),
                  TextField(
                    controller: searchController,
                    decoration: InputDecoration(
                      hintText: 'Buscar instituciÃ³n...',
                      prefixIcon: const Icon(Icons.search),
                    ),
                    onChanged: (value) => updateFiltered(),
                  ),
                  const SizedBox(height: 16),
                  Expanded(
                    child: ListView.builder(
                      itemCount: filteredInstitutions.length,
                      itemBuilder: (context, index) {
                        final institution = filteredInstitutions[index];
                        return ListTile(
                          title: Text(institution.nombre),
                          subtitle: Text(institution.email ?? ''),
                          onTap: () {
                            _institutionController.text = institution.nombre;
                            widget.onInstitutionChanged(institution.id);
                            Navigator.of(modalContext).pop();
                          },
                        );
                      },
                    ),
                  ),
                ],
              ),
            );
          },
        );
      },
    );
  }
}

/* Fin lib\screens\users\form_steps\user_account_step.dart */

/* Inicio lib\screens\users\form_steps\user_personal_info_step.dart */
import 'package:flutter/material.dart';
import '../../../theme/theme_extensions.dart';
import '../../../widgets/form_widgets.dart';
class UserPersonalInfoStep extends StatelessWidget {
  final TextEditingController nombresController;
  final TextEditingController apellidosController;
  final TextEditingController telefonoController;
  final TextEditingController identificacionController;
  final String userRole;
  final bool activo;
  final ValueChanged<bool> onActivoChanged;
  final bool activoEditable;
  final FocusNode? nombresFocusNode;
  final FocusNode? apellidosFocusNode;
  final FocusNode? telefonoFocusNode;
  final FocusNode? identificacionFocusNode;
  final GlobalKey<FormFieldState<String>>? nombresFieldKey;
  final GlobalKey<FormFieldState<String>>? apellidosFieldKey;
  final GlobalKey<FormFieldState<String>>? telefonoFieldKey;
  final GlobalKey<FormFieldState<String>>? identificacionFieldKey;

  const UserPersonalInfoStep({
    super.key,
    required this.nombresController,
    required this.apellidosController,
    required this.telefonoController,
    required this.identificacionController,
    required this.userRole,
    required this.activo,
    required this.onActivoChanged,
    this.activoEditable = true,
    this.nombresFocusNode,
    this.apellidosFocusNode,
    this.telefonoFocusNode,
    this.identificacionFocusNode,
    this.nombresFieldKey,
    this.apellidosFieldKey,
    this.telefonoFieldKey,
    this.identificacionFieldKey,
  });

  @override
  Widget build(BuildContext context) {
    final spacing = context.spacing;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'InformaciÃ³n Personal',
          style: context.textStyles.headlineSmall,
        ),
        SizedBox(height: spacing.md),
        Text(
          'Ingrese los datos personales del usuario',
          style: context.textStyles.bodyMedium.copyWith(
            color: context.colors.textSecondary,
          ),
        ),
        SizedBox(height: spacing.lg),
        LayoutBuilder(
          builder: (context, constraints) {
            final isWide = constraints.maxWidth > 600;
            return isWide
                ? Row(
                    children: [
                      Expanded(
                        child: CustomTextFormField(
                          key: const Key('user_form_nombres'),
                          fieldKey: nombresFieldKey,
                          focusNode: nombresFocusNode,
                          controller: nombresController,
                          labelText: 'Nombres',
                          hintText: 'Ingrese los nombres',
                          validator: (value) {
                            if (value == null || value.trim().isEmpty) {
                              return 'Los nombres son requeridos';
                            }
                            if (value.trim().length < 2) {
                              return 'Los nombres deben tener al menos 2 caracteres';
                            }
                            return null;
                          },
                        ),
                      ),
                      SizedBox(width: spacing.md),
                      Expanded(
                        child: CustomTextFormField(
                          key: const Key('user_form_apellidos'),
                          fieldKey: apellidosFieldKey,
                          focusNode: apellidosFocusNode,
                          controller: apellidosController,
                          labelText: 'Apellidos',
                          hintText: 'Ingrese los apellidos',
                          validator: (value) {
                            if (value == null || value.trim().isEmpty) {
                              return 'Los apellidos son requeridos';
                            }
                            if (value.trim().length < 2) {
                              return 'Los apellidos deben tener al menos 2 caracteres';
                            }
                            return null;
                          },
                        ),
                      ),
                    ],
                  )
                : Column(
                    children: [
                      CustomTextFormField(
                        key: const Key('nombresUsuarioField'),
                        fieldKey: nombresFieldKey,
                        focusNode: nombresFocusNode,
                        controller: nombresController,
                        labelText: 'Nombres',
                        hintText: 'Ingrese los nombres',
                        validator: (value) {
                          if (value == null || value.trim().isEmpty) {
                            return 'Los nombres son requeridos';
                          }
                          if (value.trim().length < 2) {
                            return 'Los nombres deben tener al menos 2 caracteres';
                          }
                          return null;
                        },
                      ),
                      SizedBox(height: spacing.md),
                      CustomTextFormField(
                        key: const Key('apellidosUsuarioField'),
                        fieldKey: apellidosFieldKey,
                        focusNode: apellidosFocusNode,
                        controller: apellidosController,
                        labelText: 'Apellidos',
                        hintText: 'Ingrese los apellidos',
                        validator: (value) {
                          if (value == null || value.trim().isEmpty) {
                            return 'Los apellidos son requeridos';
                          }
                          if (value.trim().length < 2) {
                            return 'Los apellidos deben tener al menos 2 caracteres';
                          }
                          return null;
                        },
                      ),
                    ],
                  );
          },
        ),
        SizedBox(height: spacing.md),
        LayoutBuilder(
          builder: (context, constraints) {
            final isWide = constraints.maxWidth > 600;
            return isWide
                ? Row(
                    children: [
                      Expanded(
                        child: CustomTextFormField(
                          key: const Key('user_form_telefono'),
                          fieldKey: telefonoFieldKey,
                          controller: telefonoController,
                          labelText: 'TelÃ©fono',
                          hintText: '+57 300 123 4567',
                          keyboardType: TextInputType.phone,
                          validator: (value) {
                            if (value != null && value.trim().isNotEmpty) {
                              final phoneRegex = RegExp(r'^\+?[0-9\s\-\(\)]+$');
                              if (!phoneRegex.hasMatch(value.trim())) {
                                return 'Ingrese un telÃ©fono vÃ¡lido';
                              }
                            }
                            return null;
                          },
                        ),
                      ),
                      SizedBox(width: spacing.md),
                      Expanded(
                        child: CustomTextFormField(
                          key: const Key('user_form_identificacion'),
                          fieldKey: identificacionFieldKey,
                          controller: identificacionController,
                          labelText: 'IdentificaciÃ³n',
                          hintText: 'CÃ©dula o documento',
                          validator: (value) {
                            if (userRole == 'admin_institucion' || userRole == 'super_admin') {
                              return null;
                            }

                            if (value == null || value.trim().isEmpty) {
                              return 'La identificaciÃ³n es requerida';
                            }
                            if (value.trim().length < 5) {
                              return 'La identificaciÃ³n debe tener al menos 5 caracteres';
                            }
                            return null;
                          },
                        ),
                      ),
                    ],
                  )
                : Column(
                    children: [
                      CustomTextFormField(
                        key: const Key('user_form_telefono'),
                        fieldKey: telefonoFieldKey,
                        focusNode: telefonoFocusNode,
                        controller: telefonoController,
                        labelText: 'TelÃ©fono',
                        hintText: '+57 300 123 4567',
                        keyboardType: TextInputType.phone,
                        validator: (value) {
                          if (value != null && value.trim().isNotEmpty) {
                            final phoneRegex = RegExp(r'^\+?[0-9\s\-\(\)]+$');
                            if (!phoneRegex.hasMatch(value.trim())) {
                              return 'Ingrese un telÃ©fono vÃ¡lido';
                            }
                          }
                          return null;
                        },
                      ),
                      SizedBox(height: spacing.md),
                      CustomTextFormField(
                        key: const Key('user_form_identificacion'),
                        fieldKey: identificacionFieldKey,
                        focusNode: identificacionFocusNode,
                        controller: identificacionController,
                        labelText: 'IdentificaciÃ³n',
                        hintText: 'CÃ©dula o documento',
                        validator: (value) {
                          if (userRole == 'admin_institucion' || userRole == 'super_admin') {
                            return null;
                          }

                          if (value == null || value.trim().isEmpty) {
                            return 'La identificaciÃ³n es requerida';
                          }
                          if (value.trim().length < 5) {
                            return 'La identificaciÃ³n debe tener al menos 5 caracteres';
                          }
                          return null;
                        },
                      ),
                    ],
                  );
          },
        ),
        SizedBox(height: spacing.lg),
        SwitchListTile(
          title: const Text('Usuario Activo'),
          subtitle: Text(
            activo ? 'El usuario puede iniciar sesiÃ³n' : 'El usuario estÃ¡ deshabilitado',
            style: context.textStyles.bodySmall.copyWith(
              color: context.colors.textSecondary,
            ),
          ),
          value: activo,
          onChanged: activoEditable ? onActivoChanged : null,
          activeColor: context.colors.success,
        ),
      ],
    );
  }
}

/* Fin lib\screens\users\form_steps\user_personal_info_step.dart */

/* Inicio lib\screens\users\users_list_screen.dart */
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import 'package:flutter_speed_dial/flutter_speed_dial.dart';
import '../../models/user.dart';
import '../../providers/auth_provider.dart';
import '../../providers/user_provider.dart';
import '../../theme/theme_extensions.dart';
import '../../theme/app_colors.dart';
import '../../theme/app_text_styles.dart';
import '../../theme/app_spacing.dart';
import '../../widgets/components/index.dart';

class UsersListScreen extends StatefulWidget {
  const UsersListScreen({super.key});

  @override
  State<UsersListScreen> createState() => _UsersListScreenState();
}

class _UsersListScreenState extends State<UsersListScreen> {
  final TextEditingController _searchController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  Timer? _searchDebounceTimer;
  String _searchQuery = '';
  String _selectedRoleFilter = '';
  bool? _statusFilter = true
  bool _isSearching = false;

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final userRole = authProvider.user?['rol'] as String?;
      if (userRole == 'admin_institucion') {
        setState(() {
          _selectedRoleFilter = ''
        });
      }
      _loadUsers();
    });
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _searchController.dispose();
    _searchDebounceTimer?.cancel();
    super.dispose();
  }

  void _onScroll() {
    if (_isSearching) return

    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final userProvider = Provider.of<UserProvider>(context, listen: false);

    if (_scrollController.position.pixels >= _scrollController.position.maxScrollExtent * 0.9) {
  final userRole = authProvider.user?['rol'] as String?;
  final token = authProvider.accessToken;
  _loadMoreUsers(userProvider, token, userRole);
    }
  }

  Future<void> _loadUsers() async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final userProvider = Provider.of<UserProvider>(context, listen: false);
    final userRole = authProvider.user?['rol'] as String?;

    final token = authProvider.accessToken;
    if (token == null) {
      debugPrint('Error: No hay token de acceso para cargar usuarios.');
      return;
    }
    if (userRole == 'super_admin') {
      debugPrint('Cargando usuarios (admin_institucion y super_admin) como super_admin...');
      final roles = (_selectedRoleFilter.isEmpty)
          ? ['super_admin', 'admin_institucion']
          : [_selectedRoleFilter];

      await userProvider.loadUsers(
        token,
        page: 1,
        limit: 15,
        search: _searchQuery.isEmpty ? null : _searchQuery,
        activo: _statusFilter,
        roles: roles,
      );
    } else if (userRole == 'admin_institucion') {
      if (authProvider.selectedInstitutionId != null) {
        debugPrint('Cargando usuarios para la instituciÃ³n: ${authProvider.selectedInstitutionId}');
        await userProvider.loadUsersByInstitution(
          token,
          authProvider.selectedInstitutionId!,
          page: 1,
          limit: 5,
          role: _selectedRoleFilter.isEmpty ? null : _selectedRoleFilter,
          activo: _statusFilter,
          search: _searchQuery.isEmpty ? null : _searchQuery,
        );
      } else {
        debugPrint('Admin de instituciÃ³n sin instituciÃ³n seleccionada. No se cargarÃ¡n usuarios.');
        userProvider.clearData()
      }
    }
  }

  Future<void> _loadMoreUsers(UserProvider provider, String? accessToken, String? userRole) async {
    if (accessToken == null || provider.isLoadingMore || !provider.hasMoreData) return;
    if (userRole == 'super_admin') {
      final roles = (_selectedRoleFilter.isEmpty)
          ? ['super_admin', 'admin_institucion']
          : [_selectedRoleFilter];

      provider.setFilter('activo', _statusFilter);
      provider.setFilter('search', _searchQuery.isEmpty ? null : _searchQuery);
      provider.setFilter('roles', roles);
      await provider.loadNextPage(accessToken);
    } else {
      await provider.loadNextPage(accessToken);
    }
  }

  void _onSearchChanged(String query) {
    _searchDebounceTimer?.cancel();

    setState(() {
      _isSearching = query.isNotEmpty;
    });
    _searchDebounceTimer = Timer(const Duration(milliseconds: 500), () {
      setState(() {
        _searchQuery = query.trim();
      });
      _loadUsers();
    });
  }

  @override
  @override
  Widget build(BuildContext context) {
    return Consumer2<AuthProvider, UserProvider>(
      builder: (context, authProvider, userProvider, child) {
        final userRole = authProvider.user?['rol'] as String?;
        final title = userRole == 'admin_institucion'
          ? 'GestiÃ³n de Usuarios de la InstituciÃ³n'
          : 'GestiÃ³n de Usuarios';
        final canCreateUsers = userRole == 'admin_institucion' || userRole == 'super_admin';

        return ClarityManagementPage(
          title: title,
          isLoading: userProvider.isLoading,
          hasError: userProvider.hasError,
          errorMessage: userProvider.errorMessage,
          itemCount: userProvider.users.length,
          itemBuilder: (context, index) {
            final user = userProvider.users[index];
            return _buildUserCard(user, userProvider, context);
          },
          itemSpacing: context.spacing.sm,
          filterWidgets: _buildFilterWidgets(context, authProvider),
          statisticWidgets: _buildStatisticWidgets(context, userProvider),
          onRefresh: _loadUsers,
          scrollController: _scrollController,
          hasMoreData: userProvider.hasMoreData,
          isLoadingMore: userProvider.isLoadingMore,
          emptyStateWidget: ClarityEmptyState(
            icon: _isSearching ? Icons.search_off : Icons.people,
            title: _isSearching
              ? 'No se encontraron resultados'
              : 'AÃºn no has creado ningÃºn usuario',
            subtitle: _isSearching
              ? 'Intenta con otros tÃ©rminos de bÃºsqueda'
              : 'Comienza creando tu primer usuario',
          ),
          floatingActionButton: canCreateUsers
              ? _buildSpeedDial(context, userRole!)
              : null,
        );
      },
    );
  }

  Widget _buildSpeedDial(BuildContext context, String userRole) {
    final colors = context.colors;

    if (userRole == 'super_admin') {
      return SpeedDial(
        icon: Icons.add,
        activeIcon: Icons.close,
        backgroundColor: colors.primary,
        foregroundColor: colors.getTextColorForBackground(colors.primary),
        children: [
          SpeedDialChild(
            child: Icon(Icons.admin_panel_settings,
              color: colors.getTextColorForBackground(colors.primary)),
            backgroundColor: colors.primary,
            label: 'Crear Admin InstituciÃ³n',
            onTap: _navigateToCreateAdminInstitution,
          ),
          SpeedDialChild(
            child: Icon(Icons.shield,
              color: colors.getTextColorForBackground(colors.primary)),
            backgroundColor: colors.primary,
            label: 'Crear Super Admin',
            onTap: _navigateToCreateSuperAdmin,
          ),
        ],
      );
    } else {
      return SpeedDial(
        icon: Icons.add,
        activeIcon: Icons.close,
        backgroundColor: colors.primary,
        foregroundColor: colors.getTextColorForBackground(colors.primary),
        children: [
          SpeedDialChild(
            key: const Key('createUser_professor'),
            child: Icon(Icons.school,
              color: colors.getTextColorForBackground(colors.primary)),
            backgroundColor: colors.primary,
            label: 'Crear Profesor',
            onTap: _navigateToCreateProfessor,
          ),
          SpeedDialChild(
            key: const Key('createUser_student'),
            child: Icon(Icons.person,
              color: colors.getTextColorForBackground(colors.primary)),
            backgroundColor: colors.primary,
            label: 'Crear Estudiante',
            onTap: _navigateToCreateStudent,
          ),
        ],
      );
    }
  }

  List<Widget> _buildFilterWidgets(BuildContext context, AuthProvider authProvider) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return [
      TextField(
        controller: _searchController,
        style: textStyles.bodyLarge,
        decoration: InputDecoration(
          hintText: 'Buscar por nombre, email o telÃ©fono...',
          hintStyle: textStyles.bodyMedium.withColor(colors.textMuted),
          prefixIcon: Icon(Icons.search, color: colors.textSecondary),
          suffixIcon: _isSearching
              ? IconButton(
                  icon: Icon(Icons.clear, color: colors.textSecondary),
                  onPressed: () {
                    _searchController.clear();
                    _onSearchChanged('');
                  },
                )
              : null,
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.border),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.borderLight),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.primary, width: 2),
          ),
          filled: true,
          fillColor: colors.surface,
          contentPadding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
        ),
        onChanged: _onSearchChanged,
      ),
      SizedBox(height: spacing.sm),
      Wrap(
        spacing: spacing.md,
        runSpacing: spacing.sm,
        crossAxisAlignment: WrapCrossAlignment.center,
        children: [
          Text('Mostrar:', style: textStyles.labelMedium),
          _statusFilterChip(
            label: 'Activos',
            selected: _statusFilter == true && !_isSearching,
            color: context.colors.success,
            onTap: () {
              setState(() => _statusFilter = true);
              _loadUsers();
            },
          ),
          _statusFilterChip(
            label: 'Inactivos',
            selected: _statusFilter == false && !_isSearching,
            color: context.colors.grey400,
            onTap: () {
              setState(() => _statusFilter = false);
              _loadUsers();
            },
          ),
          _statusFilterChip(
            label: 'Todos',
            selected: _statusFilter == null && !_isSearching,
            color: context.colors.grey400,
            onTap: () {
              setState(() => _statusFilter = null);
              _loadUsers();
            },
          ),
        ],
      ),
      SizedBox(height: spacing.sm),
        Row(
          children: [
            Expanded(
              child: Consumer<AuthProvider>(
                builder: (context, authProvider, _) {
                  final userRole = authProvider.user?['rol'] as String?;
                  final isAdminInstitucion = userRole == 'admin_institucion';
                  final isSuperAdmin = userRole == 'super_admin';

                  return DropdownButtonFormField<String>(
                    value: _selectedRoleFilter.isEmpty ? null : _selectedRoleFilter,
                    hint: Text('Filtrar por rol', style: textStyles.bodyMedium),
                    items: isSuperAdmin ? [
                      DropdownMenuItem(value: '', child: Text('Todos los roles', style: textStyles.bodyMedium)),
                      DropdownMenuItem(value: 'admin_institucion', child: Text('Admins InstituciÃ³n', style: textStyles.bodyMedium)),
                      DropdownMenuItem(value: 'super_admin', child: Text('Super Admins', style: textStyles.bodyMedium)),
                    ] : isAdminInstitucion ? [
                      DropdownMenuItem(value: '', child: Text('Todos los usuarios', style: textStyles.bodyMedium)),
                      DropdownMenuItem(value: 'profesor', child: Text('Solo Profesores', style: textStyles.bodyMedium)),
                      DropdownMenuItem(value: 'estudiante', child: Text('Solo Estudiantes', style: textStyles.bodyMedium)),
                    ] : [
                      DropdownMenuItem(value: '', child: Text('Todos los roles', style: textStyles.bodyMedium)),
                      DropdownMenuItem(value: 'profesor', child: Text('Profesores', style: textStyles.bodyMedium)),
                      DropdownMenuItem(value: 'estudiante', child: Text('Estudiantes', style: textStyles.bodyMedium)),
                      DropdownMenuItem(value: 'admin_institucion', child: Text('Admins InstituciÃ³n', style: textStyles.bodyMedium)),
                    ],
                    onChanged: (value) {
                      setState(() => _selectedRoleFilter = value ?? '');
                      _loadUsers();
                    },
                    decoration: InputDecoration(
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(spacing.borderRadius),
                      ),
                      contentPadding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
                    ),
                    isExpanded: true,
                  );
                },
              ),
            ),
          ],
        ),
      ];
  }

  Widget _statusFilterChip({
    required String label,
    required bool selected,
    required Color color,
    required VoidCallback onTap,
  }) {
    final colors = AppColors.instance;
    final spacing = AppSpacing.instance;
    final textStyles = AppTextStyles.instance;

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(spacing.borderRadius),
      child: Container(
        padding: EdgeInsets.symmetric(horizontal: spacing.sm, vertical: spacing.xs),
        decoration: BoxDecoration(
          color: selected ? color.withValues(alpha: 0.1) : colors.surface,
          border: Border.all(
            color: selected ? color : colors.borderLight,
            width: 1,
          ),
          borderRadius: BorderRadius.circular(spacing.borderRadius),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              width: 6,
              height: 6,
              decoration: BoxDecoration(
                color: color,
                shape: BoxShape.circle,
              ),
            ),
            SizedBox(width: spacing.xs),
            Text(
              label,
              style: textStyles.bodySmall.copyWith(
                color: selected ? color : colors.textPrimary,
                fontWeight: selected ? FontWeight.w500 : FontWeight.normal,
              ),
            ),
          ],
        ),
      ),
    );
  }

  List<Widget> _buildStatisticWidgets(BuildContext context, UserProvider provider) {
    final stats = provider.getUserStatistics();
    final colors = context.colors;

    return [
      ClarityCompactStat(
        title: 'Total',
        value: stats['total'].toString(),
        icon: Icons.people,
        color: colors.primary,
      ),
      ClarityCompactStat(
        title: 'Activos',
        value: stats['activos'].toString(),
        icon: Icons.check_circle,
        color: colors.success,
      ),
      ClarityCompactStat(
        title: 'Profesores',
        value: stats['profesores'].toString(),
        icon: Icons.school,
        color: colors.info,
      ),
      ClarityCompactStat(
        title: 'Estudiantes',
        value: stats['estudiantes'].toString(),
        icon: Icons.person,
        color: colors.warning,
      ),
    ];
  }

  Widget _buildUserCard(User user, UserProvider provider, BuildContext context) {
    final colors = context.colors;
    final textStyles = context.textStyles;

    return Consumer<AuthProvider>(
      builder: (context, authProvider, child) {
        final userRole = authProvider.user?['rol'] as String?;
        final canEditUsers = userRole == 'admin_institucion' || userRole == 'super_admin';
        final currentUserId = authProvider.user?['id']?.toString();
        final bool isSelf = currentUserId != null && currentUserId == user.id;

        final List<ClarityContextMenuAction> contextActions = canEditUsers
            ? [
                ClarityContextMenuAction(
                  label: 'Editar',
                  icon: Icons.edit,
                  color: colors.primary,
                  onPressed: () => _navigateToUserEdit(user),
                ),
                if (!isSelf)
                  ClarityContextMenuAction(
                    label: user.activo ? 'Desactivar' : 'Activar',
                    icon: user.activo ? Icons.toggle_off : Icons.toggle_on,
                    color: user.activo ? colors.warning : colors.success,
                    onPressed: () => _handleMenuAction('toggle_status', user, provider),
                  ),
                if (!isSelf)
                  ClarityContextMenuAction(
                    label: 'Eliminar',
                    icon: Icons.delete,
                    color: colors.error,
                    onPressed: () => _handleMenuAction('delete', user, provider),
                  ),
              ]
            : [];

        return ClarityListItem(
          leading: CircleAvatar(
            backgroundColor: _getRoleColor(user.rol, context),
            child: Text(
              user.nombreCompleto.substring(0, 1).toUpperCase(),
              style: textStyles.labelMedium.copyWith(color: colors.white),
            ),
          ),
          title: user.nombreCompleto,
          subtitle: null,
          subtitleWidget: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Expanded(
                    child: Text(
                      user.email,
                      style: textStyles.bodySmall.copyWith(color: context.colors.textPrimary),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                  const SizedBox(width: 8),
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 3),
                    decoration: BoxDecoration(
                      color: context.colors.surfaceVariant,
                      borderRadius: BorderRadius.circular(12),
                      border: Border.all(
                        color: context.colors.borderLight,
                        width: 1,
                      ),
                    ),
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Container(
                          width: 6,
                          height: 6,
                          decoration: BoxDecoration(
                            color: user.activo
                              ? context.colors.primary.withValues(alpha: 0.7)
                              : context.colors.textMuted,
                            shape: BoxShape.circle,
                          ),
                        ),
                        const SizedBox(width: 4),
                        Text(
                          user.activo ? 'Activo' : 'Inactivo',
                          style: textStyles.bodySmall.copyWith(
                            color: context.colors.textSecondary,
                            fontSize: 11,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              if (user.rol == 'admin_institucion' && (user.instituciones?.isNotEmpty ?? false)) ...[
                const SizedBox(height: 4),
                Wrap(
                  spacing: 4,
                  runSpacing: 2,
                  children: (user.instituciones ?? []).map((i) {
                    return Container(
                      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                      decoration: BoxDecoration(
                        color: context.colors.surfaceVariant,
                        borderRadius: const BorderRadius.all(Radius.circular(4)),
                        border: Border.all(color: context.colors.border, width: 0.5),
                      ),
                      constraints: const BoxConstraints(maxWidth: 160),
                      child: Text(
                        i.nombre,
                        style: textStyles.bodySmall.copyWith(
                          color: context.colors.textSecondary,
                          fontSize: 12,
                        ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    );
                  }).toList(),
                ),
              ],
            ],
          ),
          contextActions: contextActions.isNotEmpty ? contextActions : null,
          onTap: () => _navigateToUserDetail(user),
        );
      },
    );
  }

  Color _getRoleColor(String role, BuildContext context) {
    final colors = context.colors;
    switch (role) {
      case 'profesor':
        return colors.info;
      case 'estudiante':
        return colors.warning;
      case 'admin_institucion':
        return colors.primary;
      case 'super_admin':
        return colors.error;
      default:
        return colors.primary;
    }
  }

  void _handleMenuAction(String action, User user, UserProvider provider) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    switch (action) {
      case 'edit':
        _navigateToUserEdit(user);
        break;

      case 'toggle_status':
        final newStatus = !user.activo;
        final token = authProvider.accessToken;
        if (token == null) {
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Debes iniciar sesiÃ³n para editar usuarios')));
          return;
        }

        final success = await provider.updateUser(
          token,
          user.id,
          UpdateUserRequest(
            activo: newStatus,
            nombres: user.nombres, // Incluir valores actuales para evitar null
            apellidos: user.apellidos,
            email: user.email,
            telefono: user.telefono,
          ),
        );

        if (success && mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                'Usuario ${newStatus ? 'activado' : 'desactivado'} correctamente',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onPrimary),
              ),
              backgroundColor: Theme.of(context).colorScheme.primary,
            ),
          );
          await _loadUsers();
        } else if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                provider.errorMessage ?? 'Error al cambiar estado del usuario',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onError),
              ),
              backgroundColor: Theme.of(context).colorScheme.error,
            ),
          );
        }
        break;

      case 'delete':
        _showDeleteConfirmationDialog(user, provider);
        break;
    }
  }

  void _showDeleteConfirmationDialog(User user, UserProvider provider) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Eliminar Usuario', style: Theme.of(context).textTheme.headlineSmall),
        content: Text(
          'Â¿EstÃ¡s seguro de que quieres eliminar "${user.nombreCompleto}"?\n\n'
          'Esta acciÃ³n no se puede deshacer.',
          style: Theme.of(context).textTheme.bodyMedium,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: Text('Cancelar', style: Theme.of(context).textTheme.labelLarge),
          ),
          TextButton(
            onPressed: () async {
              Navigator.of(context).pop();
              await _deleteUser(user, provider);
            },
            style: TextButton.styleFrom(foregroundColor: Theme.of(context).colorScheme.error),
            child: Text('Eliminar', style: Theme.of(context).textTheme.labelLarge?.copyWith(color: Theme.of(context).colorScheme.error)),
          ),
        ],
      ),
    );
  }

  Future<void> _deleteUser(User user, UserProvider provider) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    final token = authProvider.accessToken;
    if (token == null) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Debes iniciar sesiÃ³n para eliminar usuarios')));
      return;
    }

    final success = await provider.deleteUser(
      token,
      user.id,
    );

    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            'Usuario eliminado correctamente',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onPrimary),
          ),
          backgroundColor: Theme.of(context).colorScheme.primary,
        ),
      );
      await _loadUsers();
    } else if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            provider.errorMessage ?? 'Error al eliminar usuario',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onError),
          ),
          backgroundColor: Theme.of(context).colorScheme.error,
        ),
      );
    }
  }

  void _navigateToCreateProfessor() {
    context.push('/users/create', extra: 'profesor');
  }

  void _navigateToCreateStudent() {
    context.push('/users/create', extra: 'estudiante');
  }

  void _navigateToCreateAdminInstitution() {
    context.push('/users/create', extra: 'admin_institucion');
  }

  void _navigateToCreateSuperAdmin() {
    context.push('/users/create', extra: 'super_admin');
  }

  void _navigateToUserEdit(User user) {
    context.push('/users/create?edit=true&userId=${user.id}', extra: user.rol);
  }

  void _navigateToUserDetail(User user) {
    context.push('/users/detail/${user.id}', extra: user);
  }
}
/* Fin lib\screens\users\users_list_screen.dart */

/* Inicio lib\screens\users\user_detail_screen.dart */
import 'package:flutter/material.dart';
import '../../models/user.dart';
import '../../theme/theme_extensions.dart';

class UserDetailScreen extends StatelessWidget {
  final User user;

  const UserDetailScreen({
    super.key,
    required this.user,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Scaffold(
      appBar: AppBar(
        title: Text(
          user.nombreCompleto,
          style: textStyles.titleLarge,
        ),
        backgroundColor: colors.primary,
        foregroundColor: Theme.of(context).colorScheme.onPrimary,
        elevation: 0,
      ),
      body: SingleChildScrollView(
        padding: EdgeInsets.all(spacing.lg),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildInfoSection(
              context,
              'InformaciÃ³n BÃ¡sica',
              [
                _buildInfoItem('Nombres', user.nombres),
                _buildInfoItem('Apellidos', user.apellidos),
                _buildInfoItem('Email', user.email),
                _buildInfoItem('TelÃ©fono', user.telefono ?? 'No especificado'),
                _buildInfoItem('Rol', _getRoleDisplayName(user.rol)),
                _buildInfoItem('Estado', user.activo ? 'Activo' : 'Inactivo',
                    valueColor: user.activo ? colors.success : colors.error),
              ],
            ),

            SizedBox(height: spacing.lg),
            if (user.esEstudiante && user.estudiante != null) ...[
              _buildInfoSection(
                context,
                'InformaciÃ³n del Estudiante',
                [
                  _buildInfoItem('IdentificaciÃ³n', user.estudiante!.identificacion),
                  _buildInfoItem('CÃ³digo QR', user.estudiante!.codigoQr),
                  if (user.estudiante!.nombreResponsable != null)
                    _buildInfoItem('Nombre del Responsable', user.estudiante!.nombreResponsable!),
                  if (user.estudiante!.telefonoResponsable != null)
                    _buildInfoItem('TelÃ©fono del Responsable', user.estudiante!.telefonoResponsable!),
                ],
              ),
              SizedBox(height: spacing.lg),
            ],
            if (user.instituciones?.isNotEmpty ?? false) ...[
              _buildInfoSection(
                context,
                'Instituciones',
                (user.instituciones ?? []).map((inst) => _buildInfoItem(
                  inst.nombre,
                  inst.rolEnInstitucion ?? 'Sin rol especÃ­fico',
                )).toList(),
              ),
              SizedBox(height: spacing.lg),
            ],
            _buildInfoSection(
              context,
              'InformaciÃ³n del Sistema',
              [
                _buildInfoItem('ID de Usuario', user.id),
                _buildInfoItem('Fecha de CreaciÃ³n', 'No disponible'), // TODO: Agregar campo de fecha si existe
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoSection(BuildContext context, String title, List<Widget> items) {
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(spacing.borderRadius),
      ),
      child: Padding(
        padding: EdgeInsets.all(spacing.lg),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              title,
              style: textStyles.titleMedium.bold,
            ),
            SizedBox(height: spacing.md),
            ...items,
          ],
        ),
      ),
    );
  }

  Widget _buildInfoItem(String label, String value, {Color? valueColor}) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Expanded(
            flex: 2,
            child: Text(
              '$label:',
              style: TextStyle(
                fontWeight: FontWeight.w600,
                color: Colors.grey[700],
              ),
            ),
          ),
          Expanded(
            flex: 3,
            child: Text(
              value,
              style: TextStyle(
                color: valueColor,
                fontWeight: valueColor != null ? FontWeight.w500 : FontWeight.normal,
              ),
            ),
          ),
        ],
      ),
    );
  }

  String _getRoleDisplayName(String role) {
    switch (role) {
      case 'super_admin':
        return 'Super Administrador';
      case 'admin_institucion':
        return 'Administrador de InstituciÃ³n';
      case 'profesor':
        return 'Profesor';
      case 'estudiante':
        return 'Estudiante';
      default:
        return role;
    }
  }
}
/* Fin lib\screens\users\user_detail_screen.dart */

/* Inicio lib\screens\users\user_form_screen.dart */


import 'package:flutter/services.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../models/user.dart';
import '../../providers/auth_provider.dart';
import '../../providers/institution_provider.dart';
import '../../theme/theme_extensions.dart';
import '../../services/user_form_service.dart';
import '../../services/user_service.dart';
import '../../services/form_validation_service.dart';
import 'form_steps/index.dart';

class UserFormScreen extends StatefulWidget {
  final String userRole
  final String? initialInstitutionId

  const UserFormScreen({
    super.key,
    required this.userRole,
    this.initialInstitutionId,
  });

  @override
  State<UserFormScreen> createState() => _UserFormScreenState();
}

class _UserFormScreenState extends State<UserFormScreen> {
  final _formKey = GlobalKey<FormState>();
  int _currentStep = 0;
  AutovalidateMode _autoValidateMode = AutovalidateMode.disabled;
  final UserFormService _userFormService = UserFormService();
  final FocusNode _emailFocus = FocusNode();
  final FocusNode _institutionFocus = FocusNode();

  final FocusNode _nombresFocus = FocusNode();
  final FocusNode _apellidosFocus = FocusNode();
  final FocusNode _telefonoFocus = FocusNode();
  final FocusNode _identificacionFocus = FocusNode();

  final FocusNode _tituloFocus = FocusNode();
  final FocusNode _especialidadFocus = FocusNode();
  final FocusNode _nombreResponsableFocus = FocusNode();
  final FocusNode _telefonoResponsableFocus = FocusNode();
  final GlobalKey<FormFieldState<String>> _emailFieldKey = GlobalKey<FormFieldState<String>>();
  final GlobalKey<FormFieldState<String>> _institutionFieldKey = GlobalKey<FormFieldState<String>>();
  final GlobalKey<FormFieldState<String>> _nombresFieldKey = GlobalKey<FormFieldState<String>>();
  final GlobalKey<FormFieldState<String>> _apellidosFieldKey = GlobalKey<FormFieldState<String>>();
  final GlobalKey<FormFieldState<String>> _telefonoFieldKey = GlobalKey<FormFieldState<String>>();
  final GlobalKey<FormFieldState<String>> _identificacionFieldKey = GlobalKey<FormFieldState<String>>();
  final GlobalKey<FormFieldState<String>> _tituloFieldKey = GlobalKey<FormFieldState<String>>();
  final GlobalKey<FormFieldState<String>> _especialidadFieldKey = GlobalKey<FormFieldState<String>>();
  final GlobalKey<FormFieldState<String>> _nombreResponsableFieldKey = GlobalKey<FormFieldState<String>>();
  final GlobalKey<FormFieldState<String>> _telefonoResponsableFieldKey = GlobalKey<FormFieldState<String>>();
  final _nombresController = TextEditingController();
  final _apellidosController = TextEditingController();
  final _emailController = TextEditingController();
  final _telefonoController = TextEditingController();
  final _identificacionController = TextEditingController();
  final _tituloController = TextEditingController();
  final _especialidadController = TextEditingController();
  final _nombreResponsableController = TextEditingController();
  final _telefonoResponsableController = TextEditingController();

  bool _isLoading = false;
  bool _isInitialLoading = false;
  bool _activo = true;
  User? _user
  String? _selectedInstitutionId
  bool _isSelfEditing = false;
  String? _currentSessionUserRole;
  String? _emailError;

  @override
  void initState() {
    super.initState();
    final total = _getTotalSteps();
    _stepKeys = List.generate(total, (_) => GlobalKey<FormState>());
  }

  late List<GlobalKey<FormState>> _stepKeys;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      Future.microtask(() {
        _loadUserIfEditing();
        _loadInstitutionsIfNeeded();
      });
    });
  }

  Future<void> _loadUserIfEditing() async {
    if (_user != null || _isInitialLoading) return;

    final uri = GoRouterState.of(context).uri;
    final queryParams = uri.queryParameters;
    final navigator = GoRouter.of(context);
    final messenger = ScaffoldMessenger.of(context);
    final theme = Theme.of(context);

    setState(() => _isInitialLoading = true);

    try {
      final user = await _userFormService.loadUserForEditing(context, queryParams);
      if (user != null && mounted) {
        final authProvider = Provider.of<AuthProvider>(context, listen: false);
        final sessionUserId = authProvider.user?['id']?.toString();
        final sessionRole = authProvider.user?['rol'] as String?;
        setState(() {
          _user = user;
          _isSelfEditing = sessionUserId != null && sessionUserId == user.id;
          _currentSessionUserRole = sessionRole;
        });
        _fillFormWithUserData();
      }
    } catch (e) {
      if (!mounted) return;
      messenger.showSnackBar(
        SnackBar(
          content: Text(
            'Error al cargar usuario: ${e.toString()}',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: theme.colorScheme.onError,
            ),
          ),
          backgroundColor: theme.colorScheme.error,
        ),
      );
      navigator.go('/users');
    } finally {
      if (mounted) {
        setState(() => _isInitialLoading = false);
      }
    }
  }

  Future<void> _loadInstitutionsIfNeeded() async {
    await _userFormService.loadInstitutionsIfNeeded(context, widget.userRole);
    if (!mounted) return;
    if (widget.initialInstitutionId != null && _selectedInstitutionId == null) {
      final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);
      final exists = institutionProvider.institutions.any((i) => i.id == widget.initialInstitutionId);
      if (exists) _selectedInstitutionId = widget.initialInstitutionId;
    }
  }

  void _fillFormWithUserData() {
    final user = _user!;
    _userFormService.fillFormWithUserData(
      user,
      _nombresController,
      _apellidosController,
      _emailController,
      _telefonoController,
      _identificacionController,
      _tituloController,
      _especialidadController,
      _nombreResponsableController,
      _telefonoResponsableController,
      (value) => setState(() => _activo = value),
      (value) => setState(() => _selectedInstitutionId = value),
    );
  }

  @override
  void dispose() {
    _emailFocus.dispose();
    _institutionFocus.dispose();
    _nombresFocus.dispose();
    _apellidosFocus.dispose();
    _telefonoFocus.dispose();
    _identificacionFocus.dispose();
    _tituloFocus.dispose();
    _especialidadFocus.dispose();
    _nombreResponsableFocus.dispose();
    _telefonoResponsableFocus.dispose();
    _nombresController.dispose();
    _apellidosController.dispose();
    _emailController.dispose();
    _telefonoController.dispose();
    _identificacionController.dispose();
    _tituloController.dispose();
    _especialidadController.dispose();
    _nombreResponsableController.dispose();
    _telefonoResponsableController.dispose();
    super.dispose();
  }

  Future<void> _saveUser() async {
    final navigator = GoRouter.of(context);
    final messenger = ScaffoldMessenger.of(context);
    final theme = Theme.of(context);
    if (!_userFormService.validateAllSteps(_stepKeys)) {
      setState(() => _autoValidateMode = AutovalidateMode.always);
      messenger.showSnackBar(
        SnackBar(
          content: Text(
            'Corrige los campos marcados antes de guardar',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: theme.colorScheme.onPrimary,
            ),
          ),
          backgroundColor: theme.colorScheme.primary,
        ),
      );
      setState(() => _currentStep = _findFirstInvalidStep());
      _focusFirstInvalidField(_currentStep, context);
      return;
    }
    if (widget.userRole == 'admin_institucion' && _selectedInstitutionId == null) {
      messenger.showSnackBar(
        SnackBar(
          content: Text(
            'Debe seleccionar una instituciÃ³n',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: theme.colorScheme.onError,
            ),
          ),
          backgroundColor: theme.colorScheme.error,
        ),
      );
      return;
    }

    setState(() => _isLoading = true);

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final success = await _performSaveOperation(authProvider);

      if (success) {
        if (!mounted) return;
        messenger.showSnackBar(
          SnackBar(
            content: Text(
              '${_userFormService.getRoleDisplayName(widget.userRole)} ${_user != null ? 'actualizado' : 'creado'} exitosamente',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onPrimary,
              ),
            ),
            backgroundColor: theme.colorScheme.primary,
          ),
        );
        if (_user == null) {
          await _showPasswordDialog();
        }

        navigator.go('/users');
      }
    } catch (e) {
      if (!mounted) return;
      if (e is EmailAlreadyExistsException) {
        setState(() => _emailError = e.message);
        setState(() => _autoValidateMode = AutovalidateMode.always);
        setState(() => _currentStep = 0)
        _emailFocus.requestFocus();
      } else {
        messenger.showSnackBar(
          SnackBar(
            content: Text(
              'Error al ${_user != null ? 'actualizar' : 'crear'} ${_userFormService.getRoleDisplayName(widget.userRole)}: ${e.toString()}',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onError,
              ),
            ),
            backgroundColor: theme.colorScheme.error,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  Future<bool> _performSaveOperation(AuthProvider authProvider) async {
    if (_user != null) {
      final updateRequest = _userFormService.createUpdateRequest(
        email: _emailController.text,
        nombres: _nombresController.text,
        apellidos: _apellidosController.text,
        telefono: _telefonoController.text,
        identificacion: _identificacionController.text,
        userRole: widget.userRole,
        titulo: _tituloController.text,
        especialidad: _especialidadController.text,
        nombreResponsable: _nombreResponsableController.text,
        telefonoResponsable: _telefonoResponsableController.text,
        activo: _activo,
      );

      return await _userFormService.saveUser(
        context: context,
        user: _user,
        createRequest: null,
        updateRequest: updateRequest,
        userRole: widget.userRole,
      );
    } else {
      final createRequest = _userFormService.createUserRequest(
        email: _emailController.text,
        nombres: _nombresController.text,
        apellidos: _apellidosController.text,
        telefono: _telefonoController.text,
        identificacion: _identificacionController.text,
        userRole: widget.userRole,
        titulo: _tituloController.text,
        especialidad: _especialidadController.text,
        nombreResponsable: _nombreResponsableController.text,
        telefonoResponsable: _telefonoResponsableController.text,
        selectedInstitutionId: _selectedInstitutionId,
        authProvider: authProvider,
      );

      return await _userFormService.saveUser(
        context: context,
        user: null,
        createRequest: createRequest,
        updateRequest: null,
        userRole: widget.userRole,
      );
    }
  }

  Future<void> _showPasswordDialog() async {
    final tempPassword = _userFormService.generateRandomPassword();

    await showDialog<void>(
      context: context,
      barrierDismissible: false,
      builder: (context) {
        return AlertDialog(
          title: const Text('ContraseÃ±a temporal'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text('Se ha creado el usuario. Esta es la contraseÃ±a temporal (se mostrarÃ¡ sÃ³lo ahora):'),
              const SizedBox(height: 12),
              SelectableText(tempPassword, style: Theme.of(context).textTheme.headlineSmall),
              const SizedBox(height: 12),
              Text(
                'AsegÃºrate de copiarla y entregarla al usuario. No se podrÃ¡ volver a visualizar.',
                style: Theme.of(context).textTheme.bodySmall,
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () async {
                final navigator = Navigator.of(context);
                await Clipboard.setData(ClipboardData(text: tempPassword));
                if (!mounted) return;
                navigator.pop();
              },
              child: const Text('Copiar y Cerrar'),
            ),
          ],
        );
      },
    );
  }

  int _findFirstInvalidStep() {
    for (var i = 0; i < _stepKeys.length; i++) {
      final valid = _stepKeys[i].currentState?.validate() ?? true;
      if (!valid) {
        return i;
      }
    }
    return 0;
  }

  String _getRoleDisplayName(String role) {
    switch (role) {
      case 'profesor':
        return 'Profesor';
      case 'estudiante':
        return 'Estudiante';
      case 'admin_institucion':
        return 'Administrador de InstituciÃ³n';
      case 'super_admin':
        return 'Super Administrador';
      default:
        return 'Usuario';
    }
  }

  void _focusFirstInvalidField(int step, BuildContext context) {
    FormValidationService.focusFirstInvalidField(
      step,
      widget.userRole,
      {
        'email': _emailController,
        'nombres': _nombresController,
        'apellidos': _apellidosController,
        'telefono': _telefonoController,
        'identificacion': _identificacionController,
        'titulo': _tituloController,
        'especialidad': _especialidadController,
        'telefonoResponsable': _telefonoResponsableController,
      },
      {
        'email': _emailFocus,
        'nombres': _nombresFocus,
        'apellidos': _apellidosFocus,
        'telefono': _telefonoFocus,
        'identificacion': _identificacionFocus,
        'titulo': _tituloFocus,
        'especialidad': _especialidadFocus,
        'telefonoResponsable': _telefonoResponsableFocus,
      },
      {
        'email': _emailFieldKey,
        'nombres': _nombresFieldKey,
        'apellidos': _apellidosFieldKey,
        'telefono': _telefonoFieldKey,
        'identificacion': _identificacionFieldKey,
        'titulo': _tituloFieldKey,
        'especialidad': _especialidadFieldKey,
        'telefonoResponsable': _telefonoResponsableFieldKey,
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;
    final title = _user != null ? 'Editar Usuario' : 'Crear ${_getRoleDisplayName(widget.userRole)}';

    if (_isInitialLoading) {
      return Scaffold(
        backgroundColor: colors.background,
        appBar: AppBar(
          title: Text(title),
          backgroundColor: colors.primary,
          foregroundColor: colors.white,
        ),
        body: Center(
          child: const Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              CircularProgressIndicator(),
              SizedBox(height: 16),
              Text('Cargando usuario...'),
            ],
          ),
        ),
      );
    }
    final int totalSteps = _getTotalSteps();

    return Scaffold(
      backgroundColor: colors.background,
      appBar: AppBar(
        title: Text(title),
        backgroundColor: colors.primary,
        foregroundColor: colors.white,
      ),
      body: Form(
        key: _formKey,
        autovalidateMode: _autoValidateMode,
        child: Stepper(
          currentStep: _currentStep,
          onStepContinue: _onStepContinue,
          onStepCancel: _onStepCancel,
          onStepTapped: (step) => setState(() => _currentStep = step),
          controlsBuilder: (context, details) {
            final isLastStep = details.currentStep == totalSteps - 1;

            return Padding(
              padding: EdgeInsets.only(top: spacing.lg),
              child: Row(
                children: [
                  if (details.currentStep > 0) ...[
                    Expanded(
                      child: OutlinedButton(
                        onPressed: _isLoading ? null : details.onStepCancel,
                        style: OutlinedButton.styleFrom(
                          padding: EdgeInsets.symmetric(vertical: spacing.md),
                          side: BorderSide(color: colors.primary),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(spacing.borderRadius),
                          ),
                        ),
                        child: Text(
                          'Anterior',
                          style: textStyles.button.withColor(colors.primary),
                        ),
                      ),
                    ),
                    SizedBox(width: spacing.md),
                  ],
                  Expanded(
                    child: ElevatedButton(
                      key: const Key('formSaveButton'),
                      onPressed: _isLoading ? null : details.onStepContinue,
                      style: ElevatedButton.styleFrom(
                        padding: EdgeInsets.symmetric(vertical: spacing.md),
                        backgroundColor: colors.primary,
                        foregroundColor: colors.white,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(spacing.borderRadius),
                        ),
                      ),
                      child: _isLoading
                          ? const SizedBox(
                              height: 20,
                              width: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                              ),
                            )
                          : Text(
                              isLastStep ? (_user != null ? 'Actualizar' : 'Crear') : 'Siguiente',
                              style: textStyles.button.withColor(colors.white),
                            ),
                    ),
                  ),
                  if (details.currentStep == 0) ...[
                    SizedBox(width: spacing.md),
                    Expanded(
                      child: OutlinedButton(
                        onPressed: _isLoading ? null : () => context.pop(),
                        style: OutlinedButton.styleFrom(
                          padding: EdgeInsets.symmetric(vertical: spacing.md),
                          side: BorderSide(color: colors.error),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(spacing.borderRadius),
                          ),
                        ),
                        child: Text(
                          'Cancelar',
                          style: textStyles.button.withColor(colors.error),
                        ),
                      ),
                    ),
                  ],
                ],
              ),
            );
          },
          steps: _buildSteps(),
        ),
      ),
    );
  }

  int _getTotalSteps() {
    if (widget.userRole == 'profesor' || widget.userRole == 'estudiante') {
      return 3;
    }
    return 2
  }

  List<Step> _buildSteps() {
  final steps = <Step>[
      Step(
        title: const Text('Cuenta'),
        subtitle: const Text('Email y acceso'),
        content: Form(
          key: _stepKeys[0],
          child: UserAccountStep(
            emailController: _emailController,
            userRole: widget.userRole,
            selectedInstitutionId: _selectedInstitutionId,
            selectedInstitutionName: _user != null && (_user!.instituciones?.isNotEmpty ?? false) ? _user!.instituciones!.first.nombre : null,
            onInstitutionChanged: (value) => setState(() => _selectedInstitutionId = value),
            disableInstitution: _isSelfEditing && _currentSessionUserRole == 'admin_institucion',
            emailFocusNode: _emailFocus,
            institutionFocusNode: _institutionFocus,
            isEditMode: _user != null,
            emailFieldKey: _emailFieldKey,
            institutionFieldKey: _institutionFieldKey,
            errorEmail: _emailError,
          ),
        ),
        isActive: _currentStep >= 0,
        state: _currentStep > 0 ? StepState.complete : StepState.indexed,
      ),
      Step(
        title: const Text('Info Personal'),
        subtitle: const Text('Datos bÃ¡sicos'),
        content: Form(
          key: _stepKeys[1],
          child: UserPersonalInfoStep(
            nombresController: _nombresController,
            apellidosController: _apellidosController,
            telefonoController: _telefonoController,
            identificacionController: _identificacionController,
            userRole: widget.userRole,
            activo: _activo,
            onActivoChanged: (value) => setState(() => _activo = value),
            activoEditable: !(_isSelfEditing && _currentSessionUserRole == 'admin_institucion'),
            nombresFocusNode: _nombresFocus,
            apellidosFocusNode: _apellidosFocus,
            telefonoFocusNode: _telefonoFocus,
            identificacionFocusNode: _identificacionFocus,
             nombresFieldKey: _nombresFieldKey,
             apellidosFieldKey: _apellidosFieldKey,
             telefonoFieldKey: _telefonoFieldKey,
             identificacionFieldKey: _identificacionFieldKey,
          ),
        ),
        isActive: _currentStep >= 1,
        state: _currentStep > 1 ? StepState.complete : (_currentStep == 1 ? StepState.indexed : StepState.disabled),
      ),
    ];
    if (widget.userRole == 'profesor' || widget.userRole == 'estudiante') {
      steps.add(
        Step(
          title: const Text('Detalles'),
          subtitle: Text(widget.userRole == 'profesor' ? 'Info acadÃ©mica' : 'Responsable'),
          content: Form(
            key: _stepKeys[2],
            child: RoleSpecificDetailsStep(
              userRole: widget.userRole,
              tituloController: widget.userRole == 'profesor' ? _tituloController : null,
              especialidadController: widget.userRole == 'profesor' ? _especialidadController : null,
              nombreResponsableController: widget.userRole == 'estudiante' ? _nombreResponsableController : null,
              telefonoResponsableController: widget.userRole == 'estudiante' ? _telefonoResponsableController : null,
              tituloFocusNode: _tituloFocus,
              especialidadFocusNode: _especialidadFocus,
              nombreResponsableFocusNode: _nombreResponsableFocus,
              telefonoResponsableFocusNode: _telefonoResponsableFocus,
              tituloFieldKey: _tituloFieldKey,
              especialidadFieldKey: _especialidadFieldKey,
              nombreResponsableFieldKey: _nombreResponsableFieldKey,
              telefonoResponsableFieldKey: _telefonoResponsableFieldKey,
            ),
          ),
          isActive: _currentStep >= 2,
          state: _currentStep == 2 ? StepState.indexed : StepState.disabled,
        ),
      );
    }

    return steps;
  }

  void _onStepContinue() {
    final totalSteps = _getTotalSteps();
    final currentStepValid = _stepKeys[_currentStep].currentState?.validate() ?? true;
    if (!currentStepValid) {
      setState(() => _autoValidateMode = AutovalidateMode.always);

      final messenger = ScaffoldMessenger.of(context);
      final theme = Theme.of(context);
      messenger.showSnackBar(
        SnackBar(
          content: Text(
            'Corrige los campos marcados antes de continuar',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: theme.colorScheme.onPrimary,
            ),
          ),
          backgroundColor: theme.colorScheme.primary,
        ),
      );
  _focusFirstInvalidField(_currentStep, context);

      return;
    }

    if (_currentStep < totalSteps - 1) {
      setState(() => _currentStep++);
    } else {
      _saveUser();
    }
  }

  void _onStepCancel() {
    if (_currentStep > 0) {
      setState(() => _currentStep--);
    }
  }
}
/* Fin lib\screens\users\user_form_screen.dart */

/* Inicio lib\services\academic\grupo_service.dart */
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';
import '../../config/app_config.dart';
import '../../models/grupo.dart';
import '../../models/user.dart';

class PaginatedGruposResponse {
  final List<Grupo> grupos;
  final PaginationInfo pagination;

  PaginatedGruposResponse({
    required this.grupos,
    required this.pagination,
  });
}

class PaginatedUsersResponse {
  final List<User> users;
  final PaginationInfo pagination;

  PaginatedUsersResponse({
    required this.users,
    required this.pagination,
  });
}

class GrupoService {
  Future<PaginatedGruposResponse?> getGrupos(String accessToken, {int? page, int? limit, String? periodoId, String? search}) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      if (limit != null) queryParams['limit'] = limit.toString();
      if (periodoId != null && periodoId.isNotEmpty) queryParams['periodoId'] = periodoId;
      if (search != null && search.isNotEmpty) queryParams['search'] = search;

      final uri = Uri.parse('$baseUrlValue/grupos').replace(queryParameters: queryParams);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /grupos - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final grupos = (responseData['data'] as List)
              .map((grupoJson) => Grupo.fromJson(grupoJson))
              .toList();
          final pagination = PaginationInfo.fromJson(responseData['pagination']);
          return PaginatedGruposResponse(grupos: grupos, pagination: pagination);
        }
      } else {
        debugPrint('Error getting grupos: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting grupos: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Grupo?> getGrupoById(String accessToken, String grupoId) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/grupos/$grupoId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /grupos/$grupoId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Grupo.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error getting grupo: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting grupo: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Grupo?> createGrupo(String accessToken, CreateGrupoRequest grupoData) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/grupos'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(grupoData.toJson()),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('POST /grupos - Status: ${response.statusCode}');

      if (response.statusCode == 201) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Grupo.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error creating grupo: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error creating grupo: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Grupo?> updateGrupo(String accessToken, String grupoId, UpdateGrupoRequest grupoData) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.put(
        Uri.parse('$baseUrlValue/grupos/$grupoId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(grupoData.toJson()),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PUT /grupos/$grupoId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Grupo.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error updating grupo: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error updating grupo: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<bool> deleteGrupo(String accessToken, String grupoId) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.delete(
        Uri.parse('$baseUrlValue/grupos/$grupoId'),
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('DELETE /grupos/$grupoId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      } else {
        debugPrint('Error deleting grupo: ${response.statusCode} - ${response.body}');
        return false;
      }
    } catch (e, stackTrace) {
      debugPrint('Error deleting grupo: $e');
      debugPrint('StackTrace: $stackTrace');
      return false;
    }
  }
  Future<PaginatedUsersResponse?> getEstudiantesByGrupo(String accessToken, String grupoId, {int? page, int? limit}) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      if (limit != null) queryParams['limit'] = limit.toString();

      final uri = Uri.parse('$baseUrlValue/grupos/$grupoId/estudiantes').replace(queryParameters: queryParams);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /grupos/$grupoId/estudiantes - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final users = (responseData['data'] as List).map((userJson) {
            if (userJson is Map && userJson['usuario'] is Map) {
              final usuario = userJson['usuario'] as Map<String, dynamic>;
              userJson['nombres'] ??= usuario['nombres'];
              userJson['apellidos'] ??= usuario['apellidos'];
              userJson['email'] ??= usuario['email'];
            }
            return User.fromJson(userJson);
          }).toList();
          final pagination = PaginationInfo.fromJson(responseData['pagination']);
          return PaginatedUsersResponse(users: users, pagination: pagination);
        }
      } else {
        debugPrint('Error getting estudiantes by grupo: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting estudiantes by grupo: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<PaginatedUsersResponse?> getEstudiantesSinAsignar(String accessToken, {int? page, int? limit}) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      if (limit != null) queryParams['limit'] = limit.toString();

      final uri = Uri.parse('$baseUrlValue/grupos/estudiantes-sin-asignar').replace(queryParameters: queryParams);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /grupos/estudiantes-sin-asignar - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final users = (responseData['data'] as List).map((userJson) {
            if (userJson is Map && userJson['usuario'] is Map) {
              final usuario = userJson['usuario'] as Map<String, dynamic>;
              userJson['nombres'] ??= usuario['nombres'];
              userJson['apellidos'] ??= usuario['apellidos'];
              userJson['email'] ??= usuario['email'];
            }
            return User.fromJson(userJson);
          }).toList();
          final pagination = PaginationInfo.fromJson(responseData['pagination']);
          return PaginatedUsersResponse(users: users, pagination: pagination);
        }
      } else {
        debugPrint('Error getting estudiantes sin asignar: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting estudiantes sin asignar: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<bool> asignarEstudianteAGrupo(String accessToken, String grupoId, String estudianteId) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/grupos/$grupoId/asignar-estudiante'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode({'estudianteId': estudianteId}),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('POST /grupos/$grupoId/asignar-estudiante - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      } else {
        debugPrint('Error asignando estudiante a grupo: ${response.statusCode} - ${response.body}');
        return false;
      }
    } catch (e, stackTrace) {
      debugPrint('Error asignando estudiante a grupo: $e');
      debugPrint('StackTrace: $stackTrace');
      return false;
    }
  }
  Future<bool> desasignarEstudianteDeGrupo(String accessToken, String grupoId, String estudianteId) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/grupos/$grupoId/desasignar-estudiante'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode({'estudianteId': estudianteId}),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('POST /grupos/$grupoId/desasignar-estudiante - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      } else {
        debugPrint('Error desasignando estudiante de grupo: ${response.statusCode} - ${response.body}');
        return false;
      }
    } catch (e, stackTrace) {
      debugPrint('Error desasignando estudiante de grupo: $e');
      debugPrint('StackTrace: $stackTrace');
      return false;
    }
  }
}

class CreateGrupoRequest {
  final String nombre;
  final String grado;
  final String? seccion;
  final String periodoId;

  CreateGrupoRequest({
    required this.nombre,
    required this.grado,
    this.seccion,
    required this.periodoId,
  });

  Map<String, dynamic> toJson() {
    return {
      'nombre': nombre,
      'grado': grado,
      'seccion': seccion,
      'periodoId': periodoId,
    };
  }
}

class UpdateGrupoRequest {
  final String nombre;
  final String grado;
  final String? seccion;

  UpdateGrupoRequest({
    required this.nombre,
    required this.grado,
    this.seccion,
  });

  Map<String, dynamic> toJson() {
    return {
      'nombre': nombre,
      'grado': grado,
      'seccion': seccion,
    };
  }
}
/* Fin lib\services\academic\grupo_service.dart */

/* Inicio lib\services\academic\horario_service.dart */
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';
import '../../config/app_config.dart';
import '../../models/horario.dart';
import '../../models/clase_del_dia.dart';
import '../../models/user.dart';

class PaginatedHorariosResponse {
  final List<Horario> horarios;
  final PaginationInfo pagination;

  PaginatedHorariosResponse({
    required this.horarios,
    required this.pagination,
  });
}

class HorarioService {
  Future<PaginatedHorariosResponse?> getHorarios(String accessToken, {int? page, int? limit, String? grupoId, String? periodoId}) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      if (limit != null) queryParams['limit'] = limit.toString();
      if (grupoId != null && grupoId.isNotEmpty) queryParams['grupoId'] = grupoId;
      if (periodoId != null && periodoId.isNotEmpty) queryParams['periodoId'] = periodoId;

      final uri = Uri.parse('$baseUrlValue/horarios').replace(queryParameters: queryParams);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /horarios - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final horarios = (responseData['data'] as List)
              .map((horarioJson) => Horario.fromJson(horarioJson))
              .toList();
          final pagination = PaginationInfo.fromJson(responseData['pagination']);
          return PaginatedHorariosResponse(horarios: horarios, pagination: pagination);
        }
      } else {
        debugPrint('Error getting horarios: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting horarios: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<List<Horario>?> getHorariosPorGrupo(String accessToken, String grupoId) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final uri = Uri.parse('$baseUrlValue/horarios').replace(queryParameters: {'grupoId': grupoId});

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /horarios?grupoId=$grupoId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        debugPrint('Response data: ${responseData.toString().substring(0, 500)}');
        if (responseData['success'] == true && responseData['data'] != null) {
          try {
            final List<dynamic> horariosList = responseData['data'] as List<dynamic>;
            debugPrint('Parsing ${horariosList.length} horarios...');

            final result = <Horario>[];
            for (int i = 0; i < horariosList.length; i++) {
              try {
                debugPrint('=== Iniciando parseo de horario $i ===');
                final horarioJson = horariosList[i] as Map<String, dynamic>;
                debugPrint('Horario JSON keys: ${horarioJson.keys.toList()}');
                debugPrint('Horario grado: ${horarioJson['grupo']?['grado']}');
                debugPrint('Horario materia nombre: ${horarioJson['materia']?['nombre']}');
                debugPrint('Horario profesor: ${horarioJson['profesor']}');

                final horario = Horario.fromJson(horarioJson);
                result.add(horario);
                debugPrint('âœ… Horario $i parseado exitosamente');
              } catch (e, stackTrace) {
                debugPrint('âŒ Error parseando horario $i: $e');
                debugPrint('StackTrace: $stackTrace');
                debugPrint('Data: ${horariosList[i]}');
              }
            }
            debugPrint('Total horarios cargados: ${result.length}');
            return result;
          } catch (e) {
            debugPrint('Error parseando lista de horarios: $e');
            return null;
          }
        } else {
          debugPrint('Response sin success o data vacÃ­a');
          return null;
        }
      } else {
        debugPrint('Error getting horarios por grupo: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting horarios por grupo: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
  }
  Future<Horario?> getHorarioById(String accessToken, String horarioId) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/horarios/$horarioId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /horarios/$horarioId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Horario.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error getting horario: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting horario: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Horario?> createHorario(String accessToken, CreateHorarioRequest horarioData) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/horarios'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(horarioData.toJson()),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('POST /horarios - Status: ${response.statusCode}');

      if (response.statusCode == 201) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Horario.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error updating horario: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error updating horario: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Horario?> updateHorario(String accessToken, String horarioId, UpdateHorarioRequest horarioData) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.put(
        Uri.parse('$baseUrlValue/horarios/$horarioId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(horarioData.toJson()),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PUT /horarios/$horarioId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Horario.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error updating horario: ${response.statusCode} - ${response.body}');
        String serverMessage = response.body;
        String code = '';
        String reason = '';
        dynamic meta;
        try {
          final parsed = jsonDecode(response.body);
          serverMessage = parsed['error'] ?? parsed['message'] ?? response.body;
          code = parsed['code'] ?? '';
          reason = parsed['reason'] ?? '';
          meta = parsed['meta'] ?? parsed['errorMeta'];
        } catch (_) {}
        throw Exception('${response.statusCode} - $serverMessage - $code - $reason - ${meta != null ? jsonEncode(meta) : ''}');
      }
    } catch (e, stackTrace) {
      debugPrint('Error updating horario: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<bool> deleteHorario(String accessToken, String horarioId) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.delete(
        Uri.parse('$baseUrlValue/horarios/$horarioId'),
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('DELETE /horarios/$horarioId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      } else {
        debugPrint('Error deleting horario: ${response.statusCode} - ${response.body}');
        return false;
      }
    } catch (e, stackTrace) {
      debugPrint('Error deleting horario: $e');
      debugPrint('StackTrace: $stackTrace');
      return false;
    }
  }
  Future<List<ClaseDelDia>?> getMisClasesDelDia(String accessToken) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/profesores/dashboard/clases-hoy'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /profesores/dashboard/clases-hoy - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return (responseData['data'] as List)
              .map((claseJson) => ClaseDelDia.fromJson(claseJson))
              .toList();
        }
      } else {
        debugPrint('Error getting clases del dia: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting clases del dia: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<List<ClaseDelDia>?> getMisClasesPorDia(String accessToken, int diaSemana) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/profesores/dashboard/clases/$diaSemana'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /profesores/dashboard/clases/$diaSemana - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return (responseData['data'] as List)
              .map((claseJson) => ClaseDelDia.fromJson(claseJson))
              .toList();
        }
      } else {
        debugPrint('Error getting clases por dia: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting clases por dia: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<List<ClaseDelDia>?> getMiHorarioSemanal(String accessToken) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/profesores/dashboard/horario-semanal'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /profesores/dashboard/horario-semanal - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return (responseData['data'] as List)
              .map((claseJson) => ClaseDelDia.fromJson(claseJson))
              .toList();
        }
      } else {
        debugPrint('Error getting horario semanal: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting horario semanal: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
}

class CreateHorarioRequest {
  final String periodoId;
  final String grupoId;
  final String materiaId;
  final String? profesorId;
  final int diaSemana;
  final String horaInicio;
  final String horaFin;

  CreateHorarioRequest({
    required this.periodoId,
    required this.grupoId,
    required this.materiaId,
    this.profesorId,
    required this.diaSemana,
    required this.horaInicio,
    required this.horaFin,
  });

  Map<String, dynamic> toJson() {
    return {
      'periodoId': periodoId,
      'grupoId': grupoId,
      'materiaId': materiaId,
      'profesorId': profesorId,
      'diaSemana': diaSemana,
      'horaInicio': horaInicio,
      'horaFin': horaFin,
    };
  }
}

class UpdateHorarioRequest {
  final String? profesorId;
  final int diaSemana;
  final String horaInicio;
  final String horaFin;

  UpdateHorarioRequest({
    this.profesorId,
    required this.diaSemana,
    required this.horaInicio,
    required this.horaFin,
  });

  Map<String, dynamic> toJson() {
    return {
      'profesorId': profesorId,
      'diaSemana': diaSemana,
      'horaInicio': horaInicio,
      'horaFin': horaFin,
    };
  }
}
/* Fin lib\services\academic\horario_service.dart */

/* Inicio lib\services\academic\materia_service.dart */
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';
import '../../config/app_config.dart';
import '../../models/materia.dart';
import '../../models/user.dart';

class PaginatedMateriasResponse {
  final List<Materia> materias;
  final PaginationInfo pagination;

  PaginatedMateriasResponse({
    required this.materias,
    required this.pagination,
  });
}

class MateriaService {
  Future<PaginatedMateriasResponse?> getMaterias(String accessToken, {int? page, int? limit, String? search}) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      if (limit != null) queryParams['limit'] = limit.toString();
      if (search != null && search.isNotEmpty) queryParams['search'] = search;

      final uri = Uri.parse('$baseUrlValue/materias').replace(queryParameters: queryParams);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /materias - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final materias = (responseData['data'] as List)
              .map((materiaJson) => Materia.fromJson(materiaJson))
              .toList();
          final pagination = PaginationInfo.fromJson(responseData['pagination']);
          return PaginatedMateriasResponse(materias: materias, pagination: pagination);
        }
      } else {
        debugPrint('Error getting materias: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting materias: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Materia?> getMateriaById(String accessToken, String materiaId) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/materias/$materiaId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /materias/$materiaId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Materia.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error getting materia: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting materia: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Materia?> createMateria(String accessToken, CreateMateriaRequest materiaData) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/materias'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(materiaData.toJson()),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('POST /materias - Status: ${response.statusCode}');

      if (response.statusCode == 201) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Materia.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error creating materia: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error creating materia: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Materia?> updateMateria(String accessToken, String materiaId, UpdateMateriaRequest materiaData) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.put(
        Uri.parse('$baseUrlValue/materias/$materiaId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(materiaData.toJson()),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PUT /materias/$materiaId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Materia.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error updating materia: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error updating materia: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<bool> deleteMateria(String accessToken, String materiaId) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.delete(
        Uri.parse('$baseUrlValue/materias/$materiaId'),
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('DELETE /materias/$materiaId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      } else {
        debugPrint('Error deleting materia: ${response.statusCode} - ${response.body}');
        return false;
      }
    } catch (e, stackTrace) {
      debugPrint('Error deleting materia: $e');
      debugPrint('StackTrace: $stackTrace');
      return false;
    }
  }
}

class CreateMateriaRequest {
  final String nombre;
  final String? codigo;

  CreateMateriaRequest({
    required this.nombre,
    this.codigo,
  });

  Map<String, dynamic> toJson() {
    return {
      'nombre': nombre,
      'codigo': codigo,
    };
  }
}

class UpdateMateriaRequest {
  final String nombre;
  final String? codigo;

  UpdateMateriaRequest({
    required this.nombre,
    this.codigo,
  });

  Map<String, dynamic> toJson() {
    return {
      'nombre': nombre,
      'codigo': codigo,
    };
  }
}
/* Fin lib\services\academic\materia_service.dart */

/* Inicio lib\services\academic\periodo_service.dart */
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';
import '../../config/app_config.dart';
import '../../models/grupo.dart';
import '../../models/user.dart';

class PaginatedPeriodosAcademicosResponse {
  final List<PeriodoAcademico> periodosAcademicos;
  final PaginationInfo pagination;

  PaginatedPeriodosAcademicosResponse({
    required this.periodosAcademicos,
    required this.pagination,
  });
}

class PeriodoService {
  Future<PaginatedPeriodosAcademicosResponse?> getPeriodosAcademicos(String accessToken, {int? page, int? limit}) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      if (limit != null) queryParams['limit'] = limit.toString();

      final uri = Uri.parse('$baseUrlValue/periodos-academicos').replace(queryParameters: queryParams);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /periodos-academicos - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final periodos = (responseData['data'] as List)
              .map((periodoJson) => PeriodoAcademico.fromJson(periodoJson))
              .toList();
          final pagination = PaginationInfo.fromJson(responseData['pagination']);
          return PaginatedPeriodosAcademicosResponse(periodosAcademicos: periodos, pagination: pagination);
        }
      } else {
        debugPrint('Error getting periodos acadÃ©micos: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting periodos acadÃ©micos: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<List<PeriodoAcademico>?> getPeriodosActivos(String accessToken) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/periodos-academicos/activos'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /periodos-academicos/activos - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return (responseData['data'] as List)
              .map((periodoJson) => PeriodoAcademico.fromJson(periodoJson))
              .toList();
        }
      } else {
        debugPrint('Error getting periodos activos: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting periodos activos: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<PeriodoAcademico?> getPeriodoAcademicoById(String accessToken, String periodoId) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/periodos-academicos/$periodoId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /periodos-academicos/$periodoId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return PeriodoAcademico.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error getting perÃ­odo acadÃ©mico: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting perÃ­odo acadÃ©mico: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<PeriodoAcademico?> createPeriodoAcademico(String accessToken, CreatePeriodoAcademicoRequest periodoData) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/periodos-academicos'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(periodoData.toJson()),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('POST /periodos-academicos - Status: ${response.statusCode}');

      if (response.statusCode == 201) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return PeriodoAcademico.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error creating perÃ­odo acadÃ©mico: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error creating perÃ­odo acadÃ©mico: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<PeriodoAcademico?> updatePeriodoAcademico(String accessToken, String periodoId, UpdatePeriodoAcademicoRequest periodoData) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.put(
        Uri.parse('$baseUrlValue/periodos-academicos/$periodoId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(periodoData.toJson()),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PUT /periodos-academicos/$periodoId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return PeriodoAcademico.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error updating perÃ­odo acadÃ©mico: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error updating perÃ­odo acadÃ©mico: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<bool> deletePeriodoAcademico(String accessToken, String periodoId) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.delete(
        Uri.parse('$baseUrlValue/periodos-academicos/$periodoId'),
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('DELETE /periodos-academicos/$periodoId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      } else {
        debugPrint('Error deleting perÃ­odo acadÃ©mico: ${response.statusCode} - ${response.body}');
        return false;
      }
    } catch (e, stackTrace) {
      debugPrint('Error deleting perÃ­odo acadÃ©mico: $e');
      debugPrint('StackTrace: $stackTrace');
      return false;
    }
  }
  Future<PeriodoAcademico?> togglePeriodoStatus(String accessToken, String periodoId) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.patch(
        Uri.parse('$baseUrlValue/periodos-academicos/$periodoId/toggle-status'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PATCH /periodos-academicos/$periodoId/toggle-status - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return PeriodoAcademico.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error toggling perÃ­odo status: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error toggling perÃ­odo status: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
}

class CreatePeriodoAcademicoRequest {
  final String nombre;
  final String fechaInicio;
  final String fechaFin;

  CreatePeriodoAcademicoRequest({
    required this.nombre,
    required this.fechaInicio,
    required this.fechaFin,
  });

  Map<String, dynamic> toJson() {
    return {
      'nombre': nombre,
      'fechaInicio': fechaInicio,
      'fechaFin': fechaFin,
    };
  }
}

class UpdatePeriodoAcademicoRequest {
  final String nombre;
  final String fechaInicio;
  final String fechaFin;

  UpdatePeriodoAcademicoRequest({
    required this.nombre,
    required this.fechaInicio,
    required this.fechaFin,
  });

  Map<String, dynamic> toJson() {
    return {
      'nombre': nombre,
      'fechaInicio': fechaInicio,
      'fechaFin': fechaFin,
    };
  }
}
/* Fin lib\services\academic\periodo_service.dart */

/* Inicio lib\services\asistencia_service.dart */
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';
import '../config/app_config.dart';
import '../models/asistencia_estudiante.dart';

class AsistenciaService {
  Future<bool> registrarAsistencia({
    required String accessToken,
    required String horarioId,
    required String codigoQr,
  }) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;

      final response = await http.post(
        Uri.parse('$baseUrlValue/asistencias/registrar'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode({
          'horarioId': horarioId,
          'codigoQr': codigoQr,
        }),
      ).timeout(
        const Duration(seconds: 15),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('POST /asistencias/registrar - Status: ${response.statusCode}');

      if (response.statusCode == 201) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          debugPrint('âœ… Asistencia registrada exitosamente');
          return true;
        } else {
          throw Exception(responseData['message'] ?? 'Error al registrar asistencia');
        }
      } else if (response.statusCode == 400) {
        final responseData = jsonDecode(response.body);
        final errorMsg = responseData['message'] ??
                        responseData['error'] ??
                        'Datos invÃ¡lidos';
        throw Exception(errorMsg);
      } else if (response.statusCode == 403) {
        final responseData = jsonDecode(response.body);
        final errorMsg = responseData['message'] ??
                        responseData['error'] ??
                        'No tienes permisos para esta acciÃ³n';
        throw Exception(errorMsg);
      } else if (response.statusCode == 404) {
        final responseData = jsonDecode(response.body);
        throw Exception(responseData['error'] ?? 'Horario o estudiante no encontrado');
      } else if (response.statusCode == 500) {
        try {
          final responseData = jsonDecode(response.body);
          final errorMessage = responseData['error'] ??
                              responseData['message'] ??
                              'Error interno del servidor';
          throw Exception(errorMessage);
        } catch (e) {
          throw Exception('Error interno del servidor');
        }
      } else {
        throw Exception('Error del servidor: ${response.statusCode}');
      }
    } catch (e) {
      debugPrint('âŒ Error al registrar asistencia: $e');
      rethrow;
    }
  }
  Future<bool> registrarAsistenciaManual({
    required String accessToken,
    required String horarioId,
    required String estudianteId,
  }) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;

      final response = await http.post(
        Uri.parse('$baseUrlValue/asistencias/registrar-manual'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode({
          'horarioId': horarioId,
          'estudianteId': estudianteId,
        }),
      ).timeout(
        const Duration(seconds: 15),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('POST /asistencias/registrar-manual - Status: ${response.statusCode}');

      if (response.statusCode == 201) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          debugPrint('âœ… Asistencia manual registrada exitosamente');
          return true;
        } else {
          throw Exception(responseData['message'] ?? 'Error al registrar asistencia manual');
        }
      } else if (response.statusCode == 400) {
        final responseData = jsonDecode(response.body);
        throw Exception(responseData['message'] ?? 'Datos invÃ¡lidos');
      } else if (response.statusCode == 403) {
        final responseData = jsonDecode(response.body);
        throw Exception(responseData['message'] ?? 'No tienes permisos para esta acciÃ³n');
      } else if (response.statusCode == 404) {
        final responseData = jsonDecode(response.body);
        throw Exception(responseData['message'] ?? 'Horario o estudiante no encontrado');
      } else if (response.statusCode == 500) {
        try {
          final responseData = jsonDecode(response.body);
          final errorMessage = responseData['error'] ??
                              responseData['message'] ??
                              'Error interno del servidor';
          throw Exception(errorMessage);
        } catch (e) {
          throw Exception('Error interno del servidor');
        }
      } else {
        throw Exception('Error del servidor: ${response.statusCode}');
      }
    } catch (e) {
      debugPrint('âŒ Error al registrar asistencia manual: $e');
      rethrow;
    }
  }
  Future<List<AsistenciaEstudiante>> getAsistencias({
    required String accessToken,
    required String horarioId,
    DateTime? date,
  }) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final url = date != null
          ? '$baseUrlValue/horarios/$horarioId/asistencias?date=${date.toIso8601String().split('T')[0]}'
          : '$baseUrlValue/horarios/$horarioId/asistencias';

      final response = await http.get(
        Uri.parse(url),
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 15),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /horarios/$horarioId/asistencias - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final List<dynamic> asistenciasJson = responseData['data'];
          final asistencias = asistenciasJson
              .map((json) => AsistenciaEstudiante.fromJson(json))
              .toList();
          debugPrint('âœ… Obtenidas ${asistencias.length} asistencias');
          return asistencias;
        } else {
          throw Exception(responseData['message'] ?? 'Error al obtener asistencias');
        }
      } else if (response.statusCode == 404) {
        throw Exception('Horario no encontrado');
      } else {
        throw Exception('Error del servidor: ${response.statusCode}');
      }
    } catch (e) {
      debugPrint('âŒ Error al obtener asistencias: $e');
      rethrow;
    }
  }
  Future<bool> updateAsistencia({
    required String accessToken,
    required String asistenciaId,
    required String estado,
    String? observacion,
    bool? justificada,
  }) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;

      final response = await http.put(
        Uri.parse('$baseUrlValue/asistencias/$asistenciaId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode({
          'estado': estado,
          'observacion': observacion,
          'justificada': justificada,
        }),
      ).timeout(
        const Duration(seconds: 15),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PUT /asistencias/$asistenciaId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          debugPrint('âœ… Asistencia actualizada exitosamente');
          return true;
        } else {
          throw Exception(responseData['message'] ?? 'Error al actualizar asistencia');
        }
      } else {
        final responseData = jsonDecode(response.body);
        final errorMsg = responseData['message'] ??
                        responseData['error'] ??
                        'Error al actualizar asistencia';
        throw Exception(errorMsg);
      }
    } catch (e) {
      debugPrint('âŒ Error al actualizar asistencia: $e');
      rethrow;
    }
  }
}
/* Fin lib\services\asistencia_service.dart */

/* Inicio lib\services\auth_service.dart */
import 'dart:convert';
import 'package:flutter/material.dart';
import '../config/app_config.dart';
import '../utils/http_client.dart';

class LoginResponse {
  final String accessToken;
  final String refreshToken;
  final Map<String, dynamic> user;
  final int? expiresIn;

  LoginResponse({
    required this.accessToken,
    required this.refreshToken,
    required this.user,
    this.expiresIn,
  });

  factory LoginResponse.fromJson(Map<String, dynamic> json) {

    final data = json['data'] ?? json;

    final usuario = data['usuario'] ?? data['user'];

    return LoginResponse(
      accessToken: data['accessToken'] as String,
      refreshToken: data['refreshToken'] as String,
      user: usuario is Map<String, dynamic> ? usuario : {},
      expiresIn: data['expiresIn'] as int?,
    );
  }
}

class RefreshResponse {
  final String accessToken;
  final String refreshToken;

  RefreshResponse({
    required this.accessToken,
    required this.refreshToken,
  });

  factory RefreshResponse.fromJson(Map<String, dynamic> json) {
    return RefreshResponse(
      accessToken: json['accessToken'],
      refreshToken: json['refreshToken'],
    );
  }
}

class AuthService {
  final BuildContext? context;
  late final AppHttpClient _httpClient;

  AuthService({this.context}) {
    _httpClient = AppHttpClient(context: context);
  }

  Future<LoginResponse?> login(String email, String password) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final url = '$baseUrlValue/auth/login';

      final requestBody = jsonEncode({
        'email': email,
        'password': password,
      });

      debugPrint('AuthService.login - URL: $url');
      debugPrint('AuthService.login - Config Base URL: $baseUrlValue');

      final response = await _httpClient.post(
        Uri.parse(url),
        body: requestBody,
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('   Status: ${response.statusCode}');
      debugPrint('   Body: ${response.body}');
      debugPrint('========================================');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);

        final data = responseData['data'] ?? responseData;

        if (data['accessToken'] == null || data['refreshToken'] == null) {
          debugPrint('   accessToken: ${data['accessToken']}');
          debugPrint('   refreshToken: ${data['refreshToken']}');
          debugPrint('   usuario: ${data['usuario']}');
          return null;
        }

        return LoginResponse.fromJson(responseData);
      } else {
        debugPrint('   Response: ${response.body}');
        try {
          final Map<String, dynamic> errorData = jsonDecode(response.body);
          final serverMessage = errorData['message'] ??
                                errorData['error'] ??
                                (errorData['data'] is Map ? errorData['data']['message'] : null) ??
                                response.body;
          throw Exception(serverMessage);
        } catch (parseError) {
          throw Exception(response.body);
        }
      }
    } on UnauthorizedException {
      debugPrint('SesiÃ³n expirada durante login');
      return null;
    } catch (e, stackTrace) {
      debugPrint('Error: $e');
      debugPrint('StackTrace: $stackTrace');
      rethrow;
    }
  }

  Future<RefreshResponse?> refreshToken(String refreshToken) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await _httpClient.post(
        Uri.parse('$baseUrlValue/auth/refresh'),
        body: jsonEncode({'refreshToken': refreshToken}),
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        return RefreshResponse.fromJson(data);
      } else {
        debugPrint('Refresh failed: ${response.statusCode} - ${response.body}');
        return null;
      }
    } on UnauthorizedException {
      debugPrint('Refresh token expirado');
      return null;
    } catch (e) {
      debugPrint('Refresh error: $e');
      return null;
    }
  }

  Future<bool> logout(String refreshToken) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await _httpClient.post(
        Uri.parse('$baseUrlValue/auth/logout'),
        body: jsonEncode({'refreshToken': refreshToken}),
      );

      return response.statusCode == 200;
    } on UnauthorizedException {
      return true;
    } catch (e) {
      debugPrint('Logout error: $e');
      return false;
    }
  }

  Future<List<Map<String, dynamic>>?> getUserInstitutions(String accessToken) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await _httpClient.get(
        Uri.parse('$baseUrlValue/auth/institutions'),
        headers: {'Authorization': 'Bearer $accessToken'},
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        if (data['success'] == true) {
          final institutions = data['data'] as List;
          return institutions.map((e) => e as Map<String, dynamic>).toList();
        }
      } else {
        debugPrint('Get user institutions failed: ${response.statusCode} - ${response.body}');
        return null;
      }
    } on UnauthorizedException {
      return null;
    } catch (e) {
      debugPrint('Get user institutions error: $e');
      return null;
    }
    return null;
  }

  void dispose() {
    _httpClient.close();
  }
}
/* Fin lib\services\auth_service.dart */

/* Inicio lib\services\estudiante_service.dart */
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';
import '../config/app_config.dart';

class EstudianteService {
  Future<Map<String, dynamic>?> getEstudianteInfo({
    required String accessToken,
  }) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;

      final response = await http.get(
        Uri.parse('$baseUrlValue/estudiantes/me'),
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 15),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /estudiantes/me - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return responseData['data'] as Map<String, dynamic>;
        } else {
          throw Exception(responseData['message'] ?? 'Error al obtener informaciÃ³n del estudiante');
        }
      } else if (response.statusCode == 404) {
        throw Exception('Perfil de estudiante no encontrado');
      } else {
        throw Exception('Error del servidor: ${response.statusCode}');
      }
    } catch (e) {
      debugPrint('âŒ Error al obtener informaciÃ³n del estudiante: $e');
      rethrow;
    }
  }
}
/* Fin lib\services\estudiante_service.dart */

/* Inicio lib\services\form_validation_service.dart */
import 'package:flutter/material.dart';
class FormValidationService {
  static final RegExp _emailRegex = RegExp(r'^[^@\s]+@[^@\s]+\.[^@\s]+$');
  static final RegExp _phoneRegex = RegExp(r'^\+?[0-9\s\-\(\)]+$');
  static String? validateEmail(String? value) {
    if (value == null || value.trim().isEmpty) {
      return 'El email es obligatorio';
    }

    final email = value.trim();
    if (!_emailRegex.hasMatch(email)) {
      return 'Ingresa un email vÃ¡lido';
    }

    return null;
  }
  static String? validateNombres(String? value) {
    if (value == null || value.trim().isEmpty) {
      return 'Los nombres son obligatorios';
    }

    final nombres = value.trim();
    if (nombres.length < 2) {
      return 'Los nombres deben tener al menos 2 caracteres';
    }

    return null;
  }
  static String? validateApellidos(String? value) {
    if (value == null || value.trim().isEmpty) {
      return 'Los apellidos son obligatorios';
    }

    final apellidos = value.trim();
    if (apellidos.length < 2) {
      return 'Los apellidos deben tener al menos 2 caracteres';
    }

    return null;
  }
  static String? validateTelefono(String? value) {
    if (value == null || value.trim().isEmpty) {
      return null
    }

    final telefono = value.trim();
    if (!_phoneRegex.hasMatch(telefono)) {
      return 'Ingresa un nÃºmero de telÃ©fono vÃ¡lido';
    }

    return null;
  }
  static String? validateIdentificacion(String? value, String userRole) {
    if (userRole == 'admin_institucion' || userRole == 'super_admin') {
      return null;
    }

    if (value == null || value.trim().isEmpty) {
      return 'La identificaciÃ³n es obligatoria';
    }

    final identificacion = value.trim();
    if (identificacion.length < 5) {
      return 'La identificaciÃ³n debe tener al menos 5 caracteres';
    }

    return null;
  }
  static String? validateTitulo(String? value) {
    if (value == null || value.trim().isEmpty) {
      return 'El tÃ­tulo es obligatorio';
    }

    final titulo = value.trim();
    if (titulo.length < 3) {
      return 'El tÃ­tulo debe tener al menos 3 caracteres';
    }

    return null;
  }
  static String? validateEspecialidad(String? value) {
    if (value == null || value.trim().isEmpty) {
      return 'La especialidad es obligatoria';
    }

    final especialidad = value.trim();
    if (especialidad.length < 3) {
      return 'La especialidad debe tener al menos 3 caracteres';
    }

    return null;
  }
  static String? validateTelefonoResponsable(String? value) {
    if (value == null || value.trim().isEmpty) {
      return null
    }

    final telefono = value.trim();
    if (!_phoneRegex.hasMatch(telefono)) {
      return 'Ingresa un nÃºmero de telÃ©fono vÃ¡lido';
    }

    return null;
  }
  static void focusFirstInvalidField(
    int step,
    String userRole,
    Map<String, TextEditingController> controllers,
    Map<String, FocusNode> focusNodes,
    Map<String, GlobalKey<FormFieldState<String>>> fieldKeys,
  ) {
    if (step == 0) {
      final email = controllers['email']!.text.trim();
      if (email.isEmpty || !_emailRegex.hasMatch(email)) {
        _focusAndScroll(focusNodes['email']!, fieldKeys['email']!);
        return;
      }
    } else if (step == 1) {
      final nombres = controllers['nombres']!.text.trim();
      final apellidos = controllers['apellidos']!.text.trim();
      final telefono = controllers['telefono']!.text.trim();
      final identificacion = controllers['identificacion']!.text.trim();

      if (nombres.isEmpty || nombres.length < 2) {
        _focusAndScroll(focusNodes['nombres']!, fieldKeys['nombres']!);
        return;
      }
      if (apellidos.isEmpty || apellidos.length < 2) {
        _focusAndScroll(focusNodes['apellidos']!, fieldKeys['apellidos']!);
        return;
      }
      if (telefono.isNotEmpty && !_phoneRegex.hasMatch(telefono)) {
        _focusAndScroll(focusNodes['telefono']!, fieldKeys['telefono']!);
        return;
      }
      if (!(userRole == 'admin_institucion' || userRole == 'super_admin')) {
        if (identificacion.isEmpty || identificacion.length < 5) {
          _focusAndScroll(focusNodes['identificacion']!, fieldKeys['identificacion']!);
          return;
        }
      }
    } else if (step == 2) {
      if (userRole == 'profesor') {
        final titulo = controllers['titulo']!.text.trim();
        final especialidad = controllers['especialidad']!.text.trim();
        if (titulo.isEmpty || titulo.length < 3) {
          _focusAndScroll(focusNodes['titulo']!, fieldKeys['titulo']!);
          return;
        }
        if (especialidad.isEmpty || especialidad.length < 3) {
          _focusAndScroll(focusNodes['especialidad']!, fieldKeys['especialidad']!);
          return;
        }
      } else if (userRole == 'estudiante') {
        final telefonoResp = controllers['telefonoResponsable']!.text.trim();
        if (telefonoResp.isNotEmpty && !_phoneRegex.hasMatch(telefonoResp)) {
          _focusAndScroll(focusNodes['telefonoResponsable']!, fieldKeys['telefonoResponsable']!);
          return;
        }
      }
    }
  }

  static void _focusAndScroll(FocusNode focusNode, GlobalKey<FormFieldState<String>> fieldKey) {
    focusNode.requestFocus();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final ctx = fieldKey.currentContext;
      if (ctx != null) {
        Scrollable.ensureVisible(ctx, duration: const Duration(milliseconds: 300));
      }
    });
  }
}
/* Fin lib\services\form_validation_service.dart */

/* Inicio lib\services\institution_service.dart */
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';
import '../models/institution.dart';
import '../models/user.dart';
import '../config/app_config.dart';

class PaginatedInstitutionResponse {
  final List<Institution> institutions;
  final PaginationInfo pagination;

  PaginatedInstitutionResponse({
    required this.institutions,
    required this.pagination,
  });
}

class InstitutionService {
  Future<PaginatedInstitutionResponse?> getAllInstitutions(String accessToken, {int? page, int? limit, bool? activa, String? search}) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      if (limit != null) queryParams['limit'] = limit.toString();
      if (activa != null) queryParams['activa'] = activa.toString();
      if (search != null && search.isNotEmpty) queryParams['search'] = search;

      final uri = Uri.parse('$baseUrlValue/instituciones').replace(queryParameters: queryParams);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /instituciones - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final institutions = (responseData['data'] as List)
              .map((institutionJson) => Institution.fromJson(institutionJson))
              .toList();
          final pagination = PaginationInfo.fromJson(responseData['pagination']);
          return PaginatedInstitutionResponse(institutions: institutions, pagination: pagination);
        }
      } else {
        debugPrint('Error getting institutions: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting institutions: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Institution?> getInstitutionById(String accessToken, String id) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/instituciones/$id'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /instituciones/$id - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Institution.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error getting institution: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting institution: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Institution?> createInstitution(
    String accessToken, {
    required String nombre,
    String? direccion,
    String? telefono,
    String? email,
  }) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/instituciones'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode({
          'nombre': nombre,
          if (direccion != null) 'direccion': direccion,
          if (telefono != null) 'telefono': telefono,
          if (email != null) 'email': email,
        }),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('POST /instituciones - Status: ${response.statusCode}');

      if (response.statusCode == 201) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Institution.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error creating institution: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error creating institution: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<Institution?> updateInstitution(
    String accessToken,
    String id, {
    String? nombre,
    String? direccion,
    String? telefono,
    String? email,
    bool? activa,
  }) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.put(
        Uri.parse('$baseUrlValue/instituciones/$id'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode({
          if (nombre != null) 'nombre': nombre,
          if (direccion != null) 'direccion': direccion,
          if (telefono != null) 'telefono': telefono,
          if (email != null) 'email': email,
          if (activa != null) 'activa': activa,
        }),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PUT /instituciones/$id - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return Institution.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error updating institution: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error updating institution: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<bool> deleteInstitution(String accessToken, String id) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.delete(
        Uri.parse('$baseUrlValue/instituciones/$id'),
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('DELETE /instituciones/$id - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      } else {
        debugPrint('Error deleting institution: ${response.statusCode} - ${response.body}');
        return false;
      }
    } catch (e, stackTrace) {
      debugPrint('Error deleting institution: $e');
      debugPrint('StackTrace: $stackTrace');
      return false;
    }
  }
}
/* Fin lib\services\institution_service.dart */

/* Inicio lib\services\profesor_service.dart */
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';
import '../models/user.dart';
import '../config/app_constants.dart';
import '../config/app_config.dart';

class PaginatedUserResponse {
  final List<User> users;
  final PaginationInfo pagination;

  PaginatedUserResponse({
    required this.users,
    required this.pagination,
  });
}

class ProfesorService {
  Future<PaginatedUserResponse?> getAllProfesores(String accessToken, {int? page, int? limit, String? search, bool? activo}) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      if (limit != null) queryParams['limit'] = limit.toString();
      if (search != null && search.isNotEmpty) queryParams['search'] = search;
      if (activo != null) queryParams['activo'] = activo.toString();

      final uri = Uri.parse('$baseUrlValue/institution-admin/profesores').replace(queryParameters: queryParams.isNotEmpty ? queryParams : null);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /institution-admin/profesores - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final profesores = (responseData['data'] as List)
              .map((userJson) => User.fromJson(userJson))
              .toList();
          final pagination = responseData['pagination'] != null
              ? PaginationInfo.fromJson(responseData['pagination'])
              : PaginationInfo(
                  page: page ?? 1,
                  limit: limit ?? AppConstants.itemsPerPage,
                  total: profesores.length,
                  totalPages: 1,
                  hasNext: false,
                  hasPrev: false,
                );

          return PaginatedUserResponse(users: profesores, pagination: pagination);
        }
      } else {
        debugPrint('Error getting profesores: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting profesores: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<User?> getProfesorById(String accessToken, String profesorId) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/institution-admin/profesores/$profesorId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /institution-admin/profesores/$profesorId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return User.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error getting profesor: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting profesor: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<User?> createProfesor(String accessToken, CreateUserRequest profesorData) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/institution-admin/profesores'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode({
          'nombres': profesorData.nombres,
          'apellidos': profesorData.apellidos,
          'email': profesorData.email,
          'password': profesorData.password,
          'telefono': profesorData.telefono,
          'grupoId': profesorData.rolEnInstitucion, // Puede ser usado como grupoId
        }),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('POST /institution-admin/profesores - Status: ${response.statusCode}');

      if (response.statusCode == 201) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return User.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error creating profesor: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error creating profesor: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<User?> updateProfesor(String accessToken, String profesorId, UpdateUserRequest profesorData) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final Map<String, dynamic> updateData = {};
      if (profesorData.nombres != null) updateData['nombres'] = profesorData.nombres;
      if (profesorData.apellidos != null) updateData['apellidos'] = profesorData.apellidos;
      if (profesorData.email != null) updateData['email'] = profesorData.email;
      if (profesorData.telefono != null) updateData['telefono'] = profesorData.telefono;
      if (profesorData.activo != null) updateData['activo'] = profesorData.activo;

      final response = await http.put(
        Uri.parse('$baseUrlValue/institution-admin/profesores/$profesorId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(updateData),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PUT /institution-admin/profesores/$profesorId - Status: ${response.statusCode}');
      debugPrint('Update data sent: $updateData');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return User.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error updating profesor: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error updating profesor: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<bool> deleteProfesor(String accessToken, String profesorId) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.delete(
        Uri.parse('$baseUrlValue/institution-admin/profesores/$profesorId'),
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('DELETE /institution-admin/profesores/$profesorId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      } else {
        debugPrint('Error deleting profesor: ${response.statusCode} - ${response.body}');
        return false;
      }
    } catch (e, stackTrace) {
      debugPrint('Error deleting profesor: $e');
      debugPrint('StackTrace: $stackTrace');
      return false;
    }
  }
  Future<User?> toggleProfesorStatus(String accessToken, String profesorId) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.patch(
        Uri.parse('$baseUrlValue/institution-admin/profesores/$profesorId/toggle-status'),
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PATCH /institution-admin/profesores/$profesorId/toggle-status - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return User.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error toggling profesor status: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error toggling profesor status: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
}
/* Fin lib\services\profesor_service.dart */

/* Inicio lib\services\user_form_service.dart */
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../models/user.dart';
import '../providers/auth_provider.dart';
import '../providers/user_provider.dart';
import '../providers/institution_provider.dart';
class UserFormService {
  Future<User?> loadUserForEditing(
    BuildContext context,
    Map<String, String> queryParams,
  ) async {
    final isEdit = queryParams['edit'] == 'true';
    final userId = queryParams['userId'];

    if (!isEdit || userId == null) {
      return null;
    }

    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final userProvider = Provider.of<UserProvider>(context, listen: false);

    final token = authProvider.accessToken;
    if (token == null) {
      throw Exception('Debes iniciar sesiÃ³n para editar usuarios');
    }

    await userProvider.loadUserById(token, userId);
    return userProvider.selectedUser;
  }
  Future<void> loadInstitutionsIfNeeded(
    BuildContext context,
    String userRole,
  ) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    if (authProvider.user?['rol'] == 'super_admin' && userRole == 'admin_institucion') {
      final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);
      if (institutionProvider.institutions.isEmpty) {
        final token = authProvider.accessToken;
        if (token == null) return;

        await institutionProvider.loadInstitutions(
          token,
          page: 1,
          limit: 100, // Cargar todas para el dropdown
        );
      }
    }
  }
  bool isSelfEditing(User? user, AuthProvider authProvider) {
    if (user == null) return false;

    final sessionUserId = authProvider.user?['id']?.toString();
    return sessionUserId != null && sessionUserId == user.id;
  }
  void fillFormWithUserData(
    User user,
    TextEditingController nombresController,
    TextEditingController apellidosController,
    TextEditingController emailController,
    TextEditingController telefonoController,
    TextEditingController identificacionController,
    TextEditingController tituloController,
    TextEditingController especialidadController,
    TextEditingController nombreResponsableController,
    TextEditingController telefonoResponsableController,
    void Function(bool) setActivo,
    void Function(String?) setSelectedInstitutionId,
  ) {
    nombresController.text = user.nombres;
    apellidosController.text = user.apellidos;
    emailController.text = user.email;
    telefonoController.text = user.telefono ?? '';
    setActivo(user.activo);
    if (user.instituciones?.isNotEmpty ?? false) {
      setSelectedInstitutionId(user.instituciones!.first.id);
    }

    if (user.estudiante != null) {
      identificacionController.text = user.estudiante!.identificacion;
      nombreResponsableController.text = user.estudiante!.nombreResponsable ?? '';
      telefonoResponsableController.text = user.estudiante!.telefonoResponsable ?? '';
    }
    if (user.rol == 'profesor') {
      tituloController.text = user.titulo ?? '';
      especialidadController.text = user.especialidad ?? '';
      identificacionController.text = user.identificacion ?? '';
    }
  }
  bool validateAllSteps(List<GlobalKey<FormState>> stepKeys) {
    for (final stepKey in stepKeys) {
      final valid = stepKey.currentState?.validate() ?? true;
      if (!valid) {
        return false;
      }
    }
    return true;
  }
  CreateUserRequest createUserRequest({
    required String email,
    required String nombres,
    required String apellidos,
    required String telefono,
    required String identificacion,
    required String userRole,
    required String titulo,
    required String especialidad,
    required String nombreResponsable,
    required String telefonoResponsable,
    required String? selectedInstitutionId,
    required AuthProvider authProvider,
  }) {
    final tempPassword = generateRandomPassword();

    return CreateUserRequest(
      email: email.trim(),
      password: tempPassword,
      nombres: nombres.trim(),
      apellidos: apellidos.trim(),
      telefono: telefono.trim().isNotEmpty ? telefono.trim() : null,
      identificacion: (userRole == 'estudiante' || userRole == 'profesor') ? identificacion.trim() : null,
      rol: userRole,
      titulo: userRole == 'profesor' ? titulo.trim() : null,
      especialidad: userRole == 'profesor' ? especialidad.trim() : null,
      nombreResponsable: userRole == 'estudiante' ? nombreResponsable.trim().isNotEmpty ? nombreResponsable.trim() : null : null,
      telefonoResponsable: userRole == 'estudiante' ? telefonoResponsable.trim().isNotEmpty ? telefonoResponsable.trim() : null : null,
      institucionId: userRole == 'admin_institucion' ? selectedInstitutionId : authProvider.selectedInstitutionId,
      rolEnInstitucion: userRole == 'admin_institucion' ? 'admin' : null,
    );
  }
  UpdateUserRequest createUpdateRequest({
    required String email,
    required String nombres,
    required String apellidos,
    required String telefono,
    required String identificacion,
    required String userRole,
    required String titulo,
    required String especialidad,
    required String nombreResponsable,
    required String telefonoResponsable,
    required bool activo,
  }) {
    return UpdateUserRequest(
      email: email.trim(),
      nombres: nombres.trim(),
      apellidos: apellidos.trim(),
      telefono: telefono.trim().isNotEmpty ? telefono.trim() : null,
      identificacion: (userRole == 'estudiante' || userRole == 'profesor') ? identificacion.trim() : null,
      nombreResponsable: userRole == 'estudiante' ? nombreResponsable.trim().isNotEmpty ? nombreResponsable.trim() : null : null,
      telefonoResponsable: userRole == 'estudiante' ? telefonoResponsable.trim().isNotEmpty ? telefonoResponsable.trim() : null : null,
      activo: activo,
      titulo: userRole == 'profesor' ? titulo.trim() : null,
      especialidad: userRole == 'profesor' ? especialidad.trim() : null,
    );
  }
  Future<bool> saveUser({
    required BuildContext context,
    required User? user,
    required CreateUserRequest? createRequest,
    required UpdateUserRequest? updateRequest,
    required String userRole,
  }) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final userProvider = Provider.of<UserProvider>(context, listen: false);

    final token = authProvider.accessToken;
    if (token == null) {
      throw Exception('Debes iniciar sesiÃ³n para ${user != null ? 'editar' : 'crear'} usuarios');
    }

    if (user != null) {
      return await userProvider.updateUser(token, user.id, updateRequest!);
    } else {
      return await userProvider.createUser(token, createRequest!);
    }
  }
  String generateRandomPassword({int length = 12}) {
    const String chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#%^&*()';
    final Random random = Random.secure();
    return List.generate(length, (_) => chars[random.nextInt(chars.length)]).join();
  }
  String getRoleDisplayName(String role) {
    switch (role) {
      case 'profesor':
        return 'Profesor';
      case 'estudiante':
        return 'Estudiante';
      case 'admin_institucion':
        return 'Administrador de InstituciÃ³n';
      case 'super_admin':
        return 'Super Administrador';
      default:
        return 'Usuario';
    }
  }
}
/* Fin lib\services\user_form_service.dart */

/* Inicio lib\services\user_service.dart */
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';
import '../config/app_config.dart';
import '../models/user.dart';

class EmailAlreadyExistsException implements Exception {
  final String message;
  EmailAlreadyExistsException(this.message);
  @override
  String toString() => message;
}

class PaginatedUserResponse {
  final List<User> users;
  final PaginationInfo pagination;

  PaginatedUserResponse({
    required this.users,
    required this.pagination,
  });
}

class UserService {
  Future<PaginatedUserResponse?> getAllUsers(String accessToken, {int? page, int? limit, bool? activo, String? search, List<String>? roles}) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      if (limit != null) queryParams['limit'] = limit.toString();
      if (activo != null) queryParams['activo'] = activo.toString();
      if (search != null && search.isNotEmpty) queryParams['search'] = search;
      if (roles != null && roles.isNotEmpty) queryParams['rol'] = roles.join(',');

  final uri = Uri.parse('$baseUrlValue/usuarios').replace(queryParameters: queryParams);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /usuarios - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final users = (responseData['data'] as List)
              .map((userJson) => User.fromJson(userJson))
              .toList();
          final pagination = PaginationInfo.fromJson(responseData['pagination']);
          return PaginatedUserResponse(users: users, pagination: pagination);
        }
      } else {
        debugPrint('Error getting users: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting users: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<User?> getUserById(String accessToken, String userId) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/usuarios/$userId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /usuarios/$userId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        debugPrint('GET /usuarios/$userId - body: ${response.body}');
        if (responseData['success'] == true) {
          return User.fromJson(responseData['data']);
        }
      } else {
        debugPrint('Error getting user: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting user: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<PaginatedUserResponse?> getUsersByRole(String accessToken, String role, {int? page, int? limit, bool? activo, String? search}) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      if (limit != null) queryParams['limit'] = limit.toString();
      if (activo != null) queryParams['activo'] = activo.toString();
      if (search != null && search.isNotEmpty) queryParams['search'] = search;

      final uri = Uri.parse('$baseUrlValue/usuarios/rol/$role').replace(queryParameters: queryParams);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /usuarios/rol/$role - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final users = (responseData['data'] as List)
              .map((userJson) => User.fromJson(userJson))
              .toList();
          final pagination = PaginationInfo.fromJson(responseData['pagination']);
          return PaginatedUserResponse(users: users, pagination: pagination);
        }
      } else {
        debugPrint('Error getting users by role: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting users by role: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<PaginatedUserResponse?> getUsersByInstitution(String accessToken, String institutionId, {int? page, int limit = 5, String? role, bool? activo, String? search}) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final queryParams = <String, String>{};
      if (page != null) queryParams['page'] = page.toString();
      queryParams['limit'] = limit.toString();
      if (role != null && role.isNotEmpty) queryParams['rol'] = role;
      if (activo != null) queryParams['activo'] = activo.toString();
      if (search != null && search.isNotEmpty) queryParams['search'] = search;

      final uri = Uri.parse('$baseUrlValue/usuarios/institucion/$institutionId').replace(queryParameters: queryParams);

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET /usuarios/institucion/$institutionId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final users = (responseData['data'] as List)
              .map((userJson) => User.fromJson(userJson))
              .toList();
          final pagination = PaginationInfo.fromJson(responseData['pagination']);
          return PaginatedUserResponse(users: users, pagination: pagination);
        }
      } else {
        debugPrint('Error getting users by institution: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting users by institution: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<List<User>?> getAdminsByInstitution(String accessToken, String institutionId) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final uri = Uri.parse('$baseUrlValue/instituciones/$institutionId/admins');

      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(const Duration(seconds: 10));

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final list = (responseData['data'] as List)
              .map((item) {
                if (item is Map && item.containsKey('usuario')) {
                  return User.fromJson(item['usuario']);
                }
                if (item is Map && item.containsKey('email')) {
                  final usuarioJson = {
                    'id': item['usuarioId'] ?? item['id'],
                    'email': item['email'],
                    'nombres': item['nombres'],
                    'apellidos': item['apellidos'],
                    'rol': 'admin_institucion',
                    'telefono': item['telefono'],
                    'activo': item['activo'] ?? true,
                    'usuarioInstituciones': [
                      {
                        'institucion': {
                          'id': item['institucionId'],
                          'nombre': '',
                        },
                        'rolEnInstitucion': item['rolEnInstitucion'],
                        'activo': item['activo'] ?? true,
                      }
                    ],
                  };
                  return User.fromJson(usuarioJson);
                }
                return null;
              })
              .whereType<User>()
              .toList();

          return list;
        }
      }
      return null;
    } catch (e, st) {
      debugPrint('Error getting admins by institution: $e');
      debugPrint('StackTrace: $st');
      return null;
    }
  }
  Future<User?> assignAdminToInstitution(String accessToken, String institutionId, String userId) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final uri = Uri.parse('$baseUrlValue/instituciones/$institutionId/admins');

      final response = await http.post(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode({'userId': userId}),
      ).timeout(const Duration(seconds: 10));

      if (response.statusCode == 201 || response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          final data = responseData['data'];
          if (data is Map && data['id'] != null) {
            return User.fromJson(data as Map<String, dynamic>);
          }
        }
      }
      return null;
    } catch (e, st) {
      debugPrint('Error assigning admin to institution: $e');
      debugPrint('StackTrace: $st');
      return null;
    }
  }
  Future<bool?> removeAdminFromInstitution(String accessToken, String institutionId, String userId) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final uri = Uri.parse('$baseUrlValue/instituciones/$institutionId/admins/$userId');

      final response = await http.delete(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(const Duration(seconds: 10));

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      }
      return null;
    } catch (e, st) {
      debugPrint('Error removing admin from institution: $e');
      debugPrint('StackTrace: $st');
      return null;
    }
  }
  Future<bool> changePassword(String accessToken, String userId, String newPassword) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final uri = Uri.parse('$baseUrlValue/usuarios/$userId/change-password');

      final response = await http.patch(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode({'newPassword': newPassword}),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PATCH /usuarios/$userId/change-password - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      } else {
        debugPrint('Error changePassword: ${response.statusCode} - ${response.body}');
        return false;
      }
    } catch (e, st) {
      debugPrint('Error changePassword: $e');
      debugPrint('StackTrace: $st');
      return false;
    }
  }
  Future<User?> createUser(String accessToken, CreateUserRequest userData) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/usuarios'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(userData.toJson()),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('POST /usuarios - Status: ${response.statusCode}');

      if (response.statusCode == 201) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return User.fromJson(responseData['data']);
        }
      } else if (response.statusCode == 409) {
        throw EmailAlreadyExistsException('El email ya estÃ¡ en uso');
      } else {
        debugPrint('Error creating user: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error creating user: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<User?> updateUser(String accessToken, String userId, UpdateUserRequest userData) async {
    try {
  final baseUrlValue = AppConfig.baseUrl;
      final response = await http.put(
        Uri.parse('$baseUrlValue/usuarios/$userId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(userData.toJson()),
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PUT /usuarios/$userId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        debugPrint('PUT /usuarios/$userId - request: ${jsonEncode(userData.toJson())}');
        debugPrint('PUT /usuarios/$userId - body: ${response.body}');
        if (responseData['success'] == true) {
          final data = responseData['data'] as Map<String, dynamic>;
          return User.fromJson(data);
        }
      } else if (response.statusCode == 409) {
        throw EmailAlreadyExistsException('El email ya estÃ¡ en uso');
      } else {
        debugPrint('Error updating user: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error updating user: $e');
      debugPrint('StackTrace: $stackTrace');
      return null;
    }
    return null;
  }
  Future<bool> deleteUser(String accessToken, String userId) async {
    try {
      final baseUrlValue = AppConfig.baseUrl;
      final response = await http.delete(
        Uri.parse('$baseUrlValue/usuarios/$userId'),
        headers: {
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('DELETE /usuarios/$userId - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        return responseData['success'] == true;
      } else {
        debugPrint('Error deleting user: ${response.statusCode} - ${response.body}');
        return false;
      }
    } catch (e, stackTrace) {
      debugPrint('Error deleting user: $e');
      debugPrint('StackTrace: $stackTrace');
      return false;
    }
  }
}
/* Fin lib\services\user_service.dart */

/* Inicio lib\theme\app_colors.dart */
import 'package:flutter/material.dart';
class AppColors {

  AppColors._();

  static final AppColors instance = AppColors._();
  static const Color _primaryBase = Color(0xFF0055D4)
  static const Color _secondaryBase = Color(0xFF4F46E5)
  static const Color _surfaceBase = Color(0xFFFFFFFF)
  static const Color _backgroundBase = Color(0xFFF8FAFC)
  final Color primary = _primaryBase;
  final Color primaryDark = const Color(0xFF0043B8)
  final Color primaryLight = const Color(0xFF4D9DE0)
  final Color primaryContainer = const Color(0xFFE3F2FD)
  final Color secondary = _secondaryBase;
  final Color secondaryLight = const Color(0xFF6366F1)
  final Color secondaryContainer = const Color(0xFFEEF2FF)
  final Color success = const Color(0xFF16A34A)
  final Color successLight = const Color(0xFF22C55E)
  final Color successDark = const Color(0xFF15803D)
  final Color warning = const Color(0xFFF59E0B)
  final Color warningLight = const Color(0xFFFCD34D)
  final Color warningDark = const Color(0xFFD97706)
  final Color error = const Color(0xFFDC2626)
  final Color errorLight = const Color(0xFFF87171)
  final Color errorDark = const Color(0xFFB91C1C)
  final Color info = const Color(0xFF3B82F6)
  final Color infoLight = const Color(0xFF60A5FA)
  final Color infoDark = const Color(0xFF2563EB)
  final Color featureUsers = const Color(0xFF6366F1)
  final Color featureInstitutions = const Color(0xFF0EA5E9)
  final Color featureAttendance = const Color(0xFFF59E0B)
  final Color featureReports = const Color(0xFFE11D48)
  final Color featureSchedule = const Color(0xFF14B8A6)
  final Color featureSettings = const Color(0xFF475569)
  final Color featureNotifications = const Color(0xFFF97316)
  final Color featureClasses = const Color(0xFFEF4444)
  final Color featureGrades = const Color(0xFF84CC16)
  final Color featureStudents = const Color(0xFF0055D4)
  final Color stateNoData = const Color(0xFF94A3B8)
  final Color stateInDevelopment = const Color(0xFF6366F1)
  final Color stateSuccess = const Color(0xFF22C55E)
  final Color stateInactive = const Color(0xFFE2E8F0)
  final Color stateActive = const Color(0xFF16A34A)

  final Color surface = _surfaceBase
  final Color surfaceLight = const Color(0xFFF8FAFC)
  final Color surfaceContainer = const Color(0xFFFFFFFF)
  final Color surfaceVariant = const Color(0xFFF1F5F9)

  final Color background = _backgroundBase
  final Color backgroundLight = const Color(0xFFFFFFFF)
  final Color backgroundVariant = const Color(0xFFF8FAFC)
  final Color textPrimary = const Color(0xFF0F172A)
  final Color textSecondary = const Color(0xFF334155)
  final Color textMuted = const Color(0xFF64748B)
  final Color textDisabled = const Color(0xFF94A3B8)
  final Color textOnDark = const Color(0xFFF8FAFC)
  final Color textOnDarkSecondary = const Color(0xFFE2E8F0)
  final Color textOnDarkMuted = const Color(0xFFCBD5E1)
  final Color onPrimary = const Color(0xFFFFFFFF)

  final Color border = const Color(0xFFE2E8F0)
  final Color borderLight = const Color(0xFFF1F5F9)
  final Color borderStrong = const Color(0xFFCBD5E1)
  final Color divider = const Color(0xFFE2E8F0)

  final Color shadow = const Color(0x0A000000)
  final Color shadowLight = const Color(0x05000000)
  final Color shadowMedium = const Color(0x0F000000)
  final Color scrim = const Color(0x0F000000)

  final Color transparent = const Color(0x00000000);
  final Color white = const Color(0xFFFFFFFF);
  final Color black = const Color(0xFF000000);
  final Color grey50 = const Color(0xFFF8FAFC);
  final Color grey100 = const Color(0xFFF1F5F9);
  final Color grey200 = const Color(0xFFE2E8F0);
  final Color grey300 = const Color(0xFFCBD5E1);
  final Color grey400 = const Color(0xFF94A3B8);
  final Color grey500 = const Color(0xFF64748B);
  final Color grey600 = const Color(0xFF475569);
  final Color grey700 = const Color(0xFF334155);
  final Color grey800 = const Color(0xFF1E293B);
  final Color grey900 = const Color(0xFF0F172A);
  Color get primaryWithOpacity => primary.withValues(alpha: 0.9);
  Color get surfaceWithOpacity => surface.withValues(alpha: 0.95);
  Color get textSecondaryWithOpacity => textSecondary.withValues(alpha: 0.8);
  Color get warningBackground => warning.withValues(alpha: 0.08);
  Color get warningBorder => warning.withValues(alpha: 0.2);
  Color get infoBackground => info.withValues(alpha: 0.08);
  Color get infoBorder => info.withValues(alpha: 0.2);
  Color get errorBackground => error.withValues(alpha: 0.08);
  Color get errorBorder => error.withValues(alpha: 0.2);
  Color get successBackground => success.withValues(alpha: 0.08);
  Color get successBorder => success.withValues(alpha: 0.2);
  Color get roleBadgeBackground => primary.withValues(alpha: 0.1);
  Color get roleBadgeText => primary;
  Color get roleBadgeIcon => primary;
  Color getTextColorForBackground(Color backgroundColor) {
    final luminance = backgroundColor.computeLuminance();
    return luminance > 0.5 ? textPrimary : textOnDark;
  }

  Color getSecondaryTextColorForBackground(Color backgroundColor) {
    final luminance = backgroundColor.computeLuminance();
    return luminance > 0.5 ? textSecondary : textOnDarkSecondary;
  }

  Color getMutedTextColorForBackground(Color backgroundColor) {
    final luminance = backgroundColor.computeLuminance();
    return luminance > 0.5 ? textMuted : textOnDarkMuted;
  }
}

/* Fin lib\theme\app_colors.dart */

/* Inicio lib\theme\app_spacing.dart */

class AppSpacing {
  AppSpacing._();
  static final AppSpacing instance = AppSpacing._();
  static const double _baseUnit = 4;
  final double xs = _baseUnit
  final double sm = _baseUnit * 2
  final double md = _baseUnit * 4
  final double lg = _baseUnit * 6
  final double xl = _baseUnit * 8
  final double xxl = _baseUnit * 12
  final double xxxl = _baseUnit * 16
  final double buttonPadding = _baseUnit * 4
  final double cardPadding = _baseUnit * 3
  final double screenPadding = _baseUnit * 4
  final double inputPadding = _baseUnit * 3
  final double iconSize = _baseUnit * 6
  final double borderRadius = _baseUnit * 2
  final double borderRadiusLarge = _baseUnit * 3
  final double appBarHeight = _baseUnit * 14
  final double borderWidth = 1
  double multiply(double factor) => _baseUnit * factor;
  double add(double value) => _baseUnit + value;
}
/* Fin lib\theme\app_spacing.dart */

/* Inicio lib\theme\app_text_styles.dart */
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'app_colors.dart';
class AppTextStyles {

  AppTextStyles._();

  static final AppTextStyles instance = AppTextStyles._();

  TextStyle _createStyle({
    required double fontSize,
    required FontWeight fontWeight,
    required double height,
    required double letterSpacing,
    Color? color,
    TextDecoration? decoration,
  }) {
    return GoogleFonts.inter(
      fontSize: fontSize,
      fontWeight: fontWeight,
      height: height,
      letterSpacing: letterSpacing,
      color: color ?? AppColors.instance.textPrimary,
      decoration: decoration,
    );
  }

  TextStyle get displayLarge => _createStyle(
    fontSize: 32,
    fontWeight: FontWeight.w700, // Bold para impacto
    height: 1.2,
    letterSpacing: -0.5, // Letter spacing negativo para tÃ­tulos grandes
  );

  TextStyle get displayMedium => _createStyle(
    fontSize: 28,
    fontWeight: FontWeight.w700,
    height: 1.25,
    letterSpacing: -0.4,
  );

  TextStyle get headlineLarge => _createStyle(
    fontSize: 24,
    fontWeight: FontWeight.w600, // SemiBold para jerarquÃ­a
    height: 1.3,
    letterSpacing: -0.3,
  );

  TextStyle get headlineMedium => _createStyle(
    fontSize: 20,
    fontWeight: FontWeight.w600,
    height: 1.4,
    letterSpacing: -0.2,
  );

  TextStyle get headlineSmall => _createStyle(
    fontSize: 18,
    fontWeight: FontWeight.w600,
    height: 1.4,
    letterSpacing: -0.1,
  );

  TextStyle get titleLarge => _createStyle(
    fontSize: 17,
    fontWeight: FontWeight.w600,
    height: 1.4,
    letterSpacing: 0.0,
  );

  TextStyle get titleMedium => _createStyle(
    fontSize: 15,
    fontWeight: FontWeight.w500, // Medium para subtÃ­tulos
    height: 1.5,
    letterSpacing: 0.0,
  );

  TextStyle get titleSmall => _createStyle(
    fontSize: 14,
    fontWeight: FontWeight.w500,
    height: 1.5,
    letterSpacing: 0.1,
  );

  TextStyle get bodyLarge => _createStyle(
    fontSize: 16,
    fontWeight: FontWeight.w400, // Regular para legibilidad
    height: 1.5,
    letterSpacing: 0.1,
    color: AppColors.instance.textPrimary,
  );

  TextStyle get bodyMedium => _createStyle(
    fontSize: 15,
    fontWeight: FontWeight.w400,
    height: 1.5,
    letterSpacing: 0.1,
    color: AppColors.instance.textPrimary,
  );

  TextStyle get bodySmall => _createStyle(
    fontSize: 13,
    fontWeight: FontWeight.w400,
    height: 1.4,
    letterSpacing: 0.2,
    color: AppColors.instance.textMuted,
  );

  TextStyle get labelLarge => _createStyle(
    fontSize: 16,
    fontWeight: FontWeight.w600, // SemiBold para botones
    height: 1.4,
    letterSpacing: 0.1,
    color: AppColors.instance.textSecondary,
  );

  TextStyle get labelMedium => _createStyle(
    fontSize: 14,
    fontWeight: FontWeight.w500,
    height: 1.4,
    letterSpacing: 0.2,
    color: AppColors.instance.textSecondary,
  );

  TextStyle get labelSmall => _createStyle(
    fontSize: 11,
    fontWeight: FontWeight.w500,
    height: 1.4,
    letterSpacing: 0.5,
    color: AppColors.instance.textMuted,
  );
  TextStyle get button => labelLarge.copyWith(
    color: null, // Usar foregroundColor del botÃ³n
    letterSpacing: 0.2, // Mejor legibilidad en botones
  );
  TextStyle get navigation => labelMedium.copyWith(
    fontWeight: FontWeight.w500,
    letterSpacing: 0.1,
  );
  TextStyle get navigationActive => navigation.copyWith(
    fontWeight: FontWeight.w600,
    color: AppColors.instance.primary,
  );
  TextStyle get navigationInactive => navigation.copyWith(
    color: AppColors.instance.textMuted,
  );
  TextStyle get kpiNumber => _createStyle(
    fontSize: 28,
    fontWeight: FontWeight.w700,
    height: 1.2,
    letterSpacing: -0.5,
    color: AppColors.instance.textPrimary,
  );
  TextStyle get kpiLabel => labelSmall.copyWith(
    fontSize: 10,
    letterSpacing: 0.8,
    fontWeight: FontWeight.w600,
  );
  TextStyle get statusText => labelSmall.copyWith(
    fontSize: 10,
    fontWeight: FontWeight.w600,
    letterSpacing: 0.5,
  );
  TextStyle get errorText => bodySmall.copyWith(
    color: AppColors.instance.error,
    fontWeight: FontWeight.w500,
  );
  TextStyle get helpText => bodySmall.copyWith(
    color: AppColors.instance.textMuted,
    fontWeight: FontWeight.w400,
  );

  TextStyle get caption => bodySmall.copyWith(
    fontSize: 12,
  );

  TextStyle get overline => labelSmall.copyWith(
    fontSize: 10,
    letterSpacing: 1.5,
    fontWeight: FontWeight.w500,
  );

  TextStyle withColor(Color color) => _createStyle(
    fontSize: 15, // default
    fontWeight: FontWeight.normal,
    height: 1.4,
    letterSpacing: 0,
    color: color,
  );

  TextStyle withWeight(FontWeight weight) => _createStyle(
    fontSize: 15, // default
    fontWeight: weight,
    height: 1.4,
    letterSpacing: 0,
  );

  TextStyle withSize(double size) => _createStyle(
    fontSize: size,
    fontWeight: FontWeight.normal,
    height: 1.4,
    letterSpacing: 0,
  );
}
/* Fin lib\theme\app_text_styles.dart */

/* Inicio lib\theme\app_theme.dart */
import 'package:flutter/material.dart';
import 'app_colors.dart';
import 'app_spacing.dart';
import 'app_text_styles.dart';
class AppTheme {

  AppTheme._();

  static final AppTheme instance = AppTheme._();
  static ThemeData get light => _createTheme(Brightness.light);
  static ThemeData get dark => _createTheme(Brightness.dark);
  static ThemeData get defaultTheme => dark;

  static ThemeData _createTheme(Brightness brightness) {
    final colors = AppColors.instance;
    final textStyles = AppTextStyles.instance;

    return ThemeData(
      brightness: brightness,
      useMaterial3: true,

      colorScheme: ColorScheme(
        brightness: brightness,
        primary: colors.primary,
        onPrimary: brightness == Brightness.light ? colors.textPrimary : colors.white, // Negro en light, blanco en dark
        primaryContainer: colors.primaryContainer,
        onPrimaryContainer: colors.textPrimary,
        secondary: colors.secondary,
        onSecondary: colors.white, // Texto blanco sobre secondary
        secondaryContainer: colors.secondaryContainer,
        onSecondaryContainer: colors.textSecondary,
        tertiary: colors.info,
        onTertiary: colors.white, // Texto blanco sobre info
        error: colors.error,
        onError: colors.white, // Texto blanco sobre error
        surface: colors.surface,
        onSurface: colors.textPrimary,
        surfaceContainerHighest: colors.surfaceLight,
        onSurfaceVariant: colors.textMuted,
        outline: colors.border,
        outlineVariant: colors.borderLight,
        shadow: colors.shadow,
        scrim: colors.scrim,
        inverseSurface: colors.primary,
        onInverseSurface: colors.white,
        inversePrimary: colors.primaryLight,
        surfaceTint: colors.primary.withValues(alpha: 0.05),
      ),

      textTheme: TextTheme(
        displayLarge: textStyles.displayLarge,
        displayMedium: textStyles.displayMedium,
        headlineLarge: textStyles.headlineLarge,
        headlineMedium: textStyles.headlineMedium,
        titleLarge: textStyles.titleLarge,
        titleMedium: textStyles.titleMedium,
        bodyLarge: textStyles.bodyLarge,
        bodyMedium: textStyles.bodyMedium,
        bodySmall: textStyles.bodySmall,
        labelLarge: textStyles.labelLarge,
        labelMedium: textStyles.labelMedium,
        labelSmall: textStyles.labelSmall,
      ),

      appBarTheme: AppBarTheme(
        backgroundColor: colors.primary,
        foregroundColor: brightness == Brightness.light ? colors.textPrimary : colors.white, // Negro en light, blanco en dark
        elevation: 0,
        shadowColor: Colors.transparent,
        surfaceTintColor: Colors.transparent,
        titleTextStyle: textStyles.headlineMedium.copyWith(
          color: brightness == Brightness.light ? colors.textPrimary : colors.white, // Negro en light, blanco en dark
          fontWeight: FontWeight.bold,
        ),
        iconTheme: IconThemeData(color: brightness == Brightness.light ? colors.textPrimary : colors.white), // Negro en light, blanco en dark
        actionsIconTheme: IconThemeData(color: brightness == Brightness.light ? colors.textPrimary : colors.white), // Negro en light, blanco en dark
        toolbarHeight: AppSpacing.instance.appBarHeight,
        centerTitle: true,
      ),

      cardTheme: CardTheme(
        color: colors.white,
        shadowColor: colors.shadowLight,
        elevation: 1, // ElevaciÃ³n sutil
        margin: EdgeInsets.zero,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          side: BorderSide(color: colors.border, width: 0.5),
        ),
      ),

      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: colors.primary,
          foregroundColor: brightness == Brightness.light ? colors.textPrimary : colors.white, // Negro en light, blanco en dark
          elevation: 1, // ElevaciÃ³n sutil
          padding: EdgeInsets.symmetric(
            horizontal: AppSpacing.instance.buttonPadding,
            vertical: AppSpacing.instance.md,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          ),
          textStyle: textStyles.button,
        ),
      ),

      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          foregroundColor: colors.primary,
          side: BorderSide(color: colors.border, width: AppSpacing.instance.borderWidth),
          elevation: 0,
          padding: EdgeInsets.symmetric(
            horizontal: AppSpacing.instance.buttonPadding,
            vertical: AppSpacing.instance.md,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          ),
          textStyle: textStyles.button, // Usar estilo sin color fijo
        ),
      ),

      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: colors.primary,
          padding: EdgeInsets.symmetric(
            horizontal: AppSpacing.instance.sm,
            vertical: AppSpacing.instance.xs,
          ),
          textStyle: textStyles.button, // Usar estilo sin color fijo
        ),
      ),

      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: colors.white,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          borderSide: BorderSide(color: colors.border, width: AppSpacing.instance.borderWidth),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          borderSide: BorderSide(color: colors.border, width: AppSpacing.instance.borderWidth),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          borderSide: BorderSide(color: colors.primaryLight, width: 1.5),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          borderSide: BorderSide(color: colors.error, width: AppSpacing.instance.borderWidth),
        ),
        contentPadding: EdgeInsets.all(AppSpacing.instance.inputPadding),
        labelStyle: textStyles.bodyMedium.copyWith(color: colors.textMuted),
        hintStyle: textStyles.bodyMedium.copyWith(color: colors.textMuted),
        errorStyle: textStyles.bodySmall.copyWith(color: colors.error),
      ),

      dialogTheme: DialogTheme(
        backgroundColor: colors.white,
        elevation: 6, // ElevaciÃ³n media para diÃ¡logos
        shadowColor: colors.shadowLight,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
        ),
      ),

      floatingActionButtonTheme: FloatingActionButtonThemeData(
        backgroundColor: colors.primary,
        foregroundColor: colors.white,
        elevation: 2, // ElevaciÃ³n sutil
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadiusLarge),
        ),
      ),

      chipTheme: ChipThemeData(
        backgroundColor: colors.surfaceLight,
        deleteIconColor: colors.textMuted,
        disabledColor: colors.stateInactive,
        selectedColor: colors.primary,
        secondarySelectedColor: colors.secondary,
        padding: EdgeInsets.symmetric(
          horizontal: AppSpacing.instance.sm,
          vertical: AppSpacing.instance.xs,
        ),
        labelStyle: textStyles.bodyMedium.copyWith(color: colors.textPrimary),
        secondaryLabelStyle: textStyles.bodyMedium.copyWith(color: colors.white),
        brightness: brightness,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          side: BorderSide(color: colors.border),
        ),
      ),

      scaffoldBackgroundColor: colors.background,
      dividerColor: colors.divider,
      shadowColor: colors.shadow,

      typography: Typography.material2021(),
      navigationBarTheme: NavigationBarThemeData(
        backgroundColor: colors.white,
        indicatorColor: colors.primary,
        labelTextStyle: WidgetStateProperty.resolveWith((states) {
          if (states.contains(WidgetState.selected)) {
            return textStyles.labelSmall.copyWith(
              color: colors.primary,
              fontWeight: FontWeight.w600,
            );
          }
          return textStyles.labelSmall.copyWith(color: colors.textMuted);
        }),
        iconTheme: WidgetStateProperty.resolveWith((states) {
          if (states.contains(WidgetState.selected)) {
            return IconThemeData(color: colors.primary);
          }
          return IconThemeData(color: colors.textMuted);
        }),
      ),
      navigationRailTheme: NavigationRailThemeData(
        backgroundColor: colors.white,
        selectedIconTheme: IconThemeData(color: colors.primary),
        unselectedIconTheme: IconThemeData(color: colors.textMuted),
        selectedLabelTextStyle: textStyles.labelSmall.copyWith(color: colors.primary),
        unselectedLabelTextStyle: textStyles.labelSmall.copyWith(color: colors.textMuted),
      ),
      bottomSheetTheme: BottomSheetThemeData(
        backgroundColor: colors.white,
        elevation: 4,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.only(
            topLeft: Radius.circular(AppSpacing.instance.borderRadius),
            topRight: Radius.circular(AppSpacing.instance.borderRadius),
          ),
        ),
      ),
    );
  }
}

/* Fin lib\theme\app_theme.dart */

/* Inicio lib\theme\index.dart */
export 'app_theme.dart';
export 'app_colors.dart';
export 'app_spacing.dart';
export 'app_text_styles.dart';
export 'theme_extensions.dart';
/* Fin lib\theme\index.dart */

/* Inicio lib\theme\theme_extensions.dart */
import 'package:flutter/material.dart';
import 'app_colors.dart';
import 'app_spacing.dart';
import 'app_text_styles.dart';
extension ThemeExtensions on BuildContext {
  AppColors get colors => AppColors.instance;
  AppTextStyles get textStyles => AppTextStyles.instance;
  AppSpacing get spacing => AppSpacing.instance;
  ThemeData get theme => Theme.of(this);
  TextTheme get textTheme => theme.textTheme;
  ColorScheme get colorScheme => theme.colorScheme;
}
extension TextStyleExtensions on TextStyle {
  TextStyle get bold => copyWith(fontWeight: FontWeight.bold);
  TextStyle get semiBold => copyWith(fontWeight: FontWeight.w600);
  TextStyle get medium => copyWith(fontWeight: FontWeight.w500);
  TextStyle get regular => copyWith(fontWeight: FontWeight.normal);
  TextStyle get light => copyWith(fontWeight: FontWeight.w300);

  TextStyle withColor(Color color) => copyWith(color: color);
  TextStyle withSize(double size) => copyWith(fontSize: size);
  TextStyle withWeight(FontWeight weight) => copyWith(fontWeight: weight);
  TextStyle get underlined => copyWith(decoration: TextDecoration.underline);
  TextStyle get lineThrough => copyWith(decoration: TextDecoration.lineThrough);
}
extension EdgeInsetsExtensions on EdgeInsets {
  static EdgeInsets get xs => EdgeInsets.all(AppSpacing.instance.xs);
  static EdgeInsets get sm => EdgeInsets.all(AppSpacing.instance.sm);
  static EdgeInsets get md => EdgeInsets.all(AppSpacing.instance.md);
  static EdgeInsets get lg => EdgeInsets.all(AppSpacing.instance.lg);
  static EdgeInsets get xl => EdgeInsets.all(AppSpacing.instance.xl);

  static EdgeInsets horizontal(double value) => EdgeInsets.symmetric(horizontal: value);
  static EdgeInsets vertical(double value) => EdgeInsets.symmetric(vertical: value);

  static EdgeInsets get cardPadding => EdgeInsets.all(AppSpacing.instance.cardPadding);
  static EdgeInsets get screenPadding => EdgeInsets.all(AppSpacing.instance.screenPadding);
  static EdgeInsets get buttonPadding => EdgeInsets.symmetric(
    horizontal: AppSpacing.instance.buttonPadding,
    vertical: AppSpacing.instance.sm,
  );
}
/* Fin lib\theme\theme_extensions.dart */

/* Inicio lib\utils\app_router.dart */
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../screens/login_screen.dart';
import '../screens/super_admin_dashboard.dart';
import '../screens/admin_dashboard.dart';
import '../screens/teacher_dashboard.dart';
import '../screens/student_dashboard.dart';
import '../screens/users/users_list_screen.dart';
import '../screens/users/user_form_screen.dart';
import '../screens/users/user_detail_screen.dart';
import '../screens/institutions/institutions_list_screen.dart';
import '../screens/institutions/institution_admins_screen.dart';
import '../screens/institutions/institution_form_screen.dart';
import '../screens/institutions/create_institution_admin_screen.dart';
import '../screens/academic/gestion_academica_screen.dart';
import '../screens/academic/grupos_screen.dart';
import '../screens/academic/materias_screen.dart';
import '../screens/academic/horarios_screen.dart';
import '../screens/academic/periodos_academicos_screen.dart';
import '../screens/academic/grupo_detail_screen.dart';
import '../models/institution.dart';
import '../screens/app_shell.dart';
import '../models/user.dart';
import '../models/grupo.dart';
import '../screens/student_schedule_screen.dart';
import '../screens/student_attendance_screen.dart';
import '../screens/attendance_screen.dart';
import '../models/clase_del_dia.dart';
import '../screens/student_notifications_screen.dart';
import '../screens/test_multi_hora_screen.dart';
import '../screens/my_qr_code_screen.dart';
import '../screens/institution_selection_screen.dart';
final _dashboardNavigatorKey = GlobalKey<NavigatorState>(debugLabel: 'Dashboard');
final _institutionsNavigatorKey = GlobalKey<NavigatorState>(debugLabel: 'Institutions');
final _usersNavigatorKey = GlobalKey<NavigatorState>(debugLabel: 'Users');
class AppRouter {
  final AuthProvider authProvider;

  AppRouter({
    required this.authProvider,
  });

  late final GoRouter router = GoRouter(
    debugLogDiagnostics: true,
    refreshListenable: authProvider,
    initialLocation: _getStartRoute(),
    redirect: _checkAuth,
    routes: _allRoutes(),
    errorBuilder: _errorPage,
  );
  String _getStartRoute() {
    if (authProvider.isAuthenticated) {
      return '/dashboard';
    }
    return '/login';
  }
  String? _checkAuth(BuildContext context, GoRouterState state) {
    final isLoggedIn = authProvider.isAuthenticated;
    final currentRoute = state.matchedLocation;
    if (!isLoggedIn) {
      return '/login';
    }
    final userRole = authProvider.user?['rol'] as String?;
    final institutions = authProvider.institutions;
    final selectedInstitutionId = authProvider.selectedInstitutionId;
    final isSuperAdmin = userRole == 'super_admin';
    final needsSelection = !isSuperAdmin &&
                          institutions != null &&
                          institutions.length > 1 &&
                          selectedInstitutionId == null;
    if (currentRoute == '/login') {
      return '/dashboard';
    }
    if (needsSelection && currentRoute != '/institution-selection') {
      return '/institution-selection';
    }
    if (!needsSelection && currentRoute == '/institution-selection') {
      return '/dashboard';
    }
    return null;
  }
  List<RouteBase> _allRoutes() {
    return [
      GoRoute(
        path: '/login',
        name: 'login',
        pageBuilder: (context, state) => _fadePage(
          context,
          state,
          const LoginScreen(),
        ),
      ),

      GoRoute(
        path: '/institution-selection',
        name: 'institution-selection',
        pageBuilder: (context, state) => _fadePage(
          context,
          state,
          const InstitutionSelectionScreen(),
        ),
      ),
      GoRoute(
        path: '/users/create',
        name: 'create-user',
        pageBuilder: (context, state) {
          final userRole = state.extra as String?;
          return MaterialPage(
            fullscreenDialog: true,
            name: 'Crear Usuario',
            child: UserFormScreen(userRole: userRole ?? 'estudiante'),
          );
        },
      ),
      GoRoute(
        path: '/users/detail/:id',
        name: 'user-detail',
        builder: (context, state) {
          final user = state.extra as User;
          return UserDetailScreen(user: user);
        },
      ),
      StatefulShellRoute.indexedStack(
        builder: (context, state, navigationShell) {
          return AppShell(navigationShell: navigationShell);
        },
        branches: [
          StatefulShellBranch(
            navigatorKey: _dashboardNavigatorKey,
            routes: [
              GoRoute(
                path: '/dashboard',
                name: 'dashboard',
                pageBuilder: (context, state) => NoTransitionPage(
                  child: _getDashboardForRole(),
                ),
              ),
              GoRoute(
                path: '/academic',
                name: 'academic-management',
                pageBuilder: (context, state) => const NoTransitionPage(
                  child: GestionAcademicaScreen(),
                ),
              ),
              GoRoute(
                path: '/academic/grupos',
                name: 'academic-grupos',
                pageBuilder: (context, state) => const NoTransitionPage(
                  child: GruposScreen(),
                ),
              ),
              GoRoute(
                path: '/academic/materias',
                name: 'academic-materias',
                pageBuilder: (context, state) => const NoTransitionPage(
                  child: MateriasScreen(),
                ),
              ),
              GoRoute(
                path: '/academic/periodos',
                name: 'academic-periodos',
                pageBuilder: (context, state) => const NoTransitionPage(
                  child: PeriodosAcademicosScreen(),
                ),
              ),
              GoRoute(
                path: '/academic/horarios',
                name: 'academic-horarios',
                pageBuilder: (context, state) => const NoTransitionPage(
                  child: HorariosScreen(),
                ),
              ),
              GoRoute(
                path: '/test-multi-hora',
                name: 'test-multi-hora',
                pageBuilder: (context, state) => const NoTransitionPage(
                  child: TestMultiHoraScreen(),
                ),
              ),
              GoRoute(
                path: '/academic/grupos/:id',
                name: 'academic-grupo-detail',
                pageBuilder: (context, state) {
                  final grupo = state.extra as Grupo;
                  return NoTransitionPage(
                    child: GrupoDetailScreen(grupo: grupo),
                  );
                },
              ),
              GoRoute(
                path: '/student/qr',
                name: 'student-qr',
                pageBuilder: (context, state) => const NoTransitionPage(
                  child: MyQRCodeScreen(),
                ),
              ),
              GoRoute(
                path: '/student/schedule',
                name: 'student-schedule',
                pageBuilder: (context, state) => const NoTransitionPage(
                  child: StudentScheduleScreen(),
                ),
              ),
              GoRoute(
                path: '/student/attendance',
                name: 'student-attendance',
                pageBuilder: (context, state) => const NoTransitionPage(
                  child: StudentAttendanceScreen(),
                ),
              ),
              GoRoute(
                path: '/teacher/attendance',
                name: 'teacher-attendance',
                pageBuilder: (context, state) {
                  final clase = state.extra as ClaseDelDia;
                  return MaterialPage(
                    fullscreenDialog: false,
                    name: 'Teacher Attendance',
                    child: AttendanceScreen(clase: clase),
                  );
                },
              ),
              GoRoute(
                path: '/student/notifications',
                name: 'student-notifications',
                pageBuilder: (context, state) => const NoTransitionPage(
                  child: StudentNotificationsScreen(),
                ),
              ),
            ],
          ),
          StatefulShellBranch(
            navigatorKey: _institutionsNavigatorKey,
            routes: [
              GoRoute(
                path: '/institutions',
                name: 'institutions-list',
                pageBuilder: (context, state) => const NoTransitionPage(
                  child: InstitutionsListScreen(),
                ),
              ),
              GoRoute(
                path: '/institutions/form',
                name: 'institution-form',
                pageBuilder: (context, state) {
                  final institution = state.extra as Institution?;
                  return MaterialPage(
                    fullscreenDialog: true,
                    name: 'Institution Form',
                    child: InstitutionFormScreen(institution: institution),
                  );
                },
              ),
              GoRoute(
                path: '/institutions/create-admin',
                name: 'institution-create-admin',
                pageBuilder: (context, state) {
                  final institution = state.extra as Institution;
                  return MaterialPage(
                    fullscreenDialog: true,
                    name: 'Create Institution Admin',
                    child: CreateInstitutionAdminScreen(institution: institution),
                  );
                },
              ),
              GoRoute(
                path: '/institutions/:id/admins',
                name: 'institution-admins',
                pageBuilder: (context, state) {
                  final segments = state.uri.pathSegments;
                  final id = segments.length >= 2 ? segments[1] : '';
                  return MaterialPage(
                    fullscreenDialog: false,
                    name: 'Institution Admins',
                    child: InstitutionAdminsScreen(institutionId: id),
                  );
                },
              ),
            ],
          ),
          StatefulShellBranch(
            navigatorKey: _usersNavigatorKey,
            routes: [
              GoRoute(
                path: '/users',
                name: 'users-list',
                pageBuilder: (context, state) => const NoTransitionPage(
                  child: UsersListScreen(),
                ),
              ),
            ],
          ),
        ],
      ),
    ];
  }
  Widget _getDashboardForRole() {
    final role = authProvider.user?['rol'] as String?;
    switch (role) {
      case 'super_admin':
        return const SuperAdminDashboard();
      case 'admin_institucion':
        return const AdminDashboard();
      case 'profesor':
        return const TeacherDashboard();
      case 'estudiante':
        return const StudentDashboard();
      default:
        return const LoginScreen();
    }
  }
  Page _fadePage(BuildContext context, GoRouterState state, Widget child) {
    return CustomTransitionPage(
      key: state.pageKey,
      child: child,
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        return FadeTransition(opacity: animation, child: child);
      },
    );
  }
  Widget _errorPage(BuildContext context, GoRouterState state) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, size: 48, color: Colors.red),
            const SizedBox(height: 16),
            const Text('Error de NavegaciÃ³n',
              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
            const SizedBox(height: 8),
            Text('${state.error}'),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () => context.go('/login'),
              child: const Text('Ir al inicio'),
            ),
          ],
        ),
      ),
    );
  }
  void dispose() {
    router.dispose();
  }
}

/* Fin lib\utils\app_router.dart */

/* Inicio lib\utils\http_client.dart */
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/material.dart';
import '../providers/auth_provider.dart';
import 'package:provider/provider.dart';
class AppHttpClient {
  final BuildContext? context;
  final http.Client _client = http.Client();

  AppHttpClient({this.context});
  Map<String, String> _getDefaultHeaders({Map<String, String>? additionalHeaders}) {
    final headers = <String, String>{
      'Content-Type': 'application/json',
      'Accept': 'application/json',
    };

    if (additionalHeaders != null) {
      headers.addAll(additionalHeaders);
    }

    return headers;
  }
  void _handleResponse(http.Response response, Uri url) {
    debugPrint('ğŸ“¡ HTTP ${response.statusCode} ${url.path}');

    if (response.statusCode == 401) {
      debugPrint('ğŸ”’ Token expirado o invÃ¡lido - cerrando sesiÃ³n');
      _forceLogout('Tu sesiÃ³n ha expirado. Por favor inicia sesiÃ³n nuevamente.');
      throw UnauthorizedException('Token expirado o invÃ¡lido');
    }
    if (response.statusCode == 403) {
      final body = jsonDecode(response.body);
      final errorMsg = body['error'] ?? '';

      if (errorMsg.toString().contains('inactiva')) {
        debugPrint('ğŸ”’ InstituciÃ³n inactiva - cerrando sesiÃ³n');
        _forceLogout('La instituciÃ³n ha sido desactivada. Contacta al administrador.');
        throw UnauthorizedException('InstituciÃ³n inactiva');
      }
    }
  }

  void _forceLogout(String message) {
    if (context != null && context!.mounted) {
      final authProvider = Provider.of<AuthProvider>(context!, listen: false);
      authProvider.logout();
      ScaffoldMessenger.of(context!).showSnackBar(
        SnackBar(
          content: Text(message),
          backgroundColor: Colors.orange,
          duration: const Duration(seconds: 5),
        ),
      );
    }
  }
  Future<http.Response> get(
    Uri url, {
    Map<String, String>? headers,
  }) async {
    try {
      debugPrint('ğŸ“¤ GET ${url.path}');

      final response = await _client.get(
        url,
        headers: _getDefaultHeaders(additionalHeaders: headers),
      );

      _handleResponse(response, url);
      return response;
    } catch (e) {
      debugPrint('âŒ Error en GET ${url.path}: $e');
      rethrow;
    }
  }
  Future<http.Response> post(
    Uri url, {
    Map<String, String>? headers,
    Object? body,
    Encoding? encoding,
  }) async {
    try {
      debugPrint('ğŸ“¤ POST ${url.path}');

      final response = await _client.post(
        url,
        headers: _getDefaultHeaders(additionalHeaders: headers),
        body: body,
        encoding: encoding,
      );

      _handleResponse(response, url);
      return response;
    } catch (e) {
      debugPrint('âŒ Error en POST ${url.path}: $e');
      rethrow;
    }
  }
  Future<http.Response> put(
    Uri url, {
    Map<String, String>? headers,
    Object? body,
    Encoding? encoding,
  }) async {
    try {
      debugPrint('ğŸ“¤ PUT ${url.path}');

      final response = await _client.put(
        url,
        headers: _getDefaultHeaders(additionalHeaders: headers),
        body: body,
        encoding: encoding,
      );

      _handleResponse(response, url);
      return response;
    } catch (e) {
      debugPrint('âŒ Error en PUT ${url.path}: $e');
      rethrow;
    }
  }
  Future<http.Response> delete(
    Uri url, {
    Map<String, String>? headers,
    Object? body,
    Encoding? encoding,
  }) async {
    try {
      debugPrint('ğŸ“¤ DELETE ${url.path}');

      final response = await _client.delete(
        url,
        headers: _getDefaultHeaders(additionalHeaders: headers),
        body: body,
        encoding: encoding,
      );

      _handleResponse(response, url);
      return response;
    } catch (e) {
      debugPrint('âŒ Error en DELETE ${url.path}: $e');
      rethrow;
    }
  }
  Future<http.Response> patch(
    Uri url, {
    Map<String, String>? headers,
    Object? body,
    Encoding? encoding,
  }) async {
    try {
      debugPrint('ğŸ“¤ PATCH ${url.path}');

      final response = await _client.patch(
        url,
        headers: _getDefaultHeaders(additionalHeaders: headers),
        body: body,
        encoding: encoding,
      );

      _handleResponse(response, url);
      return response;
    } catch (e) {
      debugPrint('âŒ Error en PATCH ${url.path}: $e');
      rethrow;
    }
  }
  void close() {
    _client.close();
  }
}
class UnauthorizedException implements Exception {
  final String message;

  UnauthorizedException(this.message);

  @override
  String toString() => 'UnauthorizedException: $message';
}

/* Fin lib\utils\http_client.dart */

/* Inicio lib\utils\responsive_utils.dart */
import 'package:flutter/material.dart';
import '../config/app_constants.dart';
class ResponsiveUtils {
  static final AppConstants _constants = AppConstants.instance;
  static Map<String, dynamic> getResponsiveValues(BoxConstraints constraints) {
    final screenType = _constants.getScreenType(constraints.maxWidth);
    final maxWidth = _constants.getMaxWidth(constraints.maxWidth);
    final horizontalPadding = switch (screenType) {
      ScreenType.mobileSmall => 16.0,
      ScreenType.mobileLarge => 24.0,
      ScreenType.tablet => 32.0,
      ScreenType.desktop => 48.0,
      ScreenType.largeDesktop => 64.0,
    };
    final verticalPadding = switch (screenType) {
      ScreenType.mobileSmall => 24.0,
      ScreenType.mobileLarge => 32.0,
      ScreenType.tablet => 48.0,
      ScreenType.desktop => 64.0,
      ScreenType.largeDesktop => 80.0,
    };
    final elementSpacing = switch (screenType) {
      ScreenType.mobileSmall => 16.0,
      ScreenType.mobileLarge => 20.0,
      ScreenType.tablet => 24.0,
      ScreenType.desktop => 32.0,
      ScreenType.largeDesktop => 40.0,
    };
    final titleFontSize = switch (screenType) {
      ScreenType.mobileSmall => 24.0,
      ScreenType.mobileLarge => 28.0,
      ScreenType.tablet => 32.0,
      ScreenType.desktop => 40.0,
      ScreenType.largeDesktop => 48.0,
    };

    final subtitleFontSize = switch (screenType) {
      ScreenType.mobileSmall => 14.0,
      ScreenType.mobileLarge => 16.0,
      ScreenType.tablet => 18.0,
      ScreenType.desktop => 20.0,
      ScreenType.largeDesktop => 24.0,
    };

    final bodyFontSize = switch (screenType) {
      ScreenType.mobileSmall => 14.0,
      ScreenType.mobileLarge => 16.0,
      ScreenType.tablet => 16.0,
      ScreenType.desktop => 18.0,
      ScreenType.largeDesktop => 20.0,
    };
    final buttonWidth = switch (screenType) {
      ScreenType.mobileSmall => double.infinity,
      ScreenType.mobileLarge => 280.0,
      ScreenType.tablet => 320.0,
      ScreenType.desktop => 360.0,
      ScreenType.largeDesktop => 400.0,
    };
    final minHeight = switch (screenType) {
      ScreenType.mobileSmall => 600.0,
      ScreenType.mobileLarge => 700.0,
      ScreenType.tablet => 800.0,
      ScreenType.desktop => 900.0,
      ScreenType.largeDesktop => 1000.0,
    };

    return {
      'screenType': screenType,
      'maxWidth': maxWidth,
      'horizontalPadding': horizontalPadding,
      'verticalPadding': verticalPadding,
      'elementSpacing': elementSpacing,
      'titleFontSize': titleFontSize,
      'subtitleFontSize': subtitleFontSize,
      'bodyFontSize': bodyFontSize,
      'buttonWidth': buttonWidth,
      'minHeight': minHeight,
      'isSmallScreen': screenType == ScreenType.mobileSmall,
      'isMobile': screenType == ScreenType.mobileSmall || screenType == ScreenType.mobileLarge,
      'isTablet': screenType == ScreenType.tablet,
      'isDesktop': screenType == ScreenType.desktop || screenType == ScreenType.largeDesktop,
      'isLargeDesktop': screenType == ScreenType.largeDesktop,
    };
  }
  static Widget buildResponsiveContainer({
    required BuildContext context,
    required Widget child,
    double? maxWidth,
    EdgeInsets? padding,
    bool centerContent = true,
  }) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final responsive = getResponsiveValues(constraints);
        final containerMaxWidth = maxWidth ?? responsive['maxWidth'];
        final containerPadding = padding ?? EdgeInsets.symmetric(
          horizontal: responsive['horizontalPadding'],
          vertical: responsive['verticalPadding'],
        );

        final content = ConstrainedBox(
          constraints: BoxConstraints(maxWidth: containerMaxWidth),
          child: child,
        );

        return Container(
          width: double.infinity,
          padding: containerPadding,
          constraints: BoxConstraints(minHeight: responsive['minHeight']),
          child: centerContent ? Center(child: content) : content,
        );
      },
    );
  }
  static TextStyle getResponsiveTextStyle(
    TextStyle baseStyle,
    ScreenType screenType, {
    double? fontSize,
  }) {
    final scaleFactor = switch (screenType) {
      ScreenType.mobileSmall => 0.8,
      ScreenType.mobileLarge => 0.9,
      ScreenType.tablet => 1.0,
      ScreenType.desktop => 1.1,
      ScreenType.largeDesktop => 1.2,
    };

    final scaledFontSize = fontSize ?? (baseStyle.fontSize ?? 14.0) * scaleFactor;

    return baseStyle.copyWith(fontSize: scaledFontSize);
  }
  static SliverGridDelegate getResponsiveGridDelegate(ScreenType screenType) {
    return switch (screenType) {
      ScreenType.mobileSmall => const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 1,
          crossAxisSpacing: 16,
          mainAxisSpacing: 16,
          childAspectRatio: 1.2,
        ),
      ScreenType.mobileLarge => const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 2,
          crossAxisSpacing: 16,
          mainAxisSpacing: 16,
          childAspectRatio: 1.1,
        ),
      ScreenType.tablet => const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 3,
          crossAxisSpacing: 20,
          mainAxisSpacing: 20,
          childAspectRatio: 1.0,
        ),
      ScreenType.desktop => const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 4,
          crossAxisSpacing: 24,
          mainAxisSpacing: 24,
          childAspectRatio: 0.9,
        ),
      ScreenType.largeDesktop => const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 5,
          crossAxisSpacing: 28,
          mainAxisSpacing: 28,
          childAspectRatio: 0.8,
        ),
    };
  }
}
/* Fin lib\utils\responsive_utils.dart */

/* Inicio lib\utils\role_enum.dart */

enum UserRole {
  superAdmin,       // Administrador global del sistema
  adminInstitucion, // Administrador de una instituciÃ³n
  profesor,         // Profesor de clases
  estudiante,       // Estudiante
}
extension UserRoleExtension on UserRole {
  String get value {
    switch (this) {
      case UserRole.superAdmin:
        return 'super_admin';
      case UserRole.adminInstitucion:
        return 'admin_institucion';
      case UserRole.profesor:
        return 'profesor';
      case UserRole.estudiante:
        return 'estudiante';
    }
  }
  String get displayName {
    switch (this) {
      case UserRole.superAdmin:
        return 'Super Administrador';
      case UserRole.adminInstitucion:
        return 'Administrador';
      case UserRole.profesor:
        return 'Profesor';
      case UserRole.estudiante:
        return 'Estudiante';
    }
  }
  static UserRole fromString(String role) {
    switch (role) {
      case 'super_admin':
        return UserRole.superAdmin;
      case 'admin_institucion':
        return UserRole.adminInstitucion;
      case 'profesor':
        return UserRole.profesor;
      case 'estudiante':
        return UserRole.estudiante;
      default:
        throw ArgumentError('Rol desconocido: $role');
    }
  }
  bool get isAdmin {
    return this == UserRole.superAdmin || this == UserRole.adminInstitucion;
  }
  bool get isSuperAdmin {
    return this == UserRole.superAdmin;
  }
}
/* Fin lib\utils\role_enum.dart */

/* Inicio lib\utils\test_flow_manager.dart */


import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../providers/institution_provider.dart';
import '../providers/user_provider.dart';
import '../providers/materia_provider.dart';
import '../providers/grupo_provider.dart';
import '../providers/horario_provider.dart';
import '../providers/asistencia_provider.dart';
import '../models/user.dart';
import '../services/academic/materia_service.dart';
class TestFlowManager {
  static const String testSuperAdminEmail = 'superadmin@asistapp.com';
  static const String testSuperAdminPassword = 'Admin123!';
  static Future<void> step1LoginSuperAdmin(BuildContext context) async {
    debugPrint('ğŸ§ª PASO 1: Iniciando sesiÃ³n como Super Admin');
    final router = GoRouter.of(context);
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    if (ModalRoute.of(context)?.settings.name != '/login') {
      router.go('/login');
      await Future.delayed(const Duration(seconds: 1));
    }
    await authProvider.login(testSuperAdminEmail, testSuperAdminPassword);

    if (authProvider.isAuthenticated && authProvider.user?['rol'] == 'super_admin') {
      debugPrint('âœ… Login exitoso como Super Admin');
      router.go('/dashboard');
    } else {
      throw Exception('âŒ Error en login de Super Admin');
    }
  }
  static Future<void> step2CrearInstitucion(BuildContext context) async {
    debugPrint('ğŸ§ª PASO 2: Creando instituciÃ³n de prueba');

    final router = GoRouter.of(context);
    final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    router.go('/institutions');
    await Future.delayed(const Duration(seconds: 1));
    final institutionData = {
      'nombre': 'Colegio Nacional de Pruebas',
      'direccion': 'Calle de las Pruebas 123',
      'telefono': '+57 300 123 4567',
      'email': 'info@colegiopruebas.edu.co',
      'tipo': 'colegio',
      'activo': true,
    };
  final token = authProvider.accessToken;
  if (token == null) throw Exception('No hay sesiÃ³n activa');
    final success = await institutionProvider.createInstitution(token, institutionData);

    if (success) {
      debugPrint('âœ… InstituciÃ³n creada exitosamente');
      await institutionProvider.loadInstitutions(token);
    } else {
      throw Exception('âŒ Error creando instituciÃ³n');
    }
  }
  static Future<void> step3CrearAdminInstitucion(BuildContext context) async {
    debugPrint('ğŸ§ª PASO 3: Creando administrador de instituciÃ³n');

    final router = GoRouter.of(context);
    final userProvider = Provider.of<UserProvider>(context, listen: false);
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);
    final institutions = institutionProvider.institutions;
    if (institutions.isEmpty) {
      throw Exception('âŒ No hay instituciones disponibles');
    }
    final institutionId = institutions.first.id;
    router.go('/institutions/$institutionId/admins');
    await Future.delayed(const Duration(seconds: 1));
    final adminData = CreateUserRequest(
      email: 'admin.pruebas@colegiopruebas.edu.co',
      password: 'Admin123!',
      nombres: 'MarÃ­a JosÃ©',
      apellidos: 'RodrÃ­guez PÃ©rez',
      rol: 'admin_institucion',
      telefono: '+57 301 987 6543',
      institucionId: institutionId,
      rolEnInstitucion: 'director',
    );
  final token = authProvider.accessToken;
  if (token == null) throw Exception('No hay sesiÃ³n activa');
    final success = await userProvider.createUser(token, adminData);

    if (success) {
      debugPrint('âœ… Administrador creado exitosamente');
      await userProvider.loadUsers(token);
    } else {
      throw Exception('âŒ Error creando administrador de instituciÃ³n');
    }
  }
  static Future<void> step4CrearProfesores(BuildContext context) async {
    debugPrint('ğŸ§ª PASO 4: Creando profesores');
    final router = GoRouter.of(context);
    final userProvider = Provider.of<UserProvider>(context, listen: false);
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);
    final institutions = institutionProvider.institutions;
    if (institutions.isEmpty) {
      throw Exception('âŒ No hay instituciones disponibles');
    }
    final institutionId = institutions.first.id;
    router.go('/users');
    await Future.delayed(const Duration(seconds: 1));
    final profesoresData = [
      CreateUserRequest(
        email: 'juan.perez@colegiopruebas.edu.co',
        password: 'Prof123!',
        nombres: 'Juan Carlos',
        apellidos: 'PÃ©rez LÃ³pez',
        rol: 'profesor',
        telefono: '+57 302 111 2222',
        institucionId: institutionId,
        rolEnInstitucion: 'profesor',
        especialidad: 'MatemÃ¡ticas',
      ),
      CreateUserRequest(
        email: 'ana.garcia@colegiopruebas.edu.co',
        password: 'Prof123!',
        nombres: 'Ana MarÃ­a',
        apellidos: 'GarcÃ­a RodrÃ­guez',
        rol: 'profesor',
        telefono: '+57 302 333 4444',
        institucionId: institutionId,
        rolEnInstitucion: 'profesor',
        especialidad: 'EspaÃ±ol',
      ),
    ];

  final token = authProvider.accessToken;
  if (token == null) throw Exception('No hay sesiÃ³n activa');
    int created = 0;

    for (final profesorData in profesoresData) {
      final success = await userProvider.createUser(token, profesorData);
      if (success) {
        debugPrint('âœ… Profesor creado: ${profesorData.nombres} ${profesorData.apellidos}');
        created++;
      } else {
        debugPrint('âŒ Error creando profesor: ${profesorData.nombres}');
      }
    }

    if (created > 0) {
      await userProvider.loadUsers(token);
    }
  }
  static Future<void> step5CrearEstudiantes(BuildContext context) async {
    debugPrint('ğŸ§ª PASO 5: Creando estudiantes');

    final userProvider = Provider.of<UserProvider>(context, listen: false);
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);
    final institutions = institutionProvider.institutions;
    if (institutions.isEmpty) {
      throw Exception('âŒ No hay instituciones disponibles');
    }
    final institutionId = institutions.first.id;
    final estudiantesData = [
      CreateUserRequest(
        email: 'pedro.gonzalez@colegiopruebas.edu.co',
        password: 'Est123!',
        nombres: 'Pedro Antonio',
        apellidos: 'GonzÃ¡lez Silva',
        rol: 'estudiante',
        telefono: '+57 310 111 1111',
        institucionId: institutionId,
        identificacion: '1234567890',
        nombreResponsable: 'MarÃ­a GonzÃ¡lez',
        telefonoResponsable: '+57 311 222 2222',
      ),
      CreateUserRequest(
        email: 'maria.lopez@colegiopruebas.edu.co',
        password: 'Est123!',
        nombres: 'MarÃ­a Fernanda',
        apellidos: 'LÃ³pez HernÃ¡ndez',
        rol: 'estudiante',
        telefono: '+57 310 333 3333',
        institucionId: institutionId,
        identificacion: '1234567891',
        nombreResponsable: 'JosÃ© LÃ³pez',
        telefonoResponsable: '+57 311 444 4444',
      ),
    ];

  final token = authProvider.accessToken;
  if (token == null) throw Exception('No hay sesiÃ³n activa');
    int created = 0;

    for (final estudianteData in estudiantesData) {
      final success = await userProvider.createUser(token, estudianteData);
      if (success) {
        debugPrint('âœ… Estudiante creado: ${estudianteData.nombres} ${estudianteData.apellidos}');
        created++;
      } else {
        debugPrint('âŒ Error creando estudiante: ${estudianteData.nombres}');
      }
    }

    if (created > 0) {
      await userProvider.loadUsers(token);
    }
  }
  static Future<void> step6CrearMaterias(BuildContext context) async {
    debugPrint('ğŸ§ª PASO 6: Creando materias');

    final router = GoRouter.of(context);
    final materiaProvider = Provider.of<MateriaProvider>(context, listen: false);
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);
    final institutions = institutionProvider.institutions;
    if (institutions.isEmpty) {
      throw Exception('âŒ No hay instituciones disponibles');
    }
    router.go('/academic');
    await Future.delayed(const Duration(seconds: 1));
    final materiasData = [
      CreateMateriaRequest(
        nombre: 'MatemÃ¡ticas Avanzadas',
        codigo: 'MAT101',
      ),
      CreateMateriaRequest(
        nombre: 'EspaÃ±ol y Literatura',
        codigo: 'ESP201',
      ),
    ];

  final token = authProvider.accessToken;
  if (token == null) throw Exception('No hay sesiÃ³n activa');
    int created = 0;

    for (final materiaData in materiasData) {
      final success = await materiaProvider.createMateria(token, materiaData);
      if (success) {
        debugPrint('âœ… Materia creada: ${materiaData.nombre}');
        created++;
      } else {
        debugPrint('âŒ Error creando materia: ${materiaData.nombre}');
      }
    }

    if (created > 0) {
      await materiaProvider.loadMaterias(token);
    }
  }
  static Future<void> step7CrearGrupos(BuildContext context) async {
    debugPrint('ğŸ§ª PASO 7: Verificando sistema de grupos');

    final router = GoRouter.of(context);
  final grupoProvider = Provider.of<GrupoProvider>(context, listen: false);
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    router.go('/grupos');
    await Future.delayed(const Duration(seconds: 1));
  final token = authProvider.accessToken;
  if (token == null) throw Exception('No hay sesiÃ³n activa');
  await grupoProvider.loadItems(token);

  debugPrint('âœ… Sistema de grupos verificado - ${grupoProvider.items.length} grupos disponibles');
  }
  static Future<void> step8CrearHorarios(BuildContext context) async {
    debugPrint('ğŸ§ª PASO 8: Verificando sistema de horarios');

    final router = GoRouter.of(context);
    final horarioProvider = Provider.of<HorarioProvider>(context, listen: false);
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    router.go('/horarios');
    await Future.delayed(const Duration(seconds: 1));
  final token = authProvider.accessToken;
  if (token == null) throw Exception('No hay sesiÃ³n activa');
  await horarioProvider.loadHorarios(token);

    debugPrint('âœ… Sistema de horarios verificado - ${horarioProvider.horarios.length} horarios disponibles');
  }
  static Future<void> step9VerificarAsistencias(BuildContext context) async {
    debugPrint('ğŸ§ª PASO 9: Verificando sistema de asistencias');

    final asistenciaProvider = Provider.of<AsistenciaProvider>(context, listen: false);
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final horarioProvider = Provider.of<HorarioProvider>(context, listen: false);
    final horarios = horarioProvider.horarios;
    if (horarios.isEmpty) {
      debugPrint('âš ï¸ No hay horarios disponibles para verificar asistencias');
      return;
    }
  final token = authProvider.accessToken;
  if (token == null) throw Exception('No hay sesiÃ³n activa');
  await asistenciaProvider.fetchAsistencias(token, horarios.first.id);

    debugPrint('âœ… Sistema de asistencias verificado - ${asistenciaProvider.asistencias.length} estudiantes listos');
  }
  static Future<void> step10VerificarDashboards(BuildContext context) async {
    debugPrint('ğŸ§ª PASO 10: Verificando dashboards');
    final router = GoRouter.of(context);
    router.go('/teacher-dashboard');
    await Future.delayed(const Duration(seconds: 2));
    debugPrint('âœ… Dashboard de profesor verificado');
    router.go('/student-dashboard');
    await Future.delayed(const Duration(seconds: 2));
    debugPrint('âœ… Dashboard de estudiante verificado');
    router.go('/qr-scanner');
    await Future.delayed(const Duration(seconds: 2));
    debugPrint('âœ… EscÃ¡ner QR verificado');
    router.go('/my-qr-code');
    await Future.delayed(const Duration(seconds: 2));
    debugPrint('âœ… CÃ³digo QR personal verificado');
  }
  static Future<void> ejecutarFlujoCompleto(BuildContext context) async {
    debugPrint('ğŸš€ INICIANDO FLUJO COMPLETO DE PRUEBAS');
    debugPrint('=' * 50);

    try {
  await step1LoginSuperAdmin(context);
  await step2CrearInstitucion(context);
  await step3CrearAdminInstitucion(context);
  await step4CrearProfesores(context);
  await step5CrearEstudiantes(context);
  await step6CrearMaterias(context);
  await step7CrearGrupos(context);
  await step8CrearHorarios(context);
  await step9VerificarAsistencias(context);
  await step10VerificarDashboards(context);

      debugPrint('=' * 50);
      debugPrint('ğŸ‰ FLUJO COMPLETO DE PRUEBAS FINALIZADO EXITOSAMENTE');
      debugPrint('âœ… Todos los componentes probados:');
      debugPrint('   â€¢ AutenticaciÃ³n y roles');
      debugPrint('   â€¢ GestiÃ³n de instituciones');
      debugPrint('   â€¢ CreaciÃ³n de usuarios (admins, profesores, estudiantes)');
      debugPrint('   â€¢ GestiÃ³n acadÃ©mica (materias, grupos, horarios)');
      debugPrint('   â€¢ Sistema de asistencias con QR');
      debugPrint('   â€¢ Dashboards por rol');
      debugPrint('   â€¢ NavegaciÃ³n y UI/UX');

    } catch (e) {
      debugPrint('âŒ ERROR en el flujo de pruebas: $e');
      rethrow;
    }
  }
  static Future<void> ejecutarPruebasUI(BuildContext context) async {
    debugPrint('ğŸ¨ INICIANDO PRUEBAS DE UI');

    try {
      await _probarNavegacion(context);
      await _probarFormularios(context);
      await _probarDashboards(context);

      debugPrint('âœ… Pruebas de UI completadas');

    } catch (e) {
      debugPrint('âŒ Error en pruebas UI: $e');
      rethrow;
    }
  }
  static Future<void> _probarNavegacion(BuildContext context) async {
    debugPrint('ğŸ§ª Probando navegaciÃ³n...');
    final router = GoRouter.of(context);
    final rutas = [
      '/login',
      '/dashboard',
      '/admin-dashboard',
      '/teacher-dashboard',
      '/student-dashboard',
      '/users',
      '/institutions',
      '/academic',
      '/qr-scanner',
      '/my-qr-code',
    ];

    for (final ruta in rutas) {
      router.go(ruta);
      await Future.delayed(const Duration(milliseconds: 500));
      debugPrint('âœ… NavegaciÃ³n a $ruta OK');
    }
  }

  static Future<void> _probarFormularios(BuildContext context) async {
    debugPrint('ğŸ§ª Probando formularios...');
    debugPrint('âœ… Formularios probados');
  }

  static Future<void> _probarDashboards(BuildContext context) async {
    debugPrint('ğŸ§ª Probando dashboards...');
    final router = GoRouter.of(context);
    final dashboards = [
      '/dashboard',
      '/admin-dashboard',
      '/teacher-dashboard',
      '/student-dashboard',
    ];

    for (final dashboard in dashboards) {
      router.go(dashboard);
      await Future.delayed(const Duration(seconds: 1));
      debugPrint('âœ… Dashboard $dashboard OK');
    }
  }
}
/* Fin lib\utils\test_flow_manager.dart */

/* Inicio lib\widgets\common\dashboard_scaffold.dart */
import 'package:flutter/material.dart';
import '../../theme/theme_extensions.dart';

class DashboardActionItem {
  final IconData icon;
  final String label;
  final VoidCallback? onTap;

  DashboardActionItem({required this.icon, required this.label, this.onTap});
}

class DashboardScaffold extends StatelessWidget {
  final String userName;
  final String subtitle;
  final List<Widget>? statsWidgets;
  final Widget? kpiWidget;
  final Widget? recentActivityWidget;
  final List<DashboardActionItem>? actionItems;

  const DashboardScaffold({
    super.key,
    required this.userName,
    required this.subtitle,
    this.statsWidgets,
    this.kpiWidget,
    this.recentActivityWidget,
    this.actionItems,
  });

  @override
  Widget build(BuildContext context) {
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return SingleChildScrollView(
      padding: EdgeInsets.all(spacing.lg),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('Â¡Hola, $userName!', style: textStyles.displayMedium),
          SizedBox(height: spacing.sm),
          Text(subtitle, style: textStyles.bodyLarge),
          SizedBox(height: spacing.xl),

          if ((statsWidgets ?? []).isNotEmpty) ...[
            Wrap(spacing: spacing.md, runSpacing: spacing.md, children: statsWidgets ?? []),
            SizedBox(height: spacing.xl),
          ],

          if (kpiWidget != null || recentActivityWidget != null)
            LayoutBuilder(builder: (context, constraints) {
              final isNarrow = constraints.maxWidth < 800;
              final _kw = kpiWidget;
              final _raw = recentActivityWidget;
              if (isNarrow) {
                return Column(children: [if (_kw != null) _kw, if (_raw != null) SizedBox(height: spacing.md), if (_raw != null) _raw]);
              }
              return Row(crossAxisAlignment: CrossAxisAlignment.start, children: [if (_kw != null) Expanded(child: _kw), if (_kw != null) SizedBox(width: spacing.md), if (_raw != null) SizedBox(width: 420, child: _raw)]);
            }),

          SizedBox(height: spacing.xl),

          if ((actionItems ?? []).isNotEmpty) ...[
            Text('Acciones Principales', style: textStyles.headlineSmall),
            SizedBox(height: spacing.md),
            Material(
              type: MaterialType.transparency,
              child: Column(children: (actionItems ?? []).map((ai) => ListTile(leading: Icon(ai.icon), title: Text(ai.label), onTap: ai.onTap)).toList()),
            ),
          ],
        ],
      ),
    );
  }
}

/* Fin lib\widgets\common\dashboard_scaffold.dart */

/* Inicio lib\widgets\common\empty_state_widget.dart */
import 'package:flutter/material.dart';
import '../../theme/theme_extensions.dart';

class EmptyStateWidget extends StatelessWidget {
  final IconData icon;
  final String title;
  final String message;

  const EmptyStateWidget({
    super.key,
    required this.icon,
    required this.title,
    required this.message,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            icon,
            size: 64,
            color: colors.textMuted,
          ),
          SizedBox(height: spacing.lg),
          Text(
            title,
            style: textStyles.headlineMedium.withColor(colors.textSecondary),
            textAlign: TextAlign.center,
          ),
          SizedBox(height: spacing.md),
          Text(
            message,
            style: textStyles.bodyMedium.withColor(colors.textSecondary),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }
}
/* Fin lib\widgets\common\empty_state_widget.dart */

/* Inicio lib\widgets\common\index.dart */
export 'empty_state_widget.dart';
export 'management_scaffold.dart';
export 'shimmer_list_widget.dart';

/* Fin lib\widgets\common\index.dart */

/* Inicio lib\widgets\common\management_scaffold.dart */
import 'package:flutter/material.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';
import '../../models/user.dart';
import '../../theme/theme_extensions.dart';
import '../../widgets/common/empty_state_widget.dart';
import '../../widgets/common/shimmer_list_widget.dart';
import '../../widgets/pagination_widget.dart';

class ManagementScaffold extends StatelessWidget {
  final String title;
  final bool isLoading;
  final bool hasError;
  final String errorMessage;
  final int itemCount;
  final Widget Function(BuildContext, int) itemBuilder;
  final bool hasMoreData;
  final VoidCallback onRefresh;
  final ScrollController scrollController;
  final Widget? floatingActionButton;
  final List<Widget>? filterWidgets;
  final List<Widget>? statisticWidgets;
  final PaginationInfo? paginationInfo;
  final Future<void> Function(int) onPageChange;
  final String? emptyStateTitle;
  final String? emptyStateMessage;
  final IconData emptyStateIcon;

  const ManagementScaffold({
    super.key,
    required this.title,
    required this.isLoading,
    required this.hasError,
    required this.errorMessage,
    required this.itemCount,
    required this.itemBuilder,
    required this.hasMoreData,
    required this.onRefresh,
    required this.scrollController,
    this.floatingActionButton,
    this.filterWidgets,
    this.statisticWidgets,
    this.paginationInfo,
    required this.onPageChange,
    this.emptyStateTitle,
    this.emptyStateMessage,
    this.emptyStateIcon = Icons.business,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Scaffold(
      backgroundColor: colors.background,
      appBar: AppBar(
        title: Text(title, style: textStyles.headlineMedium.copyWith(color: colors.surface)),
        backgroundColor: colors.primary,
        elevation: 2,
      ),
      body: SafeArea(
        child: Column(
          children: [
            if (filterWidgets != null && filterWidgets!.isNotEmpty)
              Card(
                margin: EdgeInsets.symmetric(horizontal: spacing.lg, vertical: spacing.md),
                elevation: 2,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(spacing.borderRadius),
                ),
                child: ExpansionTile(
                  title: Text('Filtros y BÃºsqueda', style: textStyles.titleMedium),
                  children: [
                    Material(
                      color: colors.surface,
                      child: Padding(
                        padding: EdgeInsets.all(spacing.md),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: filterWidgets!,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            if (statisticWidgets != null && statisticWidgets!.isNotEmpty)
              Container(
                margin: EdgeInsets.symmetric(horizontal: spacing.lg),
                padding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
                decoration: BoxDecoration(
                  color: colors.surface,
                  borderRadius: BorderRadius.circular(spacing.borderRadius),
                  border: Border.all(color: colors.borderLight),
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: statisticWidgets!,
                ),
              ),
            Expanded(
              child: _buildListContent(context),
            ),
            if (paginationInfo != null)
              PaginationWidget(
                currentPage: paginationInfo!.page,
                totalPages: paginationInfo!.totalPages,
                totalItems: paginationInfo!.total,
                onPageChange: onPageChange,
                isLoading: isLoading,
              ),
          ],
        ),
      ),
      floatingActionButton: floatingActionButton,
    );
  }

  Widget _buildListContent(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;
    if (isLoading && itemCount == 0) {
      return ShimmerListWidget(
        itemCount: 5,
        cardBuilder: (context) => _buildShimmerCard(context),
      );
    }

    if (hasError) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline, size: 64, color: colors.error),
            SizedBox(height: spacing.lg),
            Text(
              'Error al cargar datos',
              style: textStyles.headlineMedium,
              textAlign: TextAlign.center,
            ),
            SizedBox(height: spacing.md),
            Text(
              errorMessage,
              style: textStyles.bodyMedium.withColor(colors.textSecondary),
              textAlign: TextAlign.center,
            ),
            SizedBox(height: spacing.lg),
            ElevatedButton(
              onPressed: onRefresh,
              style: ElevatedButton.styleFrom(
                backgroundColor: colors.primary,
                foregroundColor: Theme.of(context).colorScheme.onPrimary,
                padding: EdgeInsets.symmetric(
                  horizontal: spacing.lg,
                  vertical: spacing.md,
                ),
              ),
              child: Text('Reintentar', style: textStyles.button),
            ),
          ],
        ),
      );
    }

    if (itemCount == 0) {
      return EmptyStateWidget(
        icon: emptyStateIcon,
        title: emptyStateTitle ?? 'No hay elementos',
        message: emptyStateMessage ?? 'Comienza creando tu primer elemento',
      );
    }

    return AnimationLimiter(
      child: ListView.builder(
        controller: scrollController,
        padding: EdgeInsets.symmetric(horizontal: spacing.lg),
        itemCount: itemCount,
        itemBuilder: (context, index) {
          return AnimationConfiguration.staggeredList(
            position: index,
            duration: const Duration(milliseconds: 375),
            child: SlideAnimation(
              verticalOffset: 50.0,
              child: FadeInAnimation(
                child: itemBuilder(context, index),
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildShimmerCard(BuildContext context) {
    final spacing = context.spacing;
    return Card(
      margin: EdgeInsets.only(bottom: spacing.xs),
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(spacing.borderRadius),
      ),
      child: const ListTile(
        leading: CircleAvatar(),
        title: SizedBox(height: 16),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            SizedBox(height: 12),
            SizedBox(height: 12),
          ],
        ),
        trailing: SizedBox(width: 24, height: 24),
      ),
    );
  }
}
/* Fin lib\widgets\common\management_scaffold.dart */

/* Inicio lib\widgets\common\multi_step_form_scaffold.dart */
import 'package:flutter/material.dart';
import '../../theme/theme_extensions.dart';

class MultiStepFormScaffold extends StatefulWidget {
  final String title;
  final List<Step> steps;
  final Future<void> Function() onSave;
  final String nextLabel;
  final String previousLabel;
  final String submitLabel;
  final String cancelLabel;
  final GlobalKey<FormState>? formKey;

  const MultiStepFormScaffold({
    super.key,
    required this.title,
    required this.steps,
    required this.onSave,
    this.formKey,
    this.nextLabel = 'Siguiente',
    this.previousLabel = 'Anterior',
    this.submitLabel = 'Guardar',
    this.cancelLabel = 'Cancelar',
  });

  @override
  State<MultiStepFormScaffold> createState() => _MultiStepFormScaffoldState();
}

class _MultiStepFormScaffoldState extends State<MultiStepFormScaffold> {
  int _currentStep = 0;
  bool _isLoading = false;

  void _onStepContinue() async {
    final isLast = _currentStep == widget.steps.length - 1;
    if (!(_validateCurrentStep())) {
      return;
    }
    if (!isLast) {
      setState(() => _currentStep++);
    }
    else {
      setState(() => _isLoading = true);
      await widget.onSave();
      if (mounted) setState(() => _isLoading = false);
    }
  }

  bool _validateCurrentStep() {
    final currentForm = widget.formKey?.currentState;
    if (currentForm != null) return currentForm.validate();
    return true;
  }

  void _onStepCancel() {
    if (_currentStep > 0) {
      setState(() => _currentStep--);
    } else {
      Navigator.of(context).pop();
    }
  }

  @override
  Widget build(BuildContext context) {
    final spacing = context.spacing;

    return Scaffold(
      appBar: AppBar(title: Text(widget.title)),
      body: Form(
        key: widget.formKey,
        child: Stepper(
          currentStep: _currentStep,
          steps: widget.steps,
          onStepContinue: _onStepContinue,
          onStepCancel: _onStepCancel,
          onStepTapped: (index) => setState(() => _currentStep = index),
          controlsBuilder: (context, details) {
            final isLast = details.currentStep == widget.steps.length - 1;
            return Padding(
              padding: EdgeInsets.only(top: spacing.lg),
              child: Row(
                children: [
                  Expanded(child: OutlinedButton(onPressed: details.onStepCancel, child: Text(widget.previousLabel))),
                  SizedBox(width: spacing.md),
                  Expanded(child: ElevatedButton(onPressed: details.onStepContinue, child: _isLoading ? const SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2)) : Text(isLast ? widget.submitLabel : widget.nextLabel))),
                ],
              ),
            );
          },
        ),
      ),
    );
  }
}

/* Fin lib\widgets\common\multi_step_form_scaffold.dart */

/* Inicio lib\widgets\common\shimmer_list_widget.dart */
import 'package:flutter/material.dart';
import 'package:shimmer/shimmer.dart';
import '../../theme/theme_extensions.dart';

class ShimmerListWidget extends StatelessWidget {
  final Widget Function(BuildContext) cardBuilder;
  final int itemCount;

  const ShimmerListWidget({
    super.key,
    required this.cardBuilder,
    this.itemCount = 5,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;

    return Shimmer.fromColors(
      baseColor: colors.surface,
      highlightColor: colors.borderLight,
      child: ListView.builder(
        padding: EdgeInsets.symmetric(horizontal: spacing.lg, vertical: spacing.sm),
        itemCount: itemCount,
        itemBuilder: (context, index) {
          return cardBuilder(context);
        },
      ),
    );
  }
}
/* Fin lib\widgets\common\shimmer_list_widget.dart */

/* Inicio lib\widgets\components\clarity_components.dart */
import 'package:flutter/material.dart';
import '../../theme/app_colors.dart';
import '../../theme/app_text_styles.dart';
import '../../theme/app_spacing.dart';
class ClarityCard extends StatelessWidget {
  final Widget? leading;
  final Widget? title;
  final Widget? subtitle;
  final Widget? trailing;
  final VoidCallback? onTap;
  final EdgeInsetsGeometry? padding;
  final Color? backgroundColor;
  final double? elevation;

  const ClarityCard({
    super.key,
    this.leading,
    this.title,
    this.subtitle,
    this.trailing,
    this.onTap,
    this.padding,
    this.backgroundColor,
    this.elevation,
  });

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final spacing = AppSpacing.instance;

    return Card(
      color: backgroundColor ?? colors.surface,
      elevation: elevation ?? 1,
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(spacing.borderRadius),
        side: BorderSide(color: colors.border, width: 0.5),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(spacing.borderRadius),
        child: Padding(
          padding: padding ?? EdgeInsets.all(spacing.cardPadding),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.center, // Alinear verticalmente al centro
            children: [
              if (leading != null) ...[
                leading!,
                SizedBox(width: spacing.md),
              ],
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    if (title != null) title!,
                    if (subtitle != null && title != null) SizedBox(height: spacing.xs),
                    if (subtitle != null) subtitle!,
                  ],
                ),
              ),
              if (trailing != null) ...[
                SizedBox(width: spacing.md),
                trailing!,
              ],
            ],
          ),
        ),
      ),
    );
  }
}
class ClarityKPICard extends StatelessWidget {
  final String value;
  final String label;
  final IconData? icon;
  final Color? iconColor;
  final Color? backgroundColor;
  final VoidCallback? onTap;

  const ClarityKPICard({
    super.key,
    required this.value,
    required this.label,
    this.icon,
    this.iconColor,
    this.backgroundColor,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final textStyles = AppTextStyles.instance;
    final spacing = AppSpacing.instance;

    return Card(
      color: backgroundColor ?? colors.surface,
      elevation: 1,
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(spacing.borderRadius),
        side: BorderSide(color: colors.border, width: 0.5),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(spacing.borderRadius),
        child: Padding(
          padding: EdgeInsets.all(spacing.lg),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  if (icon != null) ...[
                    Icon(
                      icon,
                      color: iconColor ?? colors.primary,
                      size: spacing.iconSize,
                    ),
                    SizedBox(width: spacing.md),
                  ],
                  Flexible(
                    child: Text(
                      value,
                      style: textStyles.kpiNumber,
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
              SizedBox(height: spacing.sm),
              Text(
                label.toUpperCase(),
                style: textStyles.kpiLabel,
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
class ClarityStatusBadge extends StatelessWidget {
  final String text;
  final Color? backgroundColor;
  final Color? textColor;
  final double? fontSize;

  const ClarityStatusBadge({
    super.key,
    required this.text,
    this.backgroundColor,
    this.textColor,
    this.fontSize,
  });

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final textStyles = AppTextStyles.instance;
    final spacing = AppSpacing.instance;
    final indicatorColor = textColor ?? backgroundColor ?? colors.primary;
    final bg = backgroundColor ?? colors.surfaceLight;

    return Container(
      padding: EdgeInsets.symmetric(
        horizontal: spacing.sm,
        vertical: spacing.xs - 2,
      ),
      decoration: BoxDecoration(
        color: bg,
        borderRadius: BorderRadius.circular(spacing.borderRadiusLarge),
        border: Border.all(
          color: colors.borderLight,
          width: 0.8,
        ),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            text == 'Activo' ? Icons.check_circle : Icons.cancel,
            size: 14,
            color: indicatorColor,
          ),
          SizedBox(width: spacing.xs),
          Text(
            text,
            style: textStyles.statusText.copyWith(
              color: colors.textPrimary,
              fontSize: fontSize,
            ),
          ),
        ],
      ),
    );
  }
}
class ClarityActionButton extends StatelessWidget {
  final IconData icon;
  final String? tooltip;
  final VoidCallback? onPressed;
  final Color? color;
  final double? size;

  const ClarityActionButton({
    super.key,
    required this.icon,
    this.tooltip,
    this.onPressed,
    this.color,
    this.size,
  });

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final spacing = AppSpacing.instance;

    return IconButton(
      icon: Icon(
        icon,
        color: color ?? colors.primary,
        size: size ?? spacing.iconSize,
      ),
      tooltip: tooltip,
      onPressed: onPressed,
      padding: EdgeInsets.zero,
      constraints: BoxConstraints(
        minWidth: spacing.iconSize,
        minHeight: spacing.iconSize,
      ),
    );
  }
}
class ClaritySection extends StatelessWidget {
  final String title;
  final Widget child;
  final EdgeInsetsGeometry? padding;
  final TextStyle? titleStyle;

  const ClaritySection({
    super.key,
    required this.title,
    required this.child,
    this.padding,
    this.titleStyle,
  });

  @override
  Widget build(BuildContext context) {
    final textStyles = AppTextStyles.instance;
    final spacing = AppSpacing.instance;

    return Padding(
      padding: padding ?? EdgeInsets.all(spacing.screenPadding),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: titleStyle ?? textStyles.headlineMedium,
          ),
          SizedBox(height: spacing.md),
          child,
        ],
      ),
    );
  }
}
class ClarityEmptyState extends StatelessWidget {
  final IconData icon;
  final String title;
  final String? subtitle;
  final Widget? subtitleWidget;
  final Widget? action;

  const ClarityEmptyState({
    super.key,
    required this.icon,
    required this.title,
    this.subtitle,
    this.subtitleWidget,
    this.action,
  });

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final textStyles = AppTextStyles.instance;
    final spacing = AppSpacing.instance;

    return Center(
      child: Padding(
        padding: EdgeInsets.all(spacing.xl),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              icon,
              size: spacing.xxl,
              color: colors.textMuted,
            ),
            SizedBox(height: spacing.lg),
            Text(
              title,
              style: textStyles.headlineMedium.copyWith(
                color: colors.textSecondary,
              ),
              textAlign: TextAlign.center,
            ),
            if (subtitle != null) ...[
              SizedBox(height: spacing.md),
              Text(
                subtitle!,
                style: textStyles.bodyMedium.copyWith(
                  color: colors.textMuted,
                ),
                textAlign: TextAlign.center,
              ),
            ],
            if (action != null) ...[
              SizedBox(height: spacing.lg),
              action!,
            ],
          ],
        ),
      ),
    );
  }
}
class ClarityCompactStat extends StatelessWidget {
  final String title;
  final String value;
  final IconData icon;
  final Color color;

  const ClarityCompactStat({
    super.key,
    required this.title,
    required this.value,
    required this.icon,
    required this.color,
  });

  @override
  Widget build(BuildContext context) {
    final textStyles = AppTextStyles.instance;

    return IntrinsicWidth(
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 14, color: color),
          const SizedBox(width: 2),
          Flexible(
            child: Text(
              '$value $title',
              style: textStyles.bodySmall.copyWith(
                color: color,
                fontWeight: FontWeight.w500,
              ),
              overflow: TextOverflow.ellipsis,
              maxLines: 1,
            ),
          ),
        ],
      ),
    );
  }
}
class ClarityManagementHeader extends StatelessWidget {
  final String title;
  final String? searchHint;
  final TextEditingController? searchController;
  final ValueChanged<String>? onSearchChanged;
  final VoidCallback? onCreatePressed;
  final String? createButtonLabel;
  final List<Widget>? filterWidgets;
  final bool showSearch;
  final bool showCreateButton;

  const ClarityManagementHeader({
    super.key,
    required this.title,
    this.searchHint,
    this.searchController,
    this.onSearchChanged,
    this.onCreatePressed,
    this.createButtonLabel,
    this.filterWidgets,
    this.showSearch = true,
    this.showCreateButton = true,
  });

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final textStyles = AppTextStyles.instance;
    final spacing = AppSpacing.instance;

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Expanded(
              child: Text(
                title,
                style: textStyles.headlineMedium,
              ),
            ),
            if (showCreateButton && onCreatePressed != null)
              ElevatedButton.icon(
                onPressed: onCreatePressed,
                icon: const Icon(Icons.add),
                label: Text(createButtonLabel ?? 'Crear'),
              ),
          ],
        ),

        SizedBox(height: spacing.md),
        if (showSearch) ...[
          TextField(
            controller: searchController,
            onChanged: onSearchChanged,
            decoration: InputDecoration(
              hintText: searchHint ?? 'Buscar...',
              prefixIcon: const Icon(Icons.search),
              suffixIcon: searchController?.text.isNotEmpty == true
                  ? IconButton(
                      icon: const Icon(Icons.clear),
                      onPressed: () {
                        searchController?.clear();
                        onSearchChanged?.call('');
                      },
                    )
                  : null,
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(spacing.borderRadius),
                borderSide: BorderSide(color: colors.border),
              ),
              contentPadding: EdgeInsets.symmetric(
                horizontal: spacing.md,
                vertical: spacing.sm,
              ),
            ),
          ),
          SizedBox(height: spacing.md),
        ],
        if (filterWidgets != null && filterWidgets!.isNotEmpty)
          Wrap(
            spacing: spacing.sm,
            runSpacing: spacing.sm,
            children: filterWidgets!,
          ),
      ],
    );
  }
}
class ClarityContextMenu extends StatelessWidget {
  final List<ClarityContextMenuAction> actions;
  final IconData icon;
  final Color? iconColor;
  final String? tooltip;

  const ClarityContextMenu({
    super.key,
    required this.actions,
    this.icon = Icons.more_vert,
    this.iconColor,
    this.tooltip,
  });

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final spacing = AppSpacing.instance;

    return PopupMenuButton<int>(
      icon: Icon(
        icon,
        color: iconColor ?? colors.primary,
        size: spacing.iconSize,
      ),
      tooltip: tooltip ?? 'Mostrar menÃº',
      onSelected: (index) {
        if (index < actions.length) {
          actions[index].onPressed?.call();
        }
      },
      itemBuilder: (context) => actions
          .asMap()
          .entries
          .map((entry) {
        final action = entry.value;
        return PopupMenuItem(
          value: entry.key,
          child: Row(
            children: [
              Icon(action.icon, size: 18, color: action.color),
              const SizedBox(width: 12),
              Text(action.label),
            ],
          ),
        );
      }).toList(),
    );
  }
}
class ClarityContextMenuAction {
  final String label;
  final IconData icon;
  final Color? color;
  final VoidCallback? onPressed;

  ClarityContextMenuAction({
    required this.label,
    required this.icon,
    this.color,
    this.onPressed,
  });
}
class ClarityResponsiveContainer extends StatelessWidget {
  final Widget child;
  final double? maxWidth;
  final bool centerContent;
  final EdgeInsetsGeometry? padding;

  const ClarityResponsiveContainer({
    super.key,
    required this.child,
    this.maxWidth,
    this.centerContent = true,
    this.padding,
  });

  @override
  Widget build(BuildContext context) {
    final spacing = AppSpacing.instance;

    return LayoutBuilder(
      builder: (context, constraints) {
        final responsiveMaxWidth = maxWidth ??
            (constraints.maxWidth > 1200
                ? 1200.0
                : constraints.maxWidth > 768
                    ? 900.0
                    : double.infinity);

        final responsivePadding = padding ??
            EdgeInsets.symmetric(
              horizontal: constraints.maxWidth > 768
                  ? spacing.lg
                  : spacing.md,
              vertical: spacing.md,
            );

        final content = ConstrainedBox(
          constraints: BoxConstraints(maxWidth: responsiveMaxWidth),
          child: child,
        );

        return Container(
          width: double.infinity,
          padding: responsivePadding,
          alignment: centerContent ? Alignment.center : Alignment.topLeft,
          child: content,
        );
      },
    );
  }
}
class ClarityListItem extends StatelessWidget {
  final Widget leading;
  final String title;
  final String? subtitle;
  final Widget? subtitleWidget;
  final List<ClarityContextMenuAction>? contextActions;
  final VoidCallback? onTap;
  final Color? backgroundColor;
  final String? badgeText;
  final Color? badgeColor;

  const ClarityListItem({
    super.key,
    required this.leading,
    required this.title,
    this.subtitle,
    this.subtitleWidget,
    this.contextActions,
    this.onTap,
    this.backgroundColor,
    this.badgeText,
    this.badgeColor,
  });

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final spacing = AppSpacing.instance;

    return ClarityCard(
      backgroundColor: backgroundColor,
      onTap: onTap,
      leading: leading,
      title: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: Theme.of(context).textTheme.titleMedium,
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
          if (subtitleWidget != null) ...[
            SizedBox(height: spacing.xs),
            DefaultTextStyle(
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: colors.textMuted,
                  ) ?? const TextStyle(),
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
              child: subtitleWidget!,
            ),
          ] else if (subtitle != null) ...[
            SizedBox(height: spacing.xs),
            Text(
              subtitle!,
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: colors.textMuted,
                  ),
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
          ],
        ],
      ),
      trailing: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          if (badgeText != null) ...[
            ClarityStatusBadge(
              text: badgeText!,
              backgroundColor: badgeColor,
            ),
            SizedBox(width: spacing.sm),
          ],
          if (contextActions != null && contextActions!.isNotEmpty)
            ClarityContextMenu(actions: contextActions!),
        ],
      ),
    );
  }
}
class ClarityAccessibilityIndicator extends StatelessWidget {
  final double contrastRatio
  final String label;

  const ClarityAccessibilityIndicator({
    super.key,
    required this.contrastRatio,
    required this.label,
  });

  bool get isCompliantAA => contrastRatio >= 4.5;
  bool get isCompliantAAA => contrastRatio >= 7.0;

  Color get complianceColor =>
      isCompliantAAA
          ? Colors.green
          : isCompliantAA
              ? Colors.orange
              : Colors.red;

  String get complianceText =>
      isCompliantAAA ? 'AAA' : isCompliantAA ? 'AA' : 'No Cumple';

  @override
  Widget build(BuildContext context) {
    final spacing = AppSpacing.instance;

    return Container(
      padding: EdgeInsets.symmetric(
        horizontal: spacing.sm,
        vertical: spacing.xs,
      ),
      decoration: BoxDecoration(
        color: complianceColor.withValues(alpha: 0.1),
        border: Border.all(color: complianceColor, width: 1),
        borderRadius: BorderRadius.circular(spacing.borderRadius),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.check_circle, size: 14, color: complianceColor),
          SizedBox(width: spacing.xs),
          Text(
            '$label ($complianceText: ${contrastRatio.toStringAsFixed(1)}:1)',
            style: Theme.of(context).textTheme.labelSmall?.copyWith(
                  color: complianceColor,
                ),
          ),
        ],
      ),
    );
  }
}
/* Fin lib\widgets\components\clarity_components.dart */

/* Inicio lib\widgets\components\clarity_form_dialog.dart */
import 'package:flutter/material.dart';
class ClarityFormDialog extends StatefulWidget {
  final Widget title;
  final GlobalKey<FormState>? formKey;
  final List<Widget> children;
  final Future<bool> Function()? onSave;
  final String saveLabel;
  final String cancelLabel;

  const ClarityFormDialog({
    super.key,
    required this.title,
    this.formKey,
  this.onSave,
  this.saveLabel = 'Guardar',
  this.cancelLabel = 'Cancelar',
  required this.children,
  });

  @override
  State<ClarityFormDialog> createState() => _ClarityFormDialogState();
}

class _ClarityFormDialogState extends State<ClarityFormDialog> {
  late final GlobalKey<FormState> _formKey;
  bool _isSaving = false;

  @override
  void initState() {
    super.initState();
    _formKey = widget.formKey ?? GlobalKey<FormState>();
  }

  Future<void> _handleSave() async {
    if (!_formKey.currentState!.validate()) return;
    if (widget.onSave == null) return;

    setState(() => _isSaving = true);
    try {
      final success = await widget.onSave!();
      if (success && mounted) Navigator.of(context).pop(true);
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: ${e.toString()}')),
        );
      }
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  @override
  Widget build(BuildContext context) {

    return AlertDialog(
      title: widget.title,
      content: Form(
        key: _formKey,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: widget.children,
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isSaving ? null : () => Navigator.of(context).pop(),
          child: Text(widget.cancelLabel),
        ),
        ElevatedButton(
          onPressed: _isSaving ? null : _handleSave,
      child: _isSaving
        ? const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2))
              : Text(widget.saveLabel),
        ),
      ],
    );
  }
}

/* Fin lib\widgets\components\clarity_form_dialog.dart */

/* Inicio lib\widgets\components\clarity_management_page.dart */


import 'package:flutter/material.dart';
import '../../theme/app_colors.dart';
import '../../theme/app_text_styles.dart';
import '../../theme/app_spacing.dart';
import 'clarity_components.dart';
class ClarityManagementPage extends StatelessWidget {
  final String title;
  final bool isLoading;
  final bool hasError;
  final String? errorMessage;
  final int itemCount;
  final Widget Function(BuildContext, int) itemBuilder;
  final List<Widget>? filterWidgets;
  final List<Widget>? statisticWidgets;
  final Future<void> Function()? onRefresh;
  final Widget? floatingActionButton;
  final ScrollController? scrollController;
  final bool hasMoreData;
  final bool isLoadingMore;
  final Widget? emptyStateWidget;
  final Widget? errorStateWidget;
  final double? itemSpacing;
  final Color? backgroundColor;

  const ClarityManagementPage({
    super.key,
    required this.title,
    required this.isLoading,
    required this.hasError,
    required this.itemCount,
    required this.itemBuilder,
    this.errorMessage,
    this.filterWidgets,
    this.statisticWidgets,
    this.onRefresh,
    this.floatingActionButton,
    this.scrollController,
    this.hasMoreData = false,
    this.isLoadingMore = false,
    this.emptyStateWidget,
    this.errorStateWidget,
    this.itemSpacing,
    this.backgroundColor,
  });

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final spacing = AppSpacing.instance;
    final textStyles = AppTextStyles.instance;

    return Scaffold(
      backgroundColor: backgroundColor ?? colors.background,
      appBar: AppBar(
        backgroundColor: colors.surface,
        elevation: 0,
        title: Text(title, style: textStyles.headlineMedium),
        centerTitle: false,
      ),
      body: RefreshIndicator(
        onRefresh: onRefresh ?? () async {},
        child: CustomScrollView(
          controller: scrollController,
          slivers: [
            SliverToBoxAdapter(
              child: Container(
                color: colors.surface,
                padding: EdgeInsets.all(spacing.screenPadding),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    if (statisticWidgets != null && statisticWidgets!.isNotEmpty) ...[
                      Wrap(
                        spacing: spacing.lg,
                        runSpacing: spacing.md,
                        alignment: WrapAlignment.center,
                        children: statisticWidgets!,
                      ),
                      SizedBox(height: spacing.lg),
                    ],
                    if (filterWidgets != null && filterWidgets!.isNotEmpty)
                      ...filterWidgets!,
                  ],
                ),
              ),
            ),
            if (isLoading && itemCount == 0)
              const SliverFillRemaining(
                child: Center(child: CircularProgressIndicator()),
              )
            else if (hasError)
              SliverFillRemaining(
                child: errorStateWidget ??
                    ClarityEmptyState(
                      icon: Icons.error_outline,
                      title: 'Error al cargar datos',
                      subtitle: errorMessage ?? 'Error desconocido',
                      action: onRefresh != null
                          ? ElevatedButton.icon(
                              onPressed: onRefresh,
                              icon: const Icon(Icons.refresh),
                              label: const Text('Reintentar'),
                            )
                          : null,
                    ),
              )
            else if (itemCount == 0)
              SliverFillRemaining(
                child: emptyStateWidget ??
                    ClarityEmptyState(
                      icon: Icons.inbox_outlined,
                      title: 'No hay elementos',
                      subtitle: 'Comienza agregando tu primer elemento',
                    ),
              )
            else
              SliverPadding(
                padding: EdgeInsets.all(spacing.screenPadding),
                sliver: SliverList(
                  delegate: SliverChildBuilderDelegate(
                    (context, index) {
                      if (index >= itemCount) {
                        if (hasMoreData && !isLoadingMore) {
                          WidgetsBinding.instance.addPostFrameCallback((_) {
                          });
                        }
                        return isLoadingMore
                            ? Center(
                                child: Padding(
                                  padding: EdgeInsets.all(spacing.md),
                                  child: const CircularProgressIndicator(),
                                ),
                              )
                            : const SizedBox.shrink();
                      }
                      return Padding(
                        padding: EdgeInsets.only(
                          bottom: itemSpacing ?? spacing.md,
                        ),
                        child: itemBuilder(context, index),
                      );
                    },
                    childCount: itemCount + (hasMoreData ? 1 : 0),
                  ),
                ),
              ),
          ],
        ),
      ),
      floatingActionButton: floatingActionButton,
    );
  }
}

/* Fin lib\widgets\components\clarity_management_page.dart */

/* Inicio lib\widgets\components\command_palette.dart */


import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import '../../theme/app_colors.dart';
import '../../theme/app_text_styles.dart';
import '../../theme/app_spacing.dart';
class CommandPalette extends StatefulWidget {
  final List<CommandPaletteItem> items;
  final VoidCallback? onDismiss;

  const CommandPalette({
    super.key,
    required this.items,
    this.onDismiss,
  });

  @override
  State<CommandPalette> createState() => _CommandPaletteState();
}

class _CommandPaletteState extends State<CommandPalette> {
  final TextEditingController _searchController = TextEditingController();
  late List<CommandPaletteItem> _filteredItems;
  int _selectedIndex = 0;

  @override
  void initState() {
    super.initState();
    _filteredItems = widget.items;
    _searchController.addListener(_filterItems);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      FocusScope.of(context).requestFocus(FocusNode());
    });
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  void _filterItems() {
    final query = _searchController.text.toLowerCase();
    setState(() {
      _filteredItems = widget.items
          .where((item) =>
              item.title.toLowerCase().contains(query) ||
              item.description.toLowerCase().contains(query))
          .toList();
      _selectedIndex = 0;
    });
  }

  void _executeCommand() {
    if (_filteredItems.isNotEmpty && _selectedIndex < _filteredItems.length) {
      _filteredItems[_selectedIndex].onExecute();
      Navigator.of(context).pop();
      widget.onDismiss?.call();
    }
  }

  @override
  Widget build(BuildContext context) {
    final colors = AppColors.instance;
    final spacing = AppSpacing.instance;
    final textStyles = AppTextStyles.instance;

    return Dialog(
      backgroundColor: Colors.transparent,
      elevation: 0,
      insetPadding: EdgeInsets.symmetric(
        horizontal: spacing.md,
        vertical: spacing.xl,
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          SizedBox(height: spacing.xl),
        Container(
      constraints: const BoxConstraints(maxWidth: 600),
            decoration: BoxDecoration(
              color: colors.surface,
              borderRadius: BorderRadius.circular(spacing.borderRadius),
              border: Border.all(color: colors.borderLight),
              boxShadow: [
                BoxShadow(
                  color: colors.shadow.withValues(alpha: 0.1),
                  blurRadius: 20,
                  offset: Offset(0, 10),
                ),
              ],
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Padding(
                  padding: EdgeInsets.all(spacing.md),
                  child: KeyboardListener(
                    focusNode: FocusNode(),
                    onKeyEvent: (KeyEvent event) {
                      if (HardwareKeyboard.instance.isLogicalKeyPressed(LogicalKeyboardKey.escape)) {
                        Navigator.of(context).pop();
                        widget.onDismiss?.call();
                      } else if (HardwareKeyboard.instance.isLogicalKeyPressed(LogicalKeyboardKey.arrowDown)) {
                        setState(() {
                          if (_selectedIndex < _filteredItems.length - 1) {
                            _selectedIndex++;
                          }
                        });
                      } else if (HardwareKeyboard.instance.isLogicalKeyPressed(LogicalKeyboardKey.arrowUp)) {
                        setState(() {
                          if (_selectedIndex > 0) {
                            _selectedIndex--;
                          }
                        });
                      } else if (HardwareKeyboard.instance.isLogicalKeyPressed(LogicalKeyboardKey.enter)) {
                        _executeCommand();
                      }
                    },
                    child: TextField(
                      controller: _searchController,
                      autofocus: true,
                      decoration: InputDecoration(
                        hintText: 'Escribe para buscar (Esc para cerrar)...',
                        prefixIcon: Icon(Icons.search, color: colors.primary),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(spacing.borderRadius),
                          borderSide: BorderSide(color: colors.border),
                        ),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(spacing.borderRadius),
                          borderSide: BorderSide(color: colors.primary, width: 2),
                        ),
                        contentPadding: EdgeInsets.symmetric(
                          horizontal: spacing.md,
                          vertical: spacing.sm,
                        ),
                      ),
                    ),
                  ),
                ),
                Divider(height: 1, color: colors.borderLight),
                ConstrainedBox(
                  constraints: const BoxConstraints(maxHeight: 400),
                  child: _filteredItems.isEmpty
                      ? Padding(
                          padding: EdgeInsets.all(spacing.lg),
                          child: Text(
                            'No se encontraron resultados',
                            style: textStyles.bodyMedium.copyWith(
                              color: colors.textMuted,
                            ),
                          ),
                        )
                      : ListView.builder(
                          shrinkWrap: true,
                          itemCount: _filteredItems.length,
                          itemBuilder: (context, index) {
                            final item = _filteredItems[index];
                            final isSelected = index == _selectedIndex;

                            return Material(
                              color: isSelected
                                  ? colors.primary.withValues(alpha: 0.1)
                                  : colors.surface,
                              child: InkWell(
                                onTap: () {
                                  setState(() {
                                    _selectedIndex = index;
                                  });
                                  _executeCommand();
                                },
                                child: Padding(
                                  padding: EdgeInsets.symmetric(
                                    horizontal: spacing.md,
                                    vertical: spacing.sm,
                                  ),
                                  child: Row(
                                    children: [
                                      Icon(
                                        item.icon,
                                        color: item.color ?? colors.primary,
                                        size: 18,
                                      ),
                                      SizedBox(width: spacing.md),
                                      Expanded(
                                        child: Column(
                                          crossAxisAlignment:
                                              CrossAxisAlignment.start,
                                          children: [
                                            Text(
                                              item.title,
                                              style: textStyles.titleSmall
                                                  .copyWith(
                                                color: isSelected
                                                    ? colors.primary
                                                    : colors.textPrimary,
                                              ),
                                            ),
                                            if (item.description.isNotEmpty)
                                              Text(
                                                item.description,
                                                style: textStyles.bodySmall
                                                    .copyWith(
                                                  color: colors.textMuted,
                                                ),
                                                maxLines: 1,
                                                overflow: TextOverflow.ellipsis,
                                              ),
                                          ],
                                        ),
                                      ),
                                      SizedBox(width: spacing.md),
                                      if (item.shortcut != null)
                                        Container(
                                          padding: EdgeInsets.symmetric(
                                            horizontal: spacing.xs,
                                            vertical: spacing.xs,
                                          ),
                                          decoration: BoxDecoration(
                                            color: colors.surfaceLight,
                                            borderRadius:
                                                BorderRadius.circular(
                                              spacing.borderRadius / 2,
                                            ),
                                            border: Border.all(
                                              color: colors.borderLight,
                                            ),
                                          ),
                                          child: Text(
                                            item.shortcut!,
                                            style: textStyles.labelSmall
                                                .copyWith(
                                              color: colors.textMuted,
                                            ),
                                          ),
                                        ),
                                    ],
                                  ),
                                ),
                              ),
                            );
                          },
                        ),
                )
              ],
            ),
          ),
          SizedBox(height: spacing.xl),
        ],
      ),
    );
  }
}
class CommandPaletteItem {
  final String title;
  final String description;
  final IconData icon;
  final Color? color;
  final String? shortcut
  final VoidCallback onExecute;

  CommandPaletteItem({
    required this.title,
    this.description = '',
    required this.icon,
    this.color,
    this.shortcut,
    required this.onExecute,
  });
}
mixin CommandPaletteMixin {
  static void showCommandPalette(BuildContext context, List<CommandPaletteItem> items) {
    showDialog(
      context: context,
      builder: (context) => CommandPalette(items: items),
    );
  }

  static void setupCommandPaletteShortcut(BuildContext context, List<CommandPaletteItem> items) {
  }
}

/* Fin lib\widgets\components\command_palette.dart */

/* Inicio lib\widgets\components\index.dart */


export 'clarity_components.dart';
export 'clarity_management_page.dart';
export 'clarity_form_dialog.dart';
/* Fin lib\widgets\components\index.dart */

/* Inicio lib\widgets\dashboard_widgets.dart */
import 'package:flutter/material.dart';
import '../utils/responsive_utils.dart';
import '../config/app_constants.dart';
import '../theme/theme_extensions.dart';
import 'components/clarity_components.dart';
class DashboardFeatureCard extends StatelessWidget {
  final IconData icon;
  final String title;
  final String description;
  final Color color;
  final Map<String, dynamic> responsive;
  final VoidCallback? onTap;

  const DashboardFeatureCard({
    super.key,
    required this.icon,
    required this.title,
    required this.description,
    required this.color,
    required this.responsive,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final isDesktop = responsive['isDesktop'] as bool;
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return ClarityCard(
      onTap: onTap ?? () {
      },
      title: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            icon,
            size: isDesktop ? 48 : 32,
            color: color,
          ),
          SizedBox(width: spacing.sm),
          Expanded(
            child: Text(
              title,
              style: textStyles.titleLarge.copyWith(
                color: colors.textPrimary,
                fontWeight: FontWeight.bold,
              ),
              textAlign: TextAlign.center,
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ],
      ),
      subtitle: Text(
        description,
        style: textStyles.bodyMedium.copyWith(
          color: colors.textSecondary,
        ),
        textAlign: TextAlign.center,
        maxLines: 2,
        overflow: TextOverflow.ellipsis,
      ),
      padding: EdgeInsets.all(isDesktop ? spacing.xl : spacing.lg),
    );
  }
}
class UserGreetingWidget extends StatelessWidget {
  final String userName;
  final Map<String, dynamic> responsive;
  final String? subtitle;

  const UserGreetingWidget({
    super.key,
    required this.userName,
    required this.responsive,
    this.subtitle,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return ClarityCard(
      title: Text(
        'Â¡Hola, $userName!',
        style: textStyles.headlineMedium.copyWith(
          color: colors.primary,
          fontWeight: FontWeight.bold,
        ),
        textAlign: TextAlign.center,
      ),
      subtitle: subtitle != null ? Text(
        subtitle!,
        style: textStyles.bodyLarge.copyWith(
          color: colors.textSecondary,
        ),
        textAlign: TextAlign.center,
      ) : null,
      padding: EdgeInsets.all(spacing.xl),
    );
  }
}
class DashboardOptionsGrid extends StatelessWidget {
  final List<DashboardFeatureCard> cards;
  final Map<String, dynamic> responsive;
  final bool verticalMode;

  const DashboardOptionsGrid({
    super.key,
    required this.cards,
    required this.responsive,
    this.verticalMode = false,
  });

  @override
  Widget build(BuildContext context) {
    final screenType = responsive['screenType'] as ScreenType;

    if (verticalMode) {
      return Column(
        children: [
          const SizedBox(height: 32),
          Column(
            children: cards.map((card) {
              return Padding(
                padding: const EdgeInsets.symmetric(vertical: 6.0),
                child: ListTile(
                  onTap: card.onTap,
                  tileColor: Theme.of(context).cardColor,
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                  leading: Icon(card.icon, color: card.color, size: 28),
                  title: Text(card.title, style: context.textStyles.bodyLarge),
                  subtitle: Text(card.description, style: context.textStyles.bodySmall),
                ),
              );
            }).toList(),
          ),
        ],
      );
    }

    return Column(
      children: [
        const SizedBox(height: 32),
        LayoutBuilder(
          builder: (context, constraints) {
            final gridDelegate = ResponsiveUtils.getResponsiveGridDelegate(screenType);

            return GridView(
              gridDelegate: gridDelegate,
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              children: cards,
            );
          },
        ),
      ],
    );
  }
}
class DashboardAppBar extends StatelessWidget implements PreferredSizeWidget {
  final String title;
  final Color backgroundColor;
  final List<Widget> actions;

  const DashboardAppBar({
    super.key,
    this.title = 'AsistApp',
    required this.backgroundColor,
    required this.actions,
  });

  @override
  Widget build(BuildContext context) {
    return AppBar(
      title: Text(title),
      backgroundColor: backgroundColor,
      actions: actions,
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}
class DashboardAppBarActions extends StatelessWidget {
  final String userRole;
  final IconData roleIcon;
  final VoidCallback? onLogout;

  const DashboardAppBarActions({
    super.key,
    required this.userRole,
    required this.roleIcon,
    this.onLogout,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;

    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(
          margin: const EdgeInsets.only(right: 8),
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          constraints: const BoxConstraints(maxWidth: 120), // Limitar ancho mÃ¡ximo
          decoration: BoxDecoration(
            color: colors.roleBadgeBackground,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(roleIcon, size: 14, color: colors.roleBadgeIcon),
              const SizedBox(width: 4),
              Flexible(
                child: Text(
                  userRole,
                  style: TextStyle(
                    color: colors.roleBadgeText,
                    fontSize: 11,
                    fontWeight: FontWeight.w500,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ),
            ],
          ),
        ),
        IconButton(
          icon: const Icon(Icons.logout),
          onPressed: onLogout ?? () async {
          },
        ),
      ],
    );
  }
}
class DashboardBody extends StatelessWidget {
  final Widget userGreeting;
  final Widget dashboardOptions;
  final Map<String, dynamic> responsive;

  const DashboardBody({
    super.key,
    required this.userGreeting,
    required this.dashboardOptions,
    required this.responsive,
  });

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: SingleChildScrollView(
        child: ConstrainedBox(
          constraints: BoxConstraints(maxWidth: responsive['maxWidth']),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Padding(
                padding: EdgeInsets.symmetric(
                  horizontal: responsive['horizontalPadding'],
                  vertical: responsive['verticalPadding'],
                ),
                child: Column(
                  children: [
                    userGreeting,
                    SizedBox(height: responsive['elementSpacing']),
                    dashboardOptions,
                    SizedBox(height: responsive['elementSpacing'] * 2),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
/* Fin lib\widgets\dashboard_widgets.dart */

/* Inicio lib\widgets\form_widgets.dart */
import 'package:flutter/material.dart';
import '../theme/theme_extensions.dart';

class CustomTextFormField extends StatelessWidget {
  final TextEditingController controller;
  final String labelText;
  final String hintText;
  final TextInputType keyboardType;
  final bool obscureText;
  final String? Function(String?)? validator;
  final FocusNode? focusNode;
  final GlobalKey<FormFieldState>? fieldKey;
  final int? maxLines;
  final int? minLines;
  final Widget? prefixIcon;
  final Widget? suffixIcon;
  final bool enabled;
  final void Function(String)? onChanged;
  final void Function()? onTap;
  final String? initialValue;
  final String? errorText;

  const CustomTextFormField({
    super.key,
    required this.controller,
    required this.labelText,
    required this.hintText,
    this.focusNode,
    this.fieldKey,
    this.keyboardType = TextInputType.text,
    this.obscureText = false,
    this.validator,
    this.maxLines = 1,
    this.minLines,
    this.prefixIcon,
    this.suffixIcon,
    this.enabled = true,
    this.onChanged,
    this.onTap,
    this.initialValue,
    this.errorText,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Material(
      color: Colors.transparent,
      child: TextFormField(
        key: fieldKey,
        focusNode: focusNode,
        controller: controller,
        initialValue: initialValue,
        keyboardType: keyboardType,
        obscureText: obscureText,
        maxLines: maxLines,
        minLines: minLines,
        enabled: enabled,
        onChanged: onChanged,
        onTap: onTap,
        validator: validator,
        style: textStyles.bodyLarge,
        decoration: InputDecoration(
          labelText: labelText,
          hintText: hintText,
          hintStyle: textStyles.bodyMedium.withColor(colors.textMuted),
          prefixIcon: prefixIcon,
          suffixIcon: suffixIcon,
          errorText: errorText,
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.border),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.borderLight),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.primary, width: 2),
          ),
          errorBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.error),
          ),
          focusedErrorBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.error, width: 2),
          ),
          filled: true,
          fillColor: enabled ? colors.surface : colors.surface.withValues(alpha: 0.5),
          contentPadding: EdgeInsets.symmetric(
            horizontal: spacing.md,
            vertical: spacing.sm,
          ),
          labelStyle: textStyles.bodyMedium.withColor(colors.textSecondary),
        ),
      ),
    );
  }
}

class CustomDropdownFormField<T> extends StatelessWidget {
  final T? value;
  final String labelText;
  final String hintText;
  final List<DropdownMenuItem<T>> items;
  final String? Function(T?)? validator;
  final FocusNode? focusNode;
  final GlobalKey<FormFieldState>? fieldKey;
  final void Function(T?)? onChanged;
  final bool enabled;

  const CustomDropdownFormField({
    super.key,
    this.value,
    required this.labelText,
    required this.hintText,
    required this.items,
    this.validator,
    this.onChanged,
    this.enabled = true,
    this.focusNode,
    this.fieldKey,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Material(
      color: Colors.transparent,
      child: DropdownButtonFormField<T>(
        key: fieldKey,
        value: value,
        focusNode: focusNode,
        items: items,
        onChanged: enabled ? onChanged : null,
        validator: validator,
        style: textStyles.bodyLarge,
        decoration: InputDecoration(
          labelText: labelText,
          hintText: hintText,
          hintStyle: textStyles.bodyMedium.withColor(colors.textMuted),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.border),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.borderLight),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.primary, width: 2),
          ),
          errorBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.error),
          ),
          focusedErrorBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            borderSide: BorderSide(color: colors.error, width: 2),
          ),
          filled: true,
          fillColor: enabled ? colors.surface : colors.surface.withValues(alpha: 0.5),
          contentPadding: EdgeInsets.symmetric(
            horizontal: spacing.md,
            vertical: spacing.sm,
          ),
          labelStyle: textStyles.bodyMedium.withColor(colors.textSecondary),
        ),
        dropdownColor: colors.surface,
      ),
    );
  }
}

class CustomCheckboxFormField extends StatelessWidget {
  final bool value;
  final String title;
  final String? subtitle;
  final void Function(bool?)? onChanged;
  final String? Function(bool?)? validator;
  final bool enabled;

  const CustomCheckboxFormField({
    super.key,
    required this.value,
    required this.title,
    this.subtitle,
    this.onChanged,
    this.validator,
    this.enabled = true,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return FormField<bool>(
      initialValue: value,
      validator: validator,
      builder: (FormFieldState<bool> state) {
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            CheckboxListTile(
              value: state.value ?? false,
              onChanged: enabled ? (bool? newValue) {
                state.didChange(newValue);
                onChanged?.call(newValue);
              } : null,
              title: Text(
                title,
                style: textStyles.bodyLarge,
              ),
              subtitle: subtitle != null
                  ? Text(
                      subtitle!,
                      style: textStyles.bodySmall.withColor(colors.textSecondary),
                    )
                  : null,
              controlAffinity: ListTileControlAffinity.leading,
              activeColor: colors.primary,
              checkColor: Theme.of(context).colorScheme.onPrimary,
              tileColor: colors.surface,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(spacing.borderRadius),
              ),
              side: BorderSide(color: colors.borderLight),
            ),
            if (state.hasError)
              Padding(
                padding: EdgeInsets.only(left: spacing.lg, top: spacing.xs),
                child: Text(
                  state.errorText!,
                  style: textStyles.bodySmall.withColor(colors.error),
                ),
              ),
          ],
        );
      },
    );
  }
}

class CustomSwitchFormField extends StatelessWidget {
  final bool value;
  final String title;
  final String? subtitle;
  final void Function(bool)? onChanged;
  final bool enabled;

  const CustomSwitchFormField({
    super.key,
    required this.value,
    required this.title,
    this.subtitle,
    this.onChanged,
    this.enabled = true,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Material(
      color: Colors.transparent,
      child: Card(
        elevation: 1,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(spacing.borderRadius),
        ),
        child: Padding(
          padding: EdgeInsets.all(spacing.md),
          child: Row(
            children: [
              Icon(
                value ? Icons.check_circle : Icons.cancel,
                color: value ? colors.success : colors.error,
              ),
              SizedBox(width: spacing.md),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      style: textStyles.bodyLarge,
                    ),
                    if (subtitle != null)
                      Text(
                        subtitle!,
                        style: textStyles.bodySmall.withColor(colors.textSecondary),
                      ),
                  ],
                ),
              ),
              Switch(
                value: value,
                onChanged: enabled ? onChanged : null,
                activeColor: colors.primary,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
/* Fin lib\widgets\form_widgets.dart */

/* Inicio lib\widgets\horarios\create_class_dialog.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../../models/conflict_error.dart';
import '../../models/grupo.dart';
import '../../models/materia.dart';
import '../../models/user.dart';
import '../../providers/auth_provider.dart';
import '../../providers/horario_provider.dart';
import '../../providers/materia_provider.dart';
import '../../providers/user_provider.dart';
import '../../services/academic/horario_service.dart';
import '../../theme/theme_extensions.dart';
import '../components/index.dart';

class CreateClassDialog extends StatefulWidget {
  final Grupo grupo;
  final String horaInicio;
  final int diaSemana;

  const CreateClassDialog({
    super.key,
    required this.grupo,
    required this.horaInicio,
    required this.diaSemana,
  });

  @override
  State<CreateClassDialog> createState() => _CreateClassDialogState();
}

class _CreateClassDialogState extends State<CreateClassDialog> {
  final _formKey = GlobalKey<FormState>();
  Materia? _selectedMateria;
  User? _selectedProfesor;
  String? _selectedHoraFin;

  @override
  void initState() {
    super.initState();
    _selectedHoraFin = _getHoraFin(widget.horaInicio);
  }

  @override
  Widget build(BuildContext context) {
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return ClarityFormDialog(
      title: Text('Crear Clase', style: textStyles.headlineMedium),
      formKey: _formKey,
      onSave: _createClass,
      saveLabel: 'Crear Clase',
      cancelLabel: 'Cancelar',
      children: [
        Container(
          padding: EdgeInsets.all(spacing.md),
          decoration: BoxDecoration(
            color: context.colors.surface,
            borderRadius: BorderRadius.circular(spacing.borderRadius),
            border: Border.all(color: context.colors.borderLight),
          ),
          child: Column(
            children: [
              Text(
                'Horario: ${widget.horaInicio} - ${_selectedHoraFin ?? _getHoraFin(widget.horaInicio)}',
                style: textStyles.bodyMedium.copyWith(fontWeight: FontWeight.w600),
              ),
              Text('DÃ­a: ${_getDiaNombre(widget.diaSemana)}', style: textStyles.bodyMedium),
              Text('Grupo: ${widget.grupo.nombre}', style: textStyles.bodyMedium),
            ],
          ),
        ),
        SizedBox(height: spacing.lg),
        DropdownButtonFormField<String>(
          isExpanded: true,
          value: _selectedHoraFin,
          decoration: const InputDecoration(
            labelText: 'Hora de Fin',
            hintText: 'Selecciona la hora de fin',
          ),
          items: _getHorasFinDisponibles(widget.horaInicio)
              .map((hora) => DropdownMenuItem<String>(value: hora, child: Text(hora, overflow: TextOverflow.ellipsis, maxLines: 1)))
              .toList(),
          validator: (value) {
            if (value == null || value.isEmpty) {
              return 'La hora de fin es requerida';
            }
            return null;
          },
          onChanged: (hora) {
            setState(() => _selectedHoraFin = hora);
          },
        ),
        SizedBox(height: spacing.md),
        Consumer<MateriaProvider>(
          builder: (context, materiaProvider, child) {
            return DropdownButtonFormField<Materia>(
              isExpanded: true,
              value: _selectedMateria,
              decoration: const InputDecoration(
                labelText: 'Materia',
                hintText: 'Selecciona una materia',
              ),
              items: materiaProvider.materias
                  .map((materia) => DropdownMenuItem<Materia>(value: materia, child: Text(materia.nombre, overflow: TextOverflow.ellipsis, maxLines: 1)))
                  .toList(),
              validator: (value) {
                if (value == null) {
                  return 'La materia es requerida';
                }
                return null;
              },
              onChanged: (materia) {
                setState(() => _selectedMateria = materia);
              },
            );
          },
        ),
        SizedBox(height: spacing.md),
        Consumer2<UserProvider, HorarioProvider>(
          builder: (context, userProvider, horarioProvider, child) {
            final profesoresDisponibles = horarioProvider.getProfesoresDisponibles(
              userProvider.professors,
              widget.diaSemana,
              widget.horaInicio,
              _selectedHoraFin ?? _getHoraFin(widget.horaInicio),
            );

            User? selectedProfesorFromList;
            if (_selectedProfesor != null) {
              selectedProfesorFromList = profesoresDisponibles.firstWhere(
                (p) => p.id == _selectedProfesor!.id,
                orElse: () => _selectedProfesor!,
              );
            }

            return DropdownButtonFormField<User?>(
              isExpanded: true,
              value: selectedProfesorFromList,
              decoration: InputDecoration(
                labelText: 'Profesor (opcional)',
                hintText: 'Selecciona un profesor',
                helperText: profesoresDisponibles.length < userProvider.professors.length
                    ? '${profesoresDisponibles.length} disponibles'
                    : null,
              ),
              items: [
                const DropdownMenuItem<User?>(
                  value: null,
                  child: Text('Sin profesor'),
                ),
                ...profesoresDisponibles.map((profesor) {
                  return DropdownMenuItem<User?>(
                    value: profesor,
                    child: Text('${profesor.nombres} ${profesor.apellidos}', overflow: TextOverflow.ellipsis, maxLines: 1),
                  );
                }),
              ],
              onChanged: (profesor) {
                setState(() => _selectedProfesor = profesor);
              },
            );
          },
        ),
      ],
    );
  }

  Future<bool> _createClass() async {
    if (!_formKey.currentState!.validate()) return false;
    if (_selectedMateria == null) return false;

    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final horarioProvider = Provider.of<HorarioProvider>(context, listen: false);
    final colors = context.colors;

    try {
      final token = authProvider.accessToken;
      if (token == null) return false;

      final periodoId = widget.grupo.periodoId;

      final success = await horarioProvider.createHorario(
        token,
        CreateHorarioRequest(
          periodoId: periodoId,
          grupoId: widget.grupo.id,
          materiaId: _selectedMateria!.id,
          profesorId: _selectedProfesor?.id,
          diaSemana: widget.diaSemana,
          horaInicio: widget.horaInicio,
          horaFin: _selectedHoraFin ?? _getHoraFin(widget.horaInicio),
        ),
      );

      if (success && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Clase creada correctamente')));
        return true;
      } else if (mounted) {
        final errorMessage = horarioProvider.errorMessage ?? 'Error al crear clase';
        if (horarioProvider.conflictError != null) {
          _showConflictDialog(horarioProvider.conflictError!, 'crear');
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(errorMessage), backgroundColor: colors.error),
          );
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e'), backgroundColor: colors.error),
        );
      }
    }

    return false;
  }

  String _getHoraFin(String horaInicio) {
    final parts = horaInicio.split(':');
    final hour = int.parse(parts[0]);
    final nextHour = hour + 1;
    return '${nextHour.toString().padLeft(2, '0')}:00';
  }

  String _getDiaNombre(int diaSemana) {
    const dias = {
      1: 'Lunes',
      2: 'Martes',
      3: 'MiÃ©rcoles',
      4: 'Jueves',
      5: 'Viernes',
      6: 'SÃ¡bado',
      7: 'Domingo',
    };
    return dias[diaSemana] ?? 'Desconocido';
  }

  List<String> _getHorasFinDisponibles(String horaInicio) {
    final parts = horaInicio.split(':');
    final hourInicio = int.parse(parts[0]);
    final horasDisponibles = <String>[];
    for (int hour = hourInicio + 1; hour <= 18; hour++) {
      horasDisponibles.add('${hour.toString().padLeft(2, '0')}:00');
    }
    return horasDisponibles;
  }

  void _showConflictDialog(ConflictError conflictError, String operation) {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Row(
          children: [
            Icon(Icons.warning, color: colors.warning),
            SizedBox(width: spacing.sm),
            Text('Conflicto de Horario', style: textStyles.headlineMedium),
          ],
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'No se puede $operation la clase debido a un conflicto de horario.',
              style: textStyles.bodyMedium,
            ),
            SizedBox(height: spacing.md),
            Container(
              padding: EdgeInsets.all(spacing.sm),
              decoration: BoxDecoration(
                color: colors.error.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(spacing.borderRadius),
                border: Border.all(color: colors.error.withValues(alpha: 0.3)),
              ),
              child: Text(
                conflictError.userFriendlyMessage,
                style: textStyles.bodySmall.copyWith(
                  color: colors.error,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ),
            if (conflictError.conflictingHorarioIds.isNotEmpty) ...[
              SizedBox(height: spacing.md),
              Text('Horarios en conflicto:', style: textStyles.bodyMedium.copyWith(fontWeight: FontWeight.w600)),
              SizedBox(height: spacing.sm),
              ...conflictError.conflictingHorarioIds
                  .map((id) => Text('- $id', style: textStyles.bodySmall.copyWith(color: colors.textSecondary))),
            ],
            SizedBox(height: spacing.md),
            Text('Sugerencias para resolver el conflicto:', style: textStyles.bodyMedium.copyWith(fontWeight: FontWeight.w600)),
            SizedBox(height: spacing.sm),
            ...conflictError.suggestions.map((suggestion) => Text(
                  'â€¢ $suggestion',
                  style: textStyles.bodySmall.copyWith(color: colors.textSecondary),
                )),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Revisar Horarios'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(),
            style: ElevatedButton.styleFrom(
              backgroundColor: colors.primary,
              foregroundColor: colors.onPrimary,
            ),
            child: const Text('Entendido'),
          ),
        ],
      ),
    );
  }
}

/* Fin lib\widgets\horarios\create_class_dialog.dart */

/* Inicio lib\widgets\horarios\edit_class_dialog.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../../models/horario.dart';
import '../../models/user.dart';
import '../../providers/auth_provider.dart';
import '../../providers/horario_provider.dart';
import '../../providers/user_provider.dart';
import '../../services/academic/horario_service.dart';
import '../../theme/theme_extensions.dart';
import '../components/index.dart';

class EditClassDialog extends StatefulWidget {
  final Horario horario;

  const EditClassDialog({super.key, required this.horario});

  @override
  State<EditClassDialog> createState() => _EditClassDialogState();
}

class _EditClassDialogState extends State<EditClassDialog> {
  final _formKey = GlobalKey<FormState>();
  User? _selectedProfesor;
  String? _selectedHoraFin;

  @override
  void initState() {
    super.initState();
    _selectedProfesor = widget.horario.profesor;
    _selectedHoraFin = widget.horario.horaFin;
  }

  @override
  Widget build(BuildContext context) {
    final textStyles = context.textStyles;
    final spacing = context.spacing;
    final colors = context.colors;

    return ClarityFormDialog(
      title: Text('Editar Clase', style: textStyles.headlineMedium),
      formKey: _formKey,
      onSave: _updateClass,
      saveLabel: 'Actualizar',
      cancelLabel: 'Cancelar',
      children: [
        Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              padding: EdgeInsets.all(spacing.md),
              decoration: BoxDecoration(
                color: colors.surface,
                borderRadius: BorderRadius.circular(spacing.borderRadius),
                border: Border.all(color: colors.borderLight),
              ),
              child: Column(
                children: [
                  Text(
                    'Horario: ${widget.horario.horaInicio} - ${_selectedHoraFin ?? widget.horario.horaFin}',
                    style: textStyles.bodyMedium.copyWith(fontWeight: FontWeight.w600),
                  ),
                  Text('DÃ­a: ${widget.horario.diaSemanaNombre}', style: textStyles.bodyMedium),
                  Text('Grupo: ${widget.horario.grupo.nombre}', style: textStyles.bodyMedium),
                  Text('Materia: ${widget.horario.materia.nombre}', style: textStyles.bodyMedium),
                ],
              ),
            ),
            SizedBox(height: spacing.lg),
            DropdownButtonFormField<String>(
              isExpanded: true,
              value: _selectedHoraFin,
              decoration: const InputDecoration(labelText: 'Hora de Fin', hintText: 'Selecciona la hora de fin'),
              items: _getHorasFinDisponibles(widget.horario.horaInicio)
                  .map((hora) => DropdownMenuItem<String>(value: hora, child: Text(hora, overflow: TextOverflow.ellipsis, maxLines: 1)))
                  .toList(),
              validator: (value) => (value == null || value.isEmpty) ? 'La hora de fin es requerida' : null,
              onChanged: (hora) => setState(() => _selectedHoraFin = hora),
            ),
            SizedBox(height: spacing.md),
            Consumer<UserProvider>(
              builder: (context, userProvider, child) {
                User? selectedProfesorFromList;
                if (_selectedProfesor != null) {
                  selectedProfesorFromList = userProvider.professors.firstWhere(
                    (p) => p.id == _selectedProfesor!.id,
                    orElse: () => _selectedProfesor!,
                  );
                }

                return DropdownButtonFormField<User?>(
                  isExpanded: true,
                  value: selectedProfesorFromList,
                  decoration: const InputDecoration(labelText: 'Profesor', hintText: 'Selecciona un profesor'),
                  items: [
                    const DropdownMenuItem<User?>(value: null, child: Text('Sin profesor')),
                    ...userProvider.professors.map((profesor) {
                      return DropdownMenuItem<User?>(
                        value: profesor,
                        child: Text('${profesor.nombres} ${profesor.apellidos}', overflow: TextOverflow.ellipsis, maxLines: 1),
                      );
                    }),
                  ],
                  onChanged: (profesor) => setState(() => _selectedProfesor = profesor),
                );
              },
            ),
            SizedBox(height: spacing.md),
            Align(
              alignment: Alignment.centerLeft,
              child: TextButton(
                onPressed: _onDeletePressed,
                style: TextButton.styleFrom(foregroundColor: colors.error),
                child: const Text('Eliminar'),
              ),
            ),
          ],
        ),
      ],
    );
  }

  Future<void> _onDeletePressed() async {
    final confirmed = await _showDeleteConfirmationDialog();
    if (confirmed != true) return;

    final success = await _deleteClass();
    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Clase eliminada correctamente')));
      Navigator.of(context).pop(true);
    }
  }

  List<String> _getHorasFinDisponibles(String horaInicio) {
    final parts = horaInicio.split(':');
    final hourInicio = int.parse(parts[0]);
    final horasDisponibles = <String>[];
    for (int hour = hourInicio + 1; hour <= 18; hour++) {
      horasDisponibles.add('${hour.toString().padLeft(2, '0')}:00');
    }
    return horasDisponibles;
  }

  Future<bool> _updateClass() async {
    if (!_formKey.currentState!.validate()) return false;
    final messenger = ScaffoldMessenger.of(context);
    final colors = context.colors;

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final horarioProvider = Provider.of<HorarioProvider>(context, listen: false);
      final token = authProvider.accessToken;
      if (token == null) return false;

      final success = await horarioProvider.updateHorario(
        token,
        widget.horario.id,
        UpdateHorarioRequest(
          profesorId: _selectedProfesor?.id,
          diaSemana: widget.horario.diaSemana,
          horaInicio: widget.horario.horaInicio,
          horaFin: _selectedHoraFin ?? widget.horario.horaFin,
        ),
      );

      if (success) {
        messenger.showSnackBar(const SnackBar(content: Text('Clase actualizada correctamente')));
        return true;
      }
    } catch (e) {
      messenger.showSnackBar(SnackBar(content: Text('Error: $e'), backgroundColor: colors.error));
    }
    return false;
  }

  Future<bool?> _showDeleteConfirmationDialog() async {
    return showDialog<bool>(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: const Text('Confirmar eliminaciÃ³n'),
        content: const Text('Â¿EstÃ¡s seguro de que quieres eliminar esta clase?'),
        actions: [
          TextButton(onPressed: () => Navigator.of(dialogContext).pop(false), child: const Text('Cancelar')),
          TextButton(
            onPressed: () => Navigator.of(dialogContext).pop(true),
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: const Text('Eliminar'),
          ),
        ],
      ),
    );
  }

  Future<bool> _deleteClass() async {
    final messenger = ScaffoldMessenger.of(context);
    final colors = context.colors;

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final horarioProvider = Provider.of<HorarioProvider>(context, listen: false);
      final token = authProvider.accessToken;
      if (token == null) return false;

      final success = await horarioProvider.deleteHorario(token, widget.horario.id);
      if (!mounted) return false;
      if (success) {
        messenger.showSnackBar(const SnackBar(content: Text('Clase eliminada correctamente')));
        return true;
      } else {
        messenger.showSnackBar(SnackBar(content: Text(horarioProvider.errorMessage ?? 'Error al eliminar clase'), backgroundColor: colors.error));
      }
    } catch (e) {
      messenger.showSnackBar(SnackBar(content: Text('Error: $e'), backgroundColor: colors.error));
    }
    return false;
  }
}

/* Fin lib\widgets\horarios\edit_class_dialog.dart */

/* Inicio lib\widgets\horarios\weekly_calendar.dart */
import 'package:flutter/material.dart';

import '../../models/horario.dart';
import '../../providers/horario_provider.dart';
import '../../theme/theme_extensions.dart';

typedef OnHorarioTap = void Function(Horario horario);
typedef OnEmptyCellTap = void Function(String hora, int diaSemana);

class WeeklyCalendar extends StatelessWidget {
  final HorarioProvider horarioProvider;
  final List<String> horas;
  final List<String> diasSemana;
  final List<int> diasSemanaValues;
  final OnEmptyCellTap onEmptyCellTap;
  final OnHorarioTap onHorarioTap;

  const WeeklyCalendar({
    super.key,
    required this.horarioProvider,
    required this.horas,
    required this.diasSemana,
    required this.diasSemanaValues,
    required this.onEmptyCellTap,
    required this.onHorarioTap,
  });

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final isMobile = constraints.maxWidth < 600;
        final hourColumnWidth = isMobile ? 60.0 : 80.0;
        final cellHeight = isMobile ? 70.0 : 80.0;

  final spacing = context.spacing;

  return SingleChildScrollView(
          child: Container(
            decoration: BoxDecoration(
              color: context.colors.surface,
              borderRadius: BorderRadius.circular(spacing.borderRadius),
              border: Border.all(color: context.colors.borderLight),
            ),
            child: Column(
              children: [
                _buildHeader(context, cellHeight, hourColumnWidth),
                const Divider(height: 0),
                ...horas.map((hora) => _buildHourRow(
                      context,
                      hora,
                      cellHeight: cellHeight,
                      hourColumnWidth: hourColumnWidth,
                      isMobile: isMobile,
                    )),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildHeader(BuildContext context, double cellHeight, double hourColumnWidth) {
    final spacing = context.spacing;

    return Row(
      children: [
        SizedBox(width: hourColumnWidth, height: cellHeight),
        ...diasSemana.map((dia) => Expanded(
              child: Container(
                height: cellHeight,
                padding: EdgeInsets.symmetric(
                  vertical: spacing.md / 2,
                  horizontal: spacing.md / 2,
                ),
                decoration: BoxDecoration(
                  border: Border(left: BorderSide(color: context.colors.borderLight)),
                ),
                child: Center(
                  child: Text(
                    dia,
                    style: context.textStyles.bodyMedium.copyWith(
                      fontWeight: FontWeight.w600,
                      color: context.colors.primary,
                    ),
                    textAlign: TextAlign.center,
                  ),
                ),
              ),
            )),
      ],
    );
  }

  Widget _buildHourRow(
    BuildContext context,
    String hora, {
    required double hourColumnWidth,
    required double cellHeight,
    required bool isMobile,
  }) {
    return SizedBox(
      height: cellHeight,
      child: Row(
        children: [
          Container(
            width: hourColumnWidth,
            height: cellHeight,
            alignment: Alignment.center,
            decoration: BoxDecoration(
              border: Border(
                top: BorderSide(color: context.colors.borderLight),
                right: BorderSide(color: context.colors.borderLight),
              ),
            ),
            child: FittedBox(
              fit: BoxFit.scaleDown,
              child: Text(
                hora,
                style: context.textStyles.bodySmall.copyWith(
                  color: context.colors.textSecondary,
                  fontWeight: FontWeight.w600,
                ),
                textAlign: TextAlign.center,
              ),
            ),
          ),
          ...List.generate(diasSemana.length, (index) {
            final diaSemana = diasSemanaValues[index];
            return Expanded(
              child: _buildScheduleCell(
                context,
                hora,
                diaSemana,
                cellHeight: cellHeight,
                isMobile: isMobile,
              ),
            );
          }),
        ],
      ),
    );
  }

  Widget _buildScheduleCell(
    BuildContext context,
    String hora,
    int diaSemana, {
    required double cellHeight,
    required bool isMobile,
  }) {
    final horarios = horarioProvider.horariosDelGrupoSeleccionado;

    if (_estaCeldaOcupada(hora, diaSemana, horarios)) {
      return Container(
        height: cellHeight,
        decoration: BoxDecoration(
          border: Border(
            left: BorderSide(color: context.colors.borderLight),
            top: BorderSide(color: context.colors.borderLight),
          ),
            color: context.colors.surface.withValues(alpha: 0.3),
        ),
      );
    }

    Horario? horarioExistente;
    for (final horario in horarios) {
      if (horario.diaSemana == diaSemana && horario.horaInicio == hora) {
        horarioExistente = horario;
        break;
      }
    }

    if (horarioExistente != null) {
      final horarioConcreto = horarioExistente;
      final duracionHoras = _calcularDuracionEnHoras(horarioConcreto.horaInicio, horarioConcreto.horaFin);
      final alturaTotal = cellHeight * duracionHoras;
      return InkWell(
        onTap: () => onHorarioTap(horarioConcreto),
        child: Container(
          height: alturaTotal,
          decoration: BoxDecoration(
            border: Border(
              left: BorderSide(color: context.colors.borderLight),
              top: BorderSide(color: context.colors.borderLight),
            ),
            color: _getMateriaColor(context, horarioExistente.materia.nombre),
            borderRadius: BorderRadius.circular(4),
          ),
          child: Padding(
            padding: EdgeInsets.all(isMobile ? context.spacing.xs : context.spacing.sm),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  horarioExistente.materia.nombre,
                  style: context.textStyles.bodySmall.copyWith(
                    fontWeight: FontWeight.w700,
                    color: context.colors.white,
                    fontSize: isMobile ? 11 : 12,
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
                if (horarioExistente.profesor != null) ...[
                  SizedBox(height: isMobile ? context.spacing.xs : context.spacing.sm),
                  Text(
                    '${horarioExistente.profesor!.nombres.split(' ').first} ${horarioExistente.profesor!.apellidos.split(' ').first}',
                    style: context.textStyles.bodySmall.copyWith(
                      color: context.colors.white.withValues(alpha: 0.9),
                      fontSize: isMobile ? 9 : 10,
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
                SizedBox(height: isMobile ? context.spacing.xs : context.spacing.sm),
                Text(
                  '${horarioExistente.horaInicio} - ${horarioExistente.horaFin}',
                    style: context.textStyles.bodySmall.copyWith(
                      color: context.colors.white.withValues(alpha: 0.8),
                    fontSize: isMobile ? 8 : 9,
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
              ],
            ),
          ),
        ),
      );
    }

    return InkWell(
      onTap: () => onEmptyCellTap(hora, diaSemana),
      child: Container(
        height: cellHeight,
        decoration: BoxDecoration(
          border: Border(
            left: BorderSide(color: context.colors.borderLight),
            top: BorderSide(color: context.colors.borderLight),
          ),
        ),
        child: Center(
            child: Icon(
              Icons.add,
              size: isMobile ? 16 : 20,
              color: context.colors.primary.withValues(alpha: 0.5),
            ),
        ),
      ),
    );
  }
}

bool _estaCeldaOcupada(String hora, int diaSemana, List<Horario> horarios) {
  for (final horario in horarios) {
    if (horario.diaSemana == diaSemana) {
      if (horario.horaInicio == hora) continue;
      final horaInicioInt = _horaToInt(horario.horaInicio);
      final horaFinInt = _horaToInt(horario.horaFin);
      final horaActualInt = _horaToInt(hora);
      if (horaInicioInt < horaActualInt && horaFinInt > horaActualInt) {
        return true;
      }
    }
  }
  return false;
}

int _horaToInt(String hora) {
  final parts = hora.split(':');
  final hours = int.parse(parts[0]);
  final minutes = int.parse(parts[1]);
  return hours * 60 + minutes;
}

double _calcularDuracionEnHoras(String horaInicio, String horaFin) {
  final inicioInt = _horaToInt(horaInicio);
  final finInt = _horaToInt(horaFin);
  return (finInt - inicioInt) / 60.0;
}

Color _getMateriaColor(BuildContext context, String materiaNombre) {
  final hash = materiaNombre.hashCode;
  final index = hash % 5;
  switch (index) {
    case 0:
      return context.colors.primary;
    case 1:
      return context.colors.secondary;
    case 2:
      return Colors.green;
    case 3:
      return Colors.orange;
    case 4:
      return Colors.purple;
    default:
      return context.colors.primary;
  }
}

/* Fin lib\widgets\horarios\weekly_calendar.dart */

/* Inicio lib\widgets\index.dart */

export 'pagination_widget.dart';
export 'dashboard_widgets.dart';
export 'form_widgets.dart';
export 'role_guard.dart';
export 'scroll_state_keeper.dart';
export 'session_info_footer.dart';
export 'common/index.dart';
export 'components/index.dart';
export 'ui/index.dart';

/* Fin lib\widgets\index.dart */

/* Inicio lib\widgets\pagination_widget.dart */
import 'package:flutter/material.dart';
import '../theme/theme_extensions.dart';
import '../theme/app_colors.dart';
import '../theme/app_spacing.dart';
import '../theme/app_text_styles.dart';
import '../config/app_constants.dart';
typedef OnPageChangeCallback = Future<void> Function(int page);
class PaginationWidget extends StatelessWidget {
  final int currentPage;
  final int totalPages;
  final int totalItems;
  final OnPageChangeCallback onPageChange;
  final bool isLoading;
  final int maxPageButtons;

  const PaginationWidget({
    super.key,
    required this.currentPage,
    required this.totalPages,
    required this.totalItems,
    required this.onPageChange,
    this.isLoading = false,
    this.maxPageButtons = 5,
  });

  bool get _canGoPrevious => currentPage > 1;
  bool get _canGoNext => currentPage < totalPages;
  bool get _showPagination => totalPages > 1;

  Future<void> _handlePageChange(int page) async {
    if (page != currentPage && page >= 1 && page <= totalPages) {
      await onPageChange(page);
    }
  }

  List<int> _getVisiblePages() {
    final pages = <int>[];

    if (totalPages <= maxPageButtons) {
      pages.addAll(List.generate(totalPages, (i) => i + 1));
    } else {
      if (currentPage <= maxPageButtons ~/ 2 + 1) {
        pages.addAll(List.generate(maxPageButtons, (i) => i + 1));
      } else if (currentPage >= totalPages - maxPageButtons ~/ 2) {
        pages.addAll(List.generate(
          maxPageButtons,
          (i) => totalPages - maxPageButtons + i + 1,
        ));
      } else {
        final center = maxPageButtons ~/ 2;
        pages.addAll(List.generate(
          maxPageButtons,
          (i) => currentPage - center + i,
        ));
      }
    }

    return pages;
  }

  @override
  Widget build(BuildContext context) {
    if (!_showPagination) {
      return const SizedBox.shrink();
    }

    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Container(
      margin: EdgeInsets.symmetric(horizontal: spacing.lg, vertical: spacing.md),
      decoration: BoxDecoration(
        color: colors.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: colors.borderLight, width: 1),
        boxShadow: [
          BoxShadow(
            color: colors.textMuted.withValues(alpha: 0.08),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            padding: EdgeInsets.symmetric(horizontal: spacing.md, vertical: spacing.sm),
            decoration: BoxDecoration(
              color: colors.primaryContainer.withValues(alpha: 0.3),
              borderRadius: const BorderRadius.only(
                topLeft: Radius.circular(12),
                topRight: Radius.circular(12),
              ),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.library_books_outlined,
                  size: 16,
                  color: colors.primary,
                ),
                SizedBox(width: spacing.xs),
                Text(
                  'PÃ¡gina $currentPage de $totalPages',
                  style: textStyles.bodyMedium.bold.copyWith(color: colors.primary),
                ),
                SizedBox(width: spacing.sm),
                Container(
                  padding: EdgeInsets.symmetric(horizontal: spacing.sm, vertical: 2),
                  decoration: BoxDecoration(
                    color: colors.primary.withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(
                    '$totalItems items',
                    style: textStyles.bodySmall.copyWith(
                      color: colors.primary,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
              ],
            ),
          ),
          Padding(
            padding: EdgeInsets.all(spacing.md),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                _buildPageSelector(colors, spacing, textStyles),

                SizedBox(height: spacing.md),
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    _buildNavigationButton(
                      icon: Icons.first_page,
                      label: 'Primera',
                      enabled: _canGoPrevious && !isLoading,
                      onPressed: () => _handlePageChange(1),
                      colors: colors,
                      spacing: spacing,
                      textStyles: textStyles,
                      compact: true,
                    ),

                    SizedBox(width: spacing.sm),
                    _buildNavigationButton(
                      icon: Icons.chevron_left,
                      label: 'Anterior',
                      enabled: _canGoPrevious && !isLoading,
                      onPressed: () => _handlePageChange(currentPage - 1),
                      colors: colors,
                      spacing: spacing,
                      textStyles: textStyles,
                    ),

                    SizedBox(width: spacing.md),
                    _buildNavigationButton(
                      icon: Icons.chevron_right,
                      label: 'Siguiente',
                      enabled: _canGoNext && !isLoading,
                      onPressed: () => _handlePageChange(currentPage + 1),
                      colors: colors,
                      spacing: spacing,
                      textStyles: textStyles,
                      iconOnRight: true,
                    ),

                    SizedBox(width: spacing.sm),
                    _buildNavigationButton(
                      icon: Icons.last_page,
                      label: 'Ãšltima',
                      enabled: _canGoNext && !isLoading,
                      onPressed: () => _handlePageChange(totalPages),
                      colors: colors,
                      spacing: spacing,
                      textStyles: textStyles,
                      iconOnRight: true,
                      compact: true,
                    ),
                  ],
                ),
                if (isLoading) ...[
                  SizedBox(height: spacing.sm),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      SizedBox(
                        width: 16,
                        height: 16,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          valueColor: AlwaysStoppedAnimation<Color>(colors.primary),
                        ),
                      ),
                      SizedBox(width: spacing.sm),
                      Text(
                        'Cargando...',
                        style: textStyles.bodySmall.copyWith(color: colors.textSecondary),
                      ),
                    ],
                  ),
                ],
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildNavigationButton({
    required IconData icon,
    required String label,
    required bool enabled,
    required VoidCallback onPressed,
    required AppColors colors,
    required AppSpacing spacing,
    required AppTextStyles textStyles,
    bool iconOnRight = false,
    bool compact = false,
  }) {
    return AnimatedOpacity(
      opacity: enabled ? 1.0 : 0.5,
      duration: const Duration(milliseconds: 200),
      child: ElevatedButton(
        onPressed: enabled ? onPressed : null,
        style: ElevatedButton.styleFrom(
          backgroundColor: colors.primary,
          disabledBackgroundColor: colors.borderLight,
          foregroundColor: colors.getTextColorForBackground(colors.primary),
          disabledForegroundColor: colors.textMuted,
          padding: EdgeInsets.symmetric(
            horizontal: compact ? spacing.sm : spacing.md,
            vertical: spacing.sm,
          ),
          elevation: enabled ? 2 : 0,
          shadowColor: colors.primary.withValues(alpha: 0.4),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ).copyWith(
          overlayColor: WidgetStateProperty.all(
            colors.getTextColorForBackground(colors.primary).withValues(alpha: 0.1),
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            if (!iconOnRight) ...[
              Icon(icon, size: 18),
              if (!compact) SizedBox(width: spacing.xs),
            ],
            if (!compact)
              Text(
                label,
                style: textStyles.bodySmall.bold,
              ),
            if (iconOnRight) ...[
              if (!compact) SizedBox(width: spacing.xs),
              Icon(icon, size: 18),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildPageSelector(AppColors colors, AppSpacing spacing, AppTextStyles textStyles) {
    if (totalPages <= 1) {
      return const SizedBox.shrink();
    }

    final pages = _getVisiblePages();

    return Container(
      padding: EdgeInsets.symmetric(horizontal: spacing.sm, vertical: spacing.xs),
      decoration: BoxDecoration(
        color: colors.backgroundLight,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: colors.borderLight.withValues(alpha: 0.5)),
      ),
      child: SingleChildScrollView(
        scrollDirection: Axis.horizontal,
        child: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            for (int i = 0; i < pages.length; i++) ...[
              _buildPageButton(
                pageNumber: pages[i],
                isCurrentPage: pages[i] == currentPage,
                colors: colors,
                spacing: spacing,
                textStyles: textStyles,
              ),
              if (i != pages.length - 1) SizedBox(width: spacing.xs / 2),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildPageButton({
    required int pageNumber,
    required bool isCurrentPage,
    required AppColors colors,
    required AppSpacing spacing,
    required AppTextStyles textStyles,
  }) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: !isLoading && !isCurrentPage
            ? () => _handlePageChange(pageNumber)
            : null,
        borderRadius: BorderRadius.circular(8),
        splashColor: colors.primary.withValues(alpha: 0.1),
        highlightColor: colors.primary.withValues(alpha: 0.05),
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          curve: Curves.easeInOut,
          constraints: const BoxConstraints(
            minWidth: 36,
            minHeight: 36,
          ),
          padding: EdgeInsets.symmetric(
            horizontal: spacing.sm,
            vertical: spacing.xs,
          ),
          decoration: BoxDecoration(
            color: isCurrentPage
                ? colors.primary
                : Colors.transparent,
            borderRadius: BorderRadius.circular(8),
            border: Border.all(
              color: isCurrentPage
                  ? colors.primary
                  : colors.borderLight.withValues(alpha: 0.3),
              width: isCurrentPage ? 2 : 1,
            ),
            boxShadow: isCurrentPage
                ? [
                    BoxShadow(
                      color: colors.primary.withValues(alpha: 0.3),
                      blurRadius: 8,
                      offset: const Offset(0, 2),
                    ),
                  ]
                : null,
          ),
          child: Center(
            child: Text(
              '$pageNumber',
              style: textStyles.bodyMedium.copyWith(
                color: isCurrentPage
                    ? colors.getTextColorForBackground(colors.primary)
                    : colors.textSecondary,
                fontWeight: isCurrentPage ? FontWeight.bold : FontWeight.w500,
              ),
            ),
          ),
        ),
      ),
    );
  }
}
class PaginationState {
  final int currentPage;
  final int totalPages;
  final int totalItems;
  final int itemsPerPage;
  final bool isLoading;

  PaginationState({
    this.currentPage = 1,
    this.totalPages = 1,
    this.totalItems = 0,
    this.itemsPerPage = AppConstants.itemsPerPage,
    this.isLoading = false,
  });

  bool get hasNextPage => currentPage < totalPages;
  bool get hasPreviousPage => currentPage > 1;
  bool get isFirstPage => currentPage == 1;
  bool get isLastPage => currentPage == totalPages;
  PaginationState copyWith({
    int? currentPage,
    int? totalPages,
    int? totalItems,
    int? itemsPerPage,
    bool? isLoading,
  }) {
    return PaginationState(
      currentPage: currentPage ?? this.currentPage,
      totalPages: totalPages ?? this.totalPages,
      totalItems: totalItems ?? this.totalItems,
      itemsPerPage: itemsPerPage ?? this.itemsPerPage,
      isLoading: isLoading ?? this.isLoading,
    );
  }

  @override
  String toString() =>
      'PaginationState(page: $currentPage/$totalPages, items: $totalItems, perPage: $itemsPerPage)';
}

/* Fin lib\widgets\pagination_widget.dart */

/* Inicio lib\widgets\role_guard.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../utils/role_enum.dart';
class RoleGuard extends StatelessWidget {
  final List<UserRole> allowedRoles
  final Widget child
  final Widget? fallback

  const RoleGuard({
    super.key,
    required this.allowedRoles,
    required this.child,
    this.fallback,
  });

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final userRoleString = authProvider.user?['rol'] as String?;

    if (userRoleString == null) {
      return fallback ?? const SizedBox.shrink();
    }

    UserRole? userRole;
    try {
      userRole = UserRoleExtension.fromString(userRoleString);
    } catch (e) {
      return fallback ?? const SizedBox.shrink();
    }

    if (allowedRoles.contains(userRole)) {
      return child;
    } else {
      return fallback ?? const SizedBox.shrink();
    }
  }
}
/* Fin lib\widgets\role_guard.dart */

/* Inicio lib\widgets\scroll_state_keeper.dart */
import 'package:flutter/material.dart';
class ScrollStateKeeper extends StatefulWidget {
  final String routeKey;
  final bool keepScrollPosition;
  final Widget Function(BuildContext, ScrollController) builder;

  const ScrollStateKeeper({
    super.key,
    required this.routeKey,
    this.keepScrollPosition = true,
    required this.builder,
  });

  @override
  State<ScrollStateKeeper> createState() => _ScrollStateKeeperState();
}

class _ScrollStateKeeperState extends State<ScrollStateKeeper> {
  final ScrollController _scrollController = ScrollController();

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return widget.builder(context, _scrollController);
  }
}
/* Fin lib\widgets\scroll_state_keeper.dart */

/* Inicio lib\widgets\session_info_footer.dart */
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';

class SessionInfoFooter extends StatelessWidget {
  const SessionInfoFooter({super.key});

  Future<void> _copyToClipboard(BuildContext context, String text) async {
    await Clipboard.setData(ClipboardData(text: text));

    if (context.mounted) {
      final colors = context.colors;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            'Token copiado al portapapeles',
            style: TextStyle(color: colors.getTextColorForBackground(colors.success)),
          ),
          duration: const Duration(seconds: 2),
          backgroundColor: colors.success,
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final authProvider = Provider.of<AuthProvider>(context);
    final accessToken = authProvider.accessToken;

    if (accessToken == null) return const SizedBox.shrink();

    return Container(
      width: double.infinity,
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: colors.primary,
        boxShadow: [
          BoxShadow(
            color: colors.shadow,
            blurRadius: 4,
            offset: const Offset(0, -2),
          ),
        ],
      ),
      child: Row(
        children: [
          Icon(
            Icons.security,
            size: 16,
            color: colors.success,
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              'Token: ${accessToken.substring(0, 20)}...',
              style: TextStyle(
                color: colors.textOnDark,
                fontSize: 12,
                fontFamily: 'monospace',
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
          const SizedBox(width: 8),
          IconButton(
            icon: const Icon(Icons.copy, size: 16),
            color: colors.textOnDarkSecondary,
            tooltip: 'Copiar token',
            onPressed: () => _copyToClipboard(context, accessToken),
          ),
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
            decoration: BoxDecoration(
              color: colors.success.withValues(alpha: 0.2),
              borderRadius: BorderRadius.circular(4),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(
                  Icons.timer,
                  size: 14,
                  color: colors.success,
                ),
                const SizedBox(width: 4),
                Text(
                  'Activo',
                  style: TextStyle(
                    color: colors.getTextColorForBackground(colors.success),
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
/* Fin lib\widgets\session_info_footer.dart */

/* Inicio lib\widgets\test_multi_hora_widget.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:asistapp/providers/auth_provider.dart';
import 'package:asistapp/providers/horario_provider.dart';
import 'package:asistapp/providers/grupo_provider.dart';
import 'package:asistapp/providers/materia_provider.dart';
import 'package:asistapp/providers/user_provider.dart';
import '../../services/academic/horario_service.dart';

class TestMultiHoraWidget extends StatefulWidget {
  const TestMultiHoraWidget({super.key});

  @override
  State<TestMultiHoraWidget> createState() => _TestMultiHoraWidgetState();
}

class _TestMultiHoraWidgetState extends State<TestMultiHoraWidget> {
  String _testResult = 'Esperando resultados...';

  @override
  void initState() {
    super.initState();
    _runTests();
  }

  Future<void> _runTests() async {
    setState(() => _testResult = 'Ejecutando pruebas...\n');

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final horarioProvider = Provider.of<HorarioProvider>(context, listen: false);
  final grupoProvider = Provider.of<GrupoProvider>(context, listen: false);
      final materiaProvider = Provider.of<MateriaProvider>(context, listen: false);
      final userProvider = Provider.of<UserProvider>(context, listen: false);
      setState(() => _testResult += 'âœ“ Verificando providers...\n');

      if (authProvider.accessToken == null) {
        setState(() => _testResult += 'âŒ No hay token de autenticaciÃ³n\n');
        return;
      }

  if (grupoProvider.items.isEmpty) {
        setState(() => _testResult += 'âŒ No hay grupos disponibles\n');
        return;
      }

      if (materiaProvider.materias.isEmpty) {
        setState(() => _testResult += 'âŒ No hay materias disponibles\n');
        return;
      }

      setState(() => _testResult += 'âœ“ Providers configurados correctamente\n');
  final testGrupo = grupoProvider.items.first;
      setState(() => _testResult += 'âœ“ Grupo de prueba: ${testGrupo.nombre}\n');
      final token = authProvider.accessToken;
      if (token == null) {
        setState(() => _testResult += 'âŒ No hay token de autenticaciÃ³n\n');
        return;
      }

      await horarioProvider.loadHorariosByGrupo(token, testGrupo.id);
      setState(() => _testResult += 'âœ“ Horarios cargados: ${horarioProvider.horarios.length}\n');
      final testMateria = materiaProvider.materias.first;
      final testProfesor = userProvider.professors.isNotEmpty ? userProvider.professors.first : null;

      setState(() => _testResult += 'âœ“ Preparando creaciÃ³n de clase multi-hora...\n');
      final token2 = authProvider.accessToken;
      if (token2 == null) {
        setState(() => _testResult += 'âŒ No hay token de autenticaciÃ³n\n');
        return;
      }

      final success = await horarioProvider.createHorario(
        token2,
        CreateHorarioRequest(
          periodoId: testGrupo.periodoId,
          grupoId: testGrupo.id,
          materiaId: testMateria.id,
          profesorId: testProfesor?.id,
          diaSemana: 1, // Lunes
          horaInicio: '10:00',
          horaFin: '12:00',
        ),
      );

      if (success) {
        setState(() => _testResult += 'âœ… Clase multi-hora creada exitosamente\n');
  await horarioProvider.loadHorariosByGrupo(token2, testGrupo.id);
        final horariosDespues = horarioProvider.horarios;
        final claseCreada = horariosDespues.where(
          (h) => h.materiaId == testMateria.id && h.horaInicio == '10:00'
        ).firstOrNull;

        if (claseCreada != null) {
          setState(() => _testResult += 'âœ… Clase encontrada en la lista\n');
          setState(() => _testResult += '   - DuraciÃ³n: ${claseCreada.horaInicio} - ${claseCreada.horaFin}\n');
          setState(() => _testResult += '   - Altura esperada: 120px (2 horas)\n');
        } else {
          setState(() => _testResult += 'âŒ Clase no encontrada despuÃ©s de crear\n');
        }
      } else {
        final error = horarioProvider.errorMessage ?? 'Error desconocido';
        setState(() => _testResult += 'âŒ Error al crear clase: $error\n');
        if (error.contains('conflicto') || error.contains('Conflict')) {
          setState(() => _testResult += 'â„¹ï¸ Conflicto detectado (esperado si ya hay clases)\n');
        }
      }

      setState(() => _testResult += '\nğŸ‰ Pruebas completadas\n');

    } catch (e) {
      setState(() => _testResult += 'âŒ Error durante las pruebas: $e\n');
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Test Multi-Hora'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Resultados de Pruebas Multi-Hora',
                style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 16),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.grey[100],
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.grey[300]!),
                ),
                child: Text(
                  _testResult,
                  style: const TextStyle(fontFamily: 'monospace', fontSize: 12),
                ),
              ),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: _runTests,
                child: const Text('Ejecutar Pruebas Nuevamente'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
/* Fin lib\widgets\test_multi_hora_widget.dart */

/* Inicio lib\widgets\ui\app_button.dart */
import 'package:flutter/widgets.dart';
import '../../theme/theme_extensions.dart';
import '../../theme/app_colors.dart';
import '../../config/app_constants.dart';
class AppButton extends StatefulWidget {
  final String label;
  final VoidCallback onPressed;
  final bool isLoading;
  final bool isEnabled;
  final double? width;
  final EdgeInsets? padding;

  const AppButton({
    required this.label,
    required this.onPressed,
    this.isLoading = false,
    this.isEnabled = true,
    this.width,
    this.padding,
    super.key,
  });

  @override
  State<AppButton> createState() => _AppButtonState();
}

class _AppButtonState extends State<AppButton> {
  bool _isPressed = false;

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    final buttonChild = Container(
      constraints: widget.width != null
          ? BoxConstraints(minWidth: widget.width!)
          : const BoxConstraints(minWidth: 0),
      padding: widget.padding ??
          EdgeInsets.symmetric(
            horizontal: spacing.md,
            vertical: spacing.md,
          ),
      decoration: BoxDecoration(
        color: widget.isEnabled
            ? (_isPressed ? colors.primaryDark : colors.primary)
            : colors.grey300,
        borderRadius: BorderRadius.circular(AppConstants.instance.buttonBorderRadius),
      ),
      child: Center(
        child: widget.isLoading
            ? SizedBox(
                width: AppConstants.instance.spinnerSize,
                height: AppConstants.instance.spinnerSize,
                child: _buildLoadingSpinner(context),
              )
            : Text(
                widget.label,
                style: textStyles.labelLarge.copyWith(
                  color: colors.white, // Texto blanco sobre fondo primario
                ),
              ),
      ),
    );

    return GestureDetector(
      onTapDown: widget.isEnabled && !widget.isLoading
          ? (_) => setState(() => _isPressed = true)
          : null,
      onTapUp: widget.isEnabled && !widget.isLoading
          ? (_) {
              setState(() => _isPressed = false);
              widget.onPressed();
            }
          : null,
      onTapCancel: widget.isEnabled && !widget.isLoading
          ? () => setState(() => _isPressed = false)
          : null,
      child: buttonChild,
    );
  }

  Widget _buildLoadingSpinner(BuildContext context) {
    final colors = context.colors;

    return Center(
      child: SizedBox(
        width: AppConstants.instance.spinnerSize,
        height: AppConstants.instance.spinnerSize,
        child: CustomPaint(
          painter: _SpinnerPainter(colors: colors),
        ),
      ),
    );
  }
}
class AppSecondaryButton extends StatefulWidget {
  final String label;
  final VoidCallback onPressed;
  final bool isEnabled;
  final double? width;

  const AppSecondaryButton({
    required this.label,
    required this.onPressed,
    this.isEnabled = true,
    this.width,
    super.key,
  });

  @override
  State<AppSecondaryButton> createState() => _AppSecondaryButtonState();
}

class _AppSecondaryButtonState extends State<AppSecondaryButton> {
  bool _isPressed = false;

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    final buttonChild = Container(
      constraints: widget.width != null
          ? BoxConstraints(minWidth: widget.width!)
          : const BoxConstraints(minWidth: 0),
      padding: EdgeInsets.symmetric(
        horizontal: spacing.md,
        vertical: spacing.md,
      ),
      decoration: BoxDecoration(
        border: Border.all(
          color: widget.isEnabled ? colors.primary : colors.grey300,
          width: AppConstants.instance.borderWidthNormal,
        ),
        borderRadius: BorderRadius.circular(AppConstants.instance.buttonBorderRadius),
        color: _isPressed && widget.isEnabled
            ? colors.surfaceLight
            : colors.transparent,
      ),
      child: Center(
        child: Text(
          widget.label,
          style: textStyles.labelLarge.copyWith(
            color: widget.isEnabled
                ? colors.primary // Texto primario sobre fondo transparente
                : colors.textDisabled,
          ),
        ),
      ),
    );

    return GestureDetector(
      onTapDown: widget.isEnabled
          ? (_) => setState(() => _isPressed = true)
          : null,
      onTapUp: widget.isEnabled
          ? (_) {
              setState(() => _isPressed = false);
              widget.onPressed();
            }
          : null,
      onTapCancel: widget.isEnabled
          ? () => setState(() => _isPressed = false)
          : null,
      child: buttonChild,
    );
  }
}
class _SpinnerPainter extends CustomPainter {
  final AppColors colors;

  _SpinnerPainter({required this.colors});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = colors.white // Spinner blanco sobre fondo primario
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;

    final radius = size.width / 2;
    final center = Offset(size.width / 2, size.height / 2);

    canvas.drawCircle(center, radius, paint);

    final rect = Rect.fromCircle(center: center, radius: radius);
    canvas.drawArc(rect, 0, 1.5, false, paint);
  }

  @override
  bool shouldRepaint(_SpinnerPainter oldDelegate) => true;
}

/* Fin lib\widgets\ui\app_button.dart */

/* Inicio lib\widgets\ui\app_components.dart */
import 'package:flutter/material.dart';
import '../../theme/theme_extensions.dart';
class AppCard extends StatelessWidget {
  final Widget child;
  final EdgeInsets? padding;
  final VoidCallback? onTap;
  final Color? backgroundColor;
  final double? elevation;
  final BorderRadius? borderRadius;

  const AppCard({
    required this.child,
    this.padding,
    this.onTap,
    this.backgroundColor,
    this.elevation,
    this.borderRadius,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;

    return Card(
      color: backgroundColor ?? colors.surface,
      elevation: elevation ?? 2,
      shadowColor: colors.shadow,
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(
        borderRadius: borderRadius ?? BorderRadius.circular(spacing.borderRadius),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: borderRadius ?? BorderRadius.circular(spacing.borderRadius),
        child: Padding(
          padding: padding ?? EdgeInsets.all(spacing.cardPadding),
          child: child,
        ),
      ),
    );
  }
}
class AppScaffold extends StatelessWidget {
  final String? title;
  final Widget body;
  final Widget? floatingActionButton;
  final List<Widget>? actions;
  final bool showBackButton;
  final VoidCallback? onBackPressed;
  final PreferredSizeWidget? appBar;

  const AppScaffold({
    this.title,
    required this.body,
    this.floatingActionButton,
    this.actions,
    this.showBackButton = false,
    this.onBackPressed,
    this.appBar,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return Scaffold(
      backgroundColor: colors.background,
      appBar: appBar ?? (title != null ? AppBar(
        backgroundColor: colors.surface,
        foregroundColor: colors.textPrimary,
        elevation: 0,
        shadowColor: colors.shadow,
        surfaceTintColor: Colors.transparent,
        titleTextStyle: textStyles.headlineMedium,
        title: Text(title!),
        leading: showBackButton ? IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: onBackPressed ?? () => Navigator.maybePop(context),
        ) : null,
        actions: actions,
      ) : null),
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.all(spacing.screenPadding),
          child: body,
        ),
      ),
      floatingActionButton: floatingActionButton,
    );
  }
}
class AppText extends StatelessWidget {
  final String text;
  final TextStyle? style;
  final TextAlign? textAlign;
  final int? maxLines;
  final TextOverflow? overflow;
  final bool? softWrap;

  const AppText(
    this.text, {
    this.style,
    this.textAlign,
    this.maxLines,
    this.overflow,
    this.softWrap,
    super.key,
  });

  const AppText.headlineLarge(
    this.text, {
    this.textAlign,
    this.maxLines,
    this.overflow,
    this.softWrap,
    super.key,
  }) : style = null;

  const AppText.headlineMedium(
    this.text, {
    this.textAlign,
    this.maxLines,
    this.overflow,
    this.softWrap,
    super.key,
  }) : style = null;

  const AppText.bodyLarge(
    this.text, {
    this.textAlign,
    this.maxLines,
    this.overflow,
    this.softWrap,
    super.key,
  }) : style = null;

  const AppText.bodyMedium(
    this.text, {
    this.textAlign,
    this.maxLines,
    this.overflow,
    this.softWrap,
    super.key,
  }) : style = null;

  @override
  Widget build(BuildContext context) {
    final textStyles = context.textStyles;

    TextStyle resolvedStyle;
    if (style != null) {
      resolvedStyle = style!;
    } else {

      final constructorName = runtimeType.toString();
      if (constructorName.contains('headlineLarge')) {
        resolvedStyle = textStyles.headlineLarge;
      } else if (constructorName.contains('headlineMedium')) {
        resolvedStyle = textStyles.headlineMedium;
      } else if (constructorName.contains('bodyLarge')) {
        resolvedStyle = textStyles.bodyLarge;
      } else {
        resolvedStyle = textStyles.bodyMedium;
      }
    }

    return Text(
      text,
      style: resolvedStyle,
      textAlign: textAlign,
      maxLines: maxLines,
      overflow: overflow,
      softWrap: softWrap,
    );
  }
}
class AppSpacer extends StatelessWidget {
  final double? width;
  final double? height;

  const AppSpacer({this.width, this.height, super.key});

  const AppSpacer.xs({super.key}) : width = null, height = null;
  const AppSpacer.sm({super.key}) : width = null, height = null;
  const AppSpacer.md({super.key}) : width = null, height = null;
  const AppSpacer.lg({super.key}) : width = null, height = null;
  const AppSpacer.xl({super.key}) : width = null, height = null;

  @override
  Widget build(BuildContext context) {
    final spacing = context.spacing;

    final double resolvedWidth = width ?? 0;
    final double resolvedHeight = height ?? (() {
      if (width != null) return width!;
      if (height != null) return height!;
      final constructorName = runtimeType.toString();
  if (constructorName.contains('xs')) return spacing.xs.toDouble();
  if (constructorName.contains('sm')) return spacing.sm.toDouble();
  if (constructorName.contains('md')) return spacing.md.toDouble();
  if (constructorName.contains('lg')) return spacing.lg.toDouble();
  if (constructorName.contains('xl')) return spacing.xl.toDouble();
  return 0.0;
    })();

    return SizedBox(
      width: resolvedWidth,
      height: resolvedHeight,
    );
  }
}
/* Fin lib\widgets\ui\app_components.dart */

/* Inicio lib\widgets\ui\error_logger.dart */
import 'package:flutter/material.dart';
import '../../theme/theme_extensions.dart';
class ErrorLoggerWidget extends StatefulWidget {
  ErrorLoggerWidget() : super(key: errorLoggerKey);

  @override
  State<ErrorLoggerWidget> createState() => ErrorLoggerWidgetState();
}

class ErrorLoggerWidgetState extends State<ErrorLoggerWidget> {
  final List<String> _logs = [];
  bool _isExpanded = false;
  bool _isVisible = false;

  @override
  void initState() {
    super.initState();

  }

  void addLog(String message) {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        _addLog(message);
      }
    });
  }

  void _addLog(String message) {
    setState(() {
      final timestamp = DateTime.now().toString().substring(11, 19)
      _logs.add('[$timestamp] $message');
      if (_logs.length > 50) {
        _logs.removeAt(0)
      }
      _isVisible = true;
    });
  }

  void _clearLogs() {
    setState(() {
      _logs.clear();
      _isVisible = false;
    });
  }

  @override
  Widget build(BuildContext context) {
    if (!_isVisible) return const SizedBox.shrink();

    final colors = context.colors;

    return Positioned(
      bottom: 20,
      right: 20,
      child: Material(
        color: Colors.transparent,
        child: Container(
          width: _isExpanded ? 300 : 60,
          height: _isExpanded ? 200 : 60,
          decoration: BoxDecoration(
            color: colors.surface,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: colors.border),
            boxShadow: const [
              BoxShadow(
                color: Color.fromRGBO(0, 0, 0, 0.3),
                blurRadius: 8,
                offset: Offset(0, 4),
              ),
            ],
          ),
          child: _isExpanded ? _buildExpandedView(context) : _buildCollapsedView(context),
        ),
      ),
    );
  }

  Widget _buildCollapsedView(BuildContext context) {
    final colors = context.colors;
    final errorCount = _logs.where((log) => log.contains('ERROR')).length;

    return GestureDetector(
      onTap: () => setState(() => _isExpanded = true),
      child: Container(
        padding: const EdgeInsets.all(12),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              errorCount > 0 ? Icons.error : Icons.bug_report,
              color: errorCount > 0 ? colors.error : colors.warning,
              size: 24,
            ),
            if (errorCount > 0)
              Container(
                margin: const EdgeInsets.only(top: 4),
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                decoration: BoxDecoration(
                  color: colors.error,
                  borderRadius: BorderRadius.circular(10),
                ),
                child: Text(
                  errorCount.toString(),
                  style: TextStyle(
                    color: colors.getTextColorForBackground(colors.error),
                    fontSize: 10,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildExpandedView(BuildContext context) {
    final colors = context.colors;
    final textStyles = context.textStyles;

    return Column(
      children: [

        Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
          decoration: BoxDecoration(
            color: colors.surfaceLight,
            borderRadius: const BorderRadius.only(
              topLeft: Radius.circular(12),
              topRight: Radius.circular(12),
            ),
          ),
          child: Row(
            children: [
              Text(
                'Logs de Debug',
                style: textStyles.labelLarge,
              ),
              const Spacer(),
              GestureDetector(
                onTap: _clearLogs,
                child: const Padding(
                  padding: EdgeInsets.all(4),
                  child: Icon(Icons.clear_all, size: 16),
                ),
              ),
              GestureDetector(
                onTap: () => setState(() => _isExpanded = false),
                child: const Padding(
                  padding: EdgeInsets.all(4),
                  child: Icon(Icons.close, size: 16),
                ),
              ),
            ],
          ),
        ),

        Expanded(
          child: Container(
            padding: const EdgeInsets.all(8),
            child: _logs.isEmpty
                ? Center(
                    child: Text(
                      'No hay logs',
                      style: textStyles.bodySmall,
                    ),
                  )
                : ListView.builder(
                    itemCount: _logs.length,
                    itemBuilder: (context, index) {
                      final log = _logs[_logs.length - 1 - index]
                      final isError = log.contains('ERROR');
                      return Padding(
                        padding: const EdgeInsets.only(bottom: 4),
                        child: Text(
                          log,
                          style: TextStyle(
                            fontSize: 10,
                            color: isError ? colors.error : colors.textSecondary,
                            fontFamily: 'monospace',
                          ),
                        ),
                      );
                    },
                  ),
          ),
        ),
      ],
    );
  }
}
final GlobalKey<ErrorLoggerWidgetState> errorLoggerKey = GlobalKey<ErrorLoggerWidgetState>();

void addDebugLog(String message) {
  debugPrint(message);
  errorLoggerKey.currentState?.addLog(message);
}
/* Fin lib\widgets\ui\error_logger.dart */

/* Inicio lib\widgets\ui\index.dart */
export 'app_button.dart';
export 'app_components.dart';
export 'error_logger.dart';

/* Fin lib\widgets\ui\index.dart */
