
/* Directorio:  */
â”œâ”€â”€ main.dart [116]
â”œâ”€â”€ ðŸ“‚ managers
â”‚   â””â”€â”€ app_lifecycle_manager.dart [110]
â”œâ”€â”€ ðŸ“‚ models
â”‚   â””â”€â”€ institution.dart [103]
â”œâ”€â”€ ðŸ“‚ providers
â”‚   â”œâ”€â”€ auth_provider.dart [194]
â”‚   â”œâ”€â”€ institution_provider.dart [183]
â”‚   â”œâ”€â”€ navigation_state_provider.dart [91]
â”‚   â”œâ”€â”€ scroll_state_provider.dart [55]
â”‚   â””â”€â”€ user_provider.dart [1]
â”œâ”€â”€ ðŸ“‚ screens
â”‚   â”œâ”€â”€ admin_dashboard.dart [123]
â”‚   â”œâ”€â”€ home_screen.dart [363]
â”‚   â”œâ”€â”€ ðŸ“‚ institutions
â”‚   â”‚   â”œâ”€â”€ institutions_list_screen.dart [545]
â”‚   â”‚   â””â”€â”€ institution_form_screen.dart [371]
â”‚   â”œâ”€â”€ institution_selection_screen.dart [195]
â”‚   â”œâ”€â”€ login_screen.dart [374]
â”‚   â”œâ”€â”€ student_dashboard.dart [133]
â”‚   â”œâ”€â”€ super_admin_dashboard.dart [118]
â”‚   â”œâ”€â”€ teacher_dashboard.dart [133]
â”‚   â”œâ”€â”€ teacher_dashboard_with_scroll.dart [89]
â”‚   â””â”€â”€ welcome_screen.dart [105]
â”œâ”€â”€ ðŸ“‚ services
â”‚   â”œâ”€â”€ auth_service.dart [190]
â”‚   â””â”€â”€ institution_service.dart [280]
â”œâ”€â”€ ðŸ“‚ theme
â”‚   â”œâ”€â”€ app_colors.dart [95]
â”‚   â”œâ”€â”€ app_constants.dart [59]
â”‚   â”œâ”€â”€ app_spacing.dart [24]
â”‚   â”œâ”€â”€ app_text_styles.dart [153]
â”‚   â”œâ”€â”€ app_theme.dart [186]
â”‚   â”œâ”€â”€ index.dart [5]
â”‚   â””â”€â”€ theme_extensions.dart [42]
â”œâ”€â”€ ðŸ“‚ ui
â”‚   â””â”€â”€ ðŸ“‚ widgets
â”‚       â”œâ”€â”€ app_button.dart [194]
â”‚       â”œâ”€â”€ app_components.dart [217]
â”‚       â”œâ”€â”€ error_logger.dart [198]
â”‚       â””â”€â”€ index.dart [4]
â”œâ”€â”€ ðŸ“‚ utils
â”‚   â”œâ”€â”€ app_router.dart [232]
â”‚   â”œâ”€â”€ app_routes.dart [43]
â”‚   â”œâ”€â”€ responsive_utils.dart [166]
â”‚   â”œâ”€â”€ role_enum.dart [53]
â”‚   â””â”€â”€ route_guards.dart [32]
â””â”€â”€ ðŸ“‚ widgets
    â”œâ”€â”€ app_wrappers.dart [146]
    â”œâ”€â”€ dashboard_widgets.dart [279]
    â”œâ”€â”€ index.dart [1]
    â”œâ”€â”€ navigation_state_mixin.dart [72]
    â”œâ”€â”€ role_guard.dart [39]
    â”œâ”€â”€ scroll_state_keeper.dart [120]
    â””â”€â”€ session_info_footer.dart [105]


Total de lÃ­neas resumidas: 6337
Total de archivos: 44
Promedio de lÃ­neas por archivo: 144
Archivo mÃ¡s grande: institutions_list_screen.dart (545 lÃ­neas)


/* Inicio main.dart */
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'providers/auth_provider.dart';
import 'providers/navigation_state_provider.dart';
import 'providers/scroll_state_provider.dart';
import 'providers/institution_provider.dart';
import 'managers/app_lifecycle_manager.dart';
import 'theme/app_theme.dart';
import 'theme/app_colors.dart';
import 'utils/app_router.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle(
    statusBarColor: AppColors.instance.transparent,
    statusBarIconBrightness: Brightness.light,
    systemNavigationBarColor: AppColors.instance.black,
    systemNavigationBarIconBrightness: Brightness.light,
  ));

  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> with WidgetsBindingObserver {

  late final AppLifecycleManager _lifecycleManager;
  late final AuthProvider _authProvider;
  late final NavigationStateProvider _navigationProvider;
  late final ScrollStateProvider _scrollProvider;
  late final InstitutionProvider _institutionProvider;
  late AppRouter _appRouter;

  @override
  void initState() {
    super.initState();

    _lifecycleManager = AppLifecycleManager();
    _authProvider = AuthProvider();
    _navigationProvider = NavigationStateProvider();
    _scrollProvider = ScrollStateProvider();
    _institutionProvider = InstitutionProvider();

    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _appRouter.dispose();
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {

    if (state == AppLifecycleState.resumed) {
      _authProvider.recoverFullState();
      if (!_navigationProvider.hasValidState()) {
        _navigationProvider.clearNavigationState();
      }
    }

    if (state == AppLifecycleState.paused) {
      _navigationProvider.refreshStateTimestamp();
    }
  }

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider.value(value: _authProvider),
        ChangeNotifierProvider.value(value: _navigationProvider),
        ChangeNotifierProvider.value(value: _scrollProvider),
        ChangeNotifierProvider.value(value: _institutionProvider),
        ChangeNotifierProvider.value(value: _lifecycleManager),
      ],
      child: Builder(
        builder: (context) {

          _appRouter = AppRouter(
            authProvider: _authProvider,
            navigationProvider: _navigationProvider,
          );

          return MaterialApp.router(
            title: 'AsistApp',
            debugShowCheckedModeBanner: false,
            theme: AppTheme.defaultTheme,
            routerConfig: _appRouter.router,
            builder: (context, child) {
              return DefaultTextStyle(
                style: TextStyle(
                  decoration: TextDecoration.none,
                  color: AppColors.instance.white,
                  fontSize: 14.0,
                  fontWeight: FontWeight.normal,
                ),
                child: child!,
              );
            },
          );
        },
      ),
    );
  }
}
/* Fin main.dart */

/* Inicio managers\app_lifecycle_manager.dart */
import 'package:flutter/widgets.dart';
enum AppState {
  resumed,
  paused,
  hidden,
  detached,
}
class AppLifecycleManager extends ChangeNotifier {
  AppState _currentState = AppState.resumed;
  DateTime? _lastPausedTime;
  bool _isFirstResume = true;

  AppState get currentState => _currentState;
  bool get isInForeground => _currentState == AppState.resumed;
  bool get isInBackground => _currentState == AppState.paused || _currentState == AppState.hidden;

  AppLifecycleManager() {
    WidgetsBinding.instance.addObserver(_AppLifecycleObserver(this));
  }

  void _onLifecycleChanged(AppState state) {
    final previousState = _currentState;
    _currentState = state;

    switch (state) {
      case AppState.paused:
        _handleAppPaused();
        break;
      case AppState.resumed:
        _handleAppResumed(previousState);
        break;
      case AppState.hidden:
        _handleAppHidden();
        break;
      case AppState.detached:
        _handleAppDetached();
        break;
    }

    notifyListeners();
  }

  void _handleAppPaused() {
    _lastPausedTime = DateTime.now();
    debugPrint('AppLifecycleManager: App paused at $_lastPausedTime');
  }

  void _handleAppResumed(AppState previousState) {
    final now = DateTime.now();
    final timeInBackground = _lastPausedTime != null ? now.difference(_lastPausedTime!) : Duration.zero;

    debugPrint('AppLifecycleManager: App resumed after ${timeInBackground.inSeconds}s in background');
    if (_isFirstResume) {
      _isFirstResume = false;
      return;
    }
    if (timeInBackground.inSeconds > 30) {
      debugPrint('AppLifecycleManager: Long background time, triggering data refresh');
      _triggerDataRefresh();
    } else {
      debugPrint('AppLifecycleManager: Quick resume, using cached data');
    }
  }

  void _handleAppHidden() {
    debugPrint('AppLifecycleManager: App hidden');
  }

  void _handleAppDetached() {
    debugPrint('AppLifecycleManager: App detached');
  }
  void _triggerDataRefresh() {
    debugPrint('AppLifecycleManager: Triggering data refresh...');
  }
  void addLifecycleCallback(String key, VoidCallback callback) {
  }

  void removeLifecycleCallback(String key) {
  }
}
class _AppLifecycleObserver extends WidgetsBindingObserver {
  final AppLifecycleManager _manager;

  _AppLifecycleObserver(this._manager);

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    AppState mappedState;

    switch (state) {
      case AppLifecycleState.resumed:
        mappedState = AppState.resumed;
        break;
      case AppLifecycleState.paused:
        mappedState = AppState.paused;
        break;
      case AppLifecycleState.hidden:
        mappedState = AppState.hidden;
        break;
      case AppLifecycleState.detached:
        mappedState = AppState.detached;
        break;
      case AppLifecycleState.inactive:
        mappedState = AppState.paused;
        break;
    }

    _manager._onLifecycleChanged(mappedState);
  }
}
/* Fin managers\app_lifecycle_manager.dart */

/* Inicio models\institution.dart */
class Institution {
  final String id;
  final String nombre;
  final String codigo;
  final String? direccion;
  final String? telefono;
  final String? email;
  final bool activa;
  final DateTime? createdAt;
  final DateTime? updatedAt;
  final String? role
  final Map<String, dynamic>? metadata;

  Institution({
    required this.id,
    required this.nombre,
    required this.codigo,
    this.direccion,
    this.telefono,
    this.email,
    this.activa = true,
    this.createdAt,
    this.updatedAt,
    this.role,
    this.metadata,
  });

  factory Institution.fromJson(Map<String, dynamic> json) {
    return Institution(
      id: json['id'] as String,
      nombre: json['nombre'] as String? ?? json['name'] as String? ?? 'InstituciÃ³n sin nombre',
      codigo: json['codigo'] as String? ?? '',
      direccion: json['direccion'] as String?,
      telefono: json['telefono'] as String?,
      email: json['email'] as String?,
      activa: json['activa'] as bool? ?? true,
      createdAt: json['createdAt'] != null ? DateTime.parse(json['createdAt']) : null,
      updatedAt: json['updatedAt'] != null ? DateTime.parse(json['updatedAt']) : null,
      role: json['rolEnInstitucion'] as String? ?? json['role'] as String?,
      metadata: json['metadata'] as Map<String, dynamic>?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'nombre': nombre,
      'codigo': codigo,
      if (direccion != null) 'direccion': direccion,
      if (telefono != null) 'telefono': telefono,
      if (email != null) 'email': email,
      'activa': activa,
      if (createdAt != null) 'createdAt': createdAt!.toIso8601String(),
      if (updatedAt != null) 'updatedAt': updatedAt!.toIso8601String(),
      if (role != null) 'role': role,
      if (role != null) 'rolEnInstitucion': role,
      if (metadata != null) 'metadata': metadata,
    };
  }
  String get name => nombre;

  Institution copyWith({
    String? id,
    String? nombre,
    String? codigo,
    String? direccion,
    String? telefono,
    String? email,
    bool? activa,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? role,
    Map<String, dynamic>? metadata,
  }) {
    return Institution(
      id: id ?? this.id,
      nombre: nombre ?? this.nombre,
      codigo: codigo ?? this.codigo,
      direccion: direccion ?? this.direccion,
      telefono: telefono ?? this.telefono,
      email: email ?? this.email,
      activa: activa ?? this.activa,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      role: role ?? this.role,
      metadata: metadata ?? this.metadata,
    );
  }

  @override
  String toString() {
    return 'Institution(id: $id, nombre: $nombre, codigo: $codigo, activa: $activa)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Institution && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;
}
/* Fin models\institution.dart */

/* Inicio providers\auth_provider.dart */
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../services/auth_service.dart';
import '../models/institution.dart';

class AuthProvider with ChangeNotifier {
  final AuthService _authService = AuthService();

  String? _accessToken;
  String? _refreshToken;
  Map<String, dynamic>? _user;
  String? _selectedInstitutionId;
  List<Institution>? _institutions;

  String? get accessToken => _accessToken;
  String? get refreshToken => _refreshToken;
  Map<String, dynamic>? get user => _user;
  String? get selectedInstitutionId => _selectedInstitutionId;
  List<Institution>? get institutions => _institutions;

  bool get isAuthenticated => _accessToken != null && _user != null;

  Institution? get selectedInstitution {
    if (_selectedInstitutionId == null || _institutions == null) return null;
    try {
      return _institutions!.firstWhere(
        (institution) => institution.id == _selectedInstitutionId,
      );
    } catch (e) {
      return null;
    }
  }

  AuthProvider() {
    _loadTokensFromStorage();
  }

  Future<void> _loadTokensFromStorage() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      _accessToken = prefs.getString('accessToken');
      _refreshToken = prefs.getString('refreshToken');
      final userJson = prefs.getString('user');
      if (userJson != null) {
        _user = Map<String, dynamic>.from(jsonDecode(userJson));
      }
      _selectedInstitutionId = prefs.getString('selectedInstitutionId');
      notifyListeners();
    } catch (e) {
      debugPrint('Error loading from storage: $e');
    }
  }

  Future<void> _saveTokensToStorage() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      if (_accessToken != null) {
        await prefs.setString('accessToken', _accessToken!);
      } else {
        await prefs.remove('accessToken');
      }
      if (_refreshToken != null) {
        await prefs.setString('refreshToken', _refreshToken!);
      } else {
        await prefs.remove('refreshToken');
      }
      if (_user != null) {
        await prefs.setString('user', jsonEncode(_user));
      } else {
        await prefs.remove('user');
      }
      if (_selectedInstitutionId != null) {
        await prefs.setString('selectedInstitutionId', _selectedInstitutionId!);
      } else {
        await prefs.remove('selectedInstitutionId');
      }
    } catch (e) {
      debugPrint('Error saving to storage: $e');
    }
  }

  Future<void> _clearTokens() async {
    _accessToken = null;
    _refreshToken = null;
    _user = null;
    _selectedInstitutionId = null;
    await _saveTokensToStorage();
    notifyListeners();
  }

  void clearHeavyData() {
    _institutions = null;
    notifyListeners();
  }

  void clearTemporaryData() {
    _institutions = null;
    _selectedInstitutionId = null;
    notifyListeners();
  }

  Future<void> recoverFullState() async {
    if (_accessToken != null) {
      debugPrint('Recuperando estado completo del usuario');
      await loadUserInstitutions();

      if (_selectedInstitutionId != null && _institutions != null) {
        final institutionExists = _institutions!.any((i) => i.id == _selectedInstitutionId);
        if (!institutionExists) {
          debugPrint('InstituciÃ³n guardada ya no existe, limpiando');
          _selectedInstitutionId = null;
          await _saveTokensToStorage();
        }
      }

      notifyListeners();
    }
  }

  Future<void> loadUserInstitutions({bool notify = true}) async {
    if (_accessToken == null) return;

    try {
      final institutionMaps = await _authService.getUserInstitutions(_accessToken!);
      _institutions = institutionMaps?.map((map) => Institution.fromJson(map)).toList();
      if (notify) notifyListeners();
    } catch (e) {
      debugPrint('Error loading user institutions: $e');
    }
  }

  void selectInstitution(String institutionId) {
    _selectedInstitutionId = institutionId;
    _saveTokensToStorage();
    notifyListeners();
  }

  Future<bool> login(String email, String password) async {
    try {
      final result = await _authService.login(email, password);
      if (result != null) {
        _accessToken = result.accessToken;
        _refreshToken = result.refreshToken;
        _user = result.user;

        await loadUserInstitutions(notify: false);

        if (_institutions != null && _institutions!.length == 1) {
          _selectedInstitutionId = _institutions!.first.id;
          debugPrint('InstituciÃ³n seleccionada automÃ¡ticamente: $_selectedInstitutionId');
        } else if (_institutions != null && _institutions!.length > 1) {

          _selectedInstitutionId = null;
          debugPrint('MÃºltiples instituciones encontradas, esperando selecciÃ³n manual');
        }

        await _saveTokensToStorage();
        notifyListeners();
        return true;
      }
      return false;
    } catch (e) {
      debugPrint('Login error: $e');
      return false;
    }
  }

  Future<bool> refreshAccessToken() async {
    if (_refreshToken == null) return false;

    try {
      final result = await _authService.refreshToken(_refreshToken!);
      if (result != null) {
        _accessToken = result.accessToken;
        _refreshToken = result.refreshToken;
        await _saveTokensToStorage();
        notifyListeners();
        return true;
      }
      return false;
    } catch (e) {
      debugPrint('Refresh error: $e');
      return false;
    }
  }

  Future<void> logout() async {
    if (_refreshToken != null) {
      await _authService.logout(_refreshToken!);
    }
    await _clearTokens();
  }
}
/* Fin providers\auth_provider.dart */

/* Inicio providers\institution_provider.dart */
import 'dart:async';
import 'package:flutter/foundation.dart';
import '../services/institution_service.dart';
import '../models/institution.dart';

enum InstitutionState {
  initial,
  loading,
  loaded,
  error,
}

class InstitutionProvider with ChangeNotifier {
  final InstitutionService _institutionService = InstitutionService();

  InstitutionState _state = InstitutionState.initial;
  String? _errorMessage;
  List<Institution> _institutions = [];
  Institution? _selectedInstitution;
  InstitutionState get state => _state;
  String? get errorMessage => _errorMessage;
  List<Institution> get institutions => _institutions;
  Institution? get selectedInstitution => _selectedInstitution;

  bool get isLoading => _state == InstitutionState.loading;
  bool get hasError => _state == InstitutionState.error;
  bool get isLoaded => _state == InstitutionState.loaded;
  List<Institution> get activeInstitutions =>
      _institutions.where((inst) => inst.activa).toList();

  List<Institution> get inactiveInstitutions =>
      _institutions.where((inst) => !inst.activa).toList();

  int get totalInstitutions => _institutions.length;
  int get activeInstitutionsCount => activeInstitutions.length;
  int get inactiveInstitutionsCount => inactiveInstitutions.length;

  void _setState(InstitutionState newState, [String? error]) {
    _state = newState;
    _errorMessage = error;
    notifyListeners();
  }
  Future<void> loadInstitutions(String accessToken) async {
    if (_state == InstitutionState.loading) return;

    _setState(InstitutionState.loading);

    try {
      debugPrint('InstitutionProvider: Iniciando carga de instituciones...');
      final institutions = await _institutionService.getAllInstitutions(accessToken);
      debugPrint('InstitutionProvider: Recibidas ${institutions.length} instituciones');
      _institutions = institutions;
      _setState(InstitutionState.loaded);
      debugPrint('InstitutionProvider: Estado cambiado a loaded');
    } catch (e) {
      debugPrint('InstitutionProvider: Error loading institutions: $e');
      _setState(InstitutionState.error, e.toString());
    }
  }
  Future<void> loadInstitutionById(String accessToken, String id) async {
    _setState(InstitutionState.loading);

    try {
      final institution = await _institutionService.getInstitutionById(accessToken, id);
      _selectedInstitution = institution;
      _setState(InstitutionState.loaded);
    } catch (e) {
      debugPrint('Error loading institution: $e');
      _setState(InstitutionState.error, e.toString());
    }
  }
  Future<bool> createInstitution(
    String accessToken,
    Map<String, dynamic> institutionData,
  ) async {
    _setState(InstitutionState.loading);

    try {
      final newInstitution = await _institutionService.createInstitution(
        accessToken,
        nombre: institutionData['nombre'],
        codigo: institutionData['codigo'],
        direccion: institutionData['direccion'],
        telefono: institutionData['telefono'],
        email: institutionData['email'],
      );
      _institutions.insert(0, newInstitution);
      _setState(InstitutionState.loaded);
      return true;
    } catch (e) {
      debugPrint('Error creating institution: $e');
      _setState(InstitutionState.error, e.toString());
      return false;
    }
  }
  Future<bool> updateInstitution(
    String accessToken,
    String id, {
    String? nombre,
    String? codigo,
    String? direccion,
    String? telefono,
    String? email,
    bool? activa,
  }) async {
    _setState(InstitutionState.loading);

    try {
      final updatedInstitution = await _institutionService.updateInstitution(
        accessToken,
        id,
        nombre: nombre,
        codigo: codigo,
        direccion: direccion,
        telefono: telefono,
        email: email,
        activa: activa,
      );
      final index = _institutions.indexWhere((inst) => inst.id == id);
      if (index != -1) {
        _institutions[index] = updatedInstitution;
      }
      if (_selectedInstitution?.id == id) {
        _selectedInstitution = updatedInstitution;
      }

      _setState(InstitutionState.loaded);
      return true;
    } catch (e) {
      debugPrint('Error updating institution: $e');
      _setState(InstitutionState.error, e.toString());
      return false;
    }
  }
  Future<bool> deleteInstitution(String accessToken, String id) async {
    _setState(InstitutionState.loading);

    try {
      await _institutionService.deleteInstitution(accessToken, id);
      _institutions.removeWhere((inst) => inst.id == id);
      if (_selectedInstitution?.id == id) {
        _selectedInstitution = null;
      }

      _setState(InstitutionState.loaded);
      return true;
    } catch (e) {
      debugPrint('Error deleting institution: $e');
      _setState(InstitutionState.error, e.toString());
      return false;
    }
  }
  void selectInstitution(Institution institution) {
    _selectedInstitution = institution;
    notifyListeners();
  }
  void clearSelectedInstitution() {
    _selectedInstitution = null;
    notifyListeners();
  }
  void clearData() {
    _institutions = [];
    _selectedInstitution = null;
    _setState(InstitutionState.initial);
  }
  Future<void> refreshData(String accessToken) async {
    await loadInstitutions(accessToken);
  }
  List<Institution> searchInstitutions(String query) {
    if (query.isEmpty) return _institutions;

    final lowercaseQuery = query.toLowerCase();
    return _institutions.where((inst) {
      return inst.nombre.toLowerCase().contains(lowercaseQuery) ||
             inst.codigo.toLowerCase().contains(lowercaseQuery) ||
             (inst.email?.toLowerCase().contains(lowercaseQuery) ?? false);
    }).toList();
  }
  List<Institution> filterInstitutions({bool? active}) {
    if (active == null) return _institutions;
    return _institutions.where((inst) => inst.activa == active).toList();
  }
}
/* Fin providers\institution_provider.dart */

/* Inicio providers\navigation_state_provider.dart */
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';
class NavigationStateProvider with ChangeNotifier {
  String? _currentRoute;
  Map<String, dynamic>? _routeArguments;
  DateTime? _lastStateUpdate;
  static const int maxStateAgeMinutes = 30;

  String? get currentRoute => _currentRoute;
  Map<String, dynamic>? get routeArguments => _routeArguments;
  DateTime? get lastStateUpdate => _lastStateUpdate;

  NavigationStateProvider() {
    _loadNavigationState();
  }
  Future<void> _loadNavigationState() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final stateJson = prefs.getString('navigationState');

      if (stateJson != null) {
        final state = jsonDecode(stateJson) as Map<String, dynamic>;
        final lastUpdate = DateTime.parse(state['lastStateUpdate'] as String);
        final now = DateTime.now();
        final difference = now.difference(lastUpdate).inMinutes;

        if (difference <= maxStateAgeMinutes) {
          _currentRoute = state['currentRoute'] as String?;
          _routeArguments = state['routeArguments'] as Map<String, dynamic>?;
          _lastStateUpdate = lastUpdate;
          debugPrint('Estado de navegaciÃ³n recuperado: $_currentRoute (hace $difference minutos)');
        } else {
          debugPrint('Estado de navegaciÃ³n obsoleto (hace $difference minutos), descartando');
          await clearNavigationState();
        }
      }

      notifyListeners();
    } catch (e) {
      debugPrint('Error loading navigation state: $e');
    }
  }
  Future<void> saveNavigationState(String route, {Map<String, dynamic>? arguments}) async {
    try {
      _currentRoute = route;
      _routeArguments = arguments;
      _lastStateUpdate = DateTime.now();

      final prefs = await SharedPreferences.getInstance();
      final state = {
        'currentRoute': _currentRoute,
        'routeArguments': _routeArguments,
        'lastStateUpdate': _lastStateUpdate!.toIso8601String(),
      };

      await prefs.setString('navigationState', jsonEncode(state));
      debugPrint('Estado de navegaciÃ³n guardado: $_currentRoute');
      notifyListeners();
    } catch (e) {
      debugPrint('Error saving navigation state: $e');
    }
  }
  Future<void> clearNavigationState() async {
    try {
      _currentRoute = null;
      _routeArguments = null;
      _lastStateUpdate = null;

      final prefs = await SharedPreferences.getInstance();
      await prefs.remove('navigationState');

      debugPrint('Estado de navegaciÃ³n limpiado');
      notifyListeners();
    } catch (e) {
      debugPrint('Error clearing navigation state: $e');
    }
  }
  bool hasValidState() {
    if (_lastStateUpdate == null || _currentRoute == null) return false;

    final difference = DateTime.now().difference(_lastStateUpdate!).inMinutes;
    return difference <= maxStateAgeMinutes;
  }
  Future<void> refreshStateTimestamp() async {
    if (_currentRoute != null) {
      await saveNavigationState(_currentRoute!, arguments: _routeArguments);
    }
  }
}

/* Fin providers\navigation_state_provider.dart */

/* Inicio providers\scroll_state_provider.dart */
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';
class ScrollStateProvider with ChangeNotifier {
  final Map<String, double> _scrollPositions = {};
  static const String _storageKey = 'scrollPositions';

  ScrollStateProvider() {
    _loadScrollPositions();
  }
  double getScrollPosition(String route) {
    return _scrollPositions[route] ?? 0.0;
  }
  Future<void> saveScrollPosition(String route, double position) async {
    _scrollPositions[route] = position;
    await _persistScrollPositions();
    notifyListeners();
  }
  Future<void> clearScrollPosition(String route) async {
    _scrollPositions.remove(route);
    await _persistScrollPositions();
    notifyListeners();
  }
  Future<void> clearAllScrollPositions() async {
    _scrollPositions.clear();
    await _persistScrollPositions();
    notifyListeners();
  }
  Future<void> _loadScrollPositions() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final positionsJson = prefs.getString(_storageKey);

      if (positionsJson != null) {
        final positions = jsonDecode(positionsJson) as Map<String, dynamic>;
        _scrollPositions.clear();
        positions.forEach((key, value) {
          _scrollPositions[key] = (value as num).toDouble();
        });
        debugPrint('Posiciones de scroll cargadas: ${_scrollPositions.length} rutas');
      }
    } catch (e) {
      debugPrint('Error loading scroll positions: $e');
    }
  }
  Future<void> _persistScrollPositions() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString(_storageKey, jsonEncode(_scrollPositions));
    } catch (e) {
      debugPrint('Error persisting scroll positions: $e');
    }
  }
}

/* Fin providers\scroll_state_provider.dart */

/* Inicio providers\user_provider.dart */

/* Fin providers\user_provider.dart */

/* Inicio screens\admin_dashboard.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../utils/responsive_utils.dart';
import '../utils/app_routes.dart';
import '../widgets/dashboard_widgets.dart';

class AdminDashboard extends StatelessWidget {
  const AdminDashboard({super.key});

  Widget _buildUserGreeting(String userName, AuthProvider authProvider, Map<String, dynamic> responsive) {
    final selectedInstitution = authProvider.selectedInstitution;

    return UserGreetingWidget(
      userName: userName,
      responsive: responsive,
      subtitle: selectedInstitution?.name,
    );
  }

  Widget _buildDashboardOptions(BuildContext context, Map<String, dynamic> responsive) {
    final colors = context.colors;

    final cards = [
      DashboardFeatureCard(
        icon: Icons.people,
        title: 'Usuarios',
        description: 'Gestionar profesores y estudiantes',
        color: colors.featureUsers,
        responsive: responsive,
      ),
      DashboardFeatureCard(
        icon: Icons.class_,
        title: 'Grupos',
        description: 'Administrar salones de clase',
        color: colors.featureClasses,
        responsive: responsive,
      ),
      DashboardFeatureCard(
        icon: Icons.schedule,
        title: 'Horarios',
        description: 'Configurar horarios de clases',
        color: colors.featureSchedule,
        responsive: responsive,
      ),
      DashboardFeatureCard(
        icon: Icons.assignment,
        title: 'Asistencia',
        description: 'Control y registro de asistencia',
        color: colors.featureAttendance,
        responsive: responsive,
      ),
      DashboardFeatureCard(
        icon: Icons.bar_chart,
        title: 'Reportes',
        description: 'EstadÃ­sticas de la instituciÃ³n',
        color: colors.featureReports,
        responsive: responsive,
      ),
      DashboardFeatureCard(
        icon: Icons.settings,
        title: 'ConfiguraciÃ³n',
        description: 'Ajustes de la instituciÃ³n',
        color: colors.featureSettings,
        responsive: responsive,
      ),
    ];

    return DashboardOptionsGrid(
      cards: cards,
      responsive: responsive,
    );
  }

  PreferredSizeWidget _buildAppBar(BuildContext context, AuthProvider authProvider, Color primaryColor, String userRole) {
    return DashboardAppBar(
      backgroundColor: primaryColor,
      actions: [
        DashboardAppBarActions(
          userRole: userRole,
          roleIcon: Icons.admin_panel_settings,
          onLogout: () async {
            await authProvider.logout();
            if (context.mounted) {
              context.go(AppRoutes.login);
            }
          },
        ),
      ],
    );
  }

  Widget _buildBody(BuildContext context, String userName, AuthProvider authProvider, Map<String, dynamic> responsive) {
    return DashboardBody(
      userGreeting: _buildUserGreeting(userName, authProvider, responsive),
      dashboardOptions: _buildDashboardOptions(context, responsive),
      responsive: responsive,
    );
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final colors = context.colors;

    final user = authProvider.user;
    final userName = user?['nombres'] ?? 'Usuario';
    final userRole = 'Administrador';

    return Scaffold(
      backgroundColor: colors.background,
      appBar: _buildAppBar(context, authProvider, colors.primary, userRole),
      body: LayoutBuilder(
        builder: (ctx, constraints) {
          final responsive = ResponsiveUtils.getResponsiveValues(constraints);
          return _buildBody(context, userName, authProvider, responsive);
        },
      ),
    );
  }
}
/* Fin screens\admin_dashboard.dart */

/* Inicio screens\home_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../ui/widgets/app_button.dart';
import '../utils/responsive_utils.dart';

class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  Widget _buildDashboardTitle(TextStyle displayLarge, bool isSmallScreen) {
    return Text(
      'Dashboard',
      style: displayLarge.copyWith(
        fontSize: isSmallScreen ? 32 : 48,
      ),
      textAlign: TextAlign.center,
    );
  }

  Widget _buildUserInfo(AuthProvider authProvider, TextStyle headlineMedium, Color primary, bool isSmallScreen) {
    final user = authProvider.user;
    final userName = user?['nombres'] ?? user?['email'] ?? 'Usuario';

    return Column(
      children: [
        Text(
          'Bienvenido, $userName',
          style: headlineMedium.copyWith(
            color: primary,
            fontSize: isSmallScreen ? 18 : 24,
          ),
          textAlign: TextAlign.center,
        ),
        const SizedBox(height: 8),
        Text(
          'Rol: ${user?['rol'] ?? 'Sin rol'}',
          style: TextStyle(
            color: primary.withValues(alpha: 0.7),
            fontSize: isSmallScreen ? 14 : 16,
          ),
          textAlign: TextAlign.center,
        ),
      ],
    );
  }

  Widget _buildInstitutionInfo(AuthProvider authProvider, TextStyle bodyLarge, Color textMuted, bool isSmallScreen) {
    final selectedInstitution = authProvider.selectedInstitution;

    if (selectedInstitution == null) {
      return Builder(
        builder: (context) {
          final colors = context.colors;
          return Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: colors.warningBackground,
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: colors.warningBorder),
            ),
            child: Column(
              children: [
                Icon(
                  Icons.business,
                  color: colors.warning,
                  size: isSmallScreen ? 24 : 32,
                ),
                const SizedBox(height: 8),
                Text(
                  'No hay instituciÃ³n seleccionada',
                  style: bodyLarge.copyWith(
                    color: colors.warning,
                    fontWeight: FontWeight.w500,
                  ),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 4),
                Text(
                  'Como super administrador, puedes gestionar todas las instituciones del sistema.',
                  style: TextStyle(
                    color: textMuted,
                    fontSize: isSmallScreen ? 12 : 14,
                  ),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          );
        },
      );
    }

    return Column(
      children: [
        Text(
          'InstituciÃ³n: ${selectedInstitution.name}',
          style: bodyLarge.copyWith(
            fontWeight: FontWeight.bold,
            fontSize: isSmallScreen ? 16 : 18,
          ),
          textAlign: TextAlign.center,
        ),
        const SizedBox(height: 4),
        Text(
          'Rol en instituciÃ³n: ${selectedInstitution.role ?? 'Sin rol'}',
          style: TextStyle(
            color: textMuted,
            fontSize: isSmallScreen ? 14 : 16,
          ),
          textAlign: TextAlign.center,
        ),
      ],
    );
  }

  Widget _buildDashboardOptions(bool isSmallScreen, Color textPrimary, Color textSecondary) {
    return Builder(
      builder: (context) {
        final colors = context.colors;
        return Column(
          children: [
            const SizedBox(height: 32),
            Text(
              'Funcionalidades del Sistema',
              style: TextStyle(
                fontSize: isSmallScreen ? 18 : 22,
                fontWeight: FontWeight.bold,
                color: textPrimary,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 16),
            Wrap(
              spacing: 12,
              runSpacing: 12,
              alignment: WrapAlignment.center,
              children: [
                _buildFeatureCard(
                  icon: Icons.people,
                  title: 'GestiÃ³n de Usuarios',
                  description: 'Administrar usuarios del sistema',
                  isSmallScreen: isSmallScreen,
                  textPrimary: textPrimary,
                  textSecondary: textSecondary,
                ),
                _buildFeatureCard(
                  icon: Icons.business,
                  title: 'Instituciones',
                  description: 'Gestionar instituciones educativas',
                  isSmallScreen: isSmallScreen,
                  textPrimary: textPrimary,
                  textSecondary: textSecondary,
                ),
                _buildFeatureCard(
                  icon: Icons.assignment,
                  title: 'Asistencia',
                  description: 'Registro y control de asistencia',
                  isSmallScreen: isSmallScreen,
                  textPrimary: textPrimary,
                  textSecondary: textSecondary,
                ),
                _buildFeatureCard(
                  icon: Icons.bar_chart,
                  title: 'Reportes',
                  description: 'EstadÃ­sticas y reportes',
                  isSmallScreen: isSmallScreen,
                  textPrimary: textPrimary,
                  textSecondary: textSecondary,
                ),
              ],
            ),
            const SizedBox(height: 24),
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: colors.infoBackground,
                borderRadius: BorderRadius.circular(12),
                border: Border.all(color: colors.infoBorder),
              ),
              child: Column(
                children: [
                  Icon(
                    Icons.info_outline,
                    color: colors.info,
                    size: isSmallScreen ? 24 : 32,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Sistema en Desarrollo',
                    style: TextStyle(
                      color: colors.info,
                      fontWeight: FontWeight.bold,
                      fontSize: isSmallScreen ? 16 : 18,
                    ),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 4),
                  Text(
                    'Las funcionalidades estarÃ¡n disponibles prÃ³ximamente.',
                    style: TextStyle(
                      color: textSecondary,
                      fontSize: isSmallScreen ? 12 : 14,
                    ),
                    textAlign: TextAlign.center,
                  ),
                ],
              ),
            ),
          ],
        );
      },
    );
  }

  Widget _buildFeatureCard({
    required IconData icon,
    required String title,
    required String description,
    required bool isSmallScreen,
    required Color textPrimary,
    required Color textSecondary,
  }) {
    return Builder(
      builder: (context) {
        final colors = context.colors;
        return Container(
          width: isSmallScreen ? 160 : 180,
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: colors.surface,
            borderRadius: BorderRadius.circular(12),
            boxShadow: [
              BoxShadow(
                color: colors.shadow,
                spreadRadius: 1,
                blurRadius: 4,
                offset: const Offset(0, 2),
              ),
            ],
            border: Border.all(color: colors.borderLight),
          ),
          child: Column(
            children: [
              Icon(
                icon,
                size: isSmallScreen ? 32 : 40,
                color: colors.secondary,
              ),
              const SizedBox(height: 8),
              Text(
                title,
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                  fontSize: isSmallScreen ? 14 : 16,
                  color: textPrimary,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 4),
              Text(
                description,
                style: TextStyle(
                  color: textSecondary,
                  fontSize: isSmallScreen ? 10 : 12,
                ),
                textAlign: TextAlign.center,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildSignOutButton(AuthProvider authProvider) {
    return AppButton(
      label: 'Cerrar SesiÃ³n',
      onPressed: () async {
        await authProvider.logout();
      },
    );
  }

  AppBar _buildAppBar(Color primaryColor) {
    return AppBar(
      title: const Text('AsistApp'),
      backgroundColor: primaryColor,
      actions: _buildAppBarActions(),
    );
  }

  List<Widget> _buildAppBarActions() {
    return [
      IconButton(
        icon: const Icon(Icons.logout),
        onPressed: () async {
        },
      ),
    ];
  }

  Widget _buildBody(AuthProvider authProvider, dynamic textStyles, dynamic colors, Map<String, dynamic> responsive) {
    return SafeArea(
      child: SingleChildScrollView(
        child: ConstrainedBox(
          constraints: BoxConstraints(maxWidth: responsive['maxWidth']),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Padding(
                padding: EdgeInsets.symmetric(
                  horizontal: responsive['horizontalPadding'],
                  vertical: responsive['verticalPadding'],
                ),
                child: Column(
                  children: [
                    _buildDashboardTitle(textStyles.displayLarge, responsive['isSmallScreen']),
                    SizedBox(height: responsive['elementSpacing']),

                    _buildUserInfo(authProvider, textStyles.headlineMedium, colors.primary, responsive['isSmallScreen']),
                    SizedBox(height: responsive['elementSpacing']),

                    _buildInstitutionInfo(authProvider, textStyles.bodyLarge, colors.textMuted, responsive['isSmallScreen']),
                    SizedBox(height: responsive['elementSpacing']),

                    _buildDashboardOptions(responsive['isSmallScreen'], colors.textPrimary, colors.textSecondary),

                    SizedBox(height: responsive['elementSpacing'] * 2),

                    _buildSignOutButton(authProvider),

                    SizedBox(height: responsive['verticalPadding']),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final colors = context.colors;
    final textStyles = context.textStyles;

    return Scaffold(
      backgroundColor: colors.background,
      appBar: _buildAppBar(colors.primary),
      body: LayoutBuilder(
        builder: (context, constraints) {
          final responsive = ResponsiveUtils.getResponsiveValues(constraints);
          return _buildBody(authProvider, textStyles, colors, responsive);
        },
      ),
    );
  }
}
/* Fin screens\home_screen.dart */

/* Inicio screens\institutions\institutions_list_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../models/institution.dart';
import '../../providers/auth_provider.dart';
import '../../providers/institution_provider.dart';
import '../../theme/theme_extensions.dart';
import '../../theme/app_colors.dart';
import '../../theme/app_spacing.dart';
import '../../theme/app_text_styles.dart';
import '../../utils/responsive_utils.dart';
import '../../utils/app_routes.dart';
import '../../widgets/dashboard_widgets.dart';
import 'institution_form_screen.dart';

class InstitutionsListScreen extends StatefulWidget {
  const InstitutionsListScreen({super.key});

  @override
  State<InstitutionsListScreen> createState() => _InstitutionsListScreenState();
}

class _InstitutionsListScreenState extends State<InstitutionsListScreen> {
  final TextEditingController _searchController = TextEditingController();
  bool _showActiveOnly = true;
  bool _isSearching = false;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadInstitutions();
    });
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  Future<void> _loadInstitutions() async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);

    if (authProvider.accessToken != null) {
      debugPrint('Cargando instituciones con token: ${authProvider.accessToken!.substring(0, 20)}...');
      await institutionProvider.loadInstitutions(authProvider.accessToken!);
      debugPrint('Instituciones cargadas: ${institutionProvider.institutions.length}');
      debugPrint('Estado del provider: ${institutionProvider.state}');
      if (institutionProvider.hasError) {
        debugPrint('Error del provider: ${institutionProvider.errorMessage}');
      }
    } else {
      debugPrint('No hay token de acceso disponible');
    }
  }

  void _onSearchChanged(String query) {
    setState(() {
      _isSearching = query.isNotEmpty;
    });
  }

  List<Institution> _getFilteredInstitutions(InstitutionProvider provider) {
    List<Institution> institutions;

    if (_isSearching) {
      institutions = provider.searchInstitutions(_searchController.text);
    } else {
      institutions = _showActiveOnly ? provider.activeInstitutions : provider.institutions;
    }

    return institutions;
  }

  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Scaffold(
      backgroundColor: colors.background,
      appBar: DashboardAppBar(
        title: 'GestiÃ³n de Instituciones',
        backgroundColor: colors.primary,
        actions: [
          DashboardAppBarActions(
            userRole: 'Super Admin',
            roleIcon: Icons.verified_user,
            onLogout: () async {
              final authProvider = Provider.of<AuthProvider>(context, listen: false);
              await authProvider.logout();
              if (context.mounted) {
                context.go(AppRoutes.login);
              }
            },
          ),
        ],
      ),
      body: Consumer2<AuthProvider, InstitutionProvider>(
        builder: (context, authProvider, institutionProvider, child) {
          return LayoutBuilder(
            builder: (context, constraints) {
              final responsive = ResponsiveUtils.getResponsiveValues(constraints);
              return DashboardBody(
                userGreeting: UserGreetingWidget(
                  userName: authProvider.user?['nombres'] ?? 'Super Admin',
                  responsive: responsive,
                  subtitle: 'GestiÃ³n de Instituciones del Sistema',
                ),
                dashboardOptions: _buildInstitutionsContent(institutionProvider, responsive, colors, spacing, textStyles),
                responsive: responsive,
              );
            },
          );
        },
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => _navigateToForm(context),
        backgroundColor: colors.primary,
        child: Icon(Icons.add, color: colors.getTextColorForBackground(colors.primary)),
      ),
    );
  }

  Widget _buildInstitutionsContent(InstitutionProvider provider, Map<String, dynamic> responsive, AppColors colors, AppSpacing spacing, AppTextStyles textStyles) {
    if (provider.isLoading && provider.institutions.isEmpty) {
      return const Center(
        child: CircularProgressIndicator(),
      );
    }

    if (provider.hasError) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline, size: 64, color: colors.error),
            SizedBox(height: spacing.lg),
            Text(
              'Error al cargar instituciones',
              style: textStyles.headlineMedium,
              textAlign: TextAlign.center,
            ),
            SizedBox(height: spacing.md),
            Text(
              provider.errorMessage ?? 'Error desconocido',
              style: textStyles.bodyMedium.withColor(colors.textSecondary),
              textAlign: TextAlign.center,
            ),
            SizedBox(height: spacing.lg),
            ElevatedButton(
              onPressed: _loadInstitutions,
              style: ElevatedButton.styleFrom(
                backgroundColor: colors.primary,
                foregroundColor: Theme.of(context).colorScheme.onPrimary, // Color consistente con el tema
                padding: EdgeInsets.symmetric(
                  horizontal: spacing.lg,
                  vertical: spacing.md,
                ),
              ),
              child: Text('Reintentar', style: textStyles.button), // Usar estilo de botÃ³n sin color fijo
            ),
          ],
        ),
      );
    }

    return Column(
      children: [
        _buildSearchAndFilters(provider, colors, spacing, textStyles),
        SizedBox(height: spacing.lg),
        _buildStatisticsCards(provider, colors, spacing, textStyles),
        SizedBox(height: spacing.lg),
        ConstrainedBox(
          constraints: BoxConstraints(
            minHeight: 200, // Altura mÃ­nima
            maxHeight: MediaQuery.of(context).size.height * 0.6, // MÃ¡ximo 60% de la pantalla
          ),
          child: _buildInstitutionsList(provider, colors, spacing, textStyles),
        ),
      ],
    );
  }

  Widget _buildSearchAndFilters(InstitutionProvider provider, AppColors colors, AppSpacing spacing, AppTextStyles textStyles) {
    return Card(
      margin: EdgeInsets.symmetric(horizontal: spacing.lg),
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(spacing.borderRadius),
      ),
      child: Padding(
        padding: EdgeInsets.all(spacing.lg),
        child: Column(
          children: [
            TextField(
              controller: _searchController,
              style: textStyles.bodyLarge,
              decoration: InputDecoration(
                hintText: 'Buscar por nombre, cÃ³digo o email...',
                hintStyle: textStyles.bodyMedium.withColor(colors.textMuted),
                prefixIcon: Icon(Icons.search, color: colors.textSecondary),
                suffixIcon: _isSearching
                    ? IconButton(
                        icon: Icon(Icons.clear, color: colors.textSecondary),
                        onPressed: () {
                          _searchController.clear();
                          _onSearchChanged('');
                        },
                      )
                    : null,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(spacing.borderRadius),
                  borderSide: BorderSide(color: colors.border),
                ),
                enabledBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(spacing.borderRadius),
                  borderSide: BorderSide(color: colors.borderLight),
                ),
                focusedBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(spacing.borderRadius),
                  borderSide: BorderSide(color: colors.primary, width: 2),
                ),
                filled: true,
                fillColor: colors.surface,
              ),
              onChanged: _onSearchChanged,
            ),
            SizedBox(height: spacing.md),
            Row(
              children: [
                Text('Mostrar:', style: textStyles.labelMedium),
                SizedBox(width: spacing.md),
                FilterChip(
                  label: Text('Activas', style: TextStyle(color: _showActiveOnly && !_isSearching ? Colors.white : colors.textPrimary)),
                  selected: _showActiveOnly && !_isSearching,
                  onSelected: !_isSearching ? (selected) {
                    setState(() => _showActiveOnly = selected);
                  } : null,
                  backgroundColor: colors.surface,
                  selectedColor: colors.primary,
                  checkmarkColor: Colors.white,
                ),
                SizedBox(width: spacing.md),
                FilterChip(
                  label: Text('Todas', style: TextStyle(color: !_showActiveOnly && !_isSearching ? Colors.white : colors.textPrimary)),
                  selected: !_showActiveOnly && !_isSearching,
                  onSelected: !_isSearching ? (selected) {
                    setState(() => _showActiveOnly = !selected);
                  } : null,
                  backgroundColor: colors.surface,
                  selectedColor: colors.primary,
                  checkmarkColor: Colors.white,
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildStatisticsCards(InstitutionProvider provider, AppColors colors, AppSpacing spacing, AppTextStyles textStyles) {
    return Row(
      children: [
        Expanded(
          child: _buildStatCard(
            'Total',
            provider.totalInstitutions.toString(),
            Icons.business,
            colors.primary,
            colors,
            spacing,
            textStyles,
          ),
        ),
        Expanded(
          child: _buildStatCard(
            'Activas',
            provider.activeInstitutionsCount.toString(),
            Icons.check_circle,
            colors.success,
            colors,
            spacing,
            textStyles,
          ),
        ),
        Expanded(
          child: _buildStatCard(
            'Inactivas',
            provider.inactiveInstitutionsCount.toString(),
            Icons.cancel,
            colors.error,
            colors,
            spacing,
            textStyles,
          ),
        ),
      ],
    );
  }

  Widget _buildStatCard(String title, String value, IconData icon, Color color, AppColors colors, AppSpacing spacing, AppTextStyles textStyles) {
    final valueTextColor = colors.getTextColorForBackground(color);
    final titleTextColor = colors.getMutedTextColorForBackground(color);

    return Card(
      margin: EdgeInsets.symmetric(horizontal: spacing.xs),
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(spacing.borderRadius),
      ),
      child: Container(
        decoration: BoxDecoration(
          gradient: LinearGradient(
            colors: [color.withValues(alpha: 0.1), color.withValues(alpha: 0.05)],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
          borderRadius: BorderRadius.circular(spacing.borderRadius),
        ),
        child: Padding(
          padding: EdgeInsets.all(spacing.lg),
          child: Column(
            children: [
              Icon(icon, size: 32, color: color),
              SizedBox(height: spacing.md),
              Text(
                value,
                style: textStyles.headlineLarge.withColor(valueTextColor),
              ),
              Text(
                title,
                style: textStyles.labelSmall.withColor(titleTextColor),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildInstitutionsList(InstitutionProvider provider, AppColors colors, AppSpacing spacing, AppTextStyles textStyles) {
    final filteredInstitutions = _getFilteredInstitutions(provider);

    if (filteredInstitutions.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              _isSearching ? Icons.search_off : Icons.business,
              size: 64,
              color: colors.textMuted,
            ),
            SizedBox(height: spacing.lg),
            Text(
              _isSearching
                  ? 'No se encontraron instituciones'
                  : 'No hay instituciones ${_showActiveOnly ? 'activas' : ''}',
              style: textStyles.headlineMedium.withColor(colors.textSecondary),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      );
    }

    return SizedBox(
      height: filteredInstitutions.isEmpty ? 200 : null, // Altura fija si estÃ¡ vacÃ­o, null si tiene contenido
      child: ListView.builder(
        shrinkWrap: filteredInstitutions.isNotEmpty, // Solo shrinkWrap si hay contenido
        physics: filteredInstitutions.isNotEmpty ? const NeverScrollableScrollPhysics() : null,
        padding: EdgeInsets.symmetric(horizontal: spacing.lg),
        itemCount: filteredInstitutions.length,
        itemBuilder: (context, index) {
          final institution = filteredInstitutions[index];
          return _buildInstitutionCard(institution, provider, colors, spacing, textStyles);
        },
      ),
    );
  }

  Widget _buildInstitutionCard(Institution institution, InstitutionProvider provider, AppColors colors, AppSpacing spacing, AppTextStyles textStyles) {
    return Card(
      margin: EdgeInsets.only(bottom: spacing.xs),
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(spacing.borderRadius),
      ),
      child: ListTile(
        leading: CircleAvatar(
          backgroundColor: institution.activa ? colors.success : colors.error,
          child: Icon(
            institution.activa ? Icons.check : Icons.close,
            color: colors.surface,
          ),
        ),
        title: Text(
          institution.nombre,
          style: textStyles.titleMedium.bold,
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('CÃ³digo: ${institution.codigo}', style: textStyles.bodySmall),
            if (institution.email != null) Text('Email: ${institution.email}', style: textStyles.bodySmall),
            if (institution.telefono != null) Text('TelÃ©fono: ${institution.telefono}', style: textStyles.bodySmall),
          ],
        ),
        trailing: PopupMenuButton<String>(
          onSelected: (value) => _handleMenuAction(value, institution, provider),
          itemBuilder: (context) => [
            PopupMenuItem(
              value: 'edit',
              child: Row(
                children: [
                  Icon(Icons.edit, color: colors.textSecondary),
                  SizedBox(width: spacing.sm),
                  Text('Editar', style: textStyles.bodyMedium),
                ],
              ),
            ),
            PopupMenuItem(
              value: 'toggle_status',
              child: Row(
                children: [
                  Icon(Icons.toggle_on, color: colors.textSecondary),
                  SizedBox(width: spacing.sm),
                  Text('Cambiar Estado', style: textStyles.bodyMedium),
                ],
              ),
            ),
            PopupMenuItem(
              value: 'delete',
              child: Row(
                children: [
                  Icon(Icons.delete, color: colors.error),
                  SizedBox(width: spacing.sm),
                  Text('Eliminar', style: textStyles.bodyMedium.withColor(colors.error)),
                ],
              ),
            ),
          ],
        ),
        onTap: () => _navigateToForm(context, institution: institution),
      ),
    );
  }

  void _handleMenuAction(String action, Institution institution, InstitutionProvider provider) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    switch (action) {
      case 'edit':
        _navigateToForm(context, institution: institution);
        break;

      case 'toggle_status':
        final newStatus = !institution.activa;
        final success = await provider.updateInstitution(
          authProvider.accessToken!,
          institution.id,
          activa: newStatus,
        );

        if (success && mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                'InstituciÃ³n ${newStatus ? 'activada' : 'desactivada'} correctamente',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onPrimary),
              ),
              backgroundColor: Theme.of(context).colorScheme.primary,
            ),
          );
        }
        break;

      case 'delete':
        _showDeleteConfirmationDialog(institution, provider);
        break;
    }
  }

  void _showDeleteConfirmationDialog(Institution institution, InstitutionProvider provider) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Eliminar InstituciÃ³n', style: Theme.of(context).textTheme.headlineSmall),
        content: Text(
          'Â¿EstÃ¡s seguro de que quieres eliminar "${institution.nombre}"?\n\n'
          'Esta acciÃ³n no se puede deshacer.',
          style: Theme.of(context).textTheme.bodyMedium,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: Text('Cancelar', style: Theme.of(context).textTheme.labelLarge),
          ),
          TextButton(
            onPressed: () async {
              Navigator.of(context).pop();
              await _deleteInstitution(institution, provider);
            },
            style: TextButton.styleFrom(foregroundColor: Theme.of(context).colorScheme.error),
            child: Text('Eliminar', style: Theme.of(context).textTheme.labelLarge?.copyWith(color: Theme.of(context).colorScheme.error)),
          ),
        ],
      ),
    );
  }

  Future<void> _deleteInstitution(Institution institution, InstitutionProvider provider) async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    final success = await provider.deleteInstitution(
      authProvider.accessToken!,
      institution.id,
    );

    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            'InstituciÃ³n eliminada correctamente',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onPrimary),
          ),
          backgroundColor: Theme.of(context).colorScheme.primary,
        ),
      );
    }
  }

  void _navigateToForm(BuildContext context, {Institution? institution}) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => InstitutionFormScreen(institution: institution),
      ),
    );
  }
}
/* Fin screens\institutions\institutions_list_screen.dart */

/* Inicio screens\institutions\institution_form_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../../models/institution.dart';
import '../../providers/auth_provider.dart';
import '../../providers/institution_provider.dart';
import '../../theme/theme_extensions.dart';
import '../../theme/app_colors.dart';
import '../../theme/app_spacing.dart';
import '../../theme/app_text_styles.dart';
import '../../utils/app_routes.dart';
import '../../widgets/dashboard_widgets.dart';

class InstitutionFormScreen extends StatefulWidget {
  final Institution? institution;

  const InstitutionFormScreen({super.key, this.institution});

  @override
  State<InstitutionFormScreen> createState() => _InstitutionFormScreenState();
}

class _InstitutionFormScreenState extends State<InstitutionFormScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nombreController = TextEditingController();
  final _codigoController = TextEditingController();
  final _direccionController = TextEditingController();
  final _telefonoController = TextEditingController();
  final _emailController = TextEditingController();

  bool _activa = true;
  bool _isLoading = false;

  bool get isEditing => widget.institution != null;

  @override
  void initState() {
    super.initState();
    if (widget.institution != null) {
      _loadInstitutionData();
    }
  }

  @override
  void dispose() {
    _nombreController.dispose();
    _codigoController.dispose();
    _direccionController.dispose();
    _telefonoController.dispose();
    _emailController.dispose();
    super.dispose();
  }

  void _loadInstitutionData() {
    final institution = widget.institution!;
    _nombreController.text = institution.nombre;
    _codigoController.text = institution.codigo;
    _direccionController.text = institution.direccion ?? '';
    _telefonoController.text = institution.telefono ?? '';
    _emailController.text = institution.email ?? '';
    _activa = institution.activa;
  }

  Future<void> _saveInstitution() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final institutionProvider = Provider.of<InstitutionProvider>(context, listen: false);

      final institutionData = {
        'nombre': _nombreController.text.trim(),
        'codigo': _codigoController.text.trim(),
        'direccion': _direccionController.text.trim(),
        'telefono': _telefonoController.text.trim(),
        'email': _emailController.text.trim(),
        'activa': _activa,
      };

      bool success;
      if (widget.institution == null) {
        success = await institutionProvider.createInstitution(
          authProvider.accessToken!,
          institutionData,
        );
      } else {
        success = await institutionProvider.updateInstitution(
          authProvider.accessToken!,
          widget.institution!.id,
          nombre: institutionData['nombre'] as String?,
          codigo: institutionData['codigo'] as String?,
          direccion: institutionData['direccion'] as String?,
          telefono: institutionData['telefono'] as String?,
          email: institutionData['email'] as String?,
          activa: institutionData['activa'] as bool?,
        );
      }

      if (success && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              widget.institution == null
                  ? 'InstituciÃ³n creada correctamente'
                  : 'InstituciÃ³n actualizada correctamente',
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onPrimary),
            ),
            backgroundColor: Theme.of(context).colorScheme.primary,
          ),
        );
        Navigator.of(context).pop();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              'Error: ${e.toString()}',
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: Theme.of(context).colorScheme.onError),
            ),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    return Scaffold(
      backgroundColor: colors.background,
      appBar: DashboardAppBar(
        title: isEditing ? 'Editar InstituciÃ³n' : 'Nueva InstituciÃ³n',
        backgroundColor: colors.primary,
        actions: [
          DashboardAppBarActions(
            userRole: 'Super Admin',
            roleIcon: Icons.verified_user,
            onLogout: () async {
              final authProvider = Provider.of<AuthProvider>(context, listen: false);
              await authProvider.logout();
              if (context.mounted) {
                context.go(AppRoutes.login);
              }
            },
          ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : SingleChildScrollView(
              padding: EdgeInsets.all(spacing.lg),
              child: Form(
                key: _formKey,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    _buildFormCard(colors, spacing, textStyles),
                    SizedBox(height: spacing.xl),
                    _buildActionButtons(colors, spacing, textStyles),
                  ],
                ),
              ),
            ),
    );
  }

  Widget _buildFormCard(AppColors colors, AppSpacing spacing, AppTextStyles textStyles) {
    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(spacing.borderRadius),
      ),
      child: Padding(
        padding: EdgeInsets.all(spacing.lg),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'InformaciÃ³n de la InstituciÃ³n',
              style: textStyles.headlineMedium.withColor(colors.primary),
            ),
            SizedBox(height: spacing.lg),
            _buildTextField(
              controller: _nombreController,
              label: 'Nombre de la InstituciÃ³n',
              hint: 'Ingrese el nombre completo',
              validator: (value) {
                if (value == null || value.trim().isEmpty) {
                  return 'El nombre es obligatorio';
                }
                if (value.trim().length < 3) {
                  return 'El nombre debe tener al menos 3 caracteres';
                }
                return null;
              },
              prefixIcon: Icons.business,
              colors: colors,
              spacing: spacing,
              textStyles: textStyles,
            ),
            SizedBox(height: spacing.lg),
            _buildTextField(
              controller: _codigoController,
              label: 'CÃ³digo',
              hint: 'CÃ³digo Ãºnico de la instituciÃ³n',
              validator: (value) {
                if (value == null || value.trim().isEmpty) {
                  return 'El cÃ³digo es obligatorio';
                }
                if (value.trim().length < 2) {
                  return 'El cÃ³digo debe tener al menos 2 caracteres';
                }
                return null;
              },
              prefixIcon: Icons.tag,
              colors: colors,
              spacing: spacing,
              textStyles: textStyles,
            ),
            SizedBox(height: spacing.lg),
            _buildTextField(
              controller: _direccionController,
              label: 'DirecciÃ³n',
              hint: 'DirecciÃ³n completa de la instituciÃ³n',
              maxLines: 3,
              prefixIcon: Icons.location_on,
              colors: colors,
              spacing: spacing,
              textStyles: textStyles,
            ),
            SizedBox(height: spacing.lg),
            _buildTextField(
              controller: _telefonoController,
              label: 'TelÃ©fono',
              hint: '+56912345678',
              keyboardType: TextInputType.phone,
              prefixIcon: Icons.phone,
              colors: colors,
              spacing: spacing,
              textStyles: textStyles,
            ),
            SizedBox(height: spacing.lg),
            _buildTextField(
              controller: _emailController,
              label: 'Email',
              hint: 'contacto@institucion.cl',
              keyboardType: TextInputType.emailAddress,
              validator: (value) {
                if (value != null && value.isNotEmpty) {
                  final emailRegex = RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$');
                  if (!emailRegex.hasMatch(value)) {
                    return 'Ingrese un email vÃ¡lido';
                  }
                }
                return null;
              },
              prefixIcon: Icons.email,
              colors: colors,
              spacing: spacing,
              textStyles: textStyles,
            ),
            SizedBox(height: spacing.lg),
            SwitchListTile(
              title: Text('InstituciÃ³n Activa', style: textStyles.titleMedium),
              subtitle: Text('Determina si la instituciÃ³n estÃ¡ operativa', style: textStyles.bodySmall),
              value: _activa,
              onChanged: (value) => setState(() => _activa = value),
              activeColor: colors.primary,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTextField({
    required TextEditingController controller,
    required String label,
    required String hint,
    String? Function(String?)? validator,
    TextInputType? keyboardType,
    int maxLines = 1,
    IconData? prefixIcon,
    required AppColors colors,
    required AppSpacing spacing,
    required AppTextStyles textStyles,
  }) {
    return TextFormField(
      controller: controller,
      style: textStyles.bodyLarge,
      decoration: InputDecoration(
        labelText: label,
        hintText: hint,
        labelStyle: textStyles.bodyMedium.withColor(colors.textSecondary),
        hintStyle: textStyles.bodyMedium.withColor(colors.textMuted),
        prefixIcon: prefixIcon != null ? Icon(prefixIcon, color: colors.textSecondary) : null,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(spacing.borderRadius),
          borderSide: BorderSide(color: colors.border),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(spacing.borderRadius),
          borderSide: BorderSide(color: colors.borderLight),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(spacing.borderRadius),
          borderSide: BorderSide(color: colors.primary, width: 2),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(spacing.borderRadius),
          borderSide: BorderSide(color: colors.error),
        ),
        focusedErrorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(spacing.borderRadius),
          borderSide: BorderSide(color: colors.error, width: 2),
        ),
        filled: true,
        fillColor: colors.surface,
      ),
      validator: validator,
      keyboardType: keyboardType,
      maxLines: maxLines,
    );
  }

  Widget _buildActionButtons(AppColors colors, AppSpacing spacing, AppTextStyles textStyles) {
    return Row(
      children: [
        Expanded(
          child: OutlinedButton(
            onPressed: _isLoading ? null : () => Navigator.of(context).pop(),
            style: OutlinedButton.styleFrom(
              padding: EdgeInsets.symmetric(vertical: spacing.lg),
              side: BorderSide(color: colors.primary),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(spacing.borderRadius),
              ),
            ),
            child: Text('Cancelar', style: textStyles.labelLarge.withColor(colors.primary)),
          ),
        ),
        SizedBox(width: spacing.lg),
        Expanded(
          child: ElevatedButton(
            onPressed: _isLoading ? null : _saveInstitution,
            style: ElevatedButton.styleFrom(
              padding: EdgeInsets.symmetric(vertical: spacing.lg),
              backgroundColor: colors.primary,

              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(spacing.borderRadius),
              ),
            ),
            child: Text(isEditing ? 'Actualizar' : 'Crear', style: textStyles.button),
          ),
        ),
      ],
    );
  }
}
/* Fin screens\institutions\institution_form_screen.dart */

/* Inicio screens\institution_selection_screen.dart */
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../utils/app_routes.dart';
import '../utils/responsive_utils.dart';
import '../models/institution.dart';

class InstitutionSelectionScreen extends StatefulWidget {
  const InstitutionSelectionScreen({super.key});

  @override
  State<InstitutionSelectionScreen> createState() => _InstitutionSelectionScreenState();
}

class _InstitutionSelectionScreenState extends State<InstitutionSelectionScreen> {
  String? _selectedInstitutionId;
  bool _isLoading = false;

  Map<String, dynamic> _getResponsiveValues(BoxConstraints constraints) {
    return ResponsiveUtils.getResponsiveValues(constraints);
  }

  Widget _buildMainTitle(Map<String, dynamic> responsive) {
    final titleFontSize = responsive['titleFontSize'] as double;

    return Builder(
      builder: (context) {
        final colors = context.colors;
        return Text(
          'Seleccionar InstituciÃ³n',
          style: TextStyle(
            fontSize: titleFontSize,
            fontWeight: FontWeight.bold,
            color: colors.textPrimary,
          ),
          textAlign: TextAlign.center,
        );
      },
    );
  }

  Widget _buildSubtitle(Map<String, dynamic> responsive, Color textMuted) {
    final subtitleFontSize = responsive['subtitleFontSize'] as double;

    return Text(
      'Elija la instituciÃ³n con la que desea trabajar',
      style: TextStyle(
        color: textMuted,
        fontSize: subtitleFontSize,
      ),
      textAlign: TextAlign.center,
    );
  }

  Widget _buildInstitutionList(List<Institution> institutions, Map<String, dynamic> responsive) {
    final bodyFontSize = responsive['bodyFontSize'] as double;

    return ListView.builder(
      shrinkWrap: true,
      itemCount: institutions.length,
      itemBuilder: (context, index) {
        final institution = institutions[index];
        final isSelected = _selectedInstitutionId == institution.id;

        return Card(
          margin: const EdgeInsets.symmetric(vertical: 8),
          color: isSelected ? Theme.of(context).colorScheme.primaryContainer : Theme.of(context).colorScheme.surface,
          child: ListTile(
            leading: Radio<String>(
              value: institution.id,
              groupValue: _selectedInstitutionId,
              onChanged: (value) {
                setState(() {
                  _selectedInstitutionId = value;
                });
              },
            ),
            title: Text(
              institution.name,
              style: TextStyle(
                fontSize: bodyFontSize,
                color: isSelected ? Theme.of(context).colorScheme.onPrimaryContainer : Theme.of(context).colorScheme.onSurface,
              ),
            ),
            subtitle: institution.role != null
                ? Text('Rol: ${institution.role}', style: TextStyle(fontSize: bodyFontSize * 0.9))
                : null,
            onTap: () {
              setState(() {
                _selectedInstitutionId = institution.id;
              });
            },
          ),
        );
      },
    );
  }

  Widget _buildContinueButton(Map<String, dynamic> responsive) {
    final buttonWidth = responsive['buttonWidth'] as double;

    return SizedBox(
      width: buttonWidth,
      child: ElevatedButton(
        onPressed: _isLoading || _selectedInstitutionId == null ? null : _continue,
        child: Text(_isLoading ? 'Continuando...' : 'Continuar'),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final authProvider = Provider.of<AuthProvider>(context);
    final institutions = authProvider.institutions;

    if (institutions == null || institutions.isEmpty) {
      return const Scaffold(
        body: Center(
          child: Text('No hay instituciones disponibles'),
        ),
      );
    }

    return Scaffold(
      backgroundColor: colors.background,
      body: SafeArea(
        child: ResponsiveUtils.buildResponsiveContainer(
          context: context,
          child: SingleChildScrollView(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                LayoutBuilder(
                  builder: (context, constraints) {
                    final responsive = _getResponsiveValues(constraints);
                    final elementSpacing = responsive['elementSpacing'] as double;

                    return Column(
                      children: [
                        _buildMainTitle(responsive),
                        SizedBox(height: elementSpacing),

                        _buildSubtitle(responsive, colors.textMuted),
                        SizedBox(height: elementSpacing * 1.5),

                        _buildInstitutionList(institutions, responsive),
                        SizedBox(height: elementSpacing * 2),

                        _buildContinueButton(responsive),
                      ],
                    );
                  },
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _continue() async {
    if (_selectedInstitutionId == null) return;

    setState(() {
      _isLoading = true;
    });

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      authProvider.selectInstitution(_selectedInstitutionId!);

      if (mounted) {
        final authProvider = Provider.of<AuthProvider>(context, listen: false);
        final user = authProvider.user;
        final userRole = user?['rol'] as String?;

        final route = AppRoutes.getDashboardRouteForRole(userRole ?? '');
        context.go(route);
      }
    } catch (e) {

    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }
}
/* Fin screens\institution_selection_screen.dart */

/* Inicio screens\login_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../utils/responsive_utils.dart';

class LoginScreen extends StatefulWidget {
  const LoginScreen({super.key});

  @override
  State<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {

  final _emailController = TextEditingController(text: 'superadmin@asistapp.com');
  final _passwordController = TextEditingController(text: 'Admin123!');
  bool _isLoading = false;
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Widget _buildMainTitle(Map<String, dynamic> responsive) {
    final titleFontSize = responsive['titleFontSize'] as double;

    return Builder(
      builder: (context) {
        final colors = context.colors;
        return Text(
          'AsistApp',
          style: TextStyle(
            fontSize: titleFontSize,
            fontWeight: FontWeight.bold,
            color: colors.textPrimary,
          ),
          textAlign: TextAlign.center,
        );
      },
    );
  }

  Widget _buildSubtitle(Map<String, dynamic> responsive, Color textMuted) {
    final subtitleFontSize = responsive['subtitleFontSize'] as double;

    return Text(
      'Sistema de Registro de Asistencia Escolar',
      style: TextStyle(
        color: textMuted,
        fontSize: subtitleFontSize,
      ),
      textAlign: TextAlign.center,
    );
  }

  Widget _buildEmailField() {
    return TextFormField(
      controller: _emailController,
      decoration: const InputDecoration(
        labelText: 'Correo electrÃ³nico',
        border: OutlineInputBorder(),
      ),
      keyboardType: TextInputType.emailAddress,
    );
  }

  Widget _buildPasswordField() {
    return TextFormField(
      controller: _passwordController,
      decoration: const InputDecoration(
        labelText: 'ContraseÃ±a',
        border: OutlineInputBorder(),
      ),
      obscureText: true,
    );
  }

  Widget _buildLoginButton(Map<String, dynamic> responsive) {
    final buttonWidth = responsive['buttonWidth'] as double;

    return SizedBox(
      width: buttonWidth,
      child: ElevatedButton(
        onPressed: _isLoading ? null : _login,
        child: Text(_isLoading ? 'Iniciando sesiÃ³n...' : 'Iniciar SesiÃ³n'),
      ),
    );
  }

  Widget _buildTestUsersSection(Map<String, dynamic> responsive) {
    final bodyFontSize = responsive['bodyFontSize'] as double;

    return Builder(
      builder: (context) {
        final colors = context.colors;
        return Column(
          children: [
            const SizedBox(height: 32),
            Text(
              'Usuarios de Prueba (Desarrollo)',
              style: TextStyle(
                fontSize: bodyFontSize,
                fontWeight: FontWeight.bold,
                color: colors.textSecondary,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 16),
            Wrap(
              spacing: 8,
              runSpacing: 8,
              alignment: WrapAlignment.center,
              children: [
                _buildTestUserButton(
                  'Super Admin',
                  'superadmin@asistapp.com',
                  'Admin123!',
                  'super_admin',
                  'Todas',
                  colors.featureUsers,
                  responsive,
                ),
                _buildTestUserButton(
                  'Admin Multi',
                  'multi@asistapp.com',
                  'Multi123!',
                  'admin_institucion',
                  '2 instituciones',
                  colors.featureInstitutions,
                  responsive,
                ),
                _buildTestUserButton(
                  'Admin San JosÃ©',
                  'admin@sanjose.edu',
                  'SanJose123!',
                  'admin_institucion',
                  '1 instituciÃ³n',
                  colors.featureSettings,
                  responsive,
                ),
                _buildTestUserButton(
                  'Profesor',
                  'pedro.garcia@sanjose.edu',
                  'Prof123!',
                  'profesor',
                  '1 instituciÃ³n',
                  colors.featureClasses,
                  responsive,
                ),
                _buildTestUserButton(
                  'Estudiante',
                  'juan.perez@sanjose.edu',
                  'Est123!',
                  'estudiante',
                  '1 instituciÃ³n',
                  colors.featureStudents,
                  responsive,
                ),
              ],
            ),
            const SizedBox(height: 16),
            Text(
              'Presiona un botÃ³n para autocompletar los campos',
              style: TextStyle(
                fontSize: bodyFontSize * 0.8,
                color: colors.textMuted,
                fontStyle: FontStyle.italic,
              ),
              textAlign: TextAlign.center,
            ),
          ],
        );
      },
    );
  }

  Widget _buildTestUserButton(
    String name,
    String email,
    String password,
    String role,
    String institutions,
    Color color,
    Map<String, dynamic> responsive,
  ) {
    final isSmallScreen = responsive['isSmallScreen'] as bool;
    final bodyFontSize = responsive['bodyFontSize'] as double;
    final buttonWidth = isSmallScreen ? 140.0 : 160.0;

    return Builder(
      builder: (context) {
        final colors = context.colors;
        final backgroundColor = color.withValues(alpha: 0.15)
        final borderColor = color.withValues(alpha: 0.4)
        final primaryTextColor = colors.getTextColorForBackground(color);
        final secondaryTextColor = colors.getSecondaryTextColorForBackground(color);

        return SizedBox(
          width: buttonWidth,
          child: ElevatedButton(
            onPressed: () {
              setState(() {
                _emailController.text = email;
                _passwordController.text = password;
                _errorMessage = null;
              });
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: backgroundColor,
              foregroundColor: primaryTextColor, // Color de texto con contraste
              side: BorderSide(color: borderColor, width: 1.5),
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 12),
              elevation: 0,
            ),
            child: Column(
              children: [
                Text(
                  name,
                  style: TextStyle(
                    fontSize: bodyFontSize * 0.9,
                    fontWeight: FontWeight.bold,
                    color: primaryTextColor, // Color con buen contraste
                  ),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 2),
                Text(
                  role,
                  style: TextStyle(
                    fontSize: bodyFontSize * 0.8,
                    color: secondaryTextColor, // Color secundario con contraste
                  ),
                  textAlign: TextAlign.center,
                ),
                Text(
                  institutions,
                  style: TextStyle(
                    fontSize: bodyFontSize * 0.75,
                    fontStyle: FontStyle.italic,
                    color: colors.getMutedTextColorForBackground(color), // Color atenuado con contraste
                  ),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildErrorMessage() {
    if (_errorMessage == null) return const SizedBox.shrink();

    return Builder(
      builder: (context) {
        final colors = context.colors;
        return Text(
          _errorMessage!,
          style: TextStyle(color: colors.error),
          textAlign: TextAlign.center,
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;

    return Scaffold(
      backgroundColor: colors.background,
      body: SafeArea(
        child: LayoutBuilder(
          builder: (context, constraints) {
            final responsive = ResponsiveUtils.getResponsiveValues(constraints);

            return SingleChildScrollView(
              child: ConstrainedBox(
                constraints: BoxConstraints(maxWidth: responsive['maxWidth']),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    Padding(
                      padding: EdgeInsets.symmetric(
                        horizontal: responsive['horizontalPadding'],
                        vertical: responsive['verticalPadding'],
                      ),
                      child: Column(
                        children: [
                          _buildMainTitle(responsive),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildSubtitle(responsive, colors.textMuted),
                          SizedBox(height: responsive['elementSpacing'] * 1.5),

                          _buildEmailField(),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildPasswordField(),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildErrorMessage(),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildLoginButton(responsive),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildTestUsersSection(responsive),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            );
          },
        ),
      ),
    );
  }

  Future<void> _login() async {
    if (_emailController.text.isEmpty ||
        _passwordController.text.isEmpty) {
      setState(() {
        _errorMessage = 'Por favor complete todos los campos';
      });
      return;
    }

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final success = await authProvider.login(
        _emailController.text.trim(),
        _passwordController.text,
      );

      if (success) {

        debugPrint('Login exitoso, AuthWrapper manejarÃ¡ la navegaciÃ³n');
      } else {
        setState(() {
          _errorMessage = 'Credenciales incorrectas';
        });
      }
    } catch (e) {
      setState(() {
        _errorMessage = 'Error de conexiÃ³n. Intente nuevamente.';
      });
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }
}
/* Fin screens\login_screen.dart */

/* Inicio screens\student_dashboard.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../widgets/role_guard.dart';
import '../utils/role_enum.dart';
import '../utils/responsive_utils.dart';
import '../utils/app_routes.dart';
import '../widgets/dashboard_widgets.dart';

class StudentDashboard extends StatelessWidget {
  const StudentDashboard({super.key});

  Widget _buildUserGreeting(String userName, AuthProvider authProvider, Map<String, dynamic> responsive) {
    final selectedInstitution = authProvider.selectedInstitution;

    return UserGreetingWidget(
      userName: userName,
      responsive: responsive,
      subtitle: selectedInstitution?.name,
    );
  }

  Widget _buildDashboardOptions(BuildContext context, Map<String, dynamic> responsive) {
    final colors = context.colors;

    return Column(
      children: [
        const SizedBox(height: 32),
        Wrap(
          spacing: 12,
          runSpacing: 12,
          alignment: WrapAlignment.center,
          children: [
            DashboardFeatureCard(
              icon: Icons.qr_code,
              title: 'Mi CÃ³digo QR',
              description: 'Mostrar cÃ³digo para asistencia',
              color: colors.featureAttendance,
              responsive: responsive,
            ),
            RoleGuard(
              allowedRoles: [UserRole.estudiante],
              child: DashboardFeatureCard(
                icon: Icons.calendar_today,
                title: 'Mi Horario',
                description: 'Ver clases del dÃ­a',
                color: colors.featureSchedule,
                responsive: responsive,
              ),
            ),
            DashboardFeatureCard(
              icon: Icons.assignment,
              title: 'Asistencia',
              description: 'Historial de mi asistencia',
              color: colors.featureClasses,
              responsive: responsive,
            ),
            DashboardFeatureCard(
              icon: Icons.bar_chart,
              title: 'EstadÃ­sticas',
              description: 'Mi rendimiento acadÃ©mico',
              color: colors.featureReports,
              responsive: responsive,
            ),
            DashboardFeatureCard(
              icon: Icons.notifications,
              title: 'Notificaciones',
              description: 'Avisos de padres/profesores',
              color: colors.featureNotifications,
              responsive: responsive,
            ),
            DashboardFeatureCard(
              icon: Icons.contact_phone,
              title: 'Contacto',
              description: 'InformaciÃ³n de contacto',
              color: colors.info,
              responsive: responsive,
            ),
          ],
        ),
      ],
    );
  }

  PreferredSizeWidget _buildAppBar(BuildContext context, AuthProvider authProvider, Color primaryColor, String userRole) {
    return DashboardAppBar(
      backgroundColor: primaryColor,
      actions: [
        DashboardAppBarActions(
          userRole: userRole,
          roleIcon: Icons.person,
          onLogout: () async {
            await authProvider.logout();
            if (context.mounted) {
              context.go(AppRoutes.login);
            }
          },
        ),
      ],
    );
  }

  Widget _buildBody(BuildContext context, String userName, AuthProvider authProvider, Map<String, dynamic> responsive) {
    return DashboardBody(
      userGreeting: _buildUserGreeting(userName, authProvider, responsive),
      dashboardOptions: _buildDashboardOptions(context, responsive),
      responsive: responsive,
    );
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final colors = context.colors;

    final user = authProvider.user;
    final userName = user?['nombres'] ?? 'Usuario';
    final userRole = 'Estudiante';

    return Scaffold(
      backgroundColor: colors.background,
      appBar: _buildAppBar(context, authProvider, colors.primary, userRole),
      body: LayoutBuilder(
        builder: (ctx, constraints) {
          final responsive = ResponsiveUtils.getResponsiveValues(constraints);
          return _buildBody(context, userName, authProvider, responsive);
        },
      ),
    );
  }
}
/* Fin screens\student_dashboard.dart */

/* Inicio screens\super_admin_dashboard.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../utils/responsive_utils.dart';
import '../utils/app_routes.dart';
import '../widgets/dashboard_widgets.dart';

class SuperAdminDashboard extends StatelessWidget {
  const SuperAdminDashboard({super.key});

  Widget _buildDashboardOptions(BuildContext context, Map<String, dynamic> responsive) {
    final colors = context.colors;

    final cards = [
      DashboardFeatureCard(
        icon: Icons.business,
        title: 'Instituciones',
        description: 'Gestionar todas las instituciones del sistema',
        color: colors.featureInstitutions,
        responsive: responsive,
        onTap: () => context.go(AppRoutes.institutionsList),
      ),
      DashboardFeatureCard(
        icon: Icons.people,
        title: 'Usuarios Globales',
        description: 'Administrar usuarios de todo el sistema',
        color: colors.featureUsers,
        responsive: responsive,
      ),
      DashboardFeatureCard(
        icon: Icons.security,
        title: 'Permisos',
        description: 'Configurar permisos y roles del sistema',
        color: colors.featureSettings,
        responsive: responsive,
      ),
      DashboardFeatureCard(
        icon: Icons.analytics,
        title: 'Reportes Globales',
        description: 'EstadÃ­sticas y mÃ©tricas del sistema completo',
        color: colors.featureReports,
        responsive: responsive,
      ),
      DashboardFeatureCard(
        icon: Icons.settings,
        title: 'ConfiguraciÃ³n',
        description: 'Ajustes globales del sistema',
        color: colors.featureSettings,
        responsive: responsive,
      ),
      DashboardFeatureCard(
        icon: Icons.backup,
        title: 'Backup & Restore',
        description: 'GestiÃ³n de respaldos del sistema',
        color: colors.error,
        responsive: responsive,
      ),
    ];

    return DashboardOptionsGrid(
      cards: cards,
      responsive: responsive,
    );
  }

  PreferredSizeWidget _buildAppBar(BuildContext context, AuthProvider authProvider, Color primaryColor, String userRole) {
    return DashboardAppBar(
      backgroundColor: primaryColor,
      actions: [
        DashboardAppBarActions(
          userRole: userRole,
          roleIcon: Icons.verified_user,
          onLogout: () async {
            await authProvider.logout();
            if (context.mounted) {
              context.go(AppRoutes.login);
            }
          },
        ),
      ],
    );
  }

  Widget _buildBody(BuildContext context, String userName, Map<String, dynamic> responsive) {
    return DashboardBody(
      userGreeting: UserGreetingWidget(
        userName: userName,
        responsive: responsive,
        subtitle: 'Control Total del Sistema',
      ),
      dashboardOptions: _buildDashboardOptions(context, responsive),
      responsive: responsive,
    );
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final colors = context.colors;

    final user = authProvider.user;
    final userName = user?['nombres'] ?? 'Usuario';
    final userRole = 'Super Admin';

    return Scaffold(
      backgroundColor: colors.background,
      appBar: _buildAppBar(context, authProvider, colors.primary, userRole),
      body: LayoutBuilder(
        builder: (context, constraints) {
          final responsive = ResponsiveUtils.getResponsiveValues(constraints);
          return _buildBody(context, userName, responsive);
        },
      ),
    );
  }
}
/* Fin screens\super_admin_dashboard.dart */

/* Inicio screens\teacher_dashboard.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../widgets/role_guard.dart';
import '../utils/role_enum.dart';
import '../utils/responsive_utils.dart';
import '../utils/app_routes.dart';
import '../widgets/dashboard_widgets.dart';

class TeacherDashboard extends StatelessWidget {
  const TeacherDashboard({super.key});

  Widget _buildUserGreeting(String userName, AuthProvider authProvider, Map<String, dynamic> responsive) {
    final selectedInstitution = authProvider.selectedInstitution;

    return UserGreetingWidget(
      userName: userName,
      responsive: responsive,
      subtitle: selectedInstitution?.name,
    );
  }

  Widget _buildDashboardOptions(BuildContext context, Map<String, dynamic> responsive) {
    final colors = context.colors;

    return Column(
      children: [
        const SizedBox(height: 32),
        Wrap(
          spacing: 12,
          runSpacing: 12,
          alignment: WrapAlignment.center,
          children: [
            DashboardFeatureCard(
              icon: Icons.qr_code_scanner,
              title: 'Tomar Asistencia',
              description: 'Registrar asistencia con QR',
              color: colors.featureAttendance,
              responsive: responsive,
            ),
            DashboardFeatureCard(
              icon: Icons.assignment,
              title: 'Mis Clases',
              description: 'Ver horarios y grupos asignados',
              color: colors.featureClasses,
              responsive: responsive,
            ),
            DashboardFeatureCard(
              icon: Icons.people,
              title: 'Estudiantes',
              description: 'Lista de estudiantes por grupo',
              color: colors.featureStudents,
              responsive: responsive,
            ),
            DashboardFeatureCard(
              icon: Icons.bar_chart,
              title: 'Reportes',
              description: 'EstadÃ­sticas de asistencia',
              color: colors.featureReports,
              responsive: responsive,
            ),
            RoleGuard(
              allowedRoles: [UserRole.profesor],
              child: DashboardFeatureCard(
                icon: Icons.notifications,
                title: 'Notificaciones',
                description: 'Enviar avisos a padres',
                color: colors.featureNotifications,
                responsive: responsive,
              ),
            ),
            DashboardFeatureCard(
              icon: Icons.calendar_today,
              title: 'Horario',
              description: 'Mi horario de clases',
              color: colors.featureSchedule,
              responsive: responsive,
            ),
          ],
        ),
      ],
    );
  }

  PreferredSizeWidget _buildAppBar(BuildContext context, AuthProvider authProvider, Color primaryColor, String userRole) {
    return DashboardAppBar(
      backgroundColor: primaryColor,
      actions: [
        DashboardAppBarActions(
          userRole: userRole,
          roleIcon: Icons.school,
          onLogout: () async {
            await authProvider.logout();
            if (context.mounted) {
              context.go(AppRoutes.login);
            }
          },
        ),
      ],
    );
  }

  Widget _buildBody(BuildContext context, String userName, AuthProvider authProvider, Map<String, dynamic> responsive) {
    return DashboardBody(
      userGreeting: _buildUserGreeting(userName, authProvider, responsive),
      dashboardOptions: _buildDashboardOptions(context, responsive),
      responsive: responsive,
    );
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final colors = context.colors;

    final user = authProvider.user;
    final userName = user?['nombres'] ?? 'Usuario';
    final userRole = 'Profesor';

    return Scaffold(
      backgroundColor: colors.background,
      appBar: _buildAppBar(context, authProvider, colors.primary, userRole),
      body: LayoutBuilder(
        builder: (ctx, constraints) {
          final responsive = ResponsiveUtils.getResponsiveValues(constraints);
          return _buildBody(context, userName, authProvider, responsive);
        },
      ),
    );
  }
}
/* Fin screens\teacher_dashboard.dart */

/* Inicio screens\teacher_dashboard_with_scroll.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../widgets/scroll_state_keeper.dart';
import '../utils/app_routes.dart';
import '../utils/responsive_utils.dart';
class TeacherDashboardWithScroll extends StatelessWidget {
  const TeacherDashboardWithScroll({super.key});

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final colors = context.colors;
    final textStyles = context.textStyles;

    return Scaffold(
      backgroundColor: colors.background,
      appBar: AppBar(
        title: const Text('Profesor - AsistApp'),
        backgroundColor: colors.primary,
        actions: [
          IconButton(
            icon: const Icon(Icons.logout),
            onPressed: () async {
              await authProvider.logout();
            },
          ),
        ],
      ),
      body: SafeArea(
        child: ScrollStateKeeper(
          routeKey: AppRoutes.teacherDashboard,
          keepScrollPosition: true,
          builder: (context, scrollController) {
            return LayoutBuilder(
              builder: (context, constraints) {
                final responsive = ResponsiveUtils.getResponsiveValues(constraints);

                return SingleChildScrollView(
                  controller: scrollController, // â† El scroll se guarda automÃ¡ticamente
                  child: ConstrainedBox(
                    constraints: BoxConstraints(
                      maxWidth: responsive['maxWidth'],
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.center,
                      children: [
                        Padding(
                          padding: EdgeInsets.symmetric(
                            horizontal: responsive['horizontalPadding'],
                            vertical: responsive['verticalPadding'],
                          ),
                          child: Column(
                            children: [
                              Text(
                                'Panel del Profesor',
                                style: textStyles.displayLarge.copyWith(
                                  fontSize: responsive['isSmallScreen'] ? 28 : 42,
                                ),
                                textAlign: TextAlign.center,
                              ),
                              const SizedBox(height: 16),

                              ...List.generate(20, (index) => Card(
                                margin: const EdgeInsets.symmetric(vertical: 8),
                                child: ListTile(
                                  leading: CircleAvatar(child: Text('${index + 1}')),
                                  title: Text('Clase ${index + 1}'),
                                  subtitle: Text('Grupo ${index % 5 + 1}'),
                                  trailing: const Icon(Icons.arrow_forward_ios),
                                ),
                              )),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ),
                );
              },
            );
          },
        ),
      ),
    );
  }
}

/* Fin screens\teacher_dashboard_with_scroll.dart */

/* Inicio screens\welcome_screen.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';
import '../ui/widgets/index.dart';
import '../utils/responsive_utils.dart';

class WelcomeScreen extends StatelessWidget {
  const WelcomeScreen({super.key});

  Widget _buildWelcomeTitle(TextStyle displayLarge, bool isSmallScreen) {
    return Text(
      'Â¡Bienvenido!',
      style: displayLarge.copyWith(
        fontSize: isSmallScreen ? 32 : 48,
      ),
      textAlign: TextAlign.center,
    );
  }

  Widget _buildUserName(AuthProvider authProvider, TextStyle headlineMedium, Color primary, bool isSmallScreen) {
    final user = authProvider.user;
    final userName = user?['name'] ?? user?['email'] ?? 'Usuario';

    return Text(
      userName,
      style: headlineMedium.copyWith(
        color: primary,
        fontSize: isSmallScreen ? 18 : 24,
      ),
      textAlign: TextAlign.center,
    );
  }

  Widget _buildSignOutButton(AuthProvider authProvider) {
    return AppButton(
      label: 'Cerrar SesiÃ³n',
      onPressed: () async {
        await authProvider.logout();
      },
    );
  }

  Widget _buildBody(AuthProvider authProvider, dynamic textStyles, Color primaryColor, Map<String, dynamic> responsive) {
    return SafeArea(
      child: LayoutBuilder(
        builder: (context, constraints) {
          return Center(
            child: SingleChildScrollView(
              child: ConstrainedBox(
                constraints: BoxConstraints(maxWidth: responsive['maxWidth']),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    Padding(
                      padding: EdgeInsets.symmetric(
                        horizontal: responsive['horizontalPadding'],
                        vertical: responsive['verticalPadding'],
                      ),
                      child: Column(
                        children: [
                          _buildWelcomeTitle(textStyles.displayLarge, responsive['isSmallScreen']),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildUserName(authProvider, textStyles.headlineMedium, primaryColor, responsive['isSmallScreen']),
                          SizedBox(height: responsive['elementSpacing']),

                          const Text(
                            'Has iniciado sesiÃ³n correctamente',
                            textAlign: TextAlign.center,
                          ),
                          SizedBox(height: responsive['elementSpacing']),

                          _buildSignOutButton(authProvider),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
          );
        },
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final colors = context.colors;
    final textStyles = context.textStyles;

    return Scaffold(
      backgroundColor: colors.background,
      body: LayoutBuilder(
        builder: (context, constraints) {
          final responsive = ResponsiveUtils.getResponsiveValues(constraints);
          return _buildBody(authProvider, textStyles, colors.primary, responsive);
        },
      ),
    );
  }
}
/* Fin screens\welcome_screen.dart */

/* Inicio services\auth_service.dart */
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';

class LoginResponse {
  final String accessToken;
  final String refreshToken;
  final Map<String, dynamic> user;
  final int? expiresIn;

  LoginResponse({
    required this.accessToken,
    required this.refreshToken,
    required this.user,
    this.expiresIn,
  });

  factory LoginResponse.fromJson(Map<String, dynamic> json) {

    final data = json['data'] ?? json;

    final usuario = data['usuario'] ?? data['user'];

    return LoginResponse(
      accessToken: data['accessToken'] as String,
      refreshToken: data['refreshToken'] as String,
      user: usuario is Map<String, dynamic> ? usuario : {},
      expiresIn: data['expiresIn'] as int?,
    );
  }
}

class RefreshResponse {
  final String accessToken;
  final String refreshToken;

  RefreshResponse({
    required this.accessToken,
    required this.refreshToken,
  });

  factory RefreshResponse.fromJson(Map<String, dynamic> json) {
    return RefreshResponse(
      accessToken: json['accessToken'],
      refreshToken: json['refreshToken'],
    );
  }
}

class AuthService {

  static Future<String> _getLocalIp() async {
    try {

      if (kIsWeb) {
        return 'localhost';
      }

      return '192.168.20.22';
    } catch (e) {
      debugPrint('Error obteniendo IP local: $e');
      return 'localhost'
    }
  }

  static Future<String> get baseUrl async {
    final ip = await _getLocalIp();
    return 'http://$ip:3000';
  }

  Future<LoginResponse?> login(String email, String password) async {
    try {
      final baseUrlValue = await baseUrl;
      final url = '$baseUrlValue/auth/login';

      final requestBody = jsonEncode({
        'email': email,
        'password': password,
      });

      final response = await http.post(
        Uri.parse(url),
        headers: {'Content-Type': 'application/json'},
        body: requestBody,
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('   Status: ${response.statusCode}');
      debugPrint('   Body: ${response.body}');
      debugPrint('========================================');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);

        final data = responseData['data'] ?? responseData;

        if (data['accessToken'] == null || data['refreshToken'] == null) {
          debugPrint('   accessToken: ${data['accessToken']}');
          debugPrint('   refreshToken: ${data['refreshToken']}');
          debugPrint('   usuario: ${data['usuario']}');
          return null;
        }

        return LoginResponse.fromJson(responseData);
      } else {
        debugPrint('   Response: ${response.body}');
        return null;
      }
    } catch (e, stackTrace) {
      debugPrint('Error: $e');
      debugPrint('StackTrace: $stackTrace');
      debugPrint('====================================');
      return null;
    }
  }

  Future<RefreshResponse?> refreshToken(String refreshToken) async {
    try {
      final baseUrlValue = await baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/auth/refresh'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'refreshToken': refreshToken,
        }),
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        return RefreshResponse.fromJson(data);
      } else {
        debugPrint('Refresh failed: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e) {
      debugPrint('Refresh error: $e');
      return null;
    }
  }

  Future<bool> logout(String refreshToken) async {
    try {
      final baseUrlValue = await baseUrl;
      final response = await http.post(
        Uri.parse('$baseUrlValue/auth/logout'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'refreshToken': refreshToken,
        }),
      );

      return response.statusCode == 200;
    } catch (e) {
      debugPrint('Logout error: $e');
      return false;
    }
  }

  Future<List<Map<String, dynamic>>?> getUserInstitutions(String accessToken) async {
    try {
      final baseUrlValue = await baseUrl;
      final response = await http.get(
        Uri.parse('$baseUrlValue/auth/instituciones'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        if (data['success'] == true) {
          final institutions = data['data'] as List;
          return institutions.map((e) => e as Map<String, dynamic>).toList();
        }
      } else {
        debugPrint('Get user institutions failed: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e) {
      debugPrint('Get user institutions error: $e');
      return null;
    }
    return null;
  }
}
/* Fin services\auth_service.dart */

/* Inicio services\institution_service.dart */
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';
import '../models/institution.dart';

class InstitutionResponse {
  final bool success;
  final String? message;
  final Institution? data;
  final List<Institution>? dataList;

  InstitutionResponse({
    required this.success,
    this.message,
    this.data,
    this.dataList,
  });

  factory InstitutionResponse.fromJson(Map<String, dynamic> json) {
    return InstitutionResponse(
      success: json['success'] ?? false,
      message: json['message'],
      data: json['data'] != null && json['data'] is! List
          ? Institution.fromJson(json['data'])
          : null,
      dataList: json['data'] != null && json['data'] is List
          ? (json['data'] as List).map((e) => Institution.fromJson(e)).toList()
          : null,
    );
  }
}

class InstitutionService {
  static Future<String> _getLocalIp() async {
    try {
      if (kIsWeb) {
        return 'localhost';
      }
      return '192.168.20.22';
    } catch (e) {
      debugPrint('Error obteniendo IP local: $e');
      return 'localhost';
    }
  }

  static Future<String> get baseUrl async {
    final ip = await _getLocalIp();
    return 'http://$ip:3000';
  }
  Future<List<Institution>> getAllInstitutions(String accessToken) async {
    try {
      final baseUrlValue = await baseUrl;
      final url = '$baseUrlValue/instituciones';

      final response = await http.get(
        Uri.parse(url),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET $url - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        debugPrint('Response body: ${response.body}');
        final institutionResponse = InstitutionResponse.fromJson(jsonDecode(response.body));
        debugPrint('InstitutionResponse success: ${institutionResponse.success}');
        debugPrint('InstitutionResponse dataList length: ${institutionResponse.dataList?.length ?? 0}');
        if (institutionResponse.success && institutionResponse.dataList != null) {
          debugPrint('Returning ${institutionResponse.dataList!.length} institutions');
          return institutionResponse.dataList!;
        } else {
          debugPrint('No success or no dataList: ${institutionResponse.message}');
          throw Exception(institutionResponse.message ?? 'Error al obtener instituciones');
        }
      } else {
        debugPrint('Error response: ${response.body}');
        throw Exception('Error ${response.statusCode}: ${response.body}');
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting institutions: $e');
      debugPrint('StackTrace: $stackTrace');
      throw Exception('Error al obtener instituciones: $e');
    }
  }
  Future<Institution> getInstitutionById(String accessToken, String id) async {
    try {
      final baseUrlValue = await baseUrl;
      final url = '$baseUrlValue/instituciones/$id';

      final response = await http.get(
        Uri.parse(url),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('GET $url - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final institutionResponse = InstitutionResponse.fromJson(jsonDecode(response.body));
        if (institutionResponse.success && institutionResponse.data != null) {
          return institutionResponse.data!;
        } else {
          throw Exception(institutionResponse.message ?? 'InstituciÃ³n no encontrada');
        }
      } else {
        debugPrint('Error response: ${response.body}');
        throw Exception('Error ${response.statusCode}: ${response.body}');
      }
    } catch (e, stackTrace) {
      debugPrint('Error getting institution: $e');
      debugPrint('StackTrace: $stackTrace');
      throw Exception('Error al obtener instituciÃ³n: $e');
    }
  }
  Future<Institution> createInstitution(
    String accessToken, {
    required String nombre,
    required String codigo,
    String? direccion,
    String? telefono,
    String? email,
  }) async {
    try {
      final baseUrlValue = await baseUrl;
      final url = '$baseUrlValue/instituciones';

      final requestBody = jsonEncode({
        'nombre': nombre,
        'codigo': codigo,
        if (direccion != null) 'direccion': direccion,
        if (telefono != null) 'telefono': telefono,
        if (email != null) 'email': email,
      });

      final response = await http.post(
        Uri.parse(url),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: requestBody,
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('POST $url - Status: ${response.statusCode}');
      debugPrint('Request body: $requestBody');

      if (response.statusCode == 201) {
        final institutionResponse = InstitutionResponse.fromJson(jsonDecode(response.body));
        if (institutionResponse.success && institutionResponse.data != null) {
          return institutionResponse.data!;
        } else {
          throw Exception(institutionResponse.message ?? 'Error al crear instituciÃ³n');
        }
      } else {
        debugPrint('Error response: ${response.body}');
        final errorData = jsonDecode(response.body);
        throw Exception(errorData['message'] ?? 'Error ${response.statusCode}');
      }
    } catch (e, stackTrace) {
      debugPrint('Error creating institution: $e');
      debugPrint('StackTrace: $stackTrace');
      throw Exception('Error al crear instituciÃ³n: $e');
    }
  }
  Future<Institution> updateInstitution(
    String accessToken,
    String id, {
    String? nombre,
    String? codigo,
    String? direccion,
    String? telefono,
    String? email,
    bool? activa,
  }) async {
    try {
      final baseUrlValue = await baseUrl;
      final url = '$baseUrlValue/instituciones/$id';

      final requestBody = jsonEncode({
        if (nombre != null) 'nombre': nombre,
        if (codigo != null) 'codigo': codigo,
        if (direccion != null) 'direccion': direccion,
        if (telefono != null) 'telefono': telefono,
        if (email != null) 'email': email,
        if (activa != null) 'activa': activa,
      });

      final response = await http.put(
        Uri.parse(url),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: requestBody,
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('PUT $url - Status: ${response.statusCode}');
      debugPrint('Request body: $requestBody');

      if (response.statusCode == 200) {
        final institutionResponse = InstitutionResponse.fromJson(jsonDecode(response.body));
        if (institutionResponse.success && institutionResponse.data != null) {
          return institutionResponse.data!;
        } else {
          throw Exception(institutionResponse.message ?? 'Error al actualizar instituciÃ³n');
        }
      } else {
        debugPrint('Error response: ${response.body}');
        final errorData = jsonDecode(response.body);
        throw Exception(errorData['message'] ?? 'Error ${response.statusCode}');
      }
    } catch (e, stackTrace) {
      debugPrint('Error updating institution: $e');
      debugPrint('StackTrace: $stackTrace');
      throw Exception('Error al actualizar instituciÃ³n: $e');
    }
  }
  Future<void> deleteInstitution(String accessToken, String id) async {
    try {
      final baseUrlValue = await baseUrl;
      final url = '$baseUrlValue/instituciones/$id';

      final response = await http.delete(
        Uri.parse(url),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
      ).timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw Exception('Timeout: El servidor no responde');
        },
      );

      debugPrint('DELETE $url - Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        if (responseData['success'] == true) {
          return;
        } else {
          throw Exception(responseData['message'] ?? 'Error al eliminar instituciÃ³n');
        }
      } else {
        debugPrint('Error response: ${response.body}');
        final errorData = jsonDecode(response.body);
        throw Exception(errorData['message'] ?? 'Error ${response.statusCode}');
      }
    } catch (e, stackTrace) {
      debugPrint('Error deleting institution: $e');
      debugPrint('StackTrace: $stackTrace');
      throw Exception('Error al eliminar instituciÃ³n: $e');
    }
  }
}
/* Fin services\institution_service.dart */

/* Inicio theme\app_colors.dart */
import 'package:flutter/material.dart';
class AppColors {

  AppColors._();

  static final AppColors instance = AppColors._();

  static const Color _primaryBase = Color(0xFF2563EB)
  static const Color _secondaryBase = Color(0xFF38BDF8)
  static const Color _surfaceBase = Color(0xFFFFFFFF)
  static const Color _backgroundBase = Color(0xFFF9FAFB)

  final Color primary = _primaryBase;
  final Color primaryDark = const Color(0xFF1E40AF)
  final Color primaryLight = const Color(0xFF60A5FA)
  final Color primaryContainer = const Color(0xFFE0F2FE)

  final Color secondary = _secondaryBase;
  final Color secondaryLight = const Color(0xFF7DD3FC)
  final Color secondaryContainer = const Color(0xFFE0F7FA)
  final Color success = const Color(0xFF16A34A)
  final Color warning = const Color(0xFFFACC15)
  final Color error = const Color(0xFFDC2626)
  final Color info = const Color(0xFF3B82F6)
  final Color featureUsers = const Color(0xFF6366F1)
  final Color featureInstitutions = const Color(0xFF0EA5E9)
  final Color featureAttendance = const Color(0xFFF59E0B)
  final Color featureReports = const Color(0xFFE11D48)
  final Color featureSchedule = const Color(0xFF14B8A6)
  final Color featureSettings = const Color(0xFF475569)
  final Color featureNotifications = const Color(0xFFF97316)
  final Color featureClasses = const Color(0xFFEF4444)
  final Color featureGrades = const Color(0xFF84CC16)
  final Color featureStudents = const Color(0xFF2563EB)
  final Color stateNoData = const Color(0xFF94A3B8)
  final Color stateInDevelopment = const Color(0xFF6366F1)
  final Color stateSuccess = const Color(0xFF22C55E)
  final Color stateInactive = const Color(0xFFE2E8F0)

  final Color surface = _surfaceBase;
  final Color surfaceLight = const Color(0xFFF9FAFB)
  final Color surfaceContainer = const Color(0xFFFFFFFF)
  final Color background = _backgroundBase;
  final Color backgroundLight = const Color(0xFFFFFFFF)
  final Color textPrimary = const Color(0xFF0F172A)
  final Color textSecondary = const Color(0xFF334155)
  final Color textMuted = const Color(0xFF64748B)
  final Color textDisabled = const Color(0xFF94A3B8)
  final Color textOnDark = const Color(0xFFF8FAFC);
  final Color textOnDarkSecondary = const Color(0xFFE2E8F0);
  final Color textOnDarkMuted = const Color(0xFFCBD5E1);
  final Color border = const Color(0xFFE2E8F0);
  final Color borderLight = const Color(0xFFF1F5F9);
  final Color divider = const Color(0xFFE2E8F0);
  final Color shadow = const Color(0x0A000000);

  final Color transparent = const Color(0x00000000);
  final Color shadowLight = const Color(0x05000000);
  final Color scrim = const Color(0x0F000000);

  final Color white = const Color(0xFFFFFFFF);
  final Color black = const Color(0xFF000000);
  final Color grey = const Color(0xFF94A3B8);
  final Color greyDark = const Color(0xFF475569);
  final Color greyLight = const Color(0xFFE2E8F0);
  Color get primaryWithOpacity => primary.withValues(alpha: 0.9);
  Color get surfaceWithOpacity => surface.withValues(alpha: 0.95);
  Color get textSecondaryWithOpacity => textSecondary.withValues(alpha: 0.8);
  Color get warningBackground => warning.withValues(alpha: 0.08);
  Color get warningBorder => warning.withValues(alpha: 0.2);
  Color get infoBackground => info.withValues(alpha: 0.08);
  Color get infoBorder => info.withValues(alpha: 0.2);
  Color get errorBackground => error.withValues(alpha: 0.08);
  Color get errorBorder => error.withValues(alpha: 0.2);
  Color get successBackground => success.withValues(alpha: 0.08);
  Color get successBorder => success.withValues(alpha: 0.2);
  Color get roleBadgeBackground => white.withValues(alpha: 0.15);
  Color get roleBadgeText => white;
  Color get roleBadgeIcon => white;
  Color getTextColorForBackground(Color backgroundColor) {
    final luminance = backgroundColor.computeLuminance();
    return luminance > 0.5 ? textPrimary : textOnDark;
  }

  Color getSecondaryTextColorForBackground(Color backgroundColor) {
    final luminance = backgroundColor.computeLuminance();
    return luminance > 0.5 ? textSecondary : textOnDarkSecondary;
  }

  Color getMutedTextColorForBackground(Color backgroundColor) {
    final luminance = backgroundColor.computeLuminance();
    return luminance > 0.5 ? textMuted : textOnDarkMuted;
  }
}

/* Fin theme\app_colors.dart */

/* Inicio theme\app_constants.dart */

class AppConstants {

  AppConstants._();

  static final AppConstants instance = AppConstants._();
  final double mobileSmall = 480;
  final double mobileLarge = 768;
  final double tablet = 1024;
  final double desktop = 1440;
  final double maxWidthMobile = 480;
  final double maxWidthTablet = 768;
  final double maxWidthDesktop = 1024;
  final double maxWidthLargeDesktop = 1400;

  final double logoSize = 80;
  final double spinnerSize = 20;
  final double buttonBorderRadius = 8;
  final double cardBorderRadius = 8;
  final double logoBorderRadius = 20;
  final double errorLoggerWidthCollapsed = 60;
  final double errorLoggerHeightCollapsed = 60;
  final double errorLoggerWidthExpanded = 300;
  final double errorLoggerHeightExpanded = 200;

  final double defaultFontSize = 14;
  final double logoFontSize = 48;
  final double shadowBlurRadius = 8;
  final double shadowOffsetY = 2;
  final double errorLoggerShadowBlur = 8;
  final double errorLoggerShadowOffsetY = 4;
  final double borderWidthThin = 0.5;
  final double borderWidthNormal = 1;
  final double borderWidthThick = 1.5;

  final double shadowOpacity = 0.1
  final double surfaceTintOpacity = 0.1;
  double getMaxWidth(double screenWidth) {
    if (screenWidth <= mobileSmall) return maxWidthMobile;
    if (screenWidth <= mobileLarge) return maxWidthTablet;
    if (screenWidth <= tablet) return maxWidthDesktop;
    return maxWidthLargeDesktop;
  }
  ScreenType getScreenType(double width) {
    if (width <= mobileSmall) return ScreenType.mobileSmall;
    if (width <= mobileLarge) return ScreenType.mobileLarge;
    if (width <= tablet) return ScreenType.tablet;
    if (width <= desktop) return ScreenType.desktop;
    return ScreenType.largeDesktop;
  }
}

enum ScreenType {
  mobileSmall,    // <= 480px
  mobileLarge,    // 481-768px
  tablet,         // 769-1024px
  desktop,        // 1025-1440px
  largeDesktop,   // > 1440px
}
/* Fin theme\app_constants.dart */

/* Inicio theme\app_spacing.dart */

class AppSpacing {
  AppSpacing._();
  static final AppSpacing instance = AppSpacing._();
  static const double _baseUnit = 4;
  final double xs = _baseUnit
  final double sm = _baseUnit * 2
  final double md = _baseUnit * 4
  final double lg = _baseUnit * 6
  final double xl = _baseUnit * 8
  final double xxl = _baseUnit * 12
  final double xxxl = _baseUnit * 16
  final double buttonPadding = _baseUnit * 4
  final double cardPadding = _baseUnit * 3
  final double screenPadding = _baseUnit * 4
  final double inputPadding = _baseUnit * 3
  final double iconSize = _baseUnit * 6
  final double borderRadius = _baseUnit * 2
  final double borderRadiusLarge = _baseUnit * 3
  final double appBarHeight = _baseUnit * 14
  final double borderWidth = 1
  double multiply(double factor) => _baseUnit * factor;
  double add(double value) => _baseUnit + value;
}
/* Fin theme\app_spacing.dart */

/* Inicio theme\app_text_styles.dart */
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'app_colors.dart';
class AppTextStyles {

  AppTextStyles._();

  static final AppTextStyles instance = AppTextStyles._();

  TextStyle _createStyle({
    required double fontSize,
    required FontWeight fontWeight,
    required double height,
    required double letterSpacing,
    Color? color,
    TextDecoration? decoration,
  }) {
    return GoogleFonts.inter(
      fontSize: fontSize,
      fontWeight: fontWeight,
      height: height,
      letterSpacing: letterSpacing,
      color: color ?? AppColors.instance.textPrimary,
      decoration: decoration,
    );
  }

  TextStyle get displayLarge => _createStyle(
    fontSize: 32,
    fontWeight: FontWeight.bold,
    height: 1.2,
    letterSpacing: 0.4,
  );

  TextStyle get displayMedium => _createStyle(
    fontSize: 28,
    fontWeight: FontWeight.bold,
    height: 1.25,
    letterSpacing: 0.36,
  );

  TextStyle get headlineLarge => _createStyle(
    fontSize: 24,
    fontWeight: FontWeight.w600,
    height: 1.3,
    letterSpacing: 0.35,
  );

  TextStyle get headlineMedium => _createStyle(
    fontSize: 20,
    fontWeight: FontWeight.w600,
    height: 1.4,
    letterSpacing: 0.25,
  );

  TextStyle get titleLarge => _createStyle(
    fontSize: 17,
    fontWeight: FontWeight.w600,
    height: 1.4,
    letterSpacing: -0.41,
  );

  TextStyle get titleMedium => _createStyle(
    fontSize: 15,
    fontWeight: FontWeight.w500,
    height: 1.5,
    letterSpacing: -0.24,
  );

  TextStyle get bodyLarge => _createStyle(
    fontSize: 16,
    fontWeight: FontWeight.normal,
    height: 1.47,
    letterSpacing: -0.41,
    color: AppColors.instance.textPrimary,
  );

  TextStyle get bodyMedium => _createStyle(
    fontSize: 15,
    fontWeight: FontWeight.normal,
    height: 1.47,
    letterSpacing: -0.24,
    color: AppColors.instance.textPrimary,
  );

  TextStyle get bodySmall => _createStyle(
    fontSize: 13,
    fontWeight: FontWeight.normal,
    height: 1.38,
    letterSpacing: -0.08,
    color: AppColors.instance.textMuted,
  );

  TextStyle get labelLarge => _createStyle(
    fontSize: 16,
    fontWeight: FontWeight.w600,
    height: 1.43,
    letterSpacing: -0.5,
     color: AppColors.instance.textSecondary,
  );

  TextStyle get labelMedium => _createStyle(
    fontSize: 14,
    fontWeight: FontWeight.w500,
    height: 1.38,
    letterSpacing: -0.08,
    color: AppColors.instance.textSecondary,
  );

  TextStyle get labelSmall => _createStyle(
    fontSize: 11,
    fontWeight: FontWeight.w500,
    height: 1.36,
    letterSpacing: 0.06,
    color: AppColors.instance.textMuted,
  );

  TextStyle get button => labelLarge.copyWith(
    color: null, // Usar foregroundColor del botÃ³n
  );

  TextStyle get caption => bodySmall.copyWith(
    fontSize: 12,
  );

  TextStyle get overline => labelSmall.copyWith(
    fontSize: 10,
    letterSpacing: 1.5,
    fontWeight: FontWeight.w500,
  );

  TextStyle withColor(Color color) => _createStyle(
    fontSize: 15, // default
    fontWeight: FontWeight.normal,
    height: 1.4,
    letterSpacing: 0,
    color: color,
  );

  TextStyle withWeight(FontWeight weight) => _createStyle(
    fontSize: 15, // default
    fontWeight: weight,
    height: 1.4,
    letterSpacing: 0,
  );

  TextStyle withSize(double size) => _createStyle(
    fontSize: size,
    fontWeight: FontWeight.normal,
    height: 1.4,
    letterSpacing: 0,
  );
}
/* Fin theme\app_text_styles.dart */

/* Inicio theme\app_theme.dart */
import 'package:flutter/material.dart';
import 'app_colors.dart';
import 'app_spacing.dart';
import 'app_text_styles.dart';
class AppTheme {

  AppTheme._();

  static final AppTheme instance = AppTheme._();
  static ThemeData get light => _createTheme(Brightness.light);
  static ThemeData get dark => _createTheme(Brightness.dark);
  static ThemeData get defaultTheme => dark;

  static ThemeData _createTheme(Brightness brightness) {
    final colors = AppColors.instance;
    final textStyles = AppTextStyles.instance;

    return ThemeData(
      brightness: brightness,
      useMaterial3: true,

      colorScheme: ColorScheme(
        brightness: brightness,
        primary: colors.primary,
        onPrimary: colors.white, // Texto blanco sobre primary oscuro
        primaryContainer: colors.primaryContainer,
        onPrimaryContainer: colors.textPrimary,
        secondary: colors.secondary,
        onSecondary: colors.white, // Texto blanco sobre secondary
        secondaryContainer: colors.secondaryContainer,
        onSecondaryContainer: colors.textSecondary,
        tertiary: colors.info,
        onTertiary: colors.white, // Texto blanco sobre info
        error: colors.error,
        onError: colors.white, // Texto blanco sobre error
        surface: colors.surface,
        onSurface: colors.textPrimary,
        surfaceContainerHighest: colors.surfaceLight,
        onSurfaceVariant: colors.textMuted,
        outline: colors.border,
        outlineVariant: colors.borderLight,
        shadow: colors.shadow,
        scrim: colors.scrim,
        inverseSurface: colors.primary,
        onInverseSurface: colors.white,
        inversePrimary: colors.primaryLight,
        surfaceTint: colors.primary.withValues(alpha: 0.05),
      ),

      textTheme: TextTheme(
        displayLarge: textStyles.displayLarge,
        displayMedium: textStyles.displayMedium,
        headlineLarge: textStyles.headlineLarge,
        headlineMedium: textStyles.headlineMedium,
        titleLarge: textStyles.titleLarge,
        titleMedium: textStyles.titleMedium,
        bodyLarge: textStyles.bodyLarge,
        bodyMedium: textStyles.bodyMedium,
        bodySmall: textStyles.bodySmall,
        labelLarge: textStyles.labelLarge,
        labelMedium: textStyles.labelMedium,
        labelSmall: textStyles.labelSmall,
      ),

      appBarTheme: AppBarTheme(
        backgroundColor: colors.primary,
        foregroundColor: colors.white, // Texto blanco en AppBar oscuro
        elevation: 0,
        shadowColor: Colors.transparent,
        surfaceTintColor: Colors.transparent,
        titleTextStyle: textStyles.headlineMedium.copyWith(
          color: colors.white, // Asegurar texto blanco
          fontWeight: FontWeight.bold,
        ),
        iconTheme: IconThemeData(color: colors.white), // Iconos blancos
        actionsIconTheme: IconThemeData(color: colors.white), // Iconos de acciones blancos
        toolbarHeight: AppSpacing.instance.appBarHeight,
        centerTitle: true,
      ),

      cardTheme: CardTheme(
        color: colors.white,
        shadowColor: colors.shadowLight,
        elevation: 1, // ElevaciÃ³n sutil
        margin: EdgeInsets.zero,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          side: BorderSide(color: colors.border, width: 0.5),
        ),
      ),

      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: colors.primary,
          foregroundColor: colors.white,
          elevation: 1, // ElevaciÃ³n sutil
          padding: EdgeInsets.symmetric(
            horizontal: AppSpacing.instance.buttonPadding,
            vertical: AppSpacing.instance.md,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          ),
          textStyle: textStyles.button,
        ),
      ),

      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          foregroundColor: colors.primary,
          side: BorderSide(color: colors.border, width: AppSpacing.instance.borderWidth),
          elevation: 0,
          padding: EdgeInsets.symmetric(
            horizontal: AppSpacing.instance.buttonPadding,
            vertical: AppSpacing.instance.md,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          ),
          textStyle: textStyles.button, // Usar estilo sin color fijo
        ),
      ),

      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: colors.primary,
          padding: EdgeInsets.symmetric(
            horizontal: AppSpacing.instance.sm,
            vertical: AppSpacing.instance.xs,
          ),
          textStyle: textStyles.button, // Usar estilo sin color fijo
        ),
      ),

      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: colors.white,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          borderSide: BorderSide(color: colors.border, width: AppSpacing.instance.borderWidth),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          borderSide: BorderSide(color: colors.border, width: AppSpacing.instance.borderWidth),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          borderSide: BorderSide(color: colors.primaryLight, width: 1.5),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
          borderSide: BorderSide(color: colors.error, width: AppSpacing.instance.borderWidth),
        ),
        contentPadding: EdgeInsets.all(AppSpacing.instance.inputPadding),
        labelStyle: textStyles.bodyMedium.copyWith(color: colors.textMuted),
        hintStyle: textStyles.bodyMedium.copyWith(color: colors.textMuted),
        errorStyle: textStyles.bodySmall.copyWith(color: colors.error),
      ),

      dialogTheme: DialogTheme(
        backgroundColor: colors.white,
        elevation: 6, // ElevaciÃ³n media para diÃ¡logos
        shadowColor: colors.shadowLight,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadius),
        ),
      ),

      floatingActionButtonTheme: FloatingActionButtonThemeData(
        backgroundColor: colors.primary,
        foregroundColor: colors.white,
        elevation: 2, // ElevaciÃ³n sutil
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppSpacing.instance.borderRadiusLarge),
        ),
      ),

      scaffoldBackgroundColor: colors.background,
      dividerColor: colors.divider,
      shadowColor: colors.shadow,

      typography: Typography.material2021(),
    );
  }
}

/* Fin theme\app_theme.dart */

/* Inicio theme\index.dart */
export 'app_theme.dart';
export 'app_colors.dart';
export 'app_spacing.dart';
export 'app_text_styles.dart';
export 'theme_extensions.dart';
/* Fin theme\index.dart */

/* Inicio theme\theme_extensions.dart */
import 'package:flutter/material.dart';
import 'app_colors.dart';
import 'app_spacing.dart';
import 'app_text_styles.dart';
extension ThemeExtensions on BuildContext {
  AppColors get colors => AppColors.instance;
  AppTextStyles get textStyles => AppTextStyles.instance;
  AppSpacing get spacing => AppSpacing.instance;
  ThemeData get theme => Theme.of(this);
  TextTheme get textTheme => theme.textTheme;
  ColorScheme get colorScheme => theme.colorScheme;
}
extension TextStyleExtensions on TextStyle {
  TextStyle get bold => copyWith(fontWeight: FontWeight.bold);
  TextStyle get semiBold => copyWith(fontWeight: FontWeight.w600);
  TextStyle get medium => copyWith(fontWeight: FontWeight.w500);
  TextStyle get regular => copyWith(fontWeight: FontWeight.normal);
  TextStyle get light => copyWith(fontWeight: FontWeight.w300);

  TextStyle withColor(Color color) => copyWith(color: color);
  TextStyle withSize(double size) => copyWith(fontSize: size);
  TextStyle withWeight(FontWeight weight) => copyWith(fontWeight: weight);
  TextStyle get underlined => copyWith(decoration: TextDecoration.underline);
  TextStyle get lineThrough => copyWith(decoration: TextDecoration.lineThrough);
}
extension EdgeInsetsExtensions on EdgeInsets {
  static EdgeInsets get xs => EdgeInsets.all(AppSpacing.instance.xs);
  static EdgeInsets get sm => EdgeInsets.all(AppSpacing.instance.sm);
  static EdgeInsets get md => EdgeInsets.all(AppSpacing.instance.md);
  static EdgeInsets get lg => EdgeInsets.all(AppSpacing.instance.lg);
  static EdgeInsets get xl => EdgeInsets.all(AppSpacing.instance.xl);

  static EdgeInsets horizontal(double value) => EdgeInsets.symmetric(horizontal: value);
  static EdgeInsets vertical(double value) => EdgeInsets.symmetric(vertical: value);

  static EdgeInsets get cardPadding => EdgeInsets.all(AppSpacing.instance.cardPadding);
  static EdgeInsets get screenPadding => EdgeInsets.all(AppSpacing.instance.screenPadding);
  static EdgeInsets get buttonPadding => EdgeInsets.symmetric(
    horizontal: AppSpacing.instance.buttonPadding,
    vertical: AppSpacing.instance.sm,
  );
}
/* Fin theme\theme_extensions.dart */

/* Inicio ui\widgets\app_button.dart */
import 'package:flutter/widgets.dart';
import '../../theme/theme_extensions.dart';
import '../../theme/app_colors.dart';
import '../../theme/app_constants.dart';
class AppButton extends StatefulWidget {
  final String label;
  final VoidCallback onPressed;
  final bool isLoading;
  final bool isEnabled;
  final double? width;
  final EdgeInsets? padding;

  const AppButton({
    required this.label,
    required this.onPressed,
    this.isLoading = false,
    this.isEnabled = true,
    this.width,
    this.padding,
    super.key,
  });

  @override
  State<AppButton> createState() => _AppButtonState();
}

class _AppButtonState extends State<AppButton> {
  bool _isPressed = false;

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    final buttonChild = Container(
      constraints: widget.width != null
          ? BoxConstraints(minWidth: widget.width!)
          : const BoxConstraints(minWidth: 0),
      padding: widget.padding ??
          EdgeInsets.symmetric(
            horizontal: spacing.md,
            vertical: spacing.md,
          ),
      decoration: BoxDecoration(
        color: widget.isEnabled
            ? (_isPressed ? colors.primaryDark : colors.primary)
            : colors.grey,
        borderRadius: BorderRadius.circular(AppConstants.instance.buttonBorderRadius),
      ),
      child: Center(
        child: widget.isLoading
            ? SizedBox(
                width: AppConstants.instance.spinnerSize,
                height: AppConstants.instance.spinnerSize,
                child: _buildLoadingSpinner(context),
              )
            : Text(
                widget.label,
                style: textStyles.labelLarge.copyWith(
                  color: colors.white, // Texto blanco sobre fondo primario
                ),
              ),
      ),
    );

    return GestureDetector(
      onTapDown: widget.isEnabled && !widget.isLoading
          ? (_) => setState(() => _isPressed = true)
          : null,
      onTapUp: widget.isEnabled && !widget.isLoading
          ? (_) {
              setState(() => _isPressed = false);
              widget.onPressed();
            }
          : null,
      onTapCancel: widget.isEnabled && !widget.isLoading
          ? () => setState(() => _isPressed = false)
          : null,
      child: buttonChild,
    );
  }

  Widget _buildLoadingSpinner(BuildContext context) {
    final colors = context.colors;

    return Center(
      child: SizedBox(
        width: AppConstants.instance.spinnerSize,
        height: AppConstants.instance.spinnerSize,
        child: CustomPaint(
          painter: _SpinnerPainter(colors: colors),
        ),
      ),
    );
  }
}
class AppSecondaryButton extends StatefulWidget {
  final String label;
  final VoidCallback onPressed;
  final bool isEnabled;
  final double? width;

  const AppSecondaryButton({
    required this.label,
    required this.onPressed,
    this.isEnabled = true,
    this.width,
    super.key,
  });

  @override
  State<AppSecondaryButton> createState() => _AppSecondaryButtonState();
}

class _AppSecondaryButtonState extends State<AppSecondaryButton> {
  bool _isPressed = false;

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;
    final textStyles = context.textStyles;

    final buttonChild = Container(
      constraints: widget.width != null
          ? BoxConstraints(minWidth: widget.width!)
          : const BoxConstraints(minWidth: 0),
      padding: EdgeInsets.symmetric(
        horizontal: spacing.md,
        vertical: spacing.md,
      ),
      decoration: BoxDecoration(
        border: Border.all(
          color: widget.isEnabled ? colors.primary : colors.grey,
          width: AppConstants.instance.borderWidthNormal,
        ),
        borderRadius: BorderRadius.circular(AppConstants.instance.buttonBorderRadius),
        color: _isPressed && widget.isEnabled
            ? colors.surfaceLight
            : colors.transparent,
      ),
      child: Center(
        child: Text(
          widget.label,
          style: textStyles.labelLarge.copyWith(
            color: widget.isEnabled
                ? colors.primary // Texto primario sobre fondo transparente
                : colors.grey,
          ),
        ),
      ),
    );

    return GestureDetector(
      onTapDown: widget.isEnabled
          ? (_) => setState(() => _isPressed = true)
          : null,
      onTapUp: widget.isEnabled
          ? (_) {
              setState(() => _isPressed = false);
              widget.onPressed();
            }
          : null,
      onTapCancel: widget.isEnabled
          ? () => setState(() => _isPressed = false)
          : null,
      child: buttonChild,
    );
  }
}
class _SpinnerPainter extends CustomPainter {
  final AppColors colors;

  _SpinnerPainter({required this.colors});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = colors.white // Spinner blanco sobre fondo primario
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;

    final radius = size.width / 2;
    final center = Offset(size.width / 2, size.height / 2);
    canvas.drawCircle(center, radius, paint);
    final rect = Rect.fromCircle(center: center, radius: radius);
    canvas.drawArc(rect, 0, 1.5, false, paint);
  }

  @override
  bool shouldRepaint(_SpinnerPainter oldDelegate) => true;
}

/* Fin ui\widgets\app_button.dart */

/* Inicio ui\widgets\app_components.dart */
import 'package:flutter/material.dart';
import '../../theme/theme_extensions.dart';
class AppCard extends StatelessWidget {
  final Widget child;
  final EdgeInsets? padding;
  final VoidCallback? onTap;
  final Color? backgroundColor;
  final double? elevation;
  final BorderRadius? borderRadius;

  const AppCard({
    required this.child,
    this.padding,
    this.onTap,
    this.backgroundColor,
    this.elevation,
    this.borderRadius,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final spacing = context.spacing;

    return Card(
      color: backgroundColor ?? colors.surface,
      elevation: elevation ?? 2,
      shadowColor: colors.shadow,
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(
        borderRadius: borderRadius ?? BorderRadius.circular(spacing.borderRadius),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: borderRadius ?? BorderRadius.circular(spacing.borderRadius),
        child: Padding(
          padding: padding ?? EdgeInsets.all(spacing.cardPadding),
          child: child,
        ),
      ),
    );
  }
}
class AppScaffold extends StatelessWidget {
  final String? title;
  final Widget body;
  final Widget? floatingActionButton;
  final List<Widget>? actions;
  final bool showBackButton;
  final VoidCallback? onBackPressed;
  final PreferredSizeWidget? appBar;

  const AppScaffold({
    this.title,
    required this.body,
    this.floatingActionButton,
    this.actions,
    this.showBackButton = false,
    this.onBackPressed,
    this.appBar,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final textStyles = context.textStyles;
    final spacing = context.spacing;

    return Scaffold(
      backgroundColor: colors.background,
      appBar: appBar ?? (title != null ? AppBar(
        backgroundColor: colors.surface,
        foregroundColor: colors.textPrimary,
        elevation: 0,
        shadowColor: colors.shadow,
        surfaceTintColor: Colors.transparent,
        titleTextStyle: textStyles.headlineMedium,
        title: Text(title!),
        leading: showBackButton ? IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: onBackPressed ?? () => Navigator.maybePop(context),
        ) : null,
        actions: actions,
      ) : null),
      body: SafeArea(
        child: Padding(
          padding: EdgeInsets.all(spacing.screenPadding),
          child: body,
        ),
      ),
      floatingActionButton: floatingActionButton,
    );
  }
}
class AppText extends StatelessWidget {
  final String text;
  final TextStyle? style;
  final TextAlign? textAlign;
  final int? maxLines;
  final TextOverflow? overflow;
  final bool? softWrap;

  const AppText(
    this.text, {
    this.style,
    this.textAlign,
    this.maxLines,
    this.overflow,
    this.softWrap,
    super.key,
  });
  const AppText.headlineLarge(
    this.text, {
    this.textAlign,
    this.maxLines,
    this.overflow,
    this.softWrap,
    super.key,
  }) : style = null;

  const AppText.headlineMedium(
    this.text, {
    this.textAlign,
    this.maxLines,
    this.overflow,
    this.softWrap,
    super.key,
  }) : style = null;

  const AppText.bodyLarge(
    this.text, {
    this.textAlign,
    this.maxLines,
    this.overflow,
    this.softWrap,
    super.key,
  }) : style = null;

  const AppText.bodyMedium(
    this.text, {
    this.textAlign,
    this.maxLines,
    this.overflow,
    this.softWrap,
    super.key,
  }) : style = null;

  @override
  Widget build(BuildContext context) {
    final textStyles = context.textStyles;

    TextStyle resolvedStyle;
    if (style != null) {
      resolvedStyle = style!;
    } else {
      final constructorName = runtimeType.toString();
      if (constructorName.contains('headlineLarge')) {
        resolvedStyle = textStyles.headlineLarge;
      } else if (constructorName.contains('headlineMedium')) {
        resolvedStyle = textStyles.headlineMedium;
      } else if (constructorName.contains('bodyLarge')) {
        resolvedStyle = textStyles.bodyLarge;
      } else {
        resolvedStyle = textStyles.bodyMedium;
      }
    }

    return Text(
      text,
      style: resolvedStyle,
      textAlign: textAlign,
      maxLines: maxLines,
      overflow: overflow,
      softWrap: softWrap,
    );
  }
}
class AppSpacer extends StatelessWidget {
  final double? width;
  final double? height;

  const AppSpacer({this.width, this.height, super.key});
  const AppSpacer.xs({super.key}) : width = null, height = null;
  const AppSpacer.sm({super.key}) : width = null, height = null;
  const AppSpacer.md({super.key}) : width = null, height = null;
  const AppSpacer.lg({super.key}) : width = null, height = null;
  const AppSpacer.xl({super.key}) : width = null, height = null;

  @override
  Widget build(BuildContext context) {
    final spacing = context.spacing;

    double resolvedWidth = width ?? 0;
    double resolvedHeight = height ?? 0;
    if (width == null && height == null) {
      final constructorName = runtimeType.toString();
      if (constructorName.contains('xs')) {
        resolvedHeight = spacing.xs;
      } else if (constructorName.contains('sm')) {
        resolvedHeight = spacing.sm;
      } else if (constructorName.contains('md')) {
        resolvedHeight = spacing.md;
      } else if (constructorName.contains('lg')) {
        resolvedHeight = spacing.lg;
      } else if (constructorName.contains('xl')) {
        resolvedHeight = spacing.xl;
      }
    }

    return SizedBox(
      width: resolvedWidth,
      height: resolvedHeight,
    );
  }
}
/* Fin ui\widgets\app_components.dart */

/* Inicio ui\widgets\error_logger.dart */
import 'package:flutter/material.dart';
import '../../theme/theme_extensions.dart';
class ErrorLoggerWidget extends StatefulWidget {
  ErrorLoggerWidget() : super(key: errorLoggerKey);

  @override
  State<ErrorLoggerWidget> createState() => ErrorLoggerWidgetState();
}

class ErrorLoggerWidgetState extends State<ErrorLoggerWidget> {
  final List<String> _logs = [];
  bool _isExpanded = false;
  bool _isVisible = false;

  @override
  void initState() {
    super.initState();

  }

  void addLog(String message) {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        _addLog(message);
      }
    });
  }

  void _addLog(String message) {
    setState(() {
      final timestamp = DateTime.now().toString().substring(11, 19)
      _logs.add('[$timestamp] $message');
      if (_logs.length > 50) {
        _logs.removeAt(0)
      }
      _isVisible = true;
    });
  }

  void _clearLogs() {
    setState(() {
      _logs.clear();
      _isVisible = false;
    });
  }

  @override
  Widget build(BuildContext context) {
    if (!_isVisible) return const SizedBox.shrink();

    final colors = context.colors;

    return Positioned(
      bottom: 20,
      right: 20,
      child: Material(
        color: Colors.transparent,
        child: Container(
          width: _isExpanded ? 300 : 60,
          height: _isExpanded ? 200 : 60,
          decoration: BoxDecoration(
            color: colors.surface,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: colors.border),
            boxShadow: const [
              BoxShadow(
                color: Color.fromRGBO(0, 0, 0, 0.3),
                blurRadius: 8,
                offset: Offset(0, 4),
              ),
            ],
          ),
          child: _isExpanded ? _buildExpandedView(context) : _buildCollapsedView(context),
        ),
      ),
    );
  }

  Widget _buildCollapsedView(BuildContext context) {
    final colors = context.colors;
    final errorCount = _logs.where((log) => log.contains('ERROR')).length;

    return GestureDetector(
      onTap: () => setState(() => _isExpanded = true),
      child: Container(
        padding: const EdgeInsets.all(12),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              errorCount > 0 ? Icons.error : Icons.bug_report,
              color: errorCount > 0 ? colors.error : colors.warning,
              size: 24,
            ),
            if (errorCount > 0)
              Container(
                margin: const EdgeInsets.only(top: 4),
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                decoration: BoxDecoration(
                  color: colors.error,
                  borderRadius: BorderRadius.circular(10),
                ),
                child: Text(
                  errorCount.toString(),
                  style: TextStyle(
                    color: colors.getTextColorForBackground(colors.error),
                    fontSize: 10,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildExpandedView(BuildContext context) {
    final colors = context.colors;
    final textStyles = context.textStyles;

    return Column(
      children: [

        Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
          decoration: BoxDecoration(
            color: colors.surfaceLight,
            borderRadius: const BorderRadius.only(
              topLeft: Radius.circular(12),
              topRight: Radius.circular(12),
            ),
          ),
          child: Row(
            children: [
              Text(
                'Logs de Debug',
                style: textStyles.labelLarge,
              ),
              const Spacer(),
              GestureDetector(
                onTap: _clearLogs,
                child: const Padding(
                  padding: EdgeInsets.all(4),
                  child: Icon(Icons.clear_all, size: 16),
                ),
              ),
              GestureDetector(
                onTap: () => setState(() => _isExpanded = false),
                child: const Padding(
                  padding: EdgeInsets.all(4),
                  child: Icon(Icons.close, size: 16),
                ),
              ),
            ],
          ),
        ),

        Expanded(
          child: Container(
            padding: const EdgeInsets.all(8),
            child: _logs.isEmpty
                ? Center(
                    child: Text(
                      'No hay logs',
                      style: textStyles.bodySmall,
                    ),
                  )
                : ListView.builder(
                    itemCount: _logs.length,
                    itemBuilder: (context, index) {
                      final log = _logs[_logs.length - 1 - index]
                      final isError = log.contains('ERROR');
                      return Padding(
                        padding: const EdgeInsets.only(bottom: 4),
                        child: Text(
                          log,
                          style: TextStyle(
                            fontSize: 10,
                            color: isError ? colors.error : colors.textSecondary,
                            fontFamily: 'monospace',
                          ),
                        ),
                      );
                    },
                  ),
          ),
        ),
      ],
    );
  }
}
final GlobalKey<ErrorLoggerWidgetState> errorLoggerKey = GlobalKey<ErrorLoggerWidgetState>();

void addDebugLog(String message) {
  debugPrint(message);
  errorLoggerKey.currentState?.addLog(message);
}
/* Fin ui\widgets\error_logger.dart */

/* Inicio ui\widgets\index.dart */
export 'app_button.dart';
export 'app_components.dart';
export 'error_logger.dart';

/* Fin ui\widgets\index.dart */

/* Inicio utils\app_router.dart */
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_provider.dart';
import '../providers/navigation_state_provider.dart';
import '../screens/login_screen.dart';
import '../screens/institution_selection_screen.dart';
import '../screens/home_screen.dart';
import '../screens/super_admin_dashboard.dart';
import '../screens/admin_dashboard.dart';
import '../screens/teacher_dashboard.dart';
import '../screens/student_dashboard.dart';
import '../screens/institutions/institutions_list_screen.dart';
import '../screens/institutions/institution_form_screen.dart';
import '../models/institution.dart';
import '../theme/theme_extensions.dart';
import 'app_routes.dart';
class AppRouter {
  final AuthProvider authProvider;
  final NavigationStateProvider navigationProvider;

  AppRouter({
    required this.authProvider,
    required this.navigationProvider,
  });

  late final GoRouter router = GoRouter(
    debugLogDiagnostics: true,
    refreshListenable: authProvider,
    initialLocation: _getStartRoute(),
    redirect: _checkAuth,
    routes: _allRoutes(),
    errorBuilder: _errorPage,
  );
  String _getStartRoute() {

    if (navigationProvider.hasValidState() &&
        navigationProvider.currentRoute != null) {
      return navigationProvider.currentRoute!;
    }

    if (authProvider.isAuthenticated) {
      final role = authProvider.user?['rol'] as String?;
      return AppRoutes.getDashboardRouteForRole(role ?? '');
    }

    return AppRoutes.login;
  }
  String? _checkAuth(BuildContext context, GoRouterState state) {
    final isLoggedIn = authProvider.isAuthenticated;
    final currentRoute = state.matchedLocation;
    if (currentRoute == AppRoutes.login) {
      if (isLoggedIn) {
        final institutions = authProvider.institutions;
        final selected = authProvider.selectedInstitutionId;
        if (institutions != null && institutions.length > 1 && selected == null) {
          return AppRoutes.institutionSelection;
        }
        final role = authProvider.user?['rol'] as String?;
        return AppRoutes.getDashboardRouteForRole(role ?? '');
      }
      return null
    }
    if (!isLoggedIn) {
      return AppRoutes.login;
    }
    final institutions = authProvider.institutions;
    final selected = authProvider.selectedInstitutionId;
    final needsSelection = institutions != null &&
                          institutions.length > 1 &&
                          selected == null &&
                          currentRoute != AppRoutes.institutionSelection &&
                          !currentRoute.startsWith('/institutions')

    if (needsSelection) {
      return AppRoutes.institutionSelection;
    }
    if (currentRoute.startsWith('/institutions')) {
      final role = authProvider.user?['rol'] as String?;
      if (role != 'super_admin') {
        return AppRoutes.getDashboardRouteForRole(role ?? '');
      }
    }

    return null
  }
  List<RouteBase> _allRoutes() {
    return [

      GoRoute(
        path: AppRoutes.login,
        name: 'login',
        pageBuilder: (context, state) => _fadePage(
          context,
          state,
          const LoginScreen(),
        ),
      ),

      GoRoute(
        path: AppRoutes.institutionSelection,
        name: 'institution-selection',
        pageBuilder: (context, state) => _fadePage(
          context,
          state,
          const InstitutionSelectionScreen(),
        ),
      ),

      GoRoute(
        path: AppRoutes.superAdminDashboard,
        name: 'super-admin',
        pageBuilder: (context, state) {
          _saveRoute(state);
          return _fadePage(context, state, const SuperAdminDashboard());
        },
      ),

      GoRoute(
        path: AppRoutes.adminDashboard,
        name: 'admin',
        pageBuilder: (context, state) {
          _saveRoute(state);
          return _fadePage(context, state, const AdminDashboard());
        },
      ),

      GoRoute(
        path: AppRoutes.teacherDashboard,
        name: 'teacher',
        pageBuilder: (context, state) {
          _saveRoute(state);
          return _fadePage(context, state, const TeacherDashboard());
        },
      ),

      GoRoute(
        path: AppRoutes.studentDashboard,
        name: 'student',
        pageBuilder: (context, state) {
          _saveRoute(state);
          return _fadePage(context, state, const StudentDashboard());
        },
      ),

      GoRoute(
        path: AppRoutes.home,
        name: 'home',
        pageBuilder: (context, state) {
          _saveRoute(state);
          return _fadePage(context, state, const HomeScreen());
        },
      ),
      GoRoute(
        path: AppRoutes.institutionsList,
        name: 'institutions-list',
        pageBuilder: (context, state) {
          _saveRoute(state);
          return _fadePage(context, state, const InstitutionsListScreen());
        },
      ),

      GoRoute(
        path: AppRoutes.institutionForm,
        name: 'institution-form',
        pageBuilder: (context, state) {
          final institutionId = state.uri.queryParameters['id'];
          final institution = institutionId != null
              ? state.extra as Institution?
              : null;

          _saveRoute(state);
          return _fadePage(
            context,
            state,
            InstitutionFormScreen(institution: institution),
          );
        },
      ),
    ];
  }
  void _saveRoute(GoRouterState state) {
    final route = state.matchedLocation;
    final params = state.uri.queryParameters;

    WidgetsBinding.instance.addPostFrameCallback((_) {
      navigationProvider.saveNavigationState(
        route,
        arguments: params.isNotEmpty ? params : null,
      );
    });
  }
  Page _fadePage(BuildContext context, GoRouterState state, Widget child) {
    return CustomTransitionPage(
      key: state.pageKey,
      child: child,
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        return FadeTransition(opacity: animation, child: child);
      },
    );
  }
  Widget _errorPage(BuildContext context, GoRouterState state) {
    return Scaffold(
      body: Builder(
        builder: (ctx) {
          final colors = ctx.colors;
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.error_outline, size: 48, color: colors.error),
                const SizedBox(height: 16),
                const Text('Error de NavegaciÃ³n',
                  style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
                const SizedBox(height: 8),
                Text('${state.error}'),
                const SizedBox(height: 16),
                ElevatedButton(
                  onPressed: () => context.go(AppRoutes.login),
                  child: const Text('Ir al inicio'),
                ),
              ],
            ),
          );
        },
      ),
    );
  }
  void dispose() {
    router.dispose();
  }
}

/* Fin utils\app_router.dart */

/* Inicio utils\app_routes.dart */

class AppRoutes {
  AppRoutes._()

  static const String login = '/login';

  static const String institutionSelection = '/institution-selection';
  static const String superAdminDashboard = '/super-admin-dashboard';
  static const String adminDashboard = '/admin-dashboard';
  static const String teacherDashboard = '/teacher-dashboard';
  static const String studentDashboard = '/student-dashboard';
  static const String home = '/home';
  static const String institutionsList = '/institutions';
  static const String institutionForm = '/institutions/form';
  static const String institutionDetail = '/institutions/:id';
  static String getDashboardRouteForRole(String role) {
    switch (role) {
      case 'super_admin':
        return superAdminDashboard;
      case 'admin_institucion':
        return adminDashboard;
      case 'profesor':
        return teacherDashboard;
      case 'estudiante':
        return studentDashboard;
      default:
        return home;
    }
  }
  static bool requiresAuth(String route) {
    return route != login;
  }
  static bool isDashboard(String route) {
    return [
      superAdminDashboard,
      adminDashboard,
      teacherDashboard,
      studentDashboard,
      home,
    ].contains(route);
  }
}

/* Fin utils\app_routes.dart */

/* Inicio utils\responsive_utils.dart */
import 'package:flutter/material.dart';
import '../theme/app_constants.dart';
class ResponsiveUtils {
  static final AppConstants _constants = AppConstants.instance;
  static Map<String, dynamic> getResponsiveValues(BoxConstraints constraints) {
    final screenType = _constants.getScreenType(constraints.maxWidth);
    final maxWidth = _constants.getMaxWidth(constraints.maxWidth);
    final horizontalPadding = switch (screenType) {
      ScreenType.mobileSmall => 16.0,
      ScreenType.mobileLarge => 24.0,
      ScreenType.tablet => 32.0,
      ScreenType.desktop => 48.0,
      ScreenType.largeDesktop => 64.0,
    };
    final verticalPadding = switch (screenType) {
      ScreenType.mobileSmall => 24.0,
      ScreenType.mobileLarge => 32.0,
      ScreenType.tablet => 48.0,
      ScreenType.desktop => 64.0,
      ScreenType.largeDesktop => 80.0,
    };
    final elementSpacing = switch (screenType) {
      ScreenType.mobileSmall => 16.0,
      ScreenType.mobileLarge => 20.0,
      ScreenType.tablet => 24.0,
      ScreenType.desktop => 32.0,
      ScreenType.largeDesktop => 40.0,
    };
    final titleFontSize = switch (screenType) {
      ScreenType.mobileSmall => 24.0,
      ScreenType.mobileLarge => 28.0,
      ScreenType.tablet => 32.0,
      ScreenType.desktop => 40.0,
      ScreenType.largeDesktop => 48.0,
    };

    final subtitleFontSize = switch (screenType) {
      ScreenType.mobileSmall => 14.0,
      ScreenType.mobileLarge => 16.0,
      ScreenType.tablet => 18.0,
      ScreenType.desktop => 20.0,
      ScreenType.largeDesktop => 24.0,
    };

    final bodyFontSize = switch (screenType) {
      ScreenType.mobileSmall => 14.0,
      ScreenType.mobileLarge => 16.0,
      ScreenType.tablet => 16.0,
      ScreenType.desktop => 18.0,
      ScreenType.largeDesktop => 20.0,
    };
    final buttonWidth = switch (screenType) {
      ScreenType.mobileSmall => double.infinity,
      ScreenType.mobileLarge => 280.0,
      ScreenType.tablet => 320.0,
      ScreenType.desktop => 360.0,
      ScreenType.largeDesktop => 400.0,
    };
    final minHeight = switch (screenType) {
      ScreenType.mobileSmall => 600.0,
      ScreenType.mobileLarge => 700.0,
      ScreenType.tablet => 800.0,
      ScreenType.desktop => 900.0,
      ScreenType.largeDesktop => 1000.0,
    };

    return {
      'screenType': screenType,
      'maxWidth': maxWidth,
      'horizontalPadding': horizontalPadding,
      'verticalPadding': verticalPadding,
      'elementSpacing': elementSpacing,
      'titleFontSize': titleFontSize,
      'subtitleFontSize': subtitleFontSize,
      'bodyFontSize': bodyFontSize,
      'buttonWidth': buttonWidth,
      'minHeight': minHeight,
      'isSmallScreen': screenType == ScreenType.mobileSmall,
      'isMobile': screenType == ScreenType.mobileSmall || screenType == ScreenType.mobileLarge,
      'isTablet': screenType == ScreenType.tablet,
      'isDesktop': screenType == ScreenType.desktop || screenType == ScreenType.largeDesktop,
      'isLargeDesktop': screenType == ScreenType.largeDesktop,
    };
  }
  static Widget buildResponsiveContainer({
    required BuildContext context,
    required Widget child,
    double? maxWidth,
    EdgeInsets? padding,
    bool centerContent = true,
  }) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final responsive = getResponsiveValues(constraints);
        final containerMaxWidth = maxWidth ?? responsive['maxWidth'];
        final containerPadding = padding ?? EdgeInsets.symmetric(
          horizontal: responsive['horizontalPadding'],
          vertical: responsive['verticalPadding'],
        );

        final content = ConstrainedBox(
          constraints: BoxConstraints(maxWidth: containerMaxWidth),
          child: child,
        );

        return Container(
          width: double.infinity,
          padding: containerPadding,
          constraints: BoxConstraints(minHeight: responsive['minHeight']),
          child: centerContent ? Center(child: content) : content,
        );
      },
    );
  }
  static TextStyle getResponsiveTextStyle(
    TextStyle baseStyle,
    ScreenType screenType, {
    double? fontSize,
  }) {
    final scaleFactor = switch (screenType) {
      ScreenType.mobileSmall => 0.8,
      ScreenType.mobileLarge => 0.9,
      ScreenType.tablet => 1.0,
      ScreenType.desktop => 1.1,
      ScreenType.largeDesktop => 1.2,
    };

    final scaledFontSize = fontSize ?? (baseStyle.fontSize ?? 14.0) * scaleFactor;

    return baseStyle.copyWith(fontSize: scaledFontSize);
  }
  static SliverGridDelegate getResponsiveGridDelegate(ScreenType screenType) {
    return switch (screenType) {
      ScreenType.mobileSmall => const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 1,
          crossAxisSpacing: 16,
          mainAxisSpacing: 16,
          childAspectRatio: 1.2,
        ),
      ScreenType.mobileLarge => const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 2,
          crossAxisSpacing: 16,
          mainAxisSpacing: 16,
          childAspectRatio: 1.1,
        ),
      ScreenType.tablet => const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 3,
          crossAxisSpacing: 20,
          mainAxisSpacing: 20,
          childAspectRatio: 1.0,
        ),
      ScreenType.desktop => const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 4,
          crossAxisSpacing: 24,
          mainAxisSpacing: 24,
          childAspectRatio: 0.9,
        ),
      ScreenType.largeDesktop => const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 5,
          crossAxisSpacing: 28,
          mainAxisSpacing: 28,
          childAspectRatio: 0.8,
        ),
    };
  }
}
/* Fin utils\responsive_utils.dart */

/* Inicio utils\role_enum.dart */

enum UserRole {
  superAdmin,       // Administrador global del sistema
  adminInstitucion, // Administrador de una instituciÃ³n
  profesor,         // Profesor de clases
  estudiante,       // Estudiante
}
extension UserRoleExtension on UserRole {
  String get value {
    switch (this) {
      case UserRole.superAdmin:
        return 'super_admin';
      case UserRole.adminInstitucion:
        return 'admin_institucion';
      case UserRole.profesor:
        return 'profesor';
      case UserRole.estudiante:
        return 'estudiante';
    }
  }
  String get displayName {
    switch (this) {
      case UserRole.superAdmin:
        return 'Super Administrador';
      case UserRole.adminInstitucion:
        return 'Administrador';
      case UserRole.profesor:
        return 'Profesor';
      case UserRole.estudiante:
        return 'Estudiante';
    }
  }
  static UserRole fromString(String role) {
    switch (role) {
      case 'super_admin':
        return UserRole.superAdmin;
      case 'admin_institucion':
        return UserRole.adminInstitucion;
      case 'profesor':
        return UserRole.profesor;
      case 'estudiante':
        return UserRole.estudiante;
      default:
        throw ArgumentError('Rol desconocido: $role');
    }
  }
  bool get isAdmin {
    return this == UserRole.superAdmin || this == UserRole.adminInstitucion;
  }
  bool get isSuperAdmin {
    return this == UserRole.superAdmin;
  }
}
/* Fin utils\role_enum.dart */

/* Inicio utils\route_guards.dart */
import 'package:flutter/widgets.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';

class RouteGuards {
  static bool requireAuth(BuildContext context) {
    final authProvider = context.read<AuthProvider>();
    return authProvider.isAuthenticated;
  }
  static bool isPublic(BuildContext context) {
    final authProvider = context.read<AuthProvider>();
    return !authProvider.isAuthenticated;
  }
}
class ProtectedRoute extends StatelessWidget {
  final Widget child;
  final bool Function(BuildContext) guard;
  final Widget fallback;

  const ProtectedRoute({
    required this.child,
    required this.guard,
    required this.fallback,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    return guard(context) ? child : fallback;
  }
}

/* Fin utils\route_guards.dart */

/* Inicio widgets\app_wrappers.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../providers/navigation_state_provider.dart';
import '../screens/login_screen.dart';
import '../screens/institution_selection_screen.dart';
import '../screens/home_screen.dart';
import '../screens/super_admin_dashboard.dart';
import '../screens/admin_dashboard.dart';
import '../screens/teacher_dashboard.dart';
import '../screens/student_dashboard.dart';
import '../utils/app_routes.dart';
class LifecycleAwareWrapper extends StatefulWidget {
  const LifecycleAwareWrapper({super.key});

  @override
  State<LifecycleAwareWrapper> createState() => _LifecycleAwareWrapperState();
}

class _LifecycleAwareWrapperState extends State<LifecycleAwareWrapper>
    with WidgetsBindingObserver {

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    final navigationProvider = Provider.of<NavigationStateProvider>(context, listen: false);

    switch (state) {
      case AppLifecycleState.resumed:
        debugPrint('App resumed - recovering full state');
        authProvider.recoverFullState();
        if (!navigationProvider.hasValidState()) {
          navigationProvider.clearNavigationState();
        }
        break;
      case AppLifecycleState.inactive:
        debugPrint('App inactive - transitioning');
        break;
      case AppLifecycleState.paused:
        debugPrint('App paused - saving current state');
        navigationProvider.refreshStateTimestamp();
        break;
      case AppLifecycleState.hidden:
        debugPrint('App hidden');
        break;
      case AppLifecycleState.detached:
        debugPrint('App detached');
        break;
    }
  }

  @override
  Widget build(BuildContext context) {
    return const AuthWrapper();
  }
}
class AuthWrapper extends StatelessWidget {
  const AuthWrapper({super.key});

  @override
  Widget build(BuildContext context) {
    return Consumer2<AuthProvider, NavigationStateProvider>(
      builder: (context, authProvider, navigationProvider, child) {
        if (!authProvider.isAuthenticated) {
          return const LoginScreen();
        }
        final institutions = authProvider.institutions;
        final selectedInstitutionId = authProvider.selectedInstitutionId;

        if (institutions != null && institutions.length > 1 && selectedInstitutionId == null) {
          return const InstitutionSelectionScreen();
        }
        if (navigationProvider.hasValidState() && navigationProvider.currentRoute != null) {
          final savedRoute = navigationProvider.currentRoute!;
          debugPrint('Recuperando navegaciÃ³n guardada: $savedRoute');

          return _getScreenForRoute(savedRoute, authProvider);
        }
        final user = authProvider.user;
        final userRole = user?['rol'] as String?;
        Widget dashboard;
        String route;

        switch (userRole) {
          case 'super_admin':
            dashboard = const SuperAdminDashboard();
            route = AppRoutes.superAdminDashboard;
            break;
          case 'admin_institucion':
            dashboard = const AdminDashboard();
            route = AppRoutes.adminDashboard;
            break;
          case 'profesor':
            dashboard = const TeacherDashboard();
            route = AppRoutes.teacherDashboard;
            break;
          case 'estudiante':
            dashboard = const StudentDashboard();
            route = AppRoutes.studentDashboard;
            break;
          default:
            dashboard = const HomeScreen();
            route = AppRoutes.home;
            break;
        }
        WidgetsBinding.instance.addPostFrameCallback((_) {
          navigationProvider.saveNavigationState(route);
        });

        return dashboard;
      },
    );
  }
  Widget _getScreenForRoute(String route, AuthProvider authProvider) {
    switch (route) {
      case AppRoutes.superAdminDashboard:
        return const SuperAdminDashboard();
      case AppRoutes.adminDashboard:
        return const AdminDashboard();
      case AppRoutes.teacherDashboard:
        return const TeacherDashboard();
      case AppRoutes.studentDashboard:
        return const StudentDashboard();
      case AppRoutes.institutionSelection:
        return const InstitutionSelectionScreen();
      case AppRoutes.home:
        return const HomeScreen();
      default:
        final userRole = authProvider.user?['rol'] as String?;
        final defaultRoute = AppRoutes.getDashboardRouteForRole(userRole ?? '');
        return _getScreenForRoute(defaultRoute, authProvider);
    }
  }
}
/* Fin widgets\app_wrappers.dart */

/* Inicio widgets\dashboard_widgets.dart */
import 'package:flutter/material.dart';
import '../utils/responsive_utils.dart';
import '../theme/app_constants.dart';
import '../theme/theme_extensions.dart';
class DashboardFeatureCard extends StatelessWidget {
  final IconData icon;
  final String title;
  final String description;
  final Color color;
  final Map<String, dynamic> responsive;
  final VoidCallback? onTap;

  const DashboardFeatureCard({
    super.key,
    required this.icon,
    required this.title,
    required this.description,
    required this.color,
    required this.responsive,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final bodyFontSize = responsive['bodyFontSize'] as double;
    final isDesktop = responsive['isDesktop'] as bool;
    final colors = context.colors;

    return Card(
      elevation: 4,
      margin: const EdgeInsets.all(8),
      child: InkWell(
        onTap: onTap ?? () {
        },
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: EdgeInsets.all(isDesktop ? 24 : 16),
          child: SizedBox(
            height: isDesktop ? 140 : 120, // Altura fija para evitar overflow
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  icon,
                  size: isDesktop ? 48 : 32,
                  color: color,
                ),
                SizedBox(height: isDesktop ? 12 : 8),
                Text(
                  title,
                  style: TextStyle(
                    fontSize: bodyFontSize,
                    fontWeight: FontWeight.bold,
                    color: colors.textPrimary,
                  ),
                  textAlign: TextAlign.center,
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
                SizedBox(height: isDesktop ? 6 : 4),
                Expanded(
                  child: Text(
                    description,
                    style: TextStyle(
                      fontSize: bodyFontSize * 0.9,
                      color: colors.textSecondary,
                    ),
                    textAlign: TextAlign.center,
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
class UserGreetingWidget extends StatelessWidget {
  final String userName;
  final Map<String, dynamic> responsive;
  final String? subtitle;

  const UserGreetingWidget({
    super.key,
    required this.userName,
    required this.responsive,
    this.subtitle,
  });

  @override
  Widget build(BuildContext context) {
    final titleFontSize = responsive['titleFontSize'] as double;
    final subtitleFontSize = responsive['subtitleFontSize'] as double;
    final colors = context.colors;

    return Column(
      children: [
        Text(
          'Hola, $userName',
          style: TextStyle(
            fontSize: titleFontSize,
            fontWeight: FontWeight.bold,
            color: colors.textPrimary,
          ),
          textAlign: TextAlign.center,
        ),
        if (subtitle != null) ...[
          const SizedBox(height: 8),
          Text(
            subtitle!,
            style: TextStyle(
              fontSize: subtitleFontSize,
              color: colors.textSecondary,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ],
    );
  }
}
class DashboardOptionsGrid extends StatelessWidget {
  final List<DashboardFeatureCard> cards;
  final Map<String, dynamic> responsive;

  const DashboardOptionsGrid({
    super.key,
    required this.cards,
    required this.responsive,
  });

  @override
  Widget build(BuildContext context) {
    final screenType = responsive['screenType'] as ScreenType;

    return Column(
      children: [
        const SizedBox(height: 32),
        LayoutBuilder(
          builder: (context, constraints) {
            final gridDelegate = ResponsiveUtils.getResponsiveGridDelegate(screenType);

            return GridView(
              gridDelegate: gridDelegate,
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              children: cards,
            );
          },
        ),
      ],
    );
  }
}
class DashboardAppBar extends StatelessWidget implements PreferredSizeWidget {
  final String title;
  final Color backgroundColor;
  final List<Widget> actions;

  const DashboardAppBar({
    super.key,
    this.title = 'AsistApp',
    required this.backgroundColor,
    required this.actions,
  });

  @override
  Widget build(BuildContext context) {
    return AppBar(
      title: Text(title),
      backgroundColor: backgroundColor,
      actions: actions,
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}
class DashboardAppBarActions extends StatelessWidget {
  final String userRole;
  final IconData roleIcon;
  final VoidCallback? onLogout;

  const DashboardAppBarActions({
    super.key,
    required this.userRole,
    required this.roleIcon,
    this.onLogout,
  });

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;

    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(
          margin: const EdgeInsets.only(right: 8),
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          constraints: const BoxConstraints(maxWidth: 120), // Limitar ancho mÃ¡ximo
          decoration: BoxDecoration(
            color: colors.roleBadgeBackground,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(roleIcon, size: 14, color: colors.roleBadgeIcon),
              const SizedBox(width: 4),
              Flexible(
                child: Text(
                  userRole,
                  style: TextStyle(
                    color: colors.roleBadgeText,
                    fontSize: 11,
                    fontWeight: FontWeight.w500,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ),
            ],
          ),
        ),
        IconButton(
          icon: const Icon(Icons.logout),
          onPressed: onLogout ?? () async {
          },
        ),
      ],
    );
  }
}
class DashboardBody extends StatelessWidget {
  final Widget userGreeting;
  final Widget dashboardOptions;
  final Map<String, dynamic> responsive;

  const DashboardBody({
    super.key,
    required this.userGreeting,
    required this.dashboardOptions,
    required this.responsive,
  });

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: SingleChildScrollView(
        child: ConstrainedBox(
          constraints: BoxConstraints(maxWidth: responsive['maxWidth']),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Padding(
                padding: EdgeInsets.symmetric(
                  horizontal: responsive['horizontalPadding'],
                  vertical: responsive['verticalPadding'],
                ),
                child: Column(
                  children: [
                    userGreeting,
                    SizedBox(height: responsive['elementSpacing']),
                    dashboardOptions,
                    SizedBox(height: responsive['elementSpacing'] * 2),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
/* Fin widgets\dashboard_widgets.dart */

/* Inicio widgets\index.dart */
export 'app_wrappers.dart';
/* Fin widgets\index.dart */

/* Inicio widgets\navigation_state_mixin.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/navigation_state_provider.dart';
mixin NavigationStateMixin<T extends StatefulWidget> on State<T> {
  String get currentRoute;
  Map<String, dynamic>? get routeArguments => null;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _saveCurrentState();
    });
  }

  @override
  void dispose() {
    _refreshStateTimestamp();
    super.dispose();
  }
  void _saveCurrentState() {
    final navigationProvider = Provider.of<NavigationStateProvider>(
      context,
      listen: false,
    );
    navigationProvider.saveNavigationState(currentRoute, arguments: routeArguments);
  }
  void _refreshStateTimestamp() {
    final navigationProvider = Provider.of<NavigationStateProvider>(
      context,
      listen: false,
    );
    navigationProvider.refreshStateTimestamp();
  }
  void updateNavigationState({Map<String, dynamic>? arguments}) {
    final navigationProvider = Provider.of<NavigationStateProvider>(
      context,
      listen: false,
    );
    navigationProvider.saveNavigationState(currentRoute, arguments: arguments);
  }
}
class NavigationStateWrapper extends StatefulWidget {
  final Widget child;
  final String route;
  final Map<String, dynamic>? arguments;

  const NavigationStateWrapper({
    super.key,
    required this.child,
    required this.route,
    this.arguments,
  });

  @override
  State<NavigationStateWrapper> createState() => _NavigationStateWrapperState();
}

class _NavigationStateWrapperState extends State<NavigationStateWrapper>
    with NavigationStateMixin {
  @override
  String get currentRoute => widget.route;

  @override
  Map<String, dynamic>? get routeArguments => widget.arguments;

  @override
  Widget build(BuildContext context) {
    return widget.child;
  }
}

/* Fin widgets\navigation_state_mixin.dart */

/* Inicio widgets\role_guard.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../utils/role_enum.dart';
class RoleGuard extends StatelessWidget {
  final List<UserRole> allowedRoles
  final Widget child
  final Widget? fallback

  const RoleGuard({
    super.key,
    required this.allowedRoles,
    required this.child,
    this.fallback,
  });

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);
    final userRoleString = authProvider.user?['rol'] as String?;

    if (userRoleString == null) {
      return fallback ?? const SizedBox.shrink();
    }

    UserRole? userRole;
    try {
      userRole = UserRoleExtension.fromString(userRoleString);
    } catch (e) {
      return fallback ?? const SizedBox.shrink();
    }

    if (allowedRoles.contains(userRole)) {
      return child;
    } else {
      return fallback ?? const SizedBox.shrink();
    }
  }
}
/* Fin widgets\role_guard.dart */

/* Inicio widgets\scroll_state_keeper.dart */
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/scroll_state_provider.dart';
class ScrollStateKeeper extends StatefulWidget {
  final String routeKey;
  final Widget Function(BuildContext, ScrollController) builder;
  final bool keepScrollPosition;

  const ScrollStateKeeper({
    super.key,
    required this.routeKey,
    required this.builder,
    this.keepScrollPosition = true,
  });

  @override
  State<ScrollStateKeeper> createState() => _ScrollStateKeeperState();
}

class _ScrollStateKeeperState extends State<ScrollStateKeeper> {
  late final ScrollController _scrollController;
  bool _isRestoringPosition = false;

  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController();

    if (widget.keepScrollPosition) {
      _restoreScrollPosition();
      _scrollController.addListener(_onScroll);
    }
  }

  @override
  void dispose() {
    _scrollController.removeListener(_onScroll);
    _scrollController.dispose();
    super.dispose();
  }
  void _restoreScrollPosition() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;

      final scrollProvider = Provider.of<ScrollStateProvider>(
        context,
        listen: false,
      );

      final savedPosition = scrollProvider.getScrollPosition(widget.routeKey);

      if (savedPosition > 0 && _scrollController.hasClients) {
        _isRestoringPosition = true;
        _scrollController.jumpTo(savedPosition);
        _isRestoringPosition = false;
        debugPrint('Scroll restaurado para ${widget.routeKey}: $savedPosition');
      }
    });
  }
  void _onScroll() {
    if (_isRestoringPosition || !_scrollController.hasClients) return;

    final scrollProvider = Provider.of<ScrollStateProvider>(
      context,
      listen: false,
    );

    final currentPosition = _scrollController.offset;
    scrollProvider.saveScrollPosition(widget.routeKey, currentPosition);
  }

  @override
  Widget build(BuildContext context) {
    return widget.builder(context, _scrollController);
  }
}
mixin ScrollStateMixin<T extends StatefulWidget> on State<T> {
  late final ScrollController scrollController;
  String get scrollRouteKey;

  @override
  void initState() {
    super.initState();
    scrollController = ScrollController();
    _restoreAndListenScroll();
  }

  @override
  void dispose() {
    scrollController.dispose();
    super.dispose();
  }

  void _restoreAndListenScroll() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;

      final scrollProvider = Provider.of<ScrollStateProvider>(
        context,
        listen: false,
      );

      final savedPosition = scrollProvider.getScrollPosition(scrollRouteKey);

      if (savedPosition > 0 && scrollController.hasClients) {
        scrollController.jumpTo(savedPosition);
      }

      scrollController.addListener(() {
        if (scrollController.hasClients) {
          scrollProvider.saveScrollPosition(
            scrollRouteKey,
            scrollController.offset,
          );
        }
      });
    });
  }
}

/* Fin widgets\scroll_state_keeper.dart */

/* Inicio widgets\session_info_footer.dart */
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';
import '../theme/theme_extensions.dart';

class SessionInfoFooter extends StatelessWidget {
  const SessionInfoFooter({super.key});

  Future<void> _copyToClipboard(BuildContext context, String text) async {
    await Clipboard.setData(ClipboardData(text: text));

    if (context.mounted) {
      final colors = context.colors;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            'Token copiado al portapapeles',
            style: TextStyle(color: colors.getTextColorForBackground(colors.success)),
          ),
          duration: const Duration(seconds: 2),
          backgroundColor: colors.success,
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final colors = context.colors;
    final authProvider = Provider.of<AuthProvider>(context);
    final accessToken = authProvider.accessToken;

    if (accessToken == null) return const SizedBox.shrink();

    return Container(
      width: double.infinity,
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: colors.primary,
        boxShadow: [
          BoxShadow(
            color: colors.shadow,
            blurRadius: 4,
            offset: const Offset(0, -2),
          ),
        ],
      ),
      child: Row(
        children: [
          Icon(
            Icons.security,
            size: 16,
            color: colors.success,
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              'Token: ${accessToken.substring(0, 20)}...',
              style: TextStyle(
                color: colors.textOnDark,
                fontSize: 12,
                fontFamily: 'monospace',
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
          const SizedBox(width: 8),
          IconButton(
            icon: const Icon(Icons.copy, size: 16),
            color: colors.textOnDarkSecondary,
            tooltip: 'Copiar token',
            onPressed: () => _copyToClipboard(context, accessToken),
          ),
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
            decoration: BoxDecoration(
              color: colors.success.withValues(alpha: 0.2),
              borderRadius: BorderRadius.circular(4),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(
                  Icons.timer,
                  size: 14,
                  color: colors.success,
                ),
                const SizedBox(width: 4),
                Text(
                  'Activo',
                  style: TextStyle(
                    color: colors.getTextColorForBackground(colors.success),
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
/* Fin widgets\session_info_footer.dart */
